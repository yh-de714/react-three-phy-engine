import * as THREE$1 from 'three';
import { Ray as Ray$1, Plane, MathUtils, EventDispatcher, Vector3, MOUSE, TOUCH, Quaternion, Spherical, Vector2, Euler, Matrix4, BufferGeometry, BufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Loader, LoaderUtils, FileLoader, Color, SpotLight, PointLight, DirectionalLight, MeshBasicMaterial, SRGBColorSpace, MeshPhysicalMaterial, InstancedMesh, Object3D, TextureLoader, ImageBitmapLoader, InterleavedBuffer, InterleavedBufferAttribute, LinearFilter, LinearMipmapLinearFilter, RepeatWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, PropertyBinding, SkinnedMesh, Mesh, LineSegments, Line as Line$1, LineLoop, Points, Group as Group$1, PerspectiveCamera, OrthographicCamera, Skeleton, AnimationClip, Bone, InterpolateLinear, NearestFilter, NearestMipmapNearestFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, ClampToEdgeWrapping, MirroredRepeatWrapping, InterpolateDiscrete, FrontSide, Texture, VectorKeyframeTrack, NumberKeyframeTrack, QuaternionKeyframeTrack, Box3, Sphere, Interpolant, LinearSRGBColorSpace, Vector4, Curve, MeshPhongMaterial, MeshLambertMaterial, EquirectangularReflectionMapping, AmbientLight, Float32BufferAttribute, Uint16BufferAttribute, Matrix3, DataTextureLoader, HalfFloatType, FloatType, DataUtils, RGBAFormat, RedFormat, NoColorSpace, ShaderChunk, AnimationMixer, SphereGeometry, CylinderGeometry, BoxGeometry, PlaneGeometry, CanvasTexture, MeshToonMaterial, Layers, InstancedBufferAttribute, CircleGeometry, Line3, Triangle, Source, LinearEncoding, Scene, sRGBEncoding, AdditiveBlending, CustomBlending, ZeroFactor, SrcAlphaFactor, SkeletonHelper, AnimationUtils, Raycaster, IcosahedronGeometry, ShaderMaterial, DirectionalLightHelper, CameraHelper, HemisphereLight, RectAreaLight, HemisphereLightHelper, SpotLightHelper, PointLightHelper, PMREMGenerator, WebGLRenderTarget, UniformsUtils, Clock, MeshDepthMaterial, RGBADepthPacking, NoBlending, DepthTexture, UnsignedShortType, MeshNormalMaterial, DstColorFactor, AddEquation, DstAlphaFactor, DataTexture, UnsignedByteType, Data3DTexture, WebGLCubeRenderTarget, CubeCamera, BackSide, InstancedBufferGeometry, NormalBlending, InstancedInterleavedBuffer, DynamicDrawUsage, MultiplyBlending, SubtractiveBlending } from 'three';
import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';

/**
 * @license
 * Copyright 2010-2021 Uil.js Authors
 * SPDX-License-Identifier: MIT
 */
const s$1={ui:[],dom:null,ID:null,lock:!1,wlock:!1,current:-1,needReZone:!0,needResize:!1,forceZone:!1,isEventsInit:!1,isLeave:!1,downTime:0,prevTime:0,prevDefault:["contextmenu"],pointerEvent:["pointerdown","pointermove","pointerup"],eventOut:["pointercancel","pointerout","pointerleave"],xmlserializer:null,tmpTime:null,tmpImage:null,oldCursor:"auto",input:null,parent:null,firstImput:!0,hiddenImput:null,hiddenSizer:null,hasFocus:!1,startInput:!1,inputRange:[0,0],cursorId:0,str:"",pos:0,startX:-1,moveX:-1,debugInput:!1,isLoop:!1,listens:[],e:{type:null,clientX:0,clientY:0,keyCode:NaN,key:null,delta:0},isMobile:!1,now:null,getTime:function(){return self.performance&&self.performance.now?self.performance.now.bind(performance):Date.now},add:function(t){s$1.ui.push(t),s$1.getZone(t),s$1.isEventsInit||s$1.initEvents();},testMobile:function(){let t=navigator.userAgent;return !!(t.match(/Android/i)||t.match(/webOS/i)||t.match(/iPhone/i)||t.match(/iPad/i)||t.match(/iPod/i)||t.match(/BlackBerry/i)||t.match(/Windows Phone/i))},remove:function(t){let i=s$1.ui.indexOf(t);-1!==i&&(s$1.removeListen(t),s$1.ui.splice(i,1)),0===s$1.ui.length&&s$1.removeEvents();},initEvents:function(){if(s$1.isEventsInit)return;let t=document.body;s$1.isMobile=s$1.testMobile(),s$1.now=s$1.getTime(),s$1.isMobile?t.style.touchAction="none":t.addEventListener("wheel",s$1,{passive:!1}),t.addEventListener("pointercancel",s$1),t.addEventListener("pointerleave",s$1),t.addEventListener("pointermove",s$1),t.addEventListener("pointerdown",s$1),t.addEventListener("pointerup",s$1),t.addEventListener("keydown",s$1,!1),t.addEventListener("keyup",s$1,!1),window.addEventListener("resize",s$1.resize,!1),s$1.isEventsInit=!0,s$1.dom=t;},removeEvents:function(){if(!s$1.isEventsInit)return;let t=document.body;s$1.isMobile||t.removeEventListener("wheel",s$1),t.removeEventListener("pointercancel",s$1),t.removeEventListener("pointerleave",s$1),t.removeEventListener("pointermove",s$1),t.removeEventListener("pointerdown",s$1),t.removeEventListener("pointerup",s$1),t.removeEventListener("keydown",s$1),t.removeEventListener("keyup",s$1),window.removeEventListener("resize",s$1.resize),s$1.isEventsInit=!1;},resize:function(){let t,i=s$1.ui.length;for(;i--;)t=s$1.ui[i],t.isGui&&!t.isCanvasOnly&&t.autoResize&&t.calc();s$1.needReZone=!0,s$1.needResize=!1;},out:function(){console.log("im am out"),s$1.clearOldID();},in:function(){console.log("im am in");},fakeUp:function(){this.handleEvent({type:"pointerup"});},handleEvent:function(t){-1!==s$1.prevDefault.indexOf(t.type)&&t.preventDefault(),s$1.needResize&&s$1.resize(),s$1.findZone(s$1.forceZone);let i=s$1.e,e=!1;"keydown"===t.type&&s$1.keydown(t),"keyup"===t.type&&s$1.keyup(t),"wheel"===t.type?i.delta=t.deltaY>0?1:-1:i.delta=0;let h=t.pointerType;if(i.clientX=("touch"===h?t.pageX:t.clientX)||0,i.clientY=("touch"===h?t.pageY:t.clientY)||0,i.type=t.type,-1!==s$1.eventOut.indexOf(t.type)&&(e=!0,i.type="mouseup"),"pointerleave"===t.type&&(s$1.isLeave=!0),"pointerdown"===t.type&&(i.type="mousedown"),"pointerup"===t.type&&(i.type="mouseup"),"pointermove"===t.type&&(s$1.isLeave&&(s$1.isLeave=!1,s$1.resize()),i.type="mousemove"),"mousedown"===i.type){if(s$1.downTime=s$1.now(),s$1.downTime-s$1.prevTime<200)return s$1.selectAll(),!1;s$1.prevTime=s$1.downTime,s$1.forceZone=!1;}"mousedown"===i.type&&s$1.clearInput(),"mousedown"===i.type&&(s$1.lock=!0),"mouseup"===i.type&&(s$1.lock=!1),s$1.isMobile&&"mousedown"===i.type&&s$1.findID(i),"mousemove"!==i.type||s$1.lock||s$1.findID(i),null!==s$1.ID&&(s$1.ID.isCanvasOnly&&(i.clientX=s$1.ID.mouse.x,i.clientY=s$1.ID.mouse.y),s$1.ID.handleEvent(i)),s$1.isMobile&&"mouseup"===i.type&&s$1.clearOldID(),e&&s$1.clearOldID();},findID:function(t){let i,e,h,o=s$1.ui.length,n=-1;for(;o--;)if(i=s$1.ui[o],i.isCanvasOnly?(e=i.mouse.x,h=i.mouse.y):(e=t.clientX,h=t.clientY),s$1.onZone(i,e,h)){n=o,n!==s$1.current&&(s$1.clearOldID(),s$1.current=n,s$1.ID=i);break}-1===n&&s$1.clearOldID();},clearOldID:function(){s$1.ID&&(s$1.current=-1,s$1.ID.reset(),s$1.ID=null,s$1.cursor());},calcUis:(t,i,e,h=!1)=>{let o,n,r,l=t.length,a=0,c=0,d=0;for(;l--;)o=t[c],c++,!h&&o.isGroup&&o.calcUis(),r=o.margin,o.zone.w=o.w,o.zone.h=o.h+r,o.autoWidth?(a=0,o.zone.x=i.x+o.dx,o.zone.y=e,e+=o.h+r,d+=o.h+r):(0===a&&(d+=o.h+r),o.zone.x=i.x+a,o.zone.y=e,n=s$1.getWidth(o),n?o.zone.w=o.w=n:o.fw&&(o.zone.w=o.w=o.fw),a+=o.zone.w,a>=i.w&&(e+=o.h+r,a=0));return d},findTarget:function(t,i){let e=t.length;for(;e--;)if(s$1.onZone(t[e],i.clientX,i.clientY))return e;return -1},findZone:function(t){if(s$1.needReZone||t){for(var i,e=s$1.ui.length;e--;)i=s$1.ui[e],s$1.getZone(i),i.isGui&&i.calcUis();s$1.needReZone=!1;}},onZone:function(t,s,i){if(void 0===s||void 0===i)return !1;let e=t.zone,h=s-e.x,o=i-e.y,n=h>=0&&o>=0&&h<=e.w&&o<=e.h;return n?t.local.set(h,o):t.local.neg(),n},getWidth:function(t){return t.getDom().clientWidth},getZone:function(t){if(t.isCanvasOnly)return;let s=t.getDom().getBoundingClientRect();t.zone={x:s.left,y:s.top,w:s.width,h:s.height};},cursor:function(t){(t=t||"auto")!==s$1.oldCursor&&(document.body.style.cursor=t,s$1.oldCursor=t);},toCanvas:function(t,i,e,h){if(s$1.xmlserializer||(s$1.xmlserializer=new XMLSerializer),h&&null!==s$1.tmpTime&&(clearTimeout(s$1.tmpTime),s$1.tmpTime=null),null!==s$1.tmpTime)return;s$1.lock&&(s$1.tmpTime=setTimeout((function(){s$1.tmpTime=null;}),10));let o=!1;i===t.canvas.width&&e===t.canvas.height||(o=!0),null===s$1.tmpImage&&(s$1.tmpImage=new Image);let n=s$1.tmpImage,r=s$1.xmlserializer.serializeToString(t.content),l='<svg xmlns="http://www.w3.org/2000/svg" width="'+i+'" height="'+e+'"><foreignObject style="pointer-events: none; left:0;" width="100%" height="100%">'+r+"</foreignObject></svg>";n.onload=function(){let s=t.canvas.getContext("2d");o?(t.canvas.width=i,t.canvas.height=e):s.clearRect(0,0,i,e),s.drawImage(this,0,0),t.onDraw();},n.src="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(l),n.crossOrigin="";},setHidden:function(){null===s$1.hiddenImput&&(s$1.hiddenImput=document.createElement("input"),s$1.hiddenImput.type="text",s$1.hiddenSizer=document.createElement("div"),document.body.appendChild(s$1.hiddenImput),document.body.appendChild(s$1.hiddenSizer));let t=s$1.debugInput?"":"opacity:0; zIndex:0;",i=s$1.parent.css.txtselect+"padding:0; width:auto; height:auto; left:10px; top:auto; color:#FFF; background:#000;"+t;s$1.hiddenImput.style.cssText=i+"bottom:10px;"+(s$1.debugInput?"":"transform:scale(0);"),s$1.hiddenSizer.style.cssText=i+"bottom:40px;",s$1.hiddenImput.style.width=s$1.input.clientWidth+"px",s$1.hiddenImput.value=s$1.str,s$1.hiddenSizer.innerHTML=s$1.str,s$1.hasFocus=!0;},clearHidden:function(t){null!==s$1.hiddenImput&&(s$1.hasFocus=!1);},clickPos:function(t){let i=s$1.str.length,e=0,h=0;for(;i--&&(e+=s$1.textWidth(s$1.str[h]),!(e>=t));)h++;return h},upInput:function(t,i){if(null===s$1.parent)return !1;let e=!1;if(i){let i=s$1.clickPos(t);if(s$1.moveX=i,-1===s$1.startX)s$1.startX=i,s$1.cursorId=i,s$1.inputRange=[s$1.startX,s$1.startX];else {s$1.moveX!==s$1.startX&&(s$1.startX>s$1.moveX?s$1.inputRange=[s$1.moveX,s$1.startX]:s$1.inputRange=[s$1.startX,s$1.moveX]);}e=!0;}else -1!==s$1.startX&&(s$1.hasFocus=!0,s$1.hiddenImput.focus(),s$1.hiddenImput.selectionStart=s$1.inputRange[0],s$1.hiddenImput.selectionEnd=s$1.inputRange[1],s$1.startX=-1,e=!0);return e&&s$1.selectParent(),e},selectAll:function(){s$1.parent&&(s$1.str=s$1.input.textContent,s$1.inputRange=[0,s$1.str.length],s$1.hasFocus=!0,s$1.hiddenImput.focus(),s$1.hiddenImput.selectionStart=s$1.inputRange[0],s$1.hiddenImput.selectionEnd=s$1.inputRange[1],s$1.cursorId=s$1.inputRange[1],s$1.selectParent());},selectParent:function(){var t=s$1.textWidth(s$1.str.substring(0,s$1.cursorId)),i=s$1.textWidth(s$1.str.substring(0,s$1.inputRange[0])),e=s$1.textWidth(s$1.str.substring(s$1.inputRange[0],s$1.inputRange[1]));s$1.parent.select(t,i,e,s$1.hiddenSizer.innerHTML);},textWidth:function(t){return null===s$1.hiddenSizer?0:(t=t.replace(/ /g,"&nbsp;"),s$1.hiddenSizer.innerHTML=t,s$1.hiddenSizer.clientWidth)},clearInput:function(){null!==s$1.parent&&(s$1.firstImput||s$1.parent.validate(!0),s$1.clearHidden(),s$1.parent.unselect(),s$1.input.style.background=s$1.parent.colors.back,s$1.input.style.borderColor=s$1.parent.colors.border,s$1.parent.isEdit=!1,s$1.input=null,s$1.parent=null,s$1.str="",s$1.firstImput=!0);},setInput:function(t,i){s$1.clearInput(),s$1.input=t,s$1.parent=i,s$1.input.style.background=s$1.parent.colors.backoff,s$1.input.style.borderColor=s$1.parent.colors.select,s$1.str=s$1.input.textContent,s$1.setHidden();},keydown:function(t){if(null===s$1.parent)return;let i=t.which;t.shiftKey,s$1.firstImput=!1,s$1.hasFocus&&(window.focus(),s$1.hiddenImput.focus()),s$1.parent.isEdit=!0,13===i?s$1.clearInput():s$1.input.isNum?t.keyCode>47&&t.keyCode<58||t.keyCode>95&&t.keyCode<106||190===t.keyCode||110===t.keyCode||8===t.keyCode||109===t.keyCode?s$1.hiddenImput.readOnly=!1:s$1.hiddenImput.readOnly=!0:s$1.hiddenImput.readOnly=!1;},keyup:function(t){null!==s$1.parent&&(s$1.str=s$1.hiddenImput.value,s$1.parent.allEqual?s$1.parent.sameStr(s$1.str):s$1.input.textContent=s$1.str,s$1.cursorId=s$1.hiddenImput.selectionStart,s$1.inputRange=[s$1.hiddenImput.selectionStart,s$1.hiddenImput.selectionEnd],s$1.selectParent(),s$1.parent.validate());},loop:function(){s$1.isLoop&&requestAnimationFrame(s$1.loop),s$1.update();},update:function(){let t=s$1.listens.length;for(;t--;)s$1.listens[t].listening();},removeListen:function(t){let i=s$1.listens.indexOf(t);-1!==i&&s$1.listens.splice(i,1),0===s$1.listens.length&&(s$1.isLoop=!1);},addListen:function(t){return -1===s$1.listens.indexOf(t)&&(s$1.listens.push(t),s$1.isLoop||(s$1.isLoop=!0,s$1.loop()),!0)}},i$3=s$1,e$1={transition:.2,frag:document.createDocumentFragment(),colorRing:null,joystick_0:null,joystick_1:null,circular:null,knob:null,pad2d:null,svgns:"http://www.w3.org/2000/svg",links:"http://www.w3.org/1999/xlink",htmls:"http://www.w3.org/1999/xhtml",DOM_SIZE:["height","width","top","left","bottom","right","margin-left","margin-right","margin-top","margin-bottom"],SVG_TYPE_D:["pattern","defs","transform","stop","animate","radialGradient","linearGradient","animateMotion","use","filter","feColorMatrix"],SVG_TYPE_G:["svg","rect","circle","path","polygon","text","g","line","foreignObject"],PI:Math.PI,TwoPI:2*Math.PI,pi90:.5*Math.PI,pi60:Math.PI/3,torad:Math.PI/180,todeg:180/Math.PI,clamp:(t,s,i)=>t=(t=t<s?s:t)>i?i:t,isDivid:t=>.5*t===Math.floor(.5*t),size:{w:240,h:20,p:30,s:8},defineColor:(t,s=e$1.colors)=>{let i={...s},h=["fontFamily","fontWeight","fontShadow","fontSize"],o=!1;t.font&&(t.fontFamily=t.font),t.shadow&&(t.fontShadow=t.shadow),t.weight&&(t.fontWeight=t.weight),t.fontColor&&(t.text=t.fontColor),t.color&&(t.text=t.color),t.text&&(i.text=t.text,t.fontColor||t.color||(i.title=e$1.ColorLuma(t.text,-.25),i.titleoff=e$1.ColorLuma(t.text,-.5)),i.textOver=e$1.ColorLuma(t.text,.25),i.textSelect=e$1.ColorLuma(t.text,.5)),t.button&&(i.button=t.button,i.border=e$1.ColorLuma(t.button,.1),i.overoff=e$1.ColorLuma(t.button,.2)),t.select&&(i.select=t.select,i.over=e$1.ColorLuma(t.select,-.1)),t.itemBg&&(t.back=t.itemBg),t.back&&(i.back=t.back,i.backoff=e$1.ColorLuma(t.back,-.1)),t.fontSelect&&(i.textSelect=t.fontSelect),t.groupBorder&&(i.gborder=t.groupBorder),t.bgOver&&(i.backgroundOver=t.bgOver);for(let s in i)void 0!==t[s]&&(i[s]=t[s]);for(let s in t)-1!==h.indexOf(s)&&(o=!0);return o&&e$1.defineText(i),i},colors:{sx:4,sy:2,radius:2,showOver:1,content:"none",background:"rgba(50,50,50,0.15)",backgroundOver:"rgba(50,50,50,0.3)",title:"#CCC",titleoff:"#BBB",text:"#DDD",textOver:"#EEE",textSelect:"#FFF",back:"rgba(0,0,0,0.2)",backoff:"rgba(0,0,0,0.3)",border:"#4c4c4c",borderSize:1,gborder:"none",groups:"none",button:"#3c3c3c",overoff:"#5c5c5c",over:"#024699",select:"#308AFF",action:"#FF3300",fontFamily:"Consolas, monospace",fontWeight:"normal",fontShadow:"none",fontSize:12,joyOver:"rgba(48,138,255,0.25)",joyOut:"rgba(100,100,100,0.5)",joySelect:"#308AFF",hide:"rgba(0,0,0,0)"},css:{basic:"position:absolute; pointer-events:none; box-sizing:border-box; margin:0; padding:0; overflow:hidden; -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select:none;",button:"display:flex; align-items:center; justify-content:center; text-align:center;",middle:"display:flex; align-items:center; justify-content:left; text-align:left; flex-direction: row-reverse;"},svgs:{g1:"M 6 4 L 0 4 0 6 6 6 6 4 M 6 0 L 0 0 0 2 6 2 6 0 Z",g2:"M 6 0 L 4 0 4 6 6 6 6 0 M 2 0 L 0 0 0 6 2 6 2 0 Z",group:"M 7 7 L 7 8 8 8 8 7 7 7 M 5 7 L 5 8 6 8 6 7 5 7 M 3 7 L 3 8 4 8 4 7 3 7 M 7 5 L 7 6 8 6 8 5 7 5 M 6 6 L 6 5 5 5 5 6 6 6 M 7 3 L 7 4 8 4 8 3 7 3 M 6 4 L 6 3 5 3 5 4 6 4 M 3 5 L 3 6 4 6 4 5 3 5 M 3 3 L 3 4 4 4 4 3 3 3 Z",arrow:"M 3 8 L 8 5 3 2 3 8 Z",arrowDown:"M 5 8 L 8 3 2 3 5 8 Z",arrowUp:"M 5 2 L 2 7 8 7 5 2 Z",solid:"M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 Z",body:"M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 M 5 4 L 4 5 4 10 9 10 10 9 10 4 5 4 Z",vehicle:"M 13 6 L 11 1 3 1 1 6 1 13 3 13 3 11 11 11 11 13 13 13 13 6 M 2.4 6 L 4 2 10 2 11.6 6 2.4 6 M 12 8 L 12 10 10 10 10 8 12 8 M 4 8 L 4 10 2 10 2 8 4 8 Z",articulation:"M 13 9 L 12 9 9 2 9 1 5 1 5 2 2 9 1 9 1 13 5 13 5 9 4 9 6 5 8 5 10 9 9 9 9 13 13 13 13 9 Z",character:"M 13 4 L 12 3 9 4 5 4 2 3 1 4 5 6 5 8 4 13 6 13 7 9 8 13 10 13 9 8 9 6 13 4 M 6 1 L 6 3 8 3 8 1 6 1 Z",terrain:"M 13 8 L 12 7 Q 9.06 -3.67 5.95 4.85 4.04 3.27 2 7 L 1 8 7 13 13 8 M 3 8 Q 3.78 5.420 5.4 6.6 5.20 7.25 5 8 L 7 8 Q 8.39 -0.16 11 8 L 7 11 3 8 Z",joint:"M 7.7 7.7 Q 8 7.45 8 7 8 6.6 7.7 6.3 7.45 6 7 6 6.6 6 6.3 6.3 6 6.6 6 7 6 7.45 6.3 7.7 6.6 8 7 8 7.45 8 7.7 7.7 M 3.35 8.65 L 1 11 3 13 5.35 10.65 Q 6.1 11 7 11 8.28 11 9.25 10.25 L 7.8 8.8 Q 7.45 9 7 9 6.15 9 5.55 8.4 5 7.85 5 7 5 6.54 5.15 6.15 L 3.7 4.7 Q 3 5.712 3 7 3 7.9 3.35 8.65 M 10.25 9.25 Q 11 8.28 11 7 11 6.1 10.65 5.35 L 13 3 11 1 8.65 3.35 Q 7.9 3 7 3 5.7 3 4.7 3.7 L 6.15 5.15 Q 6.54 5 7 5 7.85 5 8.4 5.55 9 6.15 9 7 9 7.45 8.8 7.8 L 10.25 9.25 Z",ray:"M 9 11 L 5 11 5 12 9 12 9 11 M 12 5 L 11 5 11 9 12 9 12 5 M 11.5 10 Q 10.9 10 10.45 10.45 10 10.9 10 11.5 10 12.2 10.45 12.55 10.9 13 11.5 13 12.2 13 12.55 12.55 13 12.2 13 11.5 13 10.9 12.55 10.45 12.2 10 11.5 10 M 9 10 L 10 9 2 1 1 2 9 10 Z",collision:"M 11 12 L 13 10 10 7 13 4 11 2 7.5 5.5 9 7 7.5 8.5 11 12 M 3 2 L 1 4 4 7 1 10 3 12 8 7 3 2 Z",map:"M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z",material:"M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z",texture:"M 13 4 L 13 1 1 1 1 4 5 4 5 13 9 13 9 4 13 4 Z",object:"M 10 1 L 7 4 4 1 1 1 1 13 4 13 4 5 7 8 10 5 10 13 13 13 13 1 10 1 Z",none:"M 9 5 L 5 5 5 9 9 9 9 5 Z",cursor:"M 4 7 L 1 10 1 12 2 13 4 13 7 10 9 14 14 0 0 5 4 7 Z",load:"M 13 8 L 11.5 6.5 9 9 9 3 5 3 5 9 2.5 6.5 1 8 7 14 13 8 M 9 2 L 9 0 5 0 5 2 9 2 Z",save:"M 9 12 L 5 12 5 14 9 14 9 12 M 11.5 7.5 L 13 6 7 0 1 6 2.5 7.5 5 5 5 11 9 11 9 5 11.5 7.5 Z",extern:"M 14 14 L 14 0 0 0 0 14 14 14 M 12 6 L 12 12 2 12 2 6 12 6 M 12 2 L 12 4 2 4 2 2 12 2 Z"},rezone(){i$3.needReZone=!0;},getImput:function(){return !!i$3.input},setStyle:function(t){for(var s in t)e$1.colors[s]&&(e$1.colors[s]=t[s]);e$1.setText();},defineText:function(t){e$1.setText(t.fontSize,t.text,t.fontFamily,t.fontShadow,t.fontWeight);},setText:function(t,s,i,h,o){let n=e$1.colors;void 0===i&&(i=n.fontFamily),void 0===t&&(t=n.fontSize),void 0===h&&(h=n.fontShadow),void 0===o&&(o=n.fontWeight),isNaN(t)?-1===t.search("em")&&(t+="px"):t+="px",e$1.css.txt=e$1.css.basic+e$1.css.middle+" font-family:"+i+"; font-weight:"+o+"; font-size:"+t+"; color:"+n.text+"; padding:0px 8px; left:0; top:2px; height:16px; width:100px; overflow:hidden; white-space: nowrap; letter-spacing: normal;","none"!==h&&(e$1.css.txt+=" text-shadow: 1px 1px 1px "+h+";"),e$1.css.txtselect=e$1.css.txt+"padding:0px 4px; border:1px dashed "+n.border+";",e$1.css.item=e$1.css.txt+"padding:0px 4px; position:relative; margin-bottom:1px; ";},cloneCss:function(){return {...e$1.css}},clone:function(t){return t.cloneNode(!0)},setSvg:function(t,s,i,e,h){-1===e?t.setAttributeNS(null,s,i):void 0!==h?t.childNodes[e||0].childNodes[h||0].setAttributeNS(null,s,i):t.childNodes[e||0].setAttributeNS(null,s,i);},setCss:function(t,s){for(let i in s)-1!==e$1.DOM_SIZE.indexOf(i)?t.style[i]=s[i]+"px":t.style[i]=s[i];},set:function(t,s){for(let i in s)"txt"===i&&(t.textContent=s[i]),"link"===i?t.setAttributeNS(e$1.links,"xlink:href",s[i]):t.setAttributeNS(null,i,s[i]);},get:function(t,s){if(void 0===s)return t;if(!isNaN(s))return t.childNodes[s];if(s instanceof Array){if(2===s.length)return t.childNodes[s[0]].childNodes[s[1]];if(3===s.length)return t.childNodes[s[0]].childNodes[s[1]].childNodes[s[2]]}},dom:function(t,s,i,h,o){return t=t||"div",-1!==e$1.SVG_TYPE_D.indexOf(t)||-1!==e$1.SVG_TYPE_G.indexOf(t)?"svg"===t?(h=document.createElementNS(e$1.svgns,"svg"),e$1.set(h,i)):(void 0===h&&(h=document.createElementNS(e$1.svgns,"svg")),e$1.addAttributes(h,t,i,o)):h=void 0===h?document.createElementNS(e$1.htmls,t):h.appendChild(document.createElementNS(e$1.htmls,t)),s&&(h.style.cssText=s),void 0===o?h:h.childNodes[o||0]},addAttributes:function(t,s,i,h){let o=document.createElementNS(e$1.svgns,s);return e$1.set(o,i),e$1.get(t,h).appendChild(o),-1!==e$1.SVG_TYPE_G.indexOf(s)&&(o.style.pointerEvents="none"),o},clear:function(t){for(e$1.purge(t);t.firstChild;)t.firstChild.firstChild&&e$1.clear(t.firstChild),t.removeChild(t.firstChild);},purge:function(t){let s,i,h=t.attributes;if(h)for(s=h.length;s--;)i=h[s].name,"function"==typeof t[i]&&(t[i]=null);if(h=t.childNodes,h)for(s=h.length;s--;)e$1.purge(t.childNodes[s]);},addSVGGlowEffect:function(){if(null!==document.getElementById("UILGlow"))return;let t=e$1.initUILEffects(),s=e$1.addAttributes(t,"filter",{id:"UILGlow",x:"-20%",y:"-20%",width:"140%",height:"140%"});e$1.addAttributes(s,"feGaussianBlur",{in:"SourceGraphic",stdDeviation:"3",result:"uilBlur"});let i=e$1.addAttributes(s,"feMerge",{});for(let t=0;t<=3;t++)e$1.addAttributes(i,"feMergeNode",{in:"uilBlur"});e$1.addAttributes(i,"feMergeNode",{in:"SourceGraphic"});},initUILEffects:function(){let t=document.getElementById("UILSVGEffects");return null===t&&(t=e$1.dom("svg",void 0,{id:"UILSVGEffects",width:"0",height:"0"}),document.body.appendChild(t)),t},ColorLuma:function(t,s){"n"===t&&(t="#000"),(t=String(t).replace(/[^0-9a-f]/gi,"")).length<6&&(t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]),s=s||0;let i,e,h="#";for(e=0;e<3;e++)i=parseInt(t.substr(2*e,2),16),i=Math.round(Math.min(Math.max(0,i+i*s),255)).toString(16),h+=("00"+i).substr(i.length);return h},findDeepInver:function(t){return .3*t[0]+.59*t[1]+.11*t[2]<=.6},lerpColor:function(t,s,i){let e={};for(let h=0;h<3;h++)e[h]=t[h]+(s[h]-t[h])*i;return e},hexToHtml:function(t){return "#"+("000000"+(t=void 0===t?0:t).toString(16)).substr(-6)},htmlToHex:function(t){return t.toUpperCase().replace("#","0x")},u255:function(t,s){return parseInt(t.substring(s,s+2),16)/255},u16:function(t,s){return parseInt(t.substring(s,s+1),16)/15},unpack:function(t){return 7==t.length?[e$1.u255(t,1),e$1.u255(t,3),e$1.u255(t,5)]:4==t.length?[e$1.u16(t,1),e$1.u16(t,2),e$1.u16(t,3)]:void 0},p255:function(t){let s=Math.round(255*t).toString(16);return s.length<2&&(s="0"+s),s},pack:function(t){return "#"+e$1.p255(t[0])+e$1.p255(t[1])+e$1.p255(t[2])},htmlRgba:function(t,s){return t=e$1.unpack(t),"rgba("+Math.round(255*t[0])+","+Math.round(255*t[1])+","+Math.round(255*t[2])+","+s+")"},htmlRgb:function(t,s){return "rgb("+Math.round(255*t[0])+","+Math.round(255*t[1])+","+Math.round(255*t[2])+")"},pad:function(t){return 1==t.length&&(t="0"+t),t},rgbToHex:function(t){let s=Math.round(255*t[0]).toString(16),i=Math.round(255*t[1]).toString(16),h=Math.round(255*t[2]).toString(16);return "#"+e$1.pad(s)+e$1.pad(i)+e$1.pad(h)},hueToRgb:function(t,s,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(s-t)*i:i<.5?s:i<2/3?t+6*(s-t)*(2/3-i):t},rgbToHsl:function(t){let s=t[0],i=t[1],e=t[2],h=Math.min(s,i,e),o=Math.max(s,i,e),n=o-h,r=0,l=0,a=(h+o)/2;return a>0&&a<1&&(l=n/(a<.5?2*a:2-2*a)),n>0&&(o==s&&o!=i&&(r+=(i-e)/n),o==i&&o!=e&&(r+=2+(e-s)/n),o==e&&o!=s&&(r+=4+(s-i)/n),r/=6),[r,l,a]},hslToRgb:function(t){let s,i,h=t[0],o=t[1],n=t[2];return 0===o?[n,n,n]:(i=n<=.5?n*(o+1):n+o-n*o,s=2*n-i,[e$1.hueToRgb(s,i,h+.33333),e$1.hueToRgb(s,i,h),e$1.hueToRgb(s,i,h-.33333)])},makeGradiant:function(t,s,i,h){e$1.dom(t,null,s,i,0);let o,n=i.childNodes[0].childNodes.length-1;for(let t=0;t<h.length;t++)o=h[t],e$1.dom("stop",null,{offset:o[0]+"%","stop-color":o[1],"stop-opacity":o[2]},i,[0,n]);},makePad:function(t){let s=256,i=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 256 256",width:s,height:s,preserveAspectRatio:"none"}),o=200,n=28;h$2.dom("rect","",{x:n,y:n,width:o,height:o,fill:e$1.colors.back},i),h$2.dom("rect","",{x:38,y:38,width:180,height:180,fill:e$1.colors.button},i),h$2.dom("line","",{x1:38,y1:128,x2:218,y2:128,stroke:e$1.colors.back,"stroke-width":2},i),h$2.dom("line","",{x1:128,x2:128,y1:38,y2:218,stroke:e$1.colors.back,"stroke-width":2},i),h$2.dom("circle","",{cx:128,cy:128,r:5,stroke:e$1.colors.text,"stroke-width":5,fill:"none"},i),e$1.pad2d=i;},makeKnob:function(t){let s=128,i=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 128 "+s,width:s,height:s,preserveAspectRatio:"none"});e$1.dom("circle","",{cx:64,cy:64,r:34,fill:e$1.colors.button,stroke:"rgba(0,0,0,0.3)","stroke-width":8},i),e$1.dom("path","",{d:"",stroke:e$1.colors.text,"stroke-width":4,fill:"none","stroke-linecap":"round"},i),e$1.dom("circle","",{cx:64,cy:64,r:41,stroke:"rgba(0,0,0,0.1)","stroke-width":7,fill:"none"},i),e$1.dom("path","",{d:"",stroke:"rgba(255,255,255,0.3)","stroke-width":2,fill:"none","stroke-linecap":"round","stroke-opacity":.5},i),e$1.knob=i;},makeCircular:function(t){let s=128,i=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 128 "+s,width:s,height:s,preserveAspectRatio:"none"});e$1.dom("circle","",{cx:64,cy:64,r:40,stroke:"rgba(0,0,0,0.1)","stroke-width":10,fill:"none"},i),e$1.dom("path","",{d:"",stroke:e$1.colors.text,"stroke-width":7,fill:"none","stroke-linecap":"butt"},i),e$1.circular=i;},makeJoystick:function(t){let s,i=128,h=Math.floor(49),o=Math.floor(.6*h),n=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 128 "+i,width:i,height:i,preserveAspectRatio:"none"});if(e$1.dom("defs",null,{},n),e$1.dom("g",null,{},n),0===t){s=[[40,"rgb(0,0,0)",.3],[80,"rgb(0,0,0)",0],[90,"rgb(50,50,50)",.4],[100,"rgb(50,50,50)",0]],e$1.makeGradiant("radialGradient",{id:"grad",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s),s=[[60,"rgb(0,0,0)",.5],[100,"rgb(0,0,0)",0]],e$1.makeGradiant("radialGradient",{id:"gradS",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s);let t=["rgb(40,40,40)","rgb(48,48,48)","rgb(30,30,30)"],i=["rgb(1,90,197)","rgb(3,95,207)","rgb(0,65,167)"];s=[[30,t[0],1],[60,t[1],1],[80,t[1],1],[100,t[2],1]],e$1.makeGradiant("radialGradient",{id:"gradIn",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s),s=[[30,i[0],1],[60,i[1],1],[80,i[1],1],[100,i[2],1]],e$1.makeGradiant("radialGradient",{id:"gradIn2",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s),e$1.dom("circle","",{cx:64,cy:64,r:h,fill:"url(#grad)"},n),e$1.dom("circle","",{cx:69,cy:74,r:o+10,fill:"url(#gradS)"},n),e$1.dom("circle","",{cx:64,cy:64,r:o,fill:"url(#gradIn)"},n),e$1.joystick_0=n;}else s=[[69,"rgb(0,0,0)",0],[70,"rgb(0,0,0)",.3],[100,"rgb(0,0,0)",0]],e$1.makeGradiant("radialGradient",{id:"gradX",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},n,s),e$1.dom("circle","",{cx:64,cy:64,r:h,fill:"none",stroke:"rgba(100,100,100,0.25)","stroke-width":"4"},n),e$1.dom("circle","",{cx:64,cy:64,r:o+14,fill:"url(#gradX)"},n),e$1.dom("circle","",{cx:64,cy:64,r:o,fill:"none",stroke:"rgb(100,100,100)","stroke-width":"4"},n),e$1.joystick_1=n;},makeColorRing:function(){let t=256,s=e$1.dom("svg",e$1.css.basic+"position:relative;",{viewBox:"0 0 256 "+t,width:t,height:t,preserveAspectRatio:"none"});e$1.dom("defs",null,{},s),e$1.dom("g",null,{},s);let i,h,o,n,r,l,a,c,d,u=128,p=8/113/24*Math.PI,m=0,g=[];for(l=0;l<=24;++l){if(o=l/24,n=o*e$1.TwoPI,i=.5*(m+n),h=1/Math.cos(.5*(n-m)),r=[Math.sin(m),-Math.cos(m),Math.sin(i)*h,-Math.cos(i)*h,Math.sin(n),-Math.cos(n)],g[1]=e$1.rgbToHex(e$1.hslToRgb([o,1,.5])),l>0){for(a=6;a--;)r[a]=(113*r[a]+u).toFixed(2);c=" M"+r[0]+" "+r[1]+" Q"+r[2]+" "+r[3]+" "+r[4]+" "+r[5],d=[[0,g[0],1],[100,g[1],1]],e$1.makeGradiant("linearGradient",{id:"G"+l,x1:r[0],y1:r[1],x2:r[4],y2:r[5],gradientUnits:"userSpaceOnUse"},s,d),e$1.dom("path","",{d:c,"stroke-width":30,stroke:"url(#G"+l+")","stroke-linecap":"butt"},s,1);}m=n-p,g[0]=g[1];}d=[[0,"#FFFFFF",1],[50,"#FFFFFF",0],[50,"#000000",0],[100,"#000000",1]],e$1.makeGradiant("linearGradient",{id:"GL0",x1:0,y1:u-84.9,x2:0,y2:212.9,gradientUnits:"userSpaceOnUse"},s,d),d=[[0,"#7f7f7f",1],[50,"#7f7f7f",.5],[100,"#7f7f7f",0]],e$1.makeGradiant("linearGradient",{id:"GL1",x1:78.95,y1:0,x2:226,y2:0,gradientUnits:"userSpaceOnUse"},s,d),e$1.dom("g",null,{"transform-origin":"128px 128px",transform:"rotate(0)"},s),e$1.dom("polygon","",{points:"78.95 43.1 78.95 212.85 226 128",fill:"red"},s,2),e$1.dom("polygon","",{points:"78.95 43.1 78.95 212.85 226 128",fill:"url(#GL1)","stroke-width":1,stroke:"url(#GL1)"},s,2),e$1.dom("polygon","",{points:"78.95 43.1 78.95 212.85 226 128",fill:"url(#GL0)","stroke-width":1,stroke:"url(#GL0)"},s,2),e$1.dom("path","",{d:"M 255.75 136.5 Q 256 132.3 256 128 256 123.7 255.75 119.5 L 241 128 255.75 136.5 Z",fill:"none","stroke-width":2,stroke:"#000"},s,2),e$1.dom("circle","",{cx:128,cy:128,r:6,"stroke-width":2,stroke:"#000",fill:"none"},s),e$1.colorRing=s;},icon:function(t,s,i){i=i||40;let h=["<svg xmlns='"+e$1.svgns+"' version='1.1' xmlns:xlink='"+e$1.htmls+"' style='pointer-events:none;' preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='"+i+"px' height='"+i+"px' viewBox='0 0 256 256'><g>"];switch(t){case"logo":h[1]="<path id='logoin' fill='"+s+"' stroke='none' d='"+e$1.logoFill_d+"'/>";break;case"donate":h[1]="<path id='logoin' fill='"+s+"' stroke='none' d='"+e$1.logo_donate+"'/>";break;case"neo":h[1]="<path id='logoin' fill='"+s+"' stroke='none' d='"+e$1.logo_neo+"'/>";break;case"phy":h[1]="<path id='logoin' stroke='"+s+"' stroke-width='49' stroke-linejoin='round' stroke-linecap='butt' fill='none' d='"+e$1.logo_phy+"'/>";break;case"config":h[1]="<path id='logoin' stroke='"+s+"' stroke-width='49' stroke-linejoin='round' stroke-linecap='butt' fill='none' d='"+e$1.logo_config+"'/>";break;case"github":h[1]="<path id='logoin' fill='"+s+"' stroke='none' d='"+e$1.logo_github+"'/>";break;case"save":h[1]="<path stroke='"+s+"' stroke-width='4' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 26.125 17 L 20 22.95 14.05 17 M 20 9.95 L 20 22.95'/><path stroke='"+s,h[1]+="' stroke-width='2.5' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 32.6 23 L 32.6 25.5 Q 32.6 28.5 29.6 28.5 L 10.6 28.5 Q 7.6 28.5 7.6 25.5 L 7.6 23'/>";}return h[2]="</g></svg>",h.join("\n")},logoFill_d:"\n    M 171 150.75 L 171 33.25 155.5 33.25 155.5 150.75 Q 155.5 162.2 147.45 170.2 139.45 178.25 128 178.25 116.6 178.25 108.55 170.2 100.5 162.2 100.5 150.75 \n    L 100.5 33.25 85 33.25 85 150.75 Q 85 168.65 97.55 181.15 110.15 193.75 128 193.75 145.9 193.75 158.4 181.15 171 168.65 171 150.75 \n    M 200 33.25 L 184 33.25 184 150.8 Q 184 174.1 167.6 190.4 151.3 206.8 128 206.8 104.75 206.8 88.3 190.4 72 174.1 72 150.8 L 72 33.25 56 33.25 56 150.75 \n    Q 56 180.55 77.05 201.6 98.2 222.75 128 222.75 157.8 222.75 178.9 201.6 200 180.55 200 150.75 L 200 33.25 Z\n    ",logo_github:"\n    M 180.5 70 Q 186.3 82.4 181.55 96.55 196.5 111.5 189.7 140.65 183.65 168.35 146 172.7 152.5 178.7 152.55 185.9 L 152.55 218.15 Q 152.84 224.56 159.15 223.3 \n    159.21 223.3 159.25 223.3 181.14 216.25 198.7 198.7 228 169.4 228 128 228 86.6 198.7 57.3 169.4 28 128 28 86.6 28 57.3 57.3 28 86.6 28 128 28 169.4 57.3 198.7 74.85 \n    216.25 96.75 223.3 96.78 223.3 96.8 223.3 103.16 224.54 103.45 218.15 L 103.45 200 Q 82.97 203.1 75.1 196.35 69.85 191.65 68.4 185.45 64.27 177.055 59.4 174.15 49.20 \n    166.87 60.8 167.8 69.85 169.61 75.7 180 81.13 188.09 90 188.55 98.18 188.86 103.45 185.9 103.49 178.67 110 172.7 72.33 168.33 66.3 140.65 59.48 111.49 74.45 96.55 69.7 \n    82.41 75.5 70 84.87 68.74 103.15 80 115.125 76.635 128 76.85 140.85 76.65 152.85 80 171.1 68.75 180.5 70 Z\n    ",logo_neo:"\n    M 219 52 L 206 52 206 166 Q 206 183.4 193.75 195.65 181.4 208 164 208 146.6 208 134.35 195.65 122 183.4 122 166 L 122 90 Q 122 77.6 113.15 68.85 104.4 60 92 60 79.55 \n    60 70.75 68.85 62 77.6 62 90 L 62 204 75 204 75 90 Q 75 83 79.95 78 84.95 73 92 73 99 73 104 78 109 83 109 90 L 109 166 Q 109 188.8 125.15 204.85 141.2 221 164 221 \n    186.75 221 202.95 204.85 219 188.8 219 166 L 219 52 M 194 52 L 181 52 181 166 Q 181 173 176.05 178 171.05 183 164 183 157 183 152 178 147 173 147 166 L 147 90 Q 147 \n    67.2 130.85 51.15 114.8 35 92 35 69.25 35 53.05 51.15 37 67.2 37 90 L 37 204 50 204 50 90 Q 50 72.6 62.25 60.35 74.6 48 92 48 109.4 48 121.65 60.35 134 72.6 134 90 L \n    134 166 Q 134 178.4 142.85 187.15 151.6 196 164 196 176.45 196 185.25 187.15 194 178.4 194 166 L 194 52 Z\n    ",logo_phy:"\n    M 103.55 37.95 L 127.95 37.95 Q 162.35 37.95 186.5 55 210.9 72.35 210.9 96.5 210.9 120.65 186.5 137.7 162.35 155 127.95 155 L 127.95 237.95 M 127.95 155 \n    Q 93.55 155 69.15 137.7 45 120.65 45 96.5 45 72.35 69.15 55 70.9 53.8 72.85 52.85 M 127.95 155 L 127.95 37.95\n    ",logo_config:"\n    M 204.35 51.65 L 173.25 82.75 Q 192 101.5 192 128 L 236 128 M 192 128 Q 192 154.55 173.25 173.25 L 204.4 204.4 M 51.65 51.65 L 82.75 82.75 Q 101.5 64 128 64 \n    L 128 20 M 51.6 204.4 L 82.75 173.25 Q 64 154.55 64 128 L 20 128 M 128 236 L 128 192 Q 101.5 192 82.75 173.25 M 64 128 Q 64 101.5 82.75 82.75 M 173.25 173.25 \n    Q 154.55 192 128 192 M 128 64 Q 154.55 64 173.25 82.75\n    ",logo_donate:"\n    M 171.3 80.3 Q 179.5 62.15 171.3 45.8 164.1 32.5 141.35 30.1 L 94.35 30.1 Q 89.35 30.4 88.3 35.15 L 70.5 148.05 Q 70.2 152.5 73.7 152.6 L 100.95 152.6 107 111.6 Q 108.75 \n    106.55 112.6 106.45 130.45 108.05 145.3 103.9 163.35 98.75 171.3 80.3 M 179.8 71.5 Q 178.6 79.75 174.9 87.85 168.45 102.9 151.9 109.15 140.65 113.95 117.55 113 113.15 \n    112.75 111 117.45 L 102.7 169.95 Q 102.45 173.8 105.5 173.85 L 128.95 173.85 Q 132.2 174.2 133.35 169.65 L 138.3 139.95 Q 139.75 135.6 143.1 135.5 146.6 135.75 150.6 135.65 \n    154.55 135.5 157.35 135.1 160.15 134.7 166.75 132.35 181.35 127.4 187.9 111.2 194.25 95.75 189.5 81.95 186.75 74.85 179.8 71.5 M 103.5 209.9 Q 103.5 202.85 99.7 198.85 95.95 \n    194.75 89.4 194.75 82.8 194.75 79.05 198.85 75.3 202.9 75.3 209.9 75.3 216.85 79.05 220.95 82.8 225.05 89.4 225.05 95.95 225.05 99.7 221 103.5 216.95 103.5 209.9 M 95.45 205.5 \n    Q 95.95 207.3 95.95 209.9 95.95 212.65 95.45 214.35 94.95 216 94 217.3 93.1 218.45 91.9 219 90.7 219.55 89.4 219.55 88.15 219.55 86.95 219.05 85.75 218.55 84.8 217.3 83.9 216.15 \n    83.4 214.35 82.85 212.6 82.85 209.9 82.85 207.3 83.4 205.45 83.95 203.55 84.85 202.45 85.9 201.2 86.95 200.75 88.05 200.25 89.4 200.25 90.7 200.25 91.85 200.8 93.05 201.3 94 202.5 \n    94.9 203.65 95.45 205.5 M 153.3 195.35 L 145.3 195.35 135.5 224.45 142.8 224.45 144.6 218.5 153.75 218.5 155.6 224.45 163.1 224.45 153.3 195.35 M 152.15 213.25 L 146.25 213.25 \n    149.2 203.65 152.15 213.25 M 116.75 195.35 L 107.8 195.35 107.8 224.45 114.5 224.45 114.5 204.2 125.7 224.45 132.75 224.45 132.75 195.35 126.05 195.35 126.05 212.05 116.75 195.35 M \n    66.5 197.65 Q 64.15 196.15 61.45 195.75 58.8 195.35 55.75 195.35 L 46.7 195.35 46.7 224.45 55.8 224.45 Q 58.8 224.45 61.5 224.05 64.15 223.6 66.4 222.15 69.15 220.45 70.9 217.2 \n    72.7 214 72.7 209.95 72.7 205.7 71 202.6 69.35 199.5 66.5 197.65 M 64.2 205 Q 65.2 207 65.2 209.9 65.2 212.75 64.25 214.75 63.3 216.75 61.5 217.85 60 218.85 58.3 218.9 56.6 219 \n    54.15 219 L 54 219 54 200.8 54.15 200.8 Q 56.4 200.8 58.05 200.9 59.7 200.95 61.15 201.75 63.2 202.95 64.2 205 M 210.2 195.35 L 190.5 195.35 190.5 224.45 210.2 224.45 210.2 218.9 \n    197.75 218.9 197.75 211.55 209.2 211.55 209.2 206 197.75 206 197.75 200.9 210.2 200.9 210.2 195.35 M 187.5 195.35 L 163 195.35 163 200.9 171.6 200.9 171.6 224.45 178.9 224.45 178.9 \n    200.9 187.5 200.9 187.5 195.35 Z\n    "};e$1.setText();const h$2=e$1;class o$1{static autoTypes(t){let s=[];switch(t){case"svg":s=[{accept:{"image/svg+xml":".svg"}}];break;case"wav":s=[{accept:{"audio/wav":".wav"}}];break;case"mp3":s=[{accept:{"audio/mpeg":".mp3"}}];break;case"mp4":s=[{accept:{"video/mp4":".mp4"}}];break;case"bin":case"hex":s=[{description:"Binary Files",accept:{"application/octet-stream":[".bin",".hex"]}}];break;case"text":s=[{description:"Text Files",accept:{"text/plain":[".txt",".text"],"text/html":[".html",".htm"]}}];break;case"json":s=[{description:"JSON Files",accept:{"application/json":[".json"]}}];break;case"js":s=[{description:"JavaScript Files",accept:{"text/javascript":[".js"]}}];break;case"image":s=[{description:"Images",accept:{"image/*":[".png",".gif",".jpeg",".jpg"]}}];break;case"icon":s=[{description:"Icons",accept:{"image/x-ico":[".ico"]}}];break;case"lut":s=[{description:"Lut",accept:{"text/plain":[".cube",".3dl"]}}];}return s}static async load(t={}){"function"!=typeof window.showOpenFilePicker&&(window.showOpenFilePicker=o$1.showOpenFilePickerPolyfill);try{let s=t.type||"";const i={excludeAcceptAllOption:!!s,multiple:!1};i.types=o$1.autoTypes(s);const e=await window.showOpenFilePicker(i),h=await e[0].getFile();if(!h)return null;let n=h.name,r=n.substring(n.lastIndexOf(".")+1,n.length);const l=["png","jpg","jpeg","mp4","webm","ogg","mp3"],a=["sea","z","hex","bvh","BVH","glb","gltf"],c=new FileReader;-1!==l.indexOf(r)?c.readAsDataURL(h):-1!==a.indexOf(r)?c.readAsArrayBuffer(h):c.readAsText(h),c.onload=function(i){let e=i.target.result;switch(s){case"image":let s=new Image;s.onload=function(){t.callback&&t.callback(s,n,r);},s.src=e;break;case"json":t.callback&&t.callback(JSON.parse(e),n,r);break;default:t.callback&&t.callback(e,n,r);}};}catch(s){console.log(s),t.always&&t.callback&&t.callback(null);}}static showOpenFilePickerPolyfill(t){return new Promise((s=>{const i=document.createElement("input");i.type="file",i.multiple=t.multiple,i.accept=t.types.map((t=>t.accept)).flatMap((t=>Object.keys(t).flatMap((s=>t[s])))).join(","),i.addEventListener("change",(()=>{s([...i.files].map((t=>({getFile:async()=>new Promise((s=>{s(t);}))}))));})),i.click();}))}static async save(t={}){let s=!1;"function"!=typeof window.showSaveFilePicker&&(window.showSaveFilePicker=o$1.showSaveFilePickerPolyfill,s=!0);try{let i=t.type||"";const e={suggestedName:t.name||"hello",data:t.data||""};e.types=o$1.autoTypes(i),e.finalType=Object.keys(e.types[0].accept)[0],e.suggestedName+=e.types[0].accept[e.finalType][0];const h=await window.showSaveFilePicker(e);if(s)return;const n=await h.createWritable();let r=new Blob([e.data],{type:e.finalType});await n.write(r),await n.close();}catch(t){console.log(t);}}static showSaveFilePickerPolyfill(t){return new Promise((s=>{const i=document.createElement("a");i.download=t.suggestedName||"my-file.txt";let e=new Blob([t.data],{type:t.finalType});i.href=URL.createObjectURL(e),i.addEventListener("click",(()=>{s(setTimeout((()=>URL.revokeObjectURL(i.href)),1e3));})),i.click();}))}static async getFolder(){try{const t=await window.showDirectoryPicker(),s=[];for await(const i of t.values()){const t=await i.getFile();s.push(t);}return console.log(s),s}catch(t){console.log(t);}}}class n$1{constructor(t=0,s=0){this.x=t,this.y=s;}set(t,s){return this.x=t,this.y=s,this}divide(t){return this.x/=t.x,this.y/=t.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divideScalar(t){return this.multiplyScalar(1/t)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}angle(){var t=Math.atan2(this.y,this.x);return t<0&&(t+=2*Math.PI),t}addScalar(t){return this.x+=t,this.y+=t,this}negate(){return this.x*=-1,this.y*=-1,this}neg(){return this.x=-1,this.y=-1,this}isZero(){return 0===this.x&&0===this.y}copy(t){return this.x=t.x,this.y=t.y,this}equals(t){return t.x===this.x&&t.y===this.y}nearEquals(t,s){return t.x.toFixed(s)===this.x.toFixed(s)&&t.y.toFixed(s)===this.y.toFixed(s)}lerp(t,s){return null===t?(this.x-=this.x*s,this.y-=this.y*s):(this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s),this}}class r$1{constructor(t={}){this.lock=t.lock||!1,this.neverlock=!1,this.isSpace=t.isSpace||!1,this.main=t.main||null,this.isUI=t.isUI||!1,this.group=t.group||null,this.isListen=!1,this.top=0,this.ytop=0,this.dx=t.dx||0,this.isSelectable=void 0!==t.selectable&&t.selectable,this.unselectable=void 0!==t.unselect?t.unselect:this.isSelectable,this.ontop=!!t.ontop&&t.ontop,this.css=this.main?this.main.css:h$2.css,this.colors=h$2.defineColor(t,this.main?this.group?this.group.colors:this.main.colors:h$2.colors),this.overEffect=this.colors.showOver,this.svgs=h$2.svgs,this.zone={x:0,y:0,w:0,h:0,d:0},this.local=(new n$1).neg(),this.isCanvasOnly=!1,this.isSelect=!1,this.p=void 0!==t.p?t.p:h$2.size.p,this.w=this.isUI?this.main.size.w:h$2.size.w,void 0!==t.w&&(this.w=t.w),this.h=this.isUI?this.main.size.h:h$2.size.h,void 0!==t.h&&(this.h=t.h),this.isSpace?this.lock=!0:this.h=this.h<11?11:this.h,this.fw=t.fw||0,this.autoWidth=t.auto||!0,this.isOpen=!1,this.radius=t.radius||this.colors.radius,this.transition=t.transition||h$2.transition,this.isNumber=!1,this.noNeg=t.noNeg||!1,this.allEqual=t.allEqual||!1,this.mono=!1,this.isEdit=!1,this.simple=t.simple||!1,this.simple&&(this.sa=0),this.setSize(this.w),void 0!==t.sa&&(this.sa=t.sa),void 0!==t.sb&&(this.sb=t.sb),this.simple&&(this.sb=this.w-this.sa),this.sc=void 0===t.sc?47:t.sc,this.objectLink=null,this.isSend=!1,this.objectKey=null,this.txt=t.name||"",this.name=t.rename||this.txt,this.target=t.target||null,this.callback=void 0===t.callback?null:t.callback,this.endCallback=null,this.openCallback=void 0===t.openCallback?null:t.openCallback,this.closeCallback=void 0===t.closeCallback?null:t.closeCallback,null===this.callback&&this.isUI&&null!==this.main.callback&&(this.callback=this.group?this.group.callback:this.main.callback),this.c=[],this.s=[],this.useFlex=!!this.isUI&&this.main.useFlex;let s=this.useFlex?"display:flex; justify-content:center; align-items:center; text-align:center; flex: 1 100%;":"float:left;";this.c[0]=h$2.dom("div",this.css.basic+s+"position:relative; height:20px;"),this.s[0]=this.c[0].style,this.margin=this.colors.sy,this.mtop=0;let i=h$2.isDivid(this.margin);if(this.isUI&&this.margin&&(this.s[0].boxSizing="content-box",i?(this.mtop=.5*this.margin,this.s[0].borderTop=this.mtop+"px solid transparent",this.s[0].borderBottom=this.mtop+"px solid transparent"):this.s[0].borderBottom=this.margin+"px solid transparent"),this.simple||(this.c[1]=h$2.dom("div",this.css.txt+this.css.middle),this.s[1]=this.c[1].style,this.c[1].textContent=this.name,this.s[1].color=this.lock?this.colors.titleoff:this.colors.title),t.pos){this.s[0].position="absolute";for(let s in t.pos)this.s[0][s]=t.pos[s];this.mono=!0;}t.css&&(this.s[0].cssText=t.css);}init(){this.ytop=this.top+this.mtop,this.zone.h=this.h+this.margin,this.zone.w=this.w;let t=this.s,s=this.c;t[0].height=this.h+"px",this.isUI&&(t[0].background=this.colors.background),!this.autoWidth&&this.useFlex?(t[0].flex="1 0 auto",t[0].minWidth=this.minw+"px",t[0].textAlign="center"):this.isUI&&(t[0].width="100%"),void 0!==s[1]&&this.autoWidth&&(t[1]=s[1].style,t[1].top="1px",t[1].height=this.h-2+"px");let e=h$2.frag;for(let i=1,h=s.length;i!==h;i++)void 0!==s[i]&&(e.appendChild(s[i]),t[i]=s[i].style);let o=null!==this.target?this.target:this.isUI?this.main.inner:document.body;this.ontop?o.insertAdjacentElement("afterbegin",s[0]):o.appendChild(s[0]),s[0].appendChild(e),this.rSize(),this.isUI||(this.c[0].style.pointerEvents="auto",i$3.add(this));}addTransition(){this.baseH&&this.transition&&this.isUI&&(this.c[0].style.transition="height "+this.transition+"s ease-out");}dom(t,s,i,e,o){return h$2.dom(t,s,i,e,o)}setSvg(t,s,i,e,o){h$2.setSvg(t,s,i,e,o);}setCss(t,s){h$2.setCss(t,s);}clamp(t,s,i){return h$2.clamp(t,s,i)}getColorRing(){return h$2.colorRing||h$2.makeColorRing(),h$2.clone(h$2.colorRing)}getJoystick(t){return h$2["joystick_"+t]||h$2.makeJoystick(t),h$2.clone(h$2["joystick_"+t])}getCircular(t){return h$2.circular||h$2.makeCircular(t),h$2.clone(h$2.circular)}getKnob(t){return h$2.knob||h$2.makeKnob(t),h$2.clone(h$2.knob)}getPad2d(t){return h$2.pad2d||h$2.makePad(t),h$2.clone(h$2.pad2d)}cursor(t){i$3.cursor(t);}update(){}reset(){}content(){return this.c[0]}getDom(){return this.c[0]}uiout(){this.lock||this.overEffect&&this.s&&(this.s[0].background=this.colors.background);}uiover(){this.lock||this.overEffect&&this.s&&(this.s[0].background=this.colors.backgroundOver);}rename(t){void 0!==this.c[1]&&(this.c[1].textContent=t);}listen(){return this.isListen=i$3.addListen(this),this}listening(){null!==this.objectLink&&(this.isSend||this.isEdit||this.setValue(this.objectLink[this.objectKey]));}setValue(t){this.isNumber?this.value=this.numValue(t):this.value=t,this.update();}onChange(t){if(!this.isSpace)return this.callback=t||null,this}onFinishChange(t){if(!this.isSpace)return this.callback=null,this.endCallback=t,this}onOpen(t){return this.openCallback=t,this}onClose(t){return this.closeCallback=t,this}send(t){(t=t||this.value)instanceof Array&&1===t.length&&(t=t[0]),this.isSend=!0,null!==this.objectLink&&(this.objectLink[this.objectKey]=t),this.callback&&this.callback(t,this.objectKey),this.isSend=!1;}sendEnd(t){(t=t||this.value)instanceof Array&&1===t.length&&(t=t[0]),this.endCallback&&this.endCallback(t),null!==this.objectLink&&(this.objectLink[this.objectKey]=t);}dispose(){this.isListen&&i$3.removeListen(this),h$2.clear(this.c[0]),null!==this.target?null!==this.group?this.group.clearOne(this):this.target.removeChild(this.c[0]):this.isUI?this.main.clearOne(this):document.body.removeChild(this.c[0]),this.isUI||i$3.remove(this),this.c=null,this.s=null,this.callback=null,this.target=null,this.isListen=!1;}clear(){}getWidth(){let t=i$3.getWidth(this);t&&(this.w=t);}setSize(t){if(this.autoWidth)if(this.w=t,this.simple)this.sb=this.w-this.sa;else {let t=this.w*(this.p/100);this.sa=Math.floor(t+8),this.sb=Math.floor(this.w-t-16);}}rSize(){this.autoWidth&&(this.isUI||(this.s[0].width=this.w+"px"),this.simple||(this.s[1].width=this.sa+"px"));}setTypeNumber(t){let s;switch(this.isNumber=!0,this.value=0,void 0!==t.value&&("string"==typeof t.value?this.value=1*t.value:this.value=t.value),this.min=void 0===t.min?-1/0:t.min,this.max=void 0===t.max?1/0:t.max,this.precision=void 0===t.precision?2:t.precision,this.precision){case 0:s=1;break;case 1:s=.1;break;case 2:s=.01;break;case 3:s=.001;break;case 4:s=1e-4;break;case 5:s=1e-5;break;case 6:s=1e-6;}this.step=void 0===t.step?s:t.step,this.range=this.max-this.min,this.value=this.numValue(this.value);}numValue(t){return this.noNeg&&(t=Math.abs(t)),1*Math.min(this.max,Math.max(this.min,t)).toFixed(this.precision)}handleEvent(t){if(!this.lock)return this.neverlock&&(i$3.lock=!1),this[t.type]?this[t.type](t):console.error(t.type,"this type of event no existe !")}wheel(t){return !1}mousedown(t){return !1}mousemove(t){return !1}mouseup(t){return !1}keydown(t){return !1}keyup(t){return !1}setReferency(t,s){this.objectLink=t,this.objectKey=s;}display(t=!1){this.s[0].visibility=t?"visible":"hidden";}open(){this.isOpen||(this.isOpen=!0,i$3.needResize=!0,this.openCallback&&this.openCallback());}close(){this.isOpen&&(this.isOpen=!1,i$3.needResize=!0,this.closeCallback&&this.closeCallback());}needZone(){i$3.needReZone=!0;}rezone(){i$3.needReZone=!0;}select(){}unselect(){}setInput(t){i$3.setInput(t,this);}upInput(t,s){return i$3.upInput(t,s)}selected(t){this.isSelect=t||!1;}}class l$1 extends r$1{constructor(t={}){super(t),this.value=t.value||!1,this.model=void 0!==t.mode?t.mode:0,this.onName=t.rename||this.txt,t.onName&&(t.onname=t.onName),t.onname&&(this.onName=t.onname),this.inh=t.inh||Math.floor(.8*this.h),this.inw=t.inw||36;let s=this.colors;if(0===this.model){let t=Math.floor(.5*this.h)-.5*(this.inh-2);this.c[2]=this.dom("div",this.css.basic+"background:"+s.inputBg+"; height:"+(this.inh-2)+"px; width:"+this.inw+"px; top:"+t+"px; border-radius:10px; border:2px solid "+s.back),this.c[3]=this.dom("div",this.css.basic+"height:"+(this.inh-6)+"px; width:16px; top:"+(t+2)+"px; border-radius:10px; background:"+s.button+";");}else this.p=0,void 0!==this.c[1]&&(this.c[1].textContent=""),this.c[2]=this.dom("div",this.css.txt+this.css.button+"top:1px; background:"+s.button+"; height:"+(this.h-2)+"px; border:"+s.borderSize+"px solid "+s.border+"; border-radius:"+this.radius+"px;");this.stat=-1,this.init(),this.update();}mousedown(t){return this.value=!this.value,this.update(!0),this.mousemove(t)}mousemove(t){return this.cursor("pointer"),this.mode(!0)}reset(){return this.cursor(),this.mode()}mode(t){let s,i=!1,e=this.colors,h=this.s,o=this.value;if(s=t?o?4:3:o?2:1,this.stat!==s){if(this.stat=s,0!==this.model){switch(s){case 1:h[2].color=e.text,h[2].background=e.button;break;case 2:h[2].color=e.textSelect,h[2].background=e.select;break;case 3:h[2].color=e.textOver,h[2].background=e.overoff;break;case 4:h[2].color=e.textOver,h[2].background=e.over;}this.c[2].innerHTML=o?this.onName:this.name;}else {switch(s){case 1:h[2].background=h[2].borderColor=e.backoff,h[3].background=e.button;break;case 2:h[2].background=h[2].borderColor=e.back,h[3].background=e.textOver;break;case 3:h[2].background=h[2].borderColor=e.back,h[3].background=e.overoff;break;case 4:h[2].background=h[2].borderColor=e.backoff,h[3].background=e.textSelect;}h[3].marginLeft=o?"17px":"2px",this.c[1].textContent=o?this.onName:this.name;}i=!0;}return i}update(t){this.mode(),t&&this.send();}rSize(){super.rSize();let t=this.s,s=this.w-10-this.inw;0===this.model?(t[2].left=s+"px",t[3].left=s+"px"):(t[2].left=this.sa+"px",t[2].width=this.sb+"px");}}class a$1 extends r$1{constructor(t={}){super(t),this.value="",void 0!==t.value&&(this.value=t.value),this.values=t.value||this.txt,t.values&&(this.values=t.values),t.values||t.value||(this.txt=""),this.onName=t.onName||null,this.on=!1,this.bw=t.forceWidth||0,t.bw&&(this.bw=t.bw),this.space=t.space||3,"string"==typeof this.values&&(this.values=[this.values]),this.isDown=!1,this.neverlock=!0,this.res=0,this.lng=this.values.length,this.tmp=[],this.stat=[];let s,i=this.colors;for(let t=0;t<this.lng;t++)s=!1,this.values[t]===this.value&&this.isSelectable&&(s=!0),this.c[t+2]=this.dom("div",this.css.txt+this.css.button+"top:1px; height:"+(this.h-2)+"px; border:"+i.borderSize+"px solid "+i.border+"; border-radius:"+this.radius+"px;"),this.c[t+2].style.background=s?i.select:i.button,this.c[t+2].style.color=s?i.textSelect:i.text,this.c[t+2].innerHTML=this.values[t],this.stat[t]=s?3:1;""===this.txt&&(this.p=0),(t.value||t.values)&&0!==this.p||void 0!==this.c[1]&&(this.c[1].textContent=""),this.init();}onOff(){this.on=!this.on,this.label(this.on?this.onName:this.value);}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return -1;let i=this.lng,e=this.tmp;for(;i--;)if(s.x>e[i][0]&&s.x<e[i][2])return i;return -1}mouseup(t){return !!this.isDown&&(this.isDown=!1,-1!==this.res&&(this.value===this.values[this.res]&&this.unselectable?this.value="":this.value=this.values[this.res],null!==this.onName&&this.onOff(),this.send()),this.mousemove(t))}mousedown(t){return !this.isDown&&(this.isDown=!0,this.mousemove(t))}mousemove(t){let s=!1;return this.res=this.testZone(t),-1!==this.res?(this.cursor("pointer"),s=this.modes(this.isDown?3:2,this.res)):s=this.reset(),s}modes(t=1,s=-1){let i,e,h=this.lng,o=!1;for(;h--;)e=t,i=!!this.isSelectable&&this.values[h]===this.value,h===s?i&&2===e&&(e=3):(e=1,i&&(e=4)),o=this.mode(e,h);return o}mode(t,s){let i=!1,e=this.colors,h=this.s,o=s+2;if(this.stat[s]!==t){switch(this.stat[s]=t,t){case 1:h[o].color=e.text,h[o].background=e.button;break;case 2:h[o].color=e.textOver,h[o].background=e.overoff;break;case 3:h[o].color=e.textOver,h[o].background=e.over;break;case 4:h[o].color=e.textSelect,h[o].background=e.select;}i=!0;}return i}reset(){return this.res=-1,this.cursor(),this.modes()}label(t,s){s=s||2,this.c[s].textContent=t;}switchValues(t,s){this.c[t+2].innerHTML=this.values[t]=s;}icon(t,s=0,i=2){return this.s[i].padding=s+"px 0px",this.c[i].innerHTML=t,this}rSize(){super.rSize();let t=this.s,s=this.sb,i=this.sa,e=this.lng,h=this.colors.sx,o=(s-h*(e-1))/e;for(this.bw&&(o=this.bw<o?this.bw:o,i=.5*(this.w-(o*e+h*(e-1))));e--;)this.tmp[e]=[i+o*e+h*e,o],this.tmp[e][2]=this.tmp[e][0]+this.tmp[e][1],t[e+2].left=this.tmp[e][0]+"px",t[e+2].width=this.tmp[e][1]+"px";}}class c$1 extends r$1{constructor(t={}){super(t),this.isCyclic=t.cyclic||!1,this.model=t.stype||0,void 0!==t.mode&&(this.model=t.mode),this.autoWidth=!1,this.minw=this.w,this.diam=t.diam||this.w,this.setTypeNumber(t),this.twoPi=h$2.TwoPI,this.pi90=h$2.pi90,this.offset=new n$1,this.h=t.h||this.w+10,this.c[0].style.width=this.w+"px",this.c[0].style.display="block",void 0!==this.c[1]&&(this.c[1].style.width="100%",this.c[1].style.justifyContent="center",this.top=10,this.h+=10),this.percent=0,this.cmode=0;let s=this.colors;this.c[2]=this.dom("div",this.css.txt+"justify-content:center; top:"+(this.h-20)+"px; width:100%; color:"+s.text),this.c[3]=this.getCircular(),this.setSvg(this.c[3],"stroke",s.back,0),this.setSvg(this.c[3],"d",this.makePath(),1),this.setSvg(this.c[3],"stroke",s.text,1),this.setSvg(this.c[3],"viewBox","0 0 "+this.diam+" "+this.diam),this.setCss(this.c[3],{width:this.diam,height:this.diam,left:0,top:this.top}),this.init(),this.update();}mode(t){if(this.cmode===t)return !1;let s,i=this.colors;switch(t){case 0:this.s[2].color=i.text,this.setSvg(this.c[3],"stroke",i.back,0),s=this.model>0?h$2.pack(h$2.lerpColor(h$2.unpack(h$2.ColorLuma(i.text,-.75)),h$2.unpack(i.text),this.percent)):i.text,this.setSvg(this.c[3],"stroke",s,1);break;case 1:this.s[2].color=i.textOver,this.setSvg(this.c[3],"stroke",i.backoff,0),s=this.model>0?h$2.pack(h$2.lerpColor(h$2.unpack(h$2.ColorLuma(i.text,-.75)),h$2.unpack(i.text),this.percent)):i.textOver,this.setSvg(this.c[3],"stroke",s,1);}return this.cmode=t,!0}reset(){this.isDown=!1;}testZone(t){let s=this.local;return -1===s.x&&-1===s.y?"":s.y<=this.c[1].offsetHeight?"title":s.y>this.h-this.c[2].offsetHeight?"text":"circular"}mouseup(t){return this.isDown=!1,this.sendEnd(),this.mode(0)}mousedown(t){return this.isDown=!0,this.old=this.value,this.oldr=null,this.mousemove(t),this.mode(1)}mousemove(t){if(!this.isDown)return;let s=this.offset;if(s.x=.5*this.w-(t.clientX-this.zone.x),s.y=.5*this.diam-(t.clientY-this.zone.y-this.ytop),this.r=s.angle()-this.pi90,this.r=(this.r%this.twoPi+this.twoPi)%this.twoPi,null!==this.oldr){let t=this.r-this.oldr;this.r=Math.abs(t)>Math.PI?this.oldr:this.r,t>6&&(this.r=0),t<-6&&(this.r=this.twoPi);}let i=1/this.twoPi,e=this.r*i,h=this.range*e+this.min-this.old;(h>=this.step||h<=this.step)&&(h=~~(h/this.step),this.value=this.numValue(this.old+h*this.step),this.update(!0),this.old=this.value,this.oldr=this.r);}wheel(t){if("circular"===this.testZone(t)){let s=this.value-this.step*t.delta;return s>this.max?s=this.isCyclic?this.min:this.max:s<this.min&&(s=this.isCyclic?this.max:this.min),this.setValue(s),this.old=s,this.update(!0),!0}return !1}makePath(){let t=40,s=this.percent*this.twoPi-.001,i=t+t*Math.sin(s)+24,e=t-t*Math.cos(s)+24;return "M 64,24 A 40,40 0 "+(s>Math.PI?1:0)+" 1 "+i+","+e}update(t){if(this.c[2].textContent=this.value,this.percent=(this.value-this.min)/this.range,this.setSvg(this.c[3],"d",this.makePath(),1),this.model>0){let t=this.colors,s=h$2.pack(h$2.lerpColor(h$2.unpack(h$2.ColorLuma(t.text,-.75)),h$2.unpack(t.text),this.percent));this.setSvg(this.c[3],"stroke",s,1);}t&&this.send();}}class d$1 extends r$1{constructor(t={}){super(t),this.ctype=t.ctype||"hex",this.wfixe=256,this.cw=this.sb>256?256:this.sb,null!=t.cw&&(this.cw=t.cw),this.side=t.side||"down",this.up="down"===this.side?0:1,this.baseH=this.h,this.offset=new n$1,this.decal=new n$1,this.pp=new n$1;let s=this.colors;this.c[2]=this.dom("div",`${this.css.txt} ${this.css.middle} top:1px; height:${this.h-2}px; border-radius:${this.radius}px; text-shadow:none; border:${s.borderSize}px solid ${s.border};`),this.c[0].style.display="block",this.c[3]=this.getColorRing(),this.c[3].style.visibility="hidden",this.hsl=null,this.value="#ffffff",void 0!==t.value&&(t.value instanceof Array?this.value=h$2.rgbToHex(t.value):isNaN(t.value)?this.value=t.value:this.value=h$2.hexToHtml(t.value)),this.bcolor=null,this.isDown=!1,this.fistDown=!1,this.notext=t.notext||!1,this.tr=98,this.tsl=Math.sqrt(3)*this.tr,this.hue=0,this.d=256,this.init(),this.setColor(this.value),void 0!==t.open&&this.open();}testZone(t,s){let i=this.local;return -1===i.x&&-1===i.y?"":this.up&&this.isOpen?i.y>this.wfixe?"title":"color":i.y<this.baseH+2?"title":this.isOpen?"color":void 0}mouseup(t){this.isDown=!1,this.d=256;}mousedown(t){let s=this.testZone(t.clientX,t.clientY);if("title"===s)return this.isOpen?this.close():this.open(),!0;"color"===s&&(this.isDown=!0,this.fistDown=!0,this.mousemove(t));}mousemove(t){let s,i,e,o,n,r,l,a,c,d=this.testZone(t.clientX,t.clientY),u=h$2;if("title"===d&&this.cursor("pointer"),"color"===d&&(s=this.offset,s.x=t.clientX-(this.zone.x+this.decal.x+this.mid),s.y=t.clientY-(this.zone.y+this.decal.y+this.mid)-this.ytop,i=s.length()*this.ratio,c=s.angle(),c<0&&(c+=2*u.PI),i<128?this.cursor("crosshair"):this.isDown||this.cursor(),this.isDown&&(this.fistDown&&(this.d=i,this.fistDown=!1),this.d<128)))if(this.d>this.tr)e=(c+u.pi90)/u.TwoPI,this.hue=(e+1)%1,this.setHSL([(e+1)%1,this.hsl[1],this.hsl[2]]);else {l=s.x*this.ratio,a=s.y*this.ratio;let t=this.hue*u.TwoPI+u.PI;t<0&&(t+=2*u.PI),r=Math.atan2(-a,l),r<0&&(r+=2*u.PI);let i=(r+u.pi90+u.TwoPI+t)%u.TwoPI,e=i%(2/3*u.PI)-u.pi60,h=.5*this.tr,c=Math.tan(e)*h,d=Math.sqrt(l*l+a*a),p=Math.sqrt(h*h+c*c);if(d>p){let s=Math.tan(e)*d,o=Math.atan(s/p);o>u.pi60?o=u.pi60:o<-u.pi60&&(o=-u.pi60),r+=o-e,i=(r+u.pi90+u.TwoPI+t)%u.TwoPI,e=i%(2/3*u.PI)-u.pi60,c=Math.tan(e)*h,d=p=Math.sqrt(h*h+c*c);}n=Math.sin(i)*d/this.tsl+.5;let m=1-2*Math.abs(n-.5);o=(Math.cos(i)*d+this.tr/2)/(1.5*this.tr)/m,o=u.clamp(o,0,1),this.setHSL([this.hsl[0],o,n]);}}setHeight(){this.h=this.isOpen?this.wfixe+this.baseH+5:this.baseH,this.s[0].height=this.h+"px",this.zone.h=this.h;}parentHeight(t){null!==this.group?this.group.calc(t):this.isUI&&this.main.calc(t);}open(){super.open(),this.setHeight(),this.up&&(this.zone.y-=this.wfixe+5);let t=this.h-this.baseH;this.s[3].visibility="visible",this.parentHeight(t);}close(){super.close(),this.up&&(this.zone.y+=this.wfixe+5);let t=this.h-this.baseH;this.setHeight(),this.s[3].visibility="hidden",this.parentHeight(-t);}update(t){let s=h$2.rgbToHex(h$2.hslToRgb([this.hsl[0],1,.5]));this.moveMarkers(),this.value=this.bcolor,this.setSvg(this.c[3],"fill",s,2,0),this.s[2].background=this.bcolor,this.notext||(this.c[2].textContent=h$2.htmlToHex(this.bcolor)),this.invert=h$2.findDeepInver(this.rgb),this.s[2].color=this.invert?"#fff":"#000",t&&("array"===this.ctype&&this.send(this.rgb),"rgb"===this.ctype&&this.send(h$2.htmlRgb(this.rgb)),"hex"===this.ctype&&this.send(h$2.htmlToHex(this.value)),"html"===this.ctype&&this.send());}setValue(t){t instanceof Array?this.value=h$2.rgbToHex(t):isNaN(t)?this.value=t:this.value=h$2.hexToHtml(t),this.setColor(this.value),this.update();}setColor(t){let s=h$2.unpack(t);return this.bcolor!==t&&s&&(this.bcolor=t,this.rgb=s,this.hsl=h$2.rgbToHsl(this.rgb),this.hue=this.hsl[0],this.update()),this}setHSL(t){return this.hsl=t,this.rgb=h$2.hslToRgb(t),this.bcolor=h$2.rgbToHex(this.rgb),this.update(!0),this}moveMarkers(){let t=this.pp,s=h$2;this.invert;let i=this.hsl[0]*s.TwoPI,e=2/3*s.PI,o=this.tr,n=this.hsl[0],r=this.hsl[1],l=this.hsl[2],a=(i-s.pi90)*s.todeg;n=-i+s.pi90;let c=Math.cos(n)*o,d=-Math.sin(n)*o,u=Math.cos(n-e)*o,p=-Math.sin(n-e)*o,m=Math.cos(n+e)*o,g=-Math.sin(n+e)*o,x=(u+m)/2,v=(p+g)/2;i=(1-2*Math.abs(l-.5))*r;let b=u+(m-u)*l+(c-x)*i,f=p+(g-p)*l+(d-v)*i;t.set(b,f).addScalar(128),this.setSvg(this.c[3],"transform","rotate("+a+" )",2),this.setSvg(this.c[3],"cx",t.x,3),this.setSvg(this.c[3],"cy",t.y,3),this.setSvg(this.c[3],"stroke",this.invert?"#fff":"#000",2,3),this.setSvg(this.c[3],"stroke",this.invert?"#fff":"#000",3),this.setSvg(this.c[3],"fill",this.bcolor,3);}rSize(){super.rSize();let t=this.s;t[2].width=this.sb+"px",t[2].left=this.sa+"px",this.cw=this.sb>256?256:this.sb,this.rSizeColor(this.cw),this.decal.x=Math.floor(.5*(this.w-this.wfixe));}rSizeColor(t){if(t===this.wfixe)return;this.wfixe=t;let s=this.s;this.decal.y="up"===this.side?2:this.baseH+2,this.mid=Math.floor(.5*this.wfixe),this.setSvg(this.c[3],"viewBox","0 0 "+this.wfixe+" "+this.wfixe),s[3].width=this.wfixe+"px",s[3].height=this.wfixe+"px",s[3].top=this.decal.y+"px",this.ratio=256/this.wfixe,this.square=1/(this.wfixe/256*60),this.setHeight();}}class u$1 extends r$1{constructor(t={}){super(t),this.round=Math.round,this.baseH=this.h,this.hplus=t.hplus||50,this.res=t.res||40,this.l=1,this.precision=t.precision||0,this.custom=t.custom||!1,this.names=t.names||["FPS","MS"];let s=t.cc||["220,220,220","255,255,0"];this.adding=t.adding||!1,this.range=t.range||[165,100,100],this.alpha=t.alpha||.25,this.values=[],this.points=[],this.textDisplay=[],this.custom||(this.now=i$3.getTime(),this.startTime=0,this.prevTime=0,this.frames=0,this.ms=0,this.fps=0,this.mem=0,this.mm=0,this.isMem=!(!self.performance||!self.performance.memory),this.isMem&&(this.names.push("MEM"),s.push("0,255,255")),this.txt=t.name||"Fps");let e=Math.floor(.5*this.h)-3;const h=this.colors;this.c[1].textContent=this.txt,this.c[0].style.cursor="pointer",this.c[0].style.pointerEvents="auto";let o="display:none; left:10px; top:"+this.h+"px; height:"+(this.hplus-8)+"px; box-sizing:border-box; background: rgba(0, 0, 0, 0.2); border:1px solid "+h.border+";";0!==this.radius&&(o+="border-radius:"+this.radius+"px;"),this.c[2]=this.dom("path",this.css.basic+o,{}),this.c[2].setAttribute("viewBox","0 0 "+this.res+" 50"),this.c[2].setAttribute("height","100%"),this.c[2].setAttribute("width","100%"),this.c[2].setAttribute("preserveAspectRatio","none"),this.c[3]=this.dom("path",this.css.basic+"position:absolute; width:6px; height:6px; left:0; top:"+e+"px;",{d:this.svgs.g1,fill:h.text,stroke:"none"}),this.c[4]=this.dom("div",this.css.txt+"position:absolute; left:10px; top:"+(this.h+2)+"px; display:none; width:100%; text-align:center;"),t.bottomLine&&(this.c[4]=this.dom("div",this.css.basic+"width:100%; bottom:0px; height:1px; background: rgba(255, 255, 255, 0.2);")),this.isShow=!1;let n=this.s;n[1].lineHeight=this.h-4,n[1].color=h.text,0!==this.radius&&(n[0].borderRadius=this.radius+"px"),"none"!==this.colors.gborder&&(n[0].border="1px solid "+h.gborder);let r=0;for(r=0;r<this.names.length;r++){let t=[],i=this.res+1;for(;i--;)t.push(50);this.range[r]=1/this.range[r]*49,this.points.push(t),this.values.push(0),this.textDisplay.push("<span style='color:rgb("+s[r]+")'> "+this.names[r]+" ");}for(r=this.names.length;r--;)this.dom("path",null,{fill:"rgba("+s[r]+","+this.alpha+")","stroke-width":1,stroke:"rgba("+s[r]+",1)","vector-effect":"non-scaling-stroke"},this.c[2]);this.init();}mousedown(t){this.isShow?this.close():this.open();}tick(t){this.values=t,this.isShow&&(this.drawGraph(),this.upText());}makePath(t){let s="";s+="M -1 50";for(let i=0;i<this.res+1;i++)s+=" L "+i+" "+t[i];return s+=" L "+(this.res+1)+" 50",s}upText(t){let s=t||this.values,i="";for(let t=0,e=this.names.length;t<e;t++)i+=this.textDisplay[t]+s[t].toFixed(this.precision)+"</span>";this.c[4].innerHTML=i;}drawGraph(){let t,s=this.c[2],i=this.names.length,e=0,h=0;for(;i--;)t=this.adding?(this.values[h]+e)*this.range[h]:this.values[h]*this.range[h],this.points[h].shift(),this.points[h].push(50-t),this.setSvg(s,"d",this.makePath(this.points[h]),i+1),e+=this.values[h],h++;}open(){super.open(),this.h=this.hplus+this.baseH,this.setSvg(this.c[3],"d",this.svgs.g2),null!==this.group?this.group.calc(this.hplus):this.isUI&&this.main.calc(this.hplus),this.s[0].height=this.h+"px",this.s[2].display="block",this.s[4].display="block",this.isShow=!0,this.custom||i$3.addListen(this);}close(){super.close(),this.h=this.baseH,this.setSvg(this.c[3],"d",this.svgs.g1),null!==this.group?this.group.calc(-this.hplus):this.isUI&&this.main.calc(-this.hplus),this.s[0].height=this.h+"px",this.s[2].display="none",this.s[4].display="none",this.isShow=!1,this.custom||i$3.removeListen(this),this.c[4].innerHTML="";}begin(){this.startTime=this.now();}end(){let t=this.now();if(this.ms=t-this.startTime,this.frames++,t>this.prevTime+1e3&&(this.fps=this.round(1e3*this.frames/(t-this.prevTime)),this.prevTime=t,this.frames=0,this.isMem)){let t=performance.memory.usedJSHeapSize,s=performance.memory.jsHeapSizeLimit;this.mem=this.round(954e-9*t),this.mm=t/s;}return this.values=[this.fps,this.ms,this.mm],this.drawGraph(),this.upText([this.fps,this.ms,this.mem]),t}listening(){this.custom||(this.startTime=this.end());}rSize(){let t=this.s,s=this.w;t[3].left=this.sa+this.sb-6+"px",t[0].width=s+"px",t[1].width=s+"px",t[2].left="10px",t[2].width=s-20+"px",t[4].width=s-20+"px";}}class p$1 extends r$1{constructor(t={}){super(t),this.value=void 0!==t.value?t.value:[0,0,0],this.lng=this.value.length,this.precision=void 0!==t.precision?t.precision:2,this.multiplicator=t.multiplicator||1,this.neg=t.neg||!1,this.line=void 0===t.line||t.line,this.autoWidth=void 0===t.autoWidth||t.autoWidth,this.isNumber=!1,this.isDown=!1,this.h=t.h||138,this.rh=this.h-10,this.top=0,this.c[0].style.width=this.w+"px",void 0!==this.c[1]&&(this.c[1].style.width=this.w+"px",this.autoWidth||(this.c[1].style.width="100%",this.c[1].style.justifyContent="center"),this.top=10,this.h+=10),this.gh=this.rh-28,this.gw=this.w-28,this.c[2]=this.dom("div",this.css.txt+"display:block; text-align:center; padding:0px 0px; top:"+(this.h-20)+"px; left:14px; width:"+this.gw+"px;  color:"+this.colors.text),this.c[2].innerHTML=this.valueToHtml();let s=this.dom("svg",this.css.basic,{viewBox:"0 0 "+this.w+" "+this.rh,width:this.w,height:this.rh,preserveAspectRatio:"none"});this.setCss(s,{width:this.w,height:this.rh,left:0,top:this.top}),this.dom("path","",{d:"",stroke:this.colors.text,"stroke-width":2,fill:"none","stroke-linecap":"butt"},s),this.dom("rect","",{x:10,y:10,width:this.gw+8,height:this.gh+8,stroke:"rgba(0,0,0,0.3)","stroke-width":1,fill:"none"},s),this.iw=(this.gw-4*(this.lng-1))/this.lng;let i=[];this.cMode=[],this.v=[];for(let t=0;t<this.lng;t++)i[t]=[14+t*this.iw+4*t,this.iw],i[t][2]=i[t][0]+i[t][1],this.cMode[t]=0,this.neg?this.v[t]=.5*(1+this.value[t]/this.multiplicator):this.v[t]=this.value[t]/this.multiplicator,this.dom("rect","",{x:i[t][0],y:14,width:i[t][1],height:1,fill:this.colors.text,"fill-opacity":.3},s);this.tmp=i,this.c[3]=s,this.init(),void 0!==this.c[1]&&(this.c[1].style.top="0px",this.c[1].style.height="20px",this.s[1].lineHeight="15px"),this.update(!1);}setValue(t){this.value=t,this.lng=this.value.length;for(var s=0;s<this.lng;s++)this.neg?this.v[s]=.5*(1+t[s]/this.multiplicator):this.v[s]=t[s]/this.multiplicator;this.update();}valueToHtml(){let t=this.lng,s=0,i='<table style="width:100%;"><tr>',e="width:"+100/this.lng+"%;";for(;t--;)s===this.lng-1?i+="<td style="+e+">"+this.value[s]+"</td></tr></table>":i+="<td style="+e+">"+this.value[s]+"</td>",s++;return i}updateSVG(){this.line&&this.setSvg(this.c[3],"d",this.makePath(),0);for(let t=0;t<this.lng;t++)this.setSvg(this.c[3],"height",this.v[t]*this.gh,t+2),this.setSvg(this.c[3],"y",this.gh-this.v[t]*this.gh+14,t+2),this.neg?this.value[t]=1*((2*this.v[t]-1)*this.multiplicator).toFixed(this.precision):this.value[t]=1*(this.v[t]*this.multiplicator).toFixed(this.precision);this.c[2].innerHTML=this.valueToHtml();}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";let i=this.lng,e=this.tmp;if(s.y>this.top&&s.y<this.h-20)for(;i--;)if(s.x>e[i][0]&&s.x<e[i][2])return i;return ""}mode(t,s){if(t===this.cMode[s])return !1;let i;switch(t){case 0:i=.3;break;case 1:i=.6;break;case 2:i=1;}return this.reset(),this.setSvg(this.c[3],"fill-opacity",i,s+2),this.cMode[s]=t,!0}reset(){let t=!1,s=this.lng;for(;s--;)0!==this.cMode[s]&&(this.cMode[s]=0,this.setSvg(this.c[3],"fill-opacity",.3,s+2),t=!0);return t}mouseup(t){if(this.isDown=!1,-1!==this.current)return this.reset()}mousedown(t){return this.isDown=!0,this.mousemove(t)}mousemove(t){let s=!1,i=this.testZone(t);return ""===i?s=this.reset():(s=this.mode(this.isDown?2:1,i),this.isDown&&(this.v[i]=this.clamp(1-(t.clientY-this.zone.y-this.ytop-10)/this.gh,0,1),this.update(!0))),s}update(t){this.updateSVG(),t&&this.send();}makePath(){let t,s,i,e,h,o,n="";for(let r=0;r<this.lng;r++)t=this.gh-this.v[r]*this.gh+14,s=14+r*this.iw+4*r,e=s+.5*this.iw,i=s+this.iw,n+=0===r?"M "+s+" "+t+" T "+e+" "+t:" C "+h+" "+o+","+s+" "+t+","+e+" "+t,r===this.lng-1&&(n+=" T "+i+" "+t),h=i,o=t;return n}rSize(){super.rSize();let t=this.s;void 0!==this.c[1]&&(t[1].width=this.w+"px"),t[3].width=this.w+"px";let s=this.w-28,i=(s-4*(this.lng-1))/this.lng,e=[];t[2].width=s+"px";for(let t=0;t<this.lng;t++)e[t]=[14+t*i+4*t,i],e[t][2]=e[t][0]+e[t][1];this.tmp=e;}}class m$1 extends r$1{constructor(t={}){t.isSpace=!0,t.margin=0,t.h||(t.h=10),super(t),this.init();}}class g$1 extends r$1{constructor(t={}){super(t),this.isGroup=!0,this.ADD=t.add,this.autoHeight=!0,this.uis=[],this.current=-1,this.proto=null,this.isEmpty=!0,this.decal=t.group?8:0,this.baseH=this.h,this.spaceY=new m$1({h:this.margin});let s=Math.floor(.5*this.h)-3;const i=this.colors;this.useFlex=!0;let e=this.useFlex?"display:flex; flex-flow: row wrap;":"";this.c[2]=this.dom("div",this.css.basic+e+"width:100%; left:0;  overflow:hidden; top:"+this.h+"px"),this.c[3]=this.dom("path",this.css.basic+"position:absolute; width:6px; height:6px; left:0; top:"+s+"px;",{d:this.svgs.g1,fill:i.text,stroke:"none"});let h=0===this.mtop?this.margin:this.mtop;this.c[4]=this.dom("div",this.css.basic+"width:100%; left:0; height:"+(h+1)+"px; top:"+(this.h-1)+"px; background:none;"),this.s,this.c[1].name="group",this.init(),this.setBG(t.bg),t.open&&this.open();}setBG(t){const s=this.colors,i=this.s;void 0!==t&&(s.groups=t),"none"===s.groups&&(s.groups=s.background),s.background="none",i[0].background="none",i[1].background=s.groups,i[2].background=s.groups,"none"!==s.gborder&&(i[1].border=s.borderSize+"px solid "+s.gborder),0!==this.radius&&(i[1].borderRadius=this.radius+"px",i[2].borderRadius=this.radius+"px");}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";let i="";return s.y<this.baseH+this.margin?i="title":this.isOpen&&(i="content"),i}clearTarget(){return -1!==this.current&&(this.proto.s&&(this.proto.uiout(),this.proto.reset()),this.proto=null,this.current=-1,this.cursor(),!0)}reset(){this.clearTarget();}handleEvent(t){let s=t.type,e=!1,h=!1,o=this.testZone(t);if(o){switch(o){case"content":i$3.isMobile&&"mousedown"===s&&this.getNext(t,e),this.proto&&(h=this.proto.handleEvent(t)),i$3.lock||this.getNext(t,e);break;case"title":this.cursor("pointer"),"mousedown"===s&&(this.isOpen?this.close():this.open());}return this.isDown&&(e=!0),h&&(e=!0),e}}getNext(t,s){let e=i$3.findTarget(this.uis,t);e!==this.current&&(this.clearTarget(),this.current=e),-1!==e&&(this.proto=this.uis[this.current],this.proto.uiover());}add(){let t=arguments;"object"==typeof t[1]?(t[1].isUI=this.isUI,t[1].target=this.c[2],t[1].main=this.main,t[1].group=this):"string"==typeof arguments[1]&&(void 0===t[2]?[].push.call(t,{isUI:!0,target:this.c[2],main:this.main}):(t[2].isUI=!0,t[2].target=this.c[2],t[2].main=this.main,t[2].group=this));let s=this.ADD.apply(this,t);return s.isGroup&&(s.dx=8),i$3.forceZone=!0,this.uis.push(s),this.isEmpty=!1,s}remove(t){t.dispose&&t.dispose();}dispose(){this.clear(),this.isUI&&this.main.calc(),super.dispose();}clear(){this.empty();}empty(){this.close();let t,s=this.uis.length;for(;s--;)t=this.uis.pop(),this.c[2].removeChild(t.c[0]),t.clear(!0);this.isEmpty=!0,this.h=this.baseH;}clearOne(t){let s=this.uis.indexOf(t);-1!==s&&(this.calc(-(this.uis[s].h+this.margin)),this.c[2].removeChild(this.uis[s].c[0]),this.uis.splice(s,1),0===this.uis.length&&(this.isEmpty=!0,this.close()));}open(){super.open(),this.setSvg(this.c[3],"d",this.svgs.g2),this.rSizeContent();const t=this.s,s=this.colors;t[2].top=this.h+this.mtop+"px",t[4].background=s.groups,this.radius&&(t[1].borderRadius="0px",t[2].borderRadius="0px",t[1].borderTopLeftRadius=this.radius+"px",t[1].borderTopRightRadius=this.radius+"px",t[2].borderBottomLeftRadius=this.radius+"px",t[2].borderBottomRightRadius=this.radius+"px"),"none"!==s.gborder&&(t[4].borderLeft=s.borderSize+"px solid "+s.gborder,t[4].borderRight=s.borderSize+"px solid "+s.gborder,t[2].border=s.borderSize+"px solid "+s.gborder,t[2].borderTop="none",t[1].borderBottom=s.borderSize+"px solid rgba(0,0,0,0)"),this.parentHeight();}close(){super.close(),this.setSvg(this.c[3],"d",this.svgs.g1),this.h=this.baseH;const t=this.s,s=this.colors;t[0].height=this.h+"px",t[2].top=this.h+this.mtop+"px",t[4].background="none","none"!==s.gborder&&(t[4].border="none",t[2].border="none",t[1].border=s.borderSize+"px solid "+s.gborder),this.radius&&(t[1].borderRadius=this.radius+"px"),this.parentHeight();}calcUis(){!this.isOpen||this.isEmpty?this.h=this.baseH:this.h=i$3.calcUis([...this.uis,this.spaceY],this.zone,this.zone.y+this.baseH+this.margin,!0)+this.baseH,this.s[0].height=this.h+"px",this.s[2].height=this.h-this.baseH+"px";}parentHeight(t){null!==this.group?this.group.calc(t):this.isUI&&this.main.calc(t);}calc(t){this.isOpen&&(this.isUI?this.main.calc():this.calcUis(),this.s[0].height=this.h+"px",this.s[2].height=this.h+"px");}rSizeContent(){let t=this.uis.length;for(;t--;)this.uis[t].setSize(this.w),this.uis[t].rSize();}rSize(){super.rSize();let t=this.s;this.w=this.w-this.decal,t[3].left=this.sa+this.sb-6+"px",t[1].width=this.w+"px",t[2].width=this.w+"px",t[1].left=this.decal+"px",t[2].left=this.decal+"px",this.isOpen&&this.rSizeContent();}}class x$2 extends r$1{constructor(t={}){super(t),this.autoWidth=!1,this.value=[0,0],this.minw=this.w,this.diam=t.diam||this.w,this.joyType="analogique",this.model=void 0!==t.mode?t.mode:0,this.precision=t.precision||2,this.multiplicator=t.multiplicator||1,this.pos=new n$1,this.tmp=new n$1,this.interval=null,this.c[0].style.display="block",this.haveText=void 0===t.text||t.text,this.distance=.5*this.diam*.25,this.h=t.h||this.w+(this.haveText?10:0),this.c[0].style.width=this.w+"px",void 0!==this.c[1]&&(this.c[1].style.width="100%",this.c[1].style.justifyContent="center",this.top=10,this.h+=10);let s=this.colors;this.c[2]=this.dom("div",this.css.txt+"justify-content:center; top:"+(this.h-20)+"px; width:100%; color:"+s.text),this.c[2].textContent=this.haveText?this.value:"",this.c[3]=this.getJoystick(this.model),this.setSvg(this.c[3],"viewBox","0 0 "+this.diam+" "+this.diam),this.setCss(this.c[3],{width:this.diam,height:this.diam,left:0,top:this.top}),this.mode(0),this.ratio=128/this.w,this.init(),this.update(!1);}mode(t){let s=this.colors;switch(t){case 0:0===this.model?(this.setSvg(this.c[3],"fill","url(#gradIn)",4),this.setSvg(this.c[3],"stroke","#000",4)):(this.setSvg(this.c[3],"stroke",s.joyOut,2),this.setSvg(this.c[3],"stroke",s.joyOut,4),this.setSvg(this.c[3],"fill","none",4));break;case 1:0===this.model?(this.setSvg(this.c[3],"fill","url(#gradIn2)",4),this.setSvg(this.c[3],"stroke","rgba(0,0,0,0)",4)):(this.setSvg(this.c[3],"stroke",s.joyOver,2),this.setSvg(this.c[3],"stroke",s.joySelect,4),this.setSvg(this.c[3],"fill",s.joyOver,4));}}addInterval(){null!==this.interval&&this.stopInterval(),this.pos.isZero()||(this.interval=setInterval(function(){this.update();}.bind(this),10));}stopInterval(){null!==this.interval&&(clearInterval(this.interval),this.interval=null);}reset(){this.addInterval(),this.mode(0);}mouseup(t){this.addInterval(),this.isDown=!1;}mousedown(t){this.isDown=!0,this.mousemove(t),this.mode(2);}mousemove(t){if(this.mode(1),!this.isDown)return;if(this.tmp.x=.5*this.w-(t.clientX-this.zone.x),this.tmp.y=.5*this.diam-(t.clientY-this.zone.y-this.ytop),this.tmp.length()>this.distance){let t=Math.atan2(this.tmp.x,this.tmp.y);this.tmp.x=Math.sin(t)*this.distance,this.tmp.y=Math.cos(t)*this.distance;}this.pos.copy(this.tmp).divideScalar(this.distance).negate(),this.update();}setValue(t){void 0===t&&(t=[0,0]),this.pos.set(t[0]||0,t[1]||0),this.updateSVG();}update(t){void 0===t&&(t=!0),null!==this.interval&&(this.isDown||(this.pos.lerp(null,.3),this.pos.x=Math.abs(this.pos.x)<.01?0:this.pos.x,this.pos.y=Math.abs(this.pos.y)<.01?0:this.pos.y,this.isUI&&this.main.isCanvas&&this.main.draw())),this.updateSVG(),t&&this.send(),this.pos.isZero()&&this.stopInterval();}updateSVG(){let t=.5*this.diam- -this.pos.x*this.distance,s=.5*this.diam- -this.pos.y*this.distance;if(0===this.model){let i=t+5*this.pos.x+5,e=s+5*this.pos.y+10;this.setSvg(this.c[3],"cx",i*this.ratio,3),this.setSvg(this.c[3],"cy",e*this.ratio,3);}else this.setSvg(this.c[3],"cx",t*this.ratio,3),this.setSvg(this.c[3],"cy",s*this.ratio,3);this.setSvg(this.c[3],"cx",t*this.ratio,4),this.setSvg(this.c[3],"cy",s*this.ratio,4),this.value[0]=1*(this.pos.x*this.multiplicator).toFixed(this.precision),this.value[1]=1*(this.pos.y*this.multiplicator).toFixed(this.precision),this.haveText&&(this.c[2].textContent=this.value);}clear(){this.stopInterval(),super.clear();}}class v$1 extends r$1{constructor(t={}){super(t),this.isCyclic=t.cyclic||!1,this.model=t.stype||0,void 0!==t.mode&&(this.model=t.mode),this.autoWidth=!1,this.setTypeNumber(t),this.minw=this.w,this.diam=t.diam||this.w,this.mPI=.8*Math.PI,this.toDeg=180/Math.PI,this.cirRange=2*this.mPI,this.offset=new n$1,this.h=t.h||this.w+10,this.c[0].style.width=this.w+"px",this.c[0].style.display="block",void 0!==this.c[1]&&(this.c[1].style.width="100%",this.c[1].style.justifyContent="center",this.top=10,this.h+=10),this.percent=0,this.cmode=0;let s=this.colors;this.c[2]=this.dom("div",this.css.txt+"justify-content:center; top:"+(this.h-20)+"px; width:100%; color:"+s.text),this.c[3]=this.getKnob(),this.setSvg(this.c[3],"fill",s.button,0),this.setSvg(this.c[3],"stroke",s.text,1),this.setSvg(this.c[3],"stroke",s.text,3),this.setSvg(this.c[3],"d",this.makeGrad(),3),this.setSvg(this.c[3],"viewBox","0 0 "+this.diam+" "+this.diam),this.setCss(this.c[3],{width:this.diam,height:this.diam,left:0,top:this.top}),this.model>0&&(h$2.dom("path","",{d:"",stroke:s.text,"stroke-width":2,fill:"none","stroke-linecap":"round"},this.c[3]),2==this.model&&(h$2.addSVGGlowEffect(),this.setSvg(this.c[3],"style",'filter: url("#UILGlow");',4))),this.r=0,this.init(),this.update();}mode(t){let s=this.colors;if(this.cmode===t)return !1;switch(t){case 0:this.s[2].color=s.text,this.setSvg(this.c[3],"fill",s.button,0),this.setSvg(this.c[3],"stroke",s.text,1);break;case 1:this.s[2].color=s.textOver,this.setSvg(this.c[3],"fill",s.select,0),this.setSvg(this.c[3],"stroke",s.textOver,1);}return this.cmode=t,!0}testZone(t){let s=this.local;return -1===s.x&&-1===s.y?"":s.y<=this.c[1].offsetHeight?"title":s.y>this.h-this.c[2].offsetHeight?"text":"knob"}mouseup(t){return this.isDown=!1,this.sendEnd(),this.mode(0)}mousedown(t){return this.isDown=!0,this.old=this.value,this.oldr=null,this.mousemove(t),this.mode(1)}mousemove(t){if(!this.isDown)return;let s=this.offset;s.x=.5*this.w-(t.clientX-this.zone.x),s.y=.5*this.diam-(t.clientY-this.zone.y-this.ytop),this.r=-Math.atan2(s.x,s.y),null!==this.oldr&&(this.r=Math.abs(this.r-this.oldr)>Math.PI?this.oldr:this.r),this.r=this.r>this.mPI?this.mPI:this.r,this.r=this.r<-this.mPI?-this.mPI:this.r;let i=1/this.cirRange,e=(this.r+this.mPI)*i,h=this.range*e+this.min-this.old;(h>=this.step||h<=this.step)&&(h=Math.floor(h/this.step),this.value=this.numValue(this.old+h*this.step),this.update(!0),this.old=this.value,this.oldr=this.r);}wheel(t){if("knob"===this.testZone(t)){let s=this.value-this.step*t.delta;return s>this.max?s=this.isCyclic?this.min:this.max:s<this.min&&(s=this.isCyclic?this.max:this.min),this.setValue(s),this.old=s,this.update(!0),!0}return !1}makeGrad(){let t,s,i,e,h,o,n,r="",l=64,a=Math.PI+this.mPI,c=Math.PI-this.mPI;this.step>5?(s=this.range/this.step,t=(a-c)/s):(t=(a-c)/l*2,s=32);for(let c=0;c<=s;++c)i=a-t*c,e=l+44*Math.sin(i),h=l+44*Math.cos(i),o=l+40*Math.sin(i),n=l+40*Math.cos(i),r+="M"+e+" "+h+" L"+o+" "+n+" ";return r}update(t){this.c[2].textContent=this.value,this.percent=(this.value-this.min)/this.range;let s=Math.PI+this.mPI,i=this.percent*this.cirRange-this.mPI,e=Math.sin(i),o=Math.cos(i),n=25*e+64,r=-25*o+64,l=20*e+64,a=-20*o+64;if(this.setSvg(this.c[3],"d","M "+n+" "+r+" L "+l+" "+a,1),this.model>0){let t=36*Math.sin(s)+64,n=36*Math.cos(s)+64,r=36*e+64,l=-36*o+64,a=i<=Math.PI-this.mPI?0:1;this.setSvg(this.c[3],"d","M "+t+","+n+" A 36,36 1 "+a+" 1 "+r+","+l,4);let c=h$2.pack(h$2.lerpColor(h$2.unpack(h$2.ColorLuma(this.colors.text,-.75)),h$2.unpack(this.colors.text),this.percent));this.setSvg(this.c[3],"stroke",c,4);}t&&this.send();}}class b extends r$1{constructor(t={}){super(t),this.hideCurrent=!1,this.path=t.path||"",this.format=t.format||"",this.isWithImage=""!==this.path,this.preLoadComplete=!1,this.tmpImage={},this.tmpUrl=[],this.m=void 0!==t.m?t.m:5;let s=t.align||"left",i=t.scrollSize||10;this.ss=i+1,this.sMode=0,this.tMode=0,this.listOnly=t.listOnly||!1,this.staticTop=t.staticTop||!1,this.isSelectable=this.listOnly,void 0!==t.select&&(t.selectable=t.select),void 0!==t.selectable&&(this.isSelectable=t.selectable),""===this.txt&&(this.p=0);let e=Math.floor(.5*this.h)-3,h=this.colors;if(this.c[2]=this.dom("div",this.css.basic+"top:0; display:none; border-radius:"+this.radius+"px;"),this.c[3]=this.dom("div",this.css.item+"padding:0px "+this.m+"px; margin-bottom:0px; position:absolute; justify-content:"+s+"; text-align:"+s+"; line-height:"+(this.h-4)+"px; top:1px; background:"+h.button+"; height:"+(this.h-2)+"px; border:1px solid "+h.border+"; border-radius:"+this.radius+"px;"),this.c[4]=this.dom("path",this.css.basic+"position:absolute; width:6px; height:6px; top:"+e+"px;",{d:this.svgs.g1,fill:h.text,stroke:"none"}),this.scrollerBack=this.dom("div",this.css.basic+"right:0px; width:"+i+"px; background:"+h.back+"; display:none;"),this.scroller=this.dom("div",this.css.basic+"right:"+.5*(i-.25*i)+"px; width:"+.25*i+"px; background:"+h.text+"; display:none; "),this.c[3].style.color=h.text,this.list=[],this.refObject=null,t.list)if(t.list instanceof Array)this.list=t.list;else if(t.list instanceof Object){this.refObject=t.list;for(let t in this.refObject)this.list.push(t);}this.items=[],this.prevName="",this.tmpId=0,this.baseH=this.h,this.itemHeight=t.itemHeight||this.h,this.full=t.full||!1,this.py=0,this.ww=this.sb,this.scroll=!1,this.isDown=!1,this.current=null,this.side=t.side||"down",this.up="down"===this.side?0:1,this.up?(this.c[2].style.top="auto",this.c[3].style.top="auto",this.c[4].style.top="auto",this.c[2].style.bottom=this.h-2+"px",this.c[3].style.bottom="1px",this.c[4].style.bottom=e+"px"):this.c[2].style.top=this.baseH+"px",this.listIn=this.dom("div",this.css.basic+"left:0; top:0; width:100%; background:none;"),this.listIn.name="list",this.topList=0,this.c[2].appendChild(this.listIn),this.c[2].appendChild(this.scrollerBack),this.c[2].appendChild(this.scroller),void 0!==t.value?isNaN(t.value)?this.value=t.value:this.value=this.list[t.value]:this.value=this.list[0],this.isOpenOnStart=t.open||!1,this.listOnly&&(this.baseH=5,this.c[3].style.display="none",this.c[4].style.display="none",this.c[2].style.top=this.baseH+"px",this.isOpenOnStart=!0),this.miniCanvas=t.miniCanvas||!1,this.canvasBg=t.canvasBg||"rgba(0,0,0,0)",this.imageSize=t.imageSize||[20,20],this.drag=t.drag||!1,this.dragout=t.dragout||!1,this.dragstart=t.dragstart||null,this.dragend=t.dragend||null,this.setList(this.list),this.init(),this.isWithImage&&this.preloadImage(),this.isOpenOnStart&&this.open(!0),this.baseH+=this.mtop;}preloadImage(){this.preLoadComplete=!1,this.tmpImage={};for(let t=0;t<this.list.length;t++)this.tmpUrl.push(this.list[t]);this.loadOne();}nextImg(){null!==this.c&&(this.tmpUrl.shift(),0===this.tmpUrl.length?(this.preLoadComplete=!0,this.addImages()):this.loadOne());}loadOne(){let t=this,s=this.tmpUrl[0],i=document.createElement("img");i.style.cssText="position:absolute; width:"+t.imageSize[0]+"px; height:"+t.imageSize[1]+"px",i.setAttribute("src",this.path+s+this.format),i.addEventListener("load",(function(){t.imageSize[2]=i.width,t.imageSize[3]=i.height,t.tmpImage[s]=i,t.nextImg();}));}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";if(this.up&&this.isOpen){if(s.y>this.h-this.baseH)return "title";if(this.scroll&&s.x>this.sa+this.sb-this.ss)return "scroll";if(s.x>this.sa)return this.testItems(s.y-this.baseH)}else {if(s.y<this.baseH+2)return "title";if(this.isOpen){if(this.scroll&&s.x>this.sa+this.sb-this.ss)return "scroll";if(s.x>this.sa)return this.testItems(s.y-this.baseH)}}return ""}testItems(t){let s,i,e,h="",o=this.items,n=o.length;for(;n--;)if(s=o[n],i=s.posy+this.topList,e=s.posy+this.itemHeight+1+this.topList,t>=i&&t<=e)return h="item"+n,this.modeItem(0),this.current=s,this.modeItem(1),h;return h}modeItem(t){if(!this.current)return;this.current.select&&0===t&&(t=2);let s=this.colors;switch(t){case 0:this.current.style.background=s.back,this.current.style.color=s.text;break;case 1:this.current.style.background=s.over,this.current.style.color=s.textOver;break;case 2:this.current.style.background=s.select,this.current.style.color=s.textSelect;}}unSelected(){this.current&&(this.modeItem(0),this.current=null);}selected(){this.current&&(this.resetItems(),this.modeItem(2),this.current.select=!0);}resetItems(){let t=this.items.length;for(;t--;)this.items[t].select=!1,this.items[t].style.background=this.colors.back,this.items[t].style.color=this.colors.text;}hideActive(){this.hideCurrent&&(this.current&&(this.tmpId=this.current.id),this.resetHide());}resetHide(){console.log(this.tmpId);let t=this.items.length;for(;t--;)t===this.tmpId?(this.items[t].style.height="0px",this.items[t].posy=-1):(this.items[t].style.height=this.itemHeight+"px",this.items[t].posy=(this.itemHeight+1)*(t-1));}mouseup(t){this.isDown=!1;}mousedown(t){let s=this.testZone(t);return !!s&&("scroll"===s?(this.isDown=!0,this.mousemove(t)):"title"===s?(this.modeTitle(2),this.listOnly||(this.hideActive(),this.isOpen?this.close():this.open())):this.current&&(this.value=this.list[this.current.id],this.isSelectable&&this.selected(),this.send(this.value),this.listOnly||(this.close(),this.setTopItem())),!0)}mousemove(t){let s=!1,i=this.testZone(t);if(!i)return s;if("title"===i)this.unSelected(),this.modeTitle(1),this.cursor("pointer");else if("scroll"===i){if(this.cursor("s-resize"),this.modeScroll(1),this.isDown){this.modeScroll(2);let s=this.zone.y+this.baseH-2;this.update(t.clientY-s-.5*this.sh);}}else this.modeTitle(0),this.modeScroll(0),this.cursor("pointer");return i!==this.prevName&&(s=!0),this.prevName=i,s}wheel(t){return "title"!==this.testZone(t)&&(this.py+=10*t.delta,this.update(this.py),!0)}reset(){this.prevName="",this.unSelected(),this.modeTitle(0),this.modeScroll(0);}modeScroll(t){if(t===this.sMode)return;let s=this.scroller.style,i=this.colors;switch(t){case 0:s.background=i.text;break;case 1:case 2:s.background=i.select;}this.sMode=t;}modeTitle(t){if(t===this.tMode)return;let s=this.s,i=this.colors;switch(t){case 0:s[3].color=i.text,s[3].background=i.button;break;case 1:s[3].color=i.textOver,s[3].background=i.overoff;break;case 2:s[3].color=i.textSelect,s[3].background=i.overoff;}this.tMode=t;}clearList(){for(;this.listIn.children.length;)this.listIn.removeChild(this.listIn.lastChild);this.items=[];}setList(t){this.clearList(),this.list=t,this.length=this.list.length;let s,e,h=this.hideCurrent?this.length-1:this.length;this.maxItem=this.full?h:5,this.maxItem=h<this.maxItem?h:this.maxItem,this.maxHeight=this.maxItem*(this.itemHeight+1)+2,this.max=h*(this.itemHeight+1)+2,this.ratio=this.maxHeight/this.max,this.sh=this.maxHeight*this.ratio,this.range=this.maxHeight-this.sh,this.c[2].style.height=this.maxHeight+"px",this.scrollerBack.style.height=this.maxHeight+"px",this.scroller.style.height=this.sh+"px",this.max>this.maxHeight&&(this.ww=this.sb-this.ss,this.scroll=!0),this.miniCanvas&&(this.tmpCanvas=document.createElement("canvas"),this.tmpCanvas.width=this.imageSize[0],this.tmpCanvas.height=this.imageSize[1],this.tmpCtx=this.tmpCanvas.getContext("2d"),this.tmpCtx.fillStyle=this.canvasBg,this.tmpCtx.fillRect(0,0,this.imageSize[0],this.imageSize[1]));for(let t=0;t<this.length;t++){if(e=this.list[t],s=this.dom("div",this.css.item+"padding:0px "+(this.m+1)+"px; width:"+this.ww+"px; height:"+this.itemHeight+"px; line-height:"+(this.itemHeight-2)+"px; color:"+this.colors.text+"; background:"+this.colors.back+";"),s.name="item"+t,s.id=t,s.select=!1,s.posy=(this.itemHeight+1)*t,this.listIn.appendChild(s),this.items.push(s),e===this.value&&(this.current=s),this.isWithImage||(s.textContent=e),this.miniCanvas){let t=new Image;t.src=this.tmpCanvas.toDataURL(),t.style.cssText="margin-right:4px;",s.appendChild(t),this.tmpImage[e]=t;}this.dragout&&(s.img=this.tmpImage[e],s.style.pointerEvents="auto",s.draggable="true",s.addEventListener("dragstart",this.dragstart||function(){}),s.addEventListener("drag",this.drag||function(){}),s.addEventListener("dragleave",(function(){i$3.fakeUp();})),s.addEventListener("dragend",this.dragend||function(){}.bind(this)));}this.setTopItem(),this.isSelectable&&this.selected();}drawImage(t,s,i,e,h,o){this.tmpCtx.clearRect(0,0,this.imageSize[0],this.imageSize[1]),this.tmpCtx.drawImage(s,i,e,h,o,0,0,this.imageSize[0],this.imageSize[1]),this.tmpImage[t].src=this.tmpCanvas.toDataURL();}addImages(){let t=this.list.length;for(let s=0;s<t;s++)this.items[s].appendChild(this.tmpImage[this.list[s]]);this.setTopItem();}setValue(t){isNaN(t)?this.value=t:this.value=this.list[t],this.setTopItem();}setTopItem(){if(!this.staticTop){if(this.isWithImage){if(!this.preLoadComplete)return;this.c[3].children.length||(this.canvas=document.createElement("canvas"),this.canvas.width=this.imageSize[0],this.canvas.height=this.imageSize[1],this.canvas.style.cssText="margin-right:4px;",this.ctx=this.canvas.getContext("2d"),this.c[3].style.textAlign="left",this.c[3].style.justifyContent="left",this.c[3].appendChild(this.canvas)),this.tmpImage[this.value],this.ctx.drawImage(this.tmpImage[this.value],0,0,this.imageSize[2],this.imageSize[3],0,0,this.imageSize[0],this.imageSize[1]);}else this.c[3].textContent=this.value;this.miniCanvas&&(this.c[3].children.length||(this.canvas=document.createElement("canvas"),this.canvas.width=this.imageSize[0],this.canvas.height=this.imageSize[1],this.canvas.style.cssText="margin-right:4px;",this.ctx=this.canvas.getContext("2d"),this.c[3].style.textAlign="left",this.c[3].style.justifyContent="left",this.c[3].appendChild(this.canvas)),this.ctx.drawImage(this.tmpImage[this.value],0,0));}}update(t){this.scroll&&(t=(t=t<0?0:t)>this.range?this.range:t,this.topList=-Math.floor(t/this.ratio),this.listIn.style.top=this.topList+"px",this.scroller.style.top=Math.floor(t)+"px",this.py=t);}parentHeight(t){null!==this.group?this.group.calc(t):this.isUI&&this.main.calc(t);}open(t){super.open(),this.update(0),this.h=this.maxHeight+this.baseH+5,this.scroll?(this.scroller.style.display="block",this.scrollerBack.style.display="block"):(this.topList=0,this.h=this.baseH+5+this.max,this.scroller.style.display="none",this.scrollerBack.style.display="none"),this.s[0].height=this.h+"px",this.s[2].display="block",this.up?(this.zone.y-=this.h-(this.baseH-10),this.setSvg(this.c[4],"d",this.svgs.g1)):this.setSvg(this.c[4],"d",this.svgs.g2),this.rSizeContent();let s=this.h-this.baseH;this.zone.h=this.h,t||this.parentHeight(s);}close(){super.close(),this.up&&(this.zone.y+=this.h-(this.baseH-10));let t=this.h-this.baseH;this.h=this.baseH,this.s[0].height=this.h+"px",this.s[2].display="none",this.setSvg(this.c[4],"d",this.svgs.g1),this.zone.h=this.h,this.parentHeight(-t);}text(t){this.c[3].textContent=t;}rSizeContent(){let t=this.length;for(;t--;)this.listIn.children[t].style.width=this.ww+"px";}rSize(){super.rSize();let t=this.s,s=this.sb,i=this.sa;void 0!==t[2]&&(t[2].width=s+"px",t[2].left=i+"px",t[3].width=s+"px",t[3].left=i+"px",t[4].left=i+s-15+"px",this.ww=s,this.max>this.maxHeight&&(this.ww=s-this.ss),this.isOpen&&this.rSizeContent());}}class f$1 extends r$1{constructor(t={}){super(t),this.setTypeNumber(t),this.allway=t.allway||!1,this.isDown=!1,this.value=[0],this.multy=1,this.invmulty=1,this.isSingle=!0,this.isAngle=!1,this.isVector=!1,t.isAngle&&(this.isAngle=!0,this.multy=h$2.torad,this.invmulty=h$2.todeg),this.isDrag=t.drag||!1,void 0!==t.value&&(isNaN(t.value)?t.value instanceof Array?(this.value=t.value,this.isSingle=!1):t.value instanceof Object&&(this.value=[],void 0!==t.value.x&&(this.value[0]=t.value.x),void 0!==t.value.y&&(this.value[1]=t.value.y),void 0!==t.value.z&&(this.value[2]=t.value.z),void 0!==t.value.w&&(this.value[3]=t.value.w),this.isSingle=!1,this.isVector=!0):this.value=[t.value]),this.lng=this.value.length,this.tmp=[],this.current=-1,this.prev={x:0,y:0,d:0,v:0};let s=this.colors;this.c[2]=this.dom("div",this.css.basic+" background:"+s.select+"; top:4px; width:0px; height:"+(this.h-8)+"px;"),this.cMode=[];let i=this.lng;for(;i--;)this.isAngle&&(this.value[i]=(180*this.value[i]/Math.PI).toFixed(this.precision)),this.c[3+i]=this.dom("div",this.css.txtselect+"top:1px; height:"+(this.h-2)+"px; color:"+s.text+"; background:"+s.back+"; borderColor:"+s.border+"; border-radius:"+this.radius+"px;"),t.center&&(this.c[2+i].style.textAlign="center"),this.c[3+i].textContent=this.value[i],this.c[3+i].style.color=this.colors.text,this.c[3+i].isNum=!0,this.cMode[i]=0;this.selectId=3+this.lng,this.c[this.selectId]=this.dom("div",this.css.txtselect+"position:absolute; top:2px; height:"+(this.h-4)+"px; padding:0px 0px; width:0px; color:"+s.textSelect+"; background:"+s.select+"; border:none; border-radius:0px;"),this.cursorId=4+this.lng,this.c[this.cursorId]=this.dom("div",this.css.basic+"top:2px; height:"+(this.h-4)+"px; width:0px; background:"+s.text+";"),this.init();}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";let i=this.lng,e=this.tmp;for(;i--;)if(s.x>e[i][0]&&s.x<e[i][2])return i;return ""}mousedown(t){let s=this.testZone(t);return !this.isDown&&(this.isDown=!0,""!==s&&(this.current=s,this.prev={x:t.clientX,y:t.clientY,d:0,v:this.isSingle?parseFloat(this.value):parseFloat(this.value[this.current])},this.setInput(this.c[3+this.current])),this.mousemove(t))}mouseup(t){return !!this.isDown&&(this.isDown=!1,this.prev={x:0,y:0,d:0,v:0},this.mousemove(t))}mousemove(t){let s=!1,i=0;if(""===this.testZone(t)?this.cursor():this.isDrag?this.cursor(-1!==this.current?"move":"pointer"):this.cursor("text"),!this.isDrag)return this.isDown&&(i=t.clientX-this.zone.x-3),-1!==this.current&&(i-=this.tmp[this.current][0]),this.upInput(i,this.isDown);if(-1!==this.current){this.prev.d+=t.clientX-this.prev.x-(t.clientY-this.prev.y);let i=this.prev.v+this.prev.d*this.step;this.value[this.current]=this.numValue(i),this.c[3+this.current].textContent=this.value[this.current],this.validate(),this.prev.x=t.clientX,this.prev.y=t.clientY,s=!0;}return s}reset(){return !1}setValue(t){this.isVector?(void 0!==t.x&&(this.value[0]=t.x),void 0!==t.y&&(this.value[1]=t.y),void 0!==t.z&&(this.value[2]=t.z),void 0!==t.w&&(this.value[3]=t.w)):this.value=this.isSingle?[t]:t,this.update();}sameStr(t){let s=this.value.length;for(;s--;)this.c[3+s].textContent=t;}update(t){let s=this.value.length;for(;s--;)this.value[s]=this.numValue(this.value[s]*this.invmulty),this.c[3+s].textContent=this.value[s];t&&this.send();}send(t){t=t||this.value,this.isSend=!0,null!==this.objectLink&&(this.isVector?this.objectLink[this.objectKey].fromArray(t):this.objectLink[this.objectKey]=t),this.callback&&this.callback(t,this.objectKey),this.isSend=!1;}select(t,s,i,e){let h=this.s,o=-1!==this.current?this.tmp[this.current][0]+5:0;h[this.cursorId].width="1px",h[this.cursorId].left=o+t+"px",h[this.selectId].left=o+s+"px",h[this.selectId].width=i+"px",this.c[this.selectId].innerHTML=e;}unselect(){let t=this.s;t&&(this.c[this.selectId].innerHTML="",t[this.selectId].width="0px",t[this.cursorId].width="0px");}validate(t){let s=[],i=this.lng;for(this.allway&&(t=!0);i--;){if(isNaN(this.c[3+i].textContent))this.c[3+i].textContent=this.value[i];else {let t=this.numValue(this.c[3+i].textContent);this.c[3+i].textContent=t,this.value[i]=t;}s[i]=this.value[i]*this.multy;}t&&this.send(this.isSingle?s[0]:s);}rSize(){super.rSize();let t=this.colors.sx,s=t*(this.lng-1),i=(this.sb-s)/this.lng,e=this.s,h=this.lng;for(;h--;)this.tmp[h]=[this.sa+i*h+t*h,i],this.tmp[h][2]=this.tmp[h][0]+this.tmp[h][1],e[3+h].left=this.tmp[h][0]+"px",e[3+h].width=this.tmp[h][1]+"px";}}class w$2 extends r$1{constructor(t={}){super(t),this.setTypeNumber(t),this.model=t.stype||0,void 0!==t.mode&&(this.model=t.mode),this.isDown=!1,this.isOver=!1,this.allway=t.allway||!1,this.isDeg=t.isDeg||!1,this.isCyclic=t.cyclic||!1,this.firstImput=!1;let s=this.colors;if(this.c[2]=this.dom("div",this.css.txtselect+"border:none; background:none; width:47px; color:"+s.text+";"),this.c[3]=this.dom("div",this.css.basic+" top:0; height:"+this.h+"px;"),this.c[4]=this.dom("div",this.css.basic+"background:"+s.back+"; top:2px; height:"+(this.h-4)+"px;"),this.c[5]=this.dom("div",this.css.basic+"left:4px; top:5px; height:"+(this.h-10)+"px; background:"+s.text+";"),this.c[2].isNum=!0,this.c[2].style.height=this.h-2+"px",this.c[2].style.lineHeight=this.h-10+"px",0!==this.model){let t=4,i=4,e=8,h=this.h-6,o=16;2===this.model&&(t=0,i=2,e=4,o=2,h=.5*(this.h-6)),3===this.model&&(this.c[5].style.visible="none"),this.c[4].style.borderRadius=t+"px",this.c[4].style.height=e+"px",this.c[4].style.top=.5*this.h-i+"px",this.c[5].style.borderRadius=.5*t+"px",this.c[5].style.height=i+"px",this.c[5].style.top=.5*this.h-.5*i+"px",this.c[6]=this.dom("div",this.css.basic+"border-radius:"+o+"px; margin-left:"+.5*-h+"px; background:"+s.text+"; left:4px; top:3px; height:"+(this.h-6)+"px; width:"+h+"px;");}this.init();}testZone(t){let s=this.local;return -1===s.x&&-1===s.y?"":s.x>=this.txl?"text":s.x>=this.sa?"scroll":""}mouseup(t){this.isDown&&(this.isDown=!1);}mousedown(t){let s=this.testZone(t);return !!s&&("scroll"===s&&(this.isDown=!0,this.old=this.value,this.mousemove(t)),!0)}mousemove(t){let s=!1;if("scroll"===this.testZone(t)?(this.mode(1),this.cursor("w-resize")):this.cursor(),this.isDown){let i=(t.clientX-(this.zone.x+this.sa)-3)/this.ww*this.range+this.min-this.old;(i>=this.step||i<=this.step)&&(i=Math.floor(i/this.step),this.value=this.numValue(this.old+i*this.step),this.update(!0),this.old=this.value),s=!0;}return s}wheel(t){if("scroll"===this.testZone(t)){let s=this.value-this.step*t.delta;return s>this.max?s=this.isCyclic?this.min:this.max:s<this.min&&(s=this.isCyclic?this.max:this.min),this.setValue(s),this.old=s,this.update(!0),!0}return !1}validate(){let t=this.c[2].textContent;isNaN(t)?this.c[2].textContent=this.value+(this.isDeg?"°":""):(this.value=this.numValue(t),this.update(!0));}reset(){this.isDown=!1,this.mode(0);}mode(t){let s=this.s,i=this.colors;switch(t){case 0:s[2].color=i.text,s[4].background=i.back,s[5].background=i.text,0!==this.model&&(s[6].background=i.text);break;case 1:s[2].color=i.textOver,s[4].background=i.back,s[5].background=i.textOver,0!==this.model&&(s[6].background=i.textOver);}}update(t){let s=Math.floor(this.ww*((this.value-this.min)/this.range));3!==this.model&&(this.s[5].width=s+"px"),this.s[6]&&(this.s[6].left=this.sa+s+3+"px"),this.c[2].textContent=this.value+(this.isDeg?"°":""),t&&this.send();}rSize(){super.rSize();let t=this.sb-this.sc;this.ww=t-6;let s=this.sc;!this.isUI&&this.simple||(s=this.sc+10),this.txl=this.w-s+2;let i=this.s;i[2].width=this.sc-6+"px",i[2].left=this.txl+4+"px",i[3].left=this.sa+"px",i[3].width=t+"px",i[4].left=this.sa+"px",i[4].width=t+"px",i[5].left=this.sa+3+"px",this.update();}}class y extends r$1{constructor(t={}){super(t),this.cmode=0,this.value=void 0!==t.value?t.value:"",this.placeHolder=t.placeHolder||"",this.allway=t.allway||!1,this.editable=void 0===t.edit||t.edit,this.isDown=!1;let s=this.colors;this.c[2]=this.dom("div",this.css.txtselect+"top:1px; height:"+(this.h-2)+"px; color:"+s.text+"; background:"+s.back+"; borderColor:"+s.border+"; border-radius:"+this.radius+"px;"),this.c[2].textContent=this.value,this.c[3]=this.dom("div",this.css.txtselect+"position:absolute; top:2px; height:"+(this.h-4)+"px; padding:0px 0px; width:0px; color:"+s.textSelect+"; background:"+s.select+"; border:none; border-radius:0px;"),this.c[4]=this.dom("div",this.css.basic+"top:2px; height:"+(this.h-4)+"px; width:0px; background:"+s.text+";"),this.c[5]=this.dom("div",this.css.txtselect+"top:1px; height:"+(this.h-2)+"px; border:none; justify-content: center; font-style: italic; color:"+s.border+";"),""===this.value&&(this.c[5].textContent=this.placeHolder),this.init();}testZone(t){let s=this.local;return -1===s.x&&-1===s.y?"":s.x>=this.sa?"text":""}mouseup(t){if(this.editable)return !!this.isDown&&(this.isDown=!1,this.mousemove(t))}mousedown(t){if(!this.editable)return;let s=this.testZone(t);return !this.isDown&&(this.isDown=!0,"text"===s&&this.setInput(this.c[2]),this.mousemove(t))}mousemove(t){if(!this.editable)return;let s=0;return "text"===this.testZone(t)?this.cursor("text"):this.cursor(),this.isDown&&(s=t.clientX-this.zone.x),this.upInput(s-this.sa-3,this.isDown)}update(){this.c[2].textContent=this.value;}reset(){this.cursor();}select(t,s,i,e){let h=this.s,o=this.sa+5;h[4].width="1px",h[4].left=o+s+"px",h[3].left=o+s+"px",h[3].width=i+"px",this.c[3].innerHTML=e;}unselect(){let t=this.s;t&&(t[3].width="0px",this.c[3].innerHTML="t",t[4].width="0px");}validate(t){this.allway&&(t=!0),this.value=this.c[2].textContent,""!==this.value?this.c[5].textContent="":this.c[5].textContent=this.placeHolder,t&&this.send();}rSize(){super.rSize();let t=this.s;t[2].left=this.sa+"px",t[2].width=this.sb+"px",t[5].left=this.sa+"px",t[5].width=this.sb+"px";}}class k extends r$1{constructor(t={}){super(t);let s=t.prefix||"";this.c[2]=this.dom("div",this.css.txt+"justify-content:right; width:60px; line-height:"+(this.h-8)+"px; color:"+this.colors.text),31===this.h&&(this.s[0].height=this.h+"px",this.s[1].top="8px",this.c[2].style.top="8px");let i=this.s;i[1].justifyContent=t.align||"left",i[1].fontWeight=t.fontWeight||"bold",this.c[1].textContent=this.txt.substring(0,1).toUpperCase()+this.txt.substring(1).replace("-"," "),this.c[2].textContent=s,this.init();}text(t){this.c[1].textContent=t;}text2(t){this.c[2].textContent=t;}rSize(){super.rSize(),this.s[1].width=this.w+"px",this.s[2].left=this.w+"px";}setColor(t){this.s[1].color=t,this.s[2].color=t;}}class S extends r$1{constructor(t={}){super(t),this.value=t.value||"",this.isDown=!1,this.onActif=t.onActif||function(){};const s=this.colors;this.c[2]=this.dom("div",this.css.txt+this.css.button+" top:1px; background:"+s.button+"; height:"+(this.h-2)+"px; border:"+s.buttonBorder+"; border-radius:15px; width:30px; left:10px;"),this.c[3]=this.dom("div",this.css.txtselect+"height:"+(this.h-4)+"px; background:"+s.inputBg+"; borderColor:"+s.inputBorder+"; border-radius:"+this.radius+"px;"),this.c[3].textContent=this.value;let i=Math.floor(.5*this.h)-7;this.c[4]=this.dom("path",this.css.basic+"position:absolute; width:14px; height:14px; left:5px; top:"+i+"px;",{d:this.svgs.cursor,fill:s.text,stroke:"none"}),this.stat=1,this.isActif=!1,this.init();}testZone(t){let s=this.local;return -1===s.x&&-1===s.y?"":s.x>this.sa&&s.x<this.sa+30?"over":"0"}mouseup(t){return !!this.isDown&&(this.isDown=!1,this.mousemove(t))}mousedown(t){return !!this.testZone(t)&&(this.isDown=!0,this.mousemove(t))}mousemove(t){let s=!1;return "over"===this.testZone(t)?(this.cursor("pointer"),s=this.mode(this.isDown?3:2)):s=this.reset(),s}apply(t){(t=t||"")!==this.value&&(this.value=t,this.c[3].textContent=this.value,this.send()),this.mode(1);}update(){this.mode(3);}mode(t){let s=!1,i=this.colors;if(this.stat!==t){switch(1===t&&(this.isActif=!1),3===t&&(this.isActif?this.isActif=!1:(this.isActif=!0,t=4,this.onActif(this))),2===t&&this.isActif&&(t=4),this.stat=t,t){case 1:this.s[2].color=i.text,this.s[2].background=i.button;break;case 2:this.s[2].color=i.textOver,this.s[2].background=i.overoff;break;case 3:this.s[2].color=i.textOver,this.s[2].background=i.action;break;case 4:this.s[2].color=i.textSelect,this.s[2].background=i.action;}s=!0;}return s}reset(){return this.cursor(),this.mode(this.isActif?4:1)}text(t){this.c[3].textContent=t;}rSize(){super.rSize();let t=this.s;t[2].left=this.sa+"px",t[3].left=this.sa+40+"px",t[3].width=this.sb-40+"px",t[4].left=this.sa+8+"px";}}class I$1 extends r$1{constructor(t={}){super(t),this.value=t.value||"",this.refTexture=t.texture||null,this.img=null,this.isDown=!1,this.neverlock=!0;const s=this.colors;this.c[2]=this.dom("div",this.css.txt+this.css.button+" top:1px; background:"+s.button+"; height:"+(this.h-2)+"px; border:"+s.buttonBorder+"; border-radius:15px; width:30px; left:10px;"),this.c[3]=this.dom("div",this.css.txtselect+"height:"+(this.h-4)+"px; background:"+s.inputBg+"; borderColor:"+s.inputBorder+"; border-radius:"+this.radius+"px;"),this.c[3].textContent=this.value;let i=Math.floor(.5*this.h)-7;this.c[4]=this.dom("path",this.css.basic+"position:absolute; width:14px; height:14px; left:5px; top:"+i+"px;",{d:this.svgs.load,fill:s.text,stroke:"none"}),this.stat=1,this.init();}testZone(t){let s=this.local;return -1===s.x&&-1===s.y?"":s.x>this.sa&&s.x<this.sa+30?"over":"0"}mouseup(t){return !!this.isDown&&(this.isDown=!1,this.mousemove(t))}mousedown(t){let s=this.testZone(t);return !!s&&("over"===s&&(this.isDown=!0,o$1.load({callback:this.changeBitmap.bind(this)})),this.mousemove(t))}mousemove(t){let s=!1;return "over"===this.testZone(t)?(this.cursor("pointer"),s=this.mode(this.isDown?3:2)):s=this.reset(),s}changeBitmap(t,s){t?(this.img=t,this.apply(s)):(this.img=null,this.apply("null"));}apply(t){(t=t||"")!==this.value&&(this.value=t,this.c[3].textContent=this.value,null!==this.img&&(null!==this.objectLink&&(this.objectLink[this.val]=t),this.callback&&this.callback(this.value,this.img,this.name))),this.mode(1);}update(){this.mode(3);}mode(t){let s=!1,i=this.colors;if(this.stat!==t){switch(this.stat=t,t){case 1:this.s[2].color=i.text,this.s[2].background=i.button;break;case 2:this.s[2].color=i.textOver,this.s[2].background=i.overoff;break;case 3:this.s[2].color=i.textOver,this.s[2].background=i.over;break;case 4:this.s[2].color=i.textSelect,this.s[2].background=i.select;}s=!0;}return s}reset(){return this.cursor(),this.mode(this.isActif?4:1)}text(t){this.c[3].textContent=t;}rSize(){super.rSize();let t=this.s;t[2].left=this.sa+"px",t[3].left=this.sa+40+"px",t[3].width=this.sb-40+"px",t[4].left=this.sa+8+"px";}}class M$1 extends a$1{constructor(t={}){void 0===t.selectable&&(t.selectable=!0),super(t);}}class C$2 extends r$1{constructor(t={}){super(t),this.p=100,this.value=this.txt,this.status=1,this.itype=t.itype||"none",this.val=this.itype,this.graph=this.svgs[this.itype];let s=Math.floor(.5*this.h)-7;this.c[2]=this.dom("path",this.css.basic+"position:absolute; width:14px; height:14px; left:5px; top:"+s+"px;",{d:this.graph,fill:this.colors.text,stroke:"none"}),this.s[1].marginLeft="20px",this.init();}mousemove(t){this.cursor("pointer");}mousedown(t){return this.isUI&&this.main.resetItem(),this.selected(!0),this.send(),!0}uiout(){this.isSelect?this.mode(3):this.mode(1);}uiover(){this.isSelect?this.mode(4):this.mode(2);}update(){}mode(t){let s=!1;if(this.status!==t){this.status=t;let i=this.s,e=this.colors;switch(t){case 1:this.status=1,i[1].color=e.text,i[0].background="none";break;case 2:this.status=2,i[1].color=e.textOver,i[0].background=e.back;break;case 3:this.status=3,i[1].color=e.textSelect,i[0].background=e.select;break;case 4:this.status=4,i[1].color=e.textOver,i[0].background=e.over;}s=!0;}return s}reset(){this.cursor();}selected(t){this.isSelect&&this.mode(1),this.isSelect=t||!1,this.isSelect&&this.mode(3);}}class L$1 extends r$1{constructor(t={}){if(super(t),this.values=[],t.values)if(t.values instanceof Array)this.values=t.values;else if(t.values instanceof String)this.values=[t.values];else if(t.values instanceof Object){this.refObject=t.values;for(let t in this.refObject)this.values.push(t);}this.lng=this.values.length,this.value=t.value||null;let s=this.colors;this.isSelectable=t.selectable||!1,this.spaces=t.spaces||[s.sx,s.sy],this.bsize=t.bsize||[90,this.h],this.bsizeMax=this.bsize[0],this.tmp=[],this.stat=[],this.grid=[2,Math.round(.5*this.lng)],this.h=this.grid[1]*this.bsize[1]+this.grid[1]*this.spaces[1],this.c[1].textContent="",this.c[2]=this.dom("table",this.css.basic+"width:100%; border-spacing: "+(this.spaces[0]-2)+"px "+this.spaces[1]+"px; border:none;");let i,e,h,o,n=0;this.res=-1,this.isDown=!1,this.neverlock=!0,this.buttons=[],this.stat=[],this.tmpX=[],this.tmpY=[];for(let t=0;t<this.grid[1];t++){h=this.c[2].insertRow(),h.style.cssText="pointer-events:none;";for(let t=0;t<this.grid[0];t++)e=h.insertCell(),e.style.cssText="pointer-events:none;",this.values[n]?(o=!1,this.values[n]===this.value&&this.isSelectable&&(o=!0),i=document.createElement("div"),i.style.cssText=this.css.txt+this.css.button+"position:static; top:1px; width:"+this.bsize[0]+"px; height:"+(this.bsize[1]-2)+"px; border:"+s.borderSize+"px solid "+s.border+"; left:auto; right:auto; border-radius:"+this.radius+"px;",i.style.background=o?s.select:s.button,i.style.color=o?s.textSelect:s.text,i.innerHTML=this.values[n],e.appendChild(i),this.buttons.push(i),this.stat.push(1)):(i=document.createElement("div"),i.style.cssText=this.css.txt+"position:static; width:"+this.bsize[0]+"px; height:"+this.bsize[1]+"px; text-align:center; left:auto; right:auto; background:none;",e.appendChild(i)),i.style.cssText+=0===t?"float:right;":"float:left;",n++;}this.s[0].border="none",this.init();}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return -1;s.y+=this.mtop;let i=this.tmpX,e=this.tmpY,h=-1,o=-1,n=-1,r=this.grid[0];for(;r--;)s.x>i[r][0]&&s.x<i[r][1]&&(o=r);for(r=this.grid[1];r--;)s.y>e[r][0]&&s.y<e[r][1]&&(n=r);return -1!==o&&-1!==n&&(h=o+2*n,h>this.lng-1&&(h=-1)),h}mouseup(t){return !!this.isDown&&(this.isDown=!1,-1!==this.res&&(this.value=this.values[this.res],this.send()),this.mousemove(t))}mousedown(t){return !this.isDown&&(this.isDown=!0,this.mousemove(t))}mousemove(t){let s=!1;return this.res=this.testZone(t),-1!==this.res?(this.cursor("pointer"),s=this.modes(this.isDown?3:2,this.res)):s=this.reset(),s}modes(t=1,s=-1){let i,e,h=this.lng,o=!1;for(;h--;)e=t,i=!!this.isSelectable&&this.values[h]===this.value,h===s?i&&2===e&&(e=3):(e=1,i&&(e=4)),this.mode(e,h)&&(o=!0);return o}mode(t,s){let i=!1,e=this.colors,h=this.buttons,o=s;if(this.stat[s]!==t){switch(this.stat[s]=t,t){case 1:h[o].style.color=e.text,h[o].style.background=e.button;break;case 2:h[o].style.color=e.textOver,h[o].style.background=e.overoff;break;case 3:h[o].style.color=e.textOver,h[o].style.background=e.over;break;case 4:h[o].style.color=e.textSelect,h[o].style.background=e.select;}i=!0;}return i}reset(){return this.res=-1,this.cursor(),this.modes()}label(t,s){this.buttons[s].textContent=t;}icon(t,s,i){this.buttons[i].style.padding=(s||0)+"px 0px",this.buttons[i].innerHTML=t;}testW(){let t=!1;if(3*this.spaces[0]+2*this.bsizeMax>this.w?(this.bsize[0]=.5*(this.w-3*this.spaces[0]),t=!0):this.bsize[0]!==this.bsizeMax&&(this.bsize[0]=this.bsizeMax,t=!0),!t)return;let s=this.buttons.length;for(;s--;)this.buttons[s].style.width=this.bsize[0]+"px";}rSize(){let t;super.rSize(),this.testW(),this.tmpX=[],this.tmpY=[];for(let s=0;s<this.grid[0];s++)0===s?(t=.5*this.w-.5*this.spaces[0],this.tmpX.push([t-this.bsize[0],t])):(t=.5*this.w+.5*this.spaces[0],this.tmpX.push([t,t+this.bsize[0]]));t=this.spaces[1];for(let s=0;s<this.grid[1];s++)this.tmpY.push([t,t+this.bsize[1]]),t+=this.bsize[1]+this.spaces[1];}}class z$1 extends r$1{constructor(t={}){super(t),this.autoWidth=!1,this.minw=this.w,this.diam=t.diam||this.w,this.pos=new n$1(0,0),this.maxPos=90,this.model=t.stype||0,void 0!==t.mode&&(this.model=t.mode),this.min=void 0===t.min?-1:t.min,this.max=void 0===t.max?1:t.max,this.range=.5*(this.max-this.min),this.cmode=0,this.c[0].style.display="block",this.precision=void 0===t.precision?2:t.precision,this.value=Array.isArray(t.value)&&2==t.value.length?t.value:[0,0],this.h=t.h||this.w+10,this.c[0].style.width=this.w+"px",void 0!==this.c[1]&&(this.c[1].style.width="100%",this.c[1].style.justifyContent="center",this.top=10,this.h+=10);let s=this.colors;this.c[2]=this.dom("div",this.css.txt+"justify-content:center; top:"+(this.h-20)+"px; width:100%; color:"+s.text),this.c[2].textContent=this.value;let i=this.getPad2d();this.setSvg(i,"fill",s.back,0),this.setSvg(i,"fill",s.button,1),this.setSvg(i,"stroke",s.back,2),this.setSvg(i,"stroke",s.back,3),this.setSvg(i,"stroke",s.text,4),this.setSvg(i,"viewBox","0 0 "+this.diam+" "+this.diam),this.setCss(i,{width:this.diam,height:this.diam,left:0,top:this.top}),this.c[3]=i,this.init(),this.setValue();}testZone(t){let s=this.local;return -1===s.x&&-1===s.y?"":s.y<=this.c[1].offsetHeight?"title":s.y>this.h-this.c[2].offsetHeight?"text":"pad"}mouseup(t){return this.isDown=!1,this.mode(0)}mousedown(t){if("pad"===this.testZone(t))return this.isDown=!0,this.mousemove(t),this.mode(1)}mousemove(t){if(!this.isDown)return;let s=.5*this.w-(t.clientX-this.zone.x),i=.5*this.diam-(t.clientY-this.zone.y-this.ytop),e=256/this.diam;s=-s*e,i=-i*e,s=h$2.clamp(s,-this.maxPos,this.maxPos),i=h$2.clamp(i,-this.maxPos,this.maxPos),this.setPos([s,i]),this.update(!0);}mode(t){if(this.cmode===t)return !1;let s=this.colors;switch(t){case 0:this.s[2].color=s.text,this.setSvg(this.c[3],"fill",s.back,0),this.setSvg(this.c[3],"fill",s.button,1),this.setSvg(this.c[3],"stroke",s.back,2),this.setSvg(this.c[3],"stroke",s.back,3),this.setSvg(this.c[3],"stroke",s.text,4);break;case 1:this.s[2].color=s.textSelect,this.setSvg(this.c[3],"fill",s.backoff,0),this.setSvg(this.c[3],"fill",s.overoff,1),this.setSvg(this.c[3],"stroke",s.backoff,2),this.setSvg(this.c[3],"stroke",s.backoff,3),this.setSvg(this.c[3],"stroke",s.textSelect,4);}return this.cmode=t,!0}update(t){this.c[2].textContent=this.value,this.updateSVG(),t&&this.send();}updateSVG(){1==this.model&&(this.setSvg(this.c[3],"y1",this.pos.y,2),this.setSvg(this.c[3],"y2",this.pos.y,2),this.setSvg(this.c[3],"x1",this.pos.x,3),this.setSvg(this.c[3],"x2",this.pos.x,3)),this.setSvg(this.c[3],"cx",this.pos.x,4),this.setSvg(this.c[3],"cy",this.pos.y,4);}setPos(t){this.pos.set(t[0]+128,t[1]+128);let s=1/this.maxPos;this.value[0]=(t[0]*s*this.range).toFixed(this.precision),this.value[1]=(t[1]*s*this.range).toFixed(this.precision);}setValue(t,s=!1){void 0===t&&(t=this.value),this.value[0]=1*Math.min(this.max,Math.max(this.min,t[0])).toFixed(this.precision),this.value[1]=1*Math.min(this.max,Math.max(this.min,t[1])).toFixed(this.precision),this.pos.set(this.value[0]/this.range*this.maxPos+128,this.value[1]/this.range*this.maxPos+128),this.update(s);}}const T$1=function(){let t,s,e=arguments,h=!1,o=null;"string"==typeof e[0]?(t=e[0],s=e[1]||{}):"object"==typeof e[0]&&(h=!0,void 0===e[2]&&[].push.call(e,{}),t=e[2].type?e[2].type:O$1(e[0][e[1]],e[2]),s=e[2],s.name=e[1],"list"!==t||s.list?s.value=e[0][e[1]]:s.list=e[0][e[1]]);let n=t.toLowerCase();switch("group"===n&&(s.add=T$1),n){case"bool":case"boolean":o=new l$1(s);break;case"button":o=new a$1(s);break;case"circular":o=new c$1(s);break;case"color":o=new d$1(s);break;case"fps":o=new u$1(s);break;case"graph":o=new p$1(s);break;case"group":o=new g$1(s);break;case"joystick":o=new x$2(s);break;case"knob":o=new v$1(s);break;case"list":o=new b(s);break;case"numeric":case"number":o=new f$1(s);break;case"slide":o=new w$2(s);break;case"textInput":case"string":o=new y(s);break;case"title":case"text":o=new k(s);break;case"select":o=new S(s);break;case"bitmap":o=new I$1(s);break;case"selector":o=new M$1(s);break;case"empty":case"space":o=new m$1(s);break;case"item":o=new C$2(s);break;case"grid":o=new L$1(s);break;case"pad2d":case"pad":o=new z$1(s);}if(null!==o)return i$3.needResize=!0,h&&o.setReferency(e[0],e[1]),o},O$1=function(t,s){let i="slide";return "boolean"==typeof t?i="bool":"string"==typeof t?i="#"===t.substring(0,1)?"color":"string":"number"==typeof t?i=s.ctype?"color":"slide":"array"==typeof t&&t instanceof Array?"number"==typeof t[0]?i="number":"string"==typeof t[0]&&(i="list"):"object"==typeof t&&t instanceof Object&&(i=void 0!==t.x?"number":"list"),i};class D{constructor(t={}){this.isGui=!0,this.name="gui",this.canvas=null,this.screen=null,this.plane=t.plane||null,t.config&&(t.colors=t.config),t.colors?this.setConfig(t.colors):this.colors=h$2.defineColor(t),this.css=h$2.cloneCss(),this.isReset=!0,this.tmpAdd=null,this.isCanvas=t.isCanvas||!1,this.isCanvasOnly=!1,this.callback=void 0===t.callback?null:t.callback,this.forceHeight=t.maxHeight||0,this.lockHeight=t.lockHeight||!1,this.isItemMode=void 0!==t.itemMode&&t.itemMode,this.cn="",this.size=h$2.size,void 0!==t.p&&(this.size.p=t.p),void 0!==t.w&&(this.size.w=t.w),void 0!==t.h&&(this.size.h=t.h),void 0!==t.s&&(this.size.s=t.s),this.size.h=this.size.h<11?11:this.size.h,this.local=(new n$1).neg(),this.zone={x:0,y:0,w:this.size.w,h:0},this.mouse=(new n$1).neg(),this.h=0,this.sw=0,this.margin=this.colors.sy,this.marginDiv=h$2.isDivid(this.margin),this.isWithClose=void 0===t.close||t.close,this.bh=this.isWithClose?this.size.h:0,this.autoResize=void 0===t.autoResize||t.autoResize,this.isCenter=t.center||!1,this.cssGui=void 0!==t.css?t.css:this.isCenter?"":"right:10px;",this.isOpen=void 0===t.open||t.open,this.isDown=!1,this.isScroll=!1,this.uis=[],this.current=-1,this.proto=null,this.isEmpty=!0,this.decal=0,this.ratio=1,this.oy=0,this.isNewTarget=!1;let s=this.colors;this.content=h$2.dom("div",this.css.basic+" width:0px; height:auto; top:0px; background:"+s.content+"; "+this.cssGui),this.innerContent=h$2.dom("div",this.css.basic+"width:100%; top:0; left:0; height:auto; overflow:hidden;"),this.content.appendChild(this.innerContent),this.useFlex=!0;let e=this.useFlex?"display:flex; flex-flow: row wrap;":"";this.inner=h$2.dom("div",this.css.basic+e+"width:100%; left:0; "),this.innerContent.appendChild(this.inner),this.scrollBG=h$2.dom("div",this.css.basic+"right:0; top:0; width:"+(this.size.s-1)+"px; height:10px; display:none; background:"+s.background+";"),this.content.appendChild(this.scrollBG),this.scroll=h$2.dom("div",this.css.basic+"background:"+s.button+"; right:2px; top:0; width:"+(this.size.s-4)+"px; height:10px;"),this.scrollBG.appendChild(this.scroll),this.bottomText=t.bottomText||["open","close"];let o=s.radius;this.bottom=h$2.dom("div",this.css.txt+"width:100%; top:auto; bottom:0; left:0; border-bottom-right-radius:"+o+"px; border-bottom-left-radius:"+o+"px; justify-content:center; height:"+this.bh+"px; line-height:"+(this.bh-5)+"px; color:"+s.text+";"),this.content.appendChild(this.bottom),this.bottom.textContent=this.isOpen?this.bottomText[1]:this.bottomText[0],this.bottom.style.background=s.background,this.parent=void 0!==t.parent?t.parent:null,this.parent=void 0!==t.target?t.target:this.parent,null!==this.parent||this.isCanvas||(this.parent=document.body),null!==this.parent&&this.parent.appendChild(this.content),this.isCanvas&&null===this.parent&&(this.isCanvasOnly=!0),this.isCanvasOnly?(this.content.style.left="0px",this.content.style.right="auto",t.transition=0):this.content.style.pointerEvents="auto",this.transition=void 0!==t.transition?t.transition:h$2.transition,this.transition&&setTimeout(this.addTransition.bind(this),1e3),this.setWidth(),this.isCanvas&&this.makeCanvas(),i$3.add(this);}setTop(t,s){this.content.style.top=t+"px",void 0!==s&&(this.forceHeight=s),this.calc(),i$3.needReZone=!0;}addTransition(){this.transition&&!this.isCanvas&&(this.innerContent.style.transition="height "+this.transition+"s ease-out",this.content.style.transition="height "+this.transition+"s ease-out",this.bottom.style.transition="top "+this.transition+"s ease-out");let t=this.uis.length;for(;t--;)this.uis[t].addTransition();}onDraw(){}makeCanvas(){this.canvas=document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),this.canvas.width=this.zone.w,this.canvas.height=this.forceHeight?this.forceHeight:this.zone.h;}draw(t){if(null===this.canvas)return;let s=this.zone.w,e=this.forceHeight?this.forceHeight:this.zone.h;i$3.toCanvas(this,s,e,t);}getDom(){return this.content}noMouse(){this.mouse.neg();}setMouse(t,s=!0){s?this.mouse.set(Math.round(t.x*this.canvas.width),this.canvas.height-Math.round(t.y*this.canvas.height)):this.mouse.set(Math.round(t.x*this.canvas.width),Math.round(t.y*this.canvas.height));}setConfig(t){h$2.setText(),this.colors=h$2.defineColor(t);}setColors(t){for(let s in t)this.colors[s]&&(this.colors[s]=t[s]);}setText(t,s,i,e){h$2.setText(t,s,i,e);}hide(t){this.content.style.visibility=t?"hidden":"visible";}display(t=!1){this.content.style.visibility=t?"visible":"hidden";}onChange(t){return this.callback=t||null,this}mode(t){let s=!1,e=this.colors;if(t!==this.cn){switch(this.cn=t,t){case"def":i$3.cursor(),this.scroll.style.background=e.button,this.bottom.style.background=e.background,this.bottom.style.color=e.text;break;case"scrollOver":i$3.cursor("ns-resize"),this.scroll.style.background=e.select;break;case"scrollDown":this.scroll.style.background=e.select;break;case"bottomOver":i$3.cursor("pointer"),this.bottom.style.background=e.backgroundOver,this.bottom.style.color=e.textOver;}s=!0;}return s}clearTarget(){return -1!==this.current&&(this.proto.s&&(this.proto.uiout(),this.proto.reset()),this.proto=null,this.current=-1,i$3.cursor(),!0)}testZone(t){let s=this.local;if(-1===s.x&&-1===s.y)return "";this.isReset=!1;let i="",e=this.isScroll?this.zone.w-this.size.s:this.zone.w;return i=s.y>this.zone.h-this.bh&&s.y<this.zone.h?"bottom":s.x>e?"scroll":"content",i}handleEvent(t){let s=t.type,e=!1,h=!1,o=this.testZone(t);if("mouseup"===s&&this.isDown&&(this.isDown=!1),"mousedown"!==s||this.isDown||(this.isDown=!0),this.isDown&&this.isNewTarget&&(i$3.clearInput(),this.isNewTarget=!1),o){switch(o){case"content":t.clientY=this.isScroll?t.clientY+this.decal:t.clientY,i$3.isMobile&&"mousedown"===s&&this.getNext(t,e),this.proto&&(h=this.proto.handleEvent(t)),"mousemove"===s&&(e=this.mode("def")),"wheel"===s&&!h&&this.isScroll&&(e=this.onWheel(t)),i$3.lock||this.getNext(t,e);break;case"bottom":this.clearTarget(),"mousemove"===s&&(e=this.mode("bottomOver")),"mousedown"===s&&(this.isOpen=!this.isOpen,this.bottom.textContent=this.isOpen?this.bottomText[1]:this.bottomText[0],this.calc(),this.mode("def"),e=!0);break;case"scroll":this.clearTarget(),"mousemove"===s&&(e=this.mode("scrollOver")),"mousedown"===s&&(e=this.mode("scrollDown")),"wheel"===s&&(e=this.onWheel(t)),this.isDown&&this.update(t.clientY-this.zone.y-.5*this.sh);}this.isDown&&(e=!0),h&&(e=!0),"keyup"===s&&(e=!0),"keydown"===s&&(e=!0),e&&this.draw();}}getNext(t,s){let e=i$3.findTarget(this.uis,t);e!==this.current&&(this.clearTarget(),this.current=e,this.isNewTarget=!0),-1!==e&&(this.proto=this.uis[this.current],this.proto.uiover());}onWheel(t){return this.oy+=20*t.delta,this.update(this.oy),!0}reset(t){if(this.isReset)return;this.mouse.neg(),this.isDown=!1;let s=this.mode("def"),i=this.clearTarget();(s||i)&&this.draw(!0),this.isReset=!0;}add(){let t=arguments,s=!1;"object"==typeof t[1]?(t[1].isUI=!0,t[1].main=this,s=!!t[1].ontop&&t[1].ontop):"string"==typeof t[1]&&(void 0===t[2]?[].push.call(t,{isUI:!0,main:this}):(t[2].isUI=!0,t[2].main=this,s=!!t[2].ontop&&t[2].ontop));let i=T$1.apply(this,t);if(null!==i)return s?this.uis.unshift(i):this.uis.push(i),this.calc(),this.isEmpty=!1,i}remove(t){t.dispose&&t.dispose();}clearOne(t){let s=this.uis.indexOf(t);-1!==s&&(this.inner.removeChild(this.uis[s].c[0]),this.uis.splice(s,1),this.calc());}empty(){let t,s=this.uis.length;for(;s--;)t=this.uis.pop(),this.inner.removeChild(t.c[0]),t.dispose();this.uis=[],this.isEmpty=!0,this.calc();}clear(){this.empty();}clear2(){setTimeout(this.empty.bind(this),0);}dispose(){this.clear(),null!==this.parent&&this.parent.removeChild(this.content),i$3.remove(this);}resetItem(){if(!this.isItemMode)return;let t=this.uis.length;for(;t--;)this.uis[t].selected();}setItem(t){if(!this.isItemMode)return;if(t=t||"",this.resetItem(),!t)return void this.update(0);let s=this.uis.length;for(;s--;)this.uis[s].value===t&&(this.uis[s].selected(!0),this.isScroll&&this.update(s*(this.uis[s].h+this.margin)*this.ratio));}upScroll(t){this.sw=t?this.size.s:0,this.oy=t?this.oy:0,this.scrollBG.style.display=t?"block":"none",t&&(this.total=this.h,this.maxView=this.maxHeight,this.ratio=this.maxView/this.total,this.sh=this.maxView*this.ratio,this.range=this.maxView-this.sh,this.oy=h$2.clamp(this.oy,0,this.range),this.scrollBG.style.height=this.maxView+"px",this.scroll.style.height=this.sh+"px"),this.setItemWidth(this.zone.w-this.sw),this.update(this.oy);}update(t){t=h$2.clamp(t,0,this.range),this.decal=Math.floor(t/this.ratio),this.inner.style.top=-this.decal+"px",this.scroll.style.top=Math.floor(t)+"px",this.oy=t;}calcUis(){return i$3.calcUis(this.uis,this.zone,this.zone.y)}calc(){clearTimeout(this.tmp),this.tmp=setTimeout(this.setHeight.bind(this),10);}setHeight(){if(this.tmp&&clearTimeout(this.tmp),this.zone.h=this.bh,this.isScroll=!1,this.isOpen){this.h=this.calcUis();let t=this.forceHeight?this.forceHeight+this.zone.y:window.innerHeight;this.maxHeight=t-this.zone.y-this.bh,this.h-this.maxHeight>1?(this.isScroll=!0,this.zone.h=this.maxHeight+this.bh):this.zone.h=this.h+this.bh;}this.upScroll(this.isScroll),this.innerContent.style.height=this.zone.h-this.bh+"px",this.content.style.height=this.zone.h+"px",this.bottom.style.top=this.zone.h-this.bh+"px",this.forceHeight&&this.lockHeight&&(this.content.style.height=this.forceHeight+"px"),this.isCanvas&&this.draw(!0);}rezone(){i$3.needReZone=!0;}setWidth(t){t&&(this.zone.w=t),this.zone.w=Math.floor(this.zone.w),this.content.style.width=this.zone.w+"px",this.isCenter&&(this.content.style.marginLeft=-Math.floor(.5*this.zone.w)+"px"),this.setItemWidth(this.zone.w-this.sw);}setItemWidth(t){let s=this.uis.length;for(;s--;)this.uis[s].setSize(t),this.uis[s].rSize();}}

/* webgl-memory@1.0.15, license MIT */
(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () {
  /* PixelFormat */
  const ALPHA                          = 0x1906;
  const RGB                            = 0x1907;
  const RGBA                           = 0x1908;
  const LUMINANCE                      = 0x1909;
  const LUMINANCE_ALPHA                = 0x190A;
  const DEPTH_COMPONENT                = 0x1902;
  const DEPTH_STENCIL                  = 0x84F9;

  const R8                           = 0x8229;
  const R8_SNORM                     = 0x8F94;
  const R16F                         = 0x822D;
  const R32F                         = 0x822E;
  const R8UI                         = 0x8232;
  const R8I                          = 0x8231;
  const RG16UI                       = 0x823A;
  const RG16I                        = 0x8239;
  const RG32UI                       = 0x823C;
  const RG32I                        = 0x823B;
  const RG8                          = 0x822B;
  const RG8_SNORM                    = 0x8F95;
  const RG16F                        = 0x822F;
  const RG32F                        = 0x8230;
  const RG8UI                        = 0x8238;
  const RG8I                         = 0x8237;
  const R16UI                        = 0x8234;
  const R16I                         = 0x8233;
  const R32UI                        = 0x8236;
  const R32I                         = 0x8235;
  const RGB8                         = 0x8051;
  const SRGB8                        = 0x8C41;
  const RGB565                       = 0x8D62;
  const RGB8_SNORM                   = 0x8F96;
  const R11F_G11F_B10F               = 0x8C3A;
  const RGB9_E5                      = 0x8C3D;
  const RGB16F                       = 0x881B;
  const RGB32F                       = 0x8815;
  const RGB8UI                       = 0x8D7D;
  const RGB8I                        = 0x8D8F;
  const RGB16UI                      = 0x8D77;
  const RGB16I                       = 0x8D89;
  const RGB32UI                      = 0x8D71;
  const RGB32I                       = 0x8D83;
  const RGBA8                        = 0x8058;
  const SRGB8_ALPHA8                 = 0x8C43;
  const RGBA8_SNORM                  = 0x8F97;
  const RGB5_A1                      = 0x8057;
  const RGBA4                        = 0x8056;
  const RGB10_A2                     = 0x8059;
  const RGBA16F                      = 0x881A;
  const RGBA32F                      = 0x8814;
  const RGBA8UI                      = 0x8D7C;
  const RGBA8I                       = 0x8D8E;
  const RGB10_A2UI                   = 0x906F;
  const RGBA16UI                     = 0x8D76;
  const RGBA16I                      = 0x8D88;
  const RGBA32I                      = 0x8D82;
  const RGBA32UI                     = 0x8D70;

  const DEPTH_COMPONENT16            = 0x81A5;
  const DEPTH_COMPONENT24            = 0x81A6;
  const DEPTH_COMPONENT32F           = 0x8CAC;
  const DEPTH32F_STENCIL8            = 0x8CAD;
  const DEPTH24_STENCIL8             = 0x88F0;
  const UNSIGNED_BYTE                = 0x1401;
  const UNSIGNED_SHORT               = 0x1403;
  const UNSIGNED_INT                 = 0x1405;
  const FLOAT                        = 0x1406;
  const UNSIGNED_SHORT_4_4_4_4       = 0x8033;
  const UNSIGNED_SHORT_5_5_5_1       = 0x8034;
  const UNSIGNED_SHORT_5_6_5         = 0x8363;
  const HALF_FLOAT                   = 0x140B;
  const HALF_FLOAT_OES               = 0x8D61;  // Thanks Khronos for making this different >:(

  const SRGB_ALPHA_EXT               = 0x8C42;

  /**
   * @typedef {Object} TextureFormatDetails
   * @property {number} textureFormat format to pass texImage2D and similar functions.
   * @property {boolean} colorRenderable true if you can render to this format of texture.
   * @property {boolean} textureFilterable true if you can filter the texture, false if you can ony use `NEAREST`.
   * @property {number[]} type Array of possible types you can pass to texImage2D and similar function
   * @property {Object.<number,number>} bytesPerElementMap A map of types to bytes per element
   * @private
   */

  let s_textureInternalFormatInfo;
  function getTextureInternalFormatInfo(internalFormat) {
    if (!s_textureInternalFormatInfo) {
      // NOTE: these properties need unique names so we can let Uglify mangle the name.
      const t = {};
      // unsized formats
      t[ALPHA]              = { bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT], };
      t[LUMINANCE]          = { bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT], };
      t[LUMINANCE_ALPHA]    = { bytesPerElement: [2, 4, 4, 8],        type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT], };
      t[RGB]                = { bytesPerElement: [3, 6, 6, 12, 2],    type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_5_6_5], };
      t[RGBA]               = { bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1], };
      t[SRGB_ALPHA_EXT]     = { bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1], };
      t[DEPTH_COMPONENT]    = { bytesPerElement: [2, 4],              type: [UNSIGNED_INT, UNSIGNED_SHORT], };
      t[DEPTH_STENCIL]      = { bytesPerElement: [4],                 };

      // sized formats
      t[R8]                 = { bytesPerElement: [1],  };
      t[R8_SNORM]           = { bytesPerElement: [1],  };
      t[R16F]               = { bytesPerElement: [2],  };
      t[R32F]               = { bytesPerElement: [4],  };
      t[R8UI]               = { bytesPerElement: [1],  };
      t[R8I]                = { bytesPerElement: [1],  };
      t[R16UI]              = { bytesPerElement: [2],  };
      t[R16I]               = { bytesPerElement: [2],  };
      t[R32UI]              = { bytesPerElement: [4],  };
      t[R32I]               = { bytesPerElement: [4],  };
      t[RG8]                = { bytesPerElement: [2],  };
      t[RG8_SNORM]          = { bytesPerElement: [2],  };
      t[RG16F]              = { bytesPerElement: [4],  };
      t[RG32F]              = { bytesPerElement: [8],  };
      t[RG8UI]              = { bytesPerElement: [2],  };
      t[RG8I]               = { bytesPerElement: [2],  };
      t[RG16UI]             = { bytesPerElement: [4],  };
      t[RG16I]              = { bytesPerElement: [4],  };
      t[RG32UI]             = { bytesPerElement: [8],  };
      t[RG32I]              = { bytesPerElement: [8],  };
      t[RGB8]               = { bytesPerElement: [3],  };
      t[SRGB8]              = { bytesPerElement: [3],  };
      t[RGB565]             = { bytesPerElement: [2],  };
      t[RGB8_SNORM]         = { bytesPerElement: [3],  };
      t[R11F_G11F_B10F]     = { bytesPerElement: [4],  };
      t[RGB9_E5]            = { bytesPerElement: [4],  };
      t[RGB16F]             = { bytesPerElement: [6],  };
      t[RGB32F]             = { bytesPerElement: [12], };
      t[RGB8UI]             = { bytesPerElement: [3],  };
      t[RGB8I]              = { bytesPerElement: [3],  };
      t[RGB16UI]            = { bytesPerElement: [6],  };
      t[RGB16I]             = { bytesPerElement: [6],  };
      t[RGB32UI]            = { bytesPerElement: [12], };
      t[RGB32I]             = { bytesPerElement: [12], };
      t[RGBA8]              = { bytesPerElement: [4],  };
      t[SRGB8_ALPHA8]       = { bytesPerElement: [4],  };
      t[RGBA8_SNORM]        = { bytesPerElement: [4],  };
      t[RGB5_A1]            = { bytesPerElement: [2],  };
      t[RGBA4]              = { bytesPerElement: [2],  };
      t[RGB10_A2]           = { bytesPerElement: [4],  };
      t[RGBA16F]            = { bytesPerElement: [8],  };
      t[RGBA32F]            = { bytesPerElement: [16], };
      t[RGBA8UI]            = { bytesPerElement: [4],  };
      t[RGBA8I]             = { bytesPerElement: [4],  };
      t[RGB10_A2UI]         = { bytesPerElement: [4],  };
      t[RGBA16UI]           = { bytesPerElement: [8],  };
      t[RGBA16I]            = { bytesPerElement: [8],  };
      t[RGBA32I]            = { bytesPerElement: [16], };
      t[RGBA32UI]           = { bytesPerElement: [16], };
      // Sized Internal
      t[DEPTH_COMPONENT16]  = { bytesPerElement: [2],  };
      t[DEPTH_COMPONENT24]  = { bytesPerElement: [4],  };
      t[DEPTH_COMPONENT32F] = { bytesPerElement: [4],  };
      t[DEPTH24_STENCIL8]   = { bytesPerElement: [4],  };
      t[DEPTH32F_STENCIL8]  = { bytesPerElement: [4],  };

      s_textureInternalFormatInfo = t;
    }
    return s_textureInternalFormatInfo[internalFormat];
  }

  function makeComputeBlockRectSizeFunction(blockWidth, blockHeight, bytesPerBlock) {
    return function(width, height, depth) {
      const blocksAcross = (width + blockWidth - 1) / blockWidth | 0;
      const blocksDown =  (height + blockHeight - 1) / blockHeight | 0;
      return blocksAcross * blocksDown * bytesPerBlock * depth;
    }
  } 

  function makeComputePaddedRectSizeFunction(minWidth, minHeight, divisor) {
    return function(width, height, depth) {
      return (Math.max(width, minWidth) * Math.max(height, minHeight) / divisor | 0) * depth;
    }
  } 

  // WEBGL_compressed_texture_s3tc
  const COMPRESSED_RGB_S3TC_DXT1_EXT        = 0x83F0;
  const COMPRESSED_RGBA_S3TC_DXT1_EXT       = 0x83F1;
  const COMPRESSED_RGBA_S3TC_DXT3_EXT       = 0x83F2;
  const COMPRESSED_RGBA_S3TC_DXT5_EXT       = 0x83F3;
  // WEBGL_compressed_texture_etc1
  const COMPRESSED_RGB_ETC1_WEBGL           = 0x8D64;
  // WEBGL_compressed_texture_pvrtc
  const COMPRESSED_RGB_PVRTC_4BPPV1_IMG      = 0x8C00;
  const COMPRESSED_RGB_PVRTC_2BPPV1_IMG      = 0x8C01;
  const COMPRESSED_RGBA_PVRTC_4BPPV1_IMG     = 0x8C02;
  const COMPRESSED_RGBA_PVRTC_2BPPV1_IMG     = 0x8C03;
  // WEBGL_compressed_texture_etc
  const COMPRESSED_R11_EAC                        = 0x9270;
  const COMPRESSED_SIGNED_R11_EAC                 = 0x9271;
  const COMPRESSED_RG11_EAC                       = 0x9272;
  const COMPRESSED_SIGNED_RG11_EAC                = 0x9273;
  const COMPRESSED_RGB8_ETC2                      = 0x9274;
  const COMPRESSED_SRGB8_ETC2                     = 0x9275;
  const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2  = 0x9276;
  const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277;
  const COMPRESSED_RGBA8_ETC2_EAC                 = 0x9278;
  const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC          = 0x9279;
  // WEBGL_compressed_texture_astc
  const COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0;
  const COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1;
  const COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2;
  const COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3;
  const COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4;
  const COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5;
  const COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6;
  const COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7;
  const COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8;
  const COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9;
  const COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA;
  const COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB;
  const COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC;
  const COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD;
  // WEBGL_compressed_texture_s3tc_srgb
  const COMPRESSED_SRGB_S3TC_DXT1_EXT        = 0x8C4C;
  const COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT  = 0x8C4D;
  const COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT  = 0x8C4E;
  const COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT  = 0x8C4F;
  // EXT_texture_compression_bptc
  const COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8E8C;
  const COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 0x8E8D;
  const COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 0x8E8E;
  const COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 0x8E8F;
  // EXT_texture_compression_rgtc
  const COMPRESSED_RED_RGTC1_EXT = 0x8DBB;
  const COMPRESSED_SIGNED_RED_RGTC1_EXT = 0x8DBC;
  const COMPRESSED_RED_GREEN_RGTC2_EXT = 0x8DBD;
  const COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 0x8DBE;

  const compressedTextureFunctions = new Map([
    [ COMPRESSED_RGB_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGBA_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGBA_S3TC_DXT3_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_RGBA_S3TC_DXT5_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],

    [ COMPRESSED_RGB_ETC1_WEBGL, makeComputeBlockRectSizeFunction(4, 4, 8) ],

    [ COMPRESSED_RGB_PVRTC_4BPPV1_IMG, makeComputePaddedRectSizeFunction(8, 8, 2) ],
    [ COMPRESSED_RGBA_PVRTC_4BPPV1_IMG, makeComputePaddedRectSizeFunction(8, 8, 2) ],
    [ COMPRESSED_RGB_PVRTC_2BPPV1_IMG, makeComputePaddedRectSizeFunction(16, 8, 4) ],
    [ COMPRESSED_RGBA_PVRTC_2BPPV1_IMG, makeComputePaddedRectSizeFunction(16, 8, 4) ],

    [ COMPRESSED_R11_EAC, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SIGNED_R11_EAC, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGB8_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB8_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],

    [ COMPRESSED_RG11_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SIGNED_RG11_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_RGBA8_ETC2_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],

    [ COMPRESSED_RGBA_ASTC_4x4_KHR, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_RGBA_ASTC_5x4_KHR, makeComputeBlockRectSizeFunction(5, 4, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR, makeComputeBlockRectSizeFunction(5, 4, 16) ],
    [ COMPRESSED_RGBA_ASTC_5x5_KHR, makeComputeBlockRectSizeFunction(5, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR, makeComputeBlockRectSizeFunction(5, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_6x5_KHR, makeComputeBlockRectSizeFunction(6, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR, makeComputeBlockRectSizeFunction(6, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_6x6_KHR, makeComputeBlockRectSizeFunction(6, 6, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR, makeComputeBlockRectSizeFunction(6, 6, 16) ],
    [ COMPRESSED_RGBA_ASTC_8x5_KHR, makeComputeBlockRectSizeFunction(8, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR, makeComputeBlockRectSizeFunction(8, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_8x6_KHR, makeComputeBlockRectSizeFunction(8, 6, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR, makeComputeBlockRectSizeFunction(8, 6, 16) ],
    [ COMPRESSED_RGBA_ASTC_8x8_KHR, makeComputeBlockRectSizeFunction(8, 8, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR, makeComputeBlockRectSizeFunction(8, 8, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x5_KHR, makeComputeBlockRectSizeFunction(10, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR, makeComputeBlockRectSizeFunction(10, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x6_KHR, makeComputeBlockRectSizeFunction(10, 6, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR, makeComputeBlockRectSizeFunction(10, 6, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x8_KHR, makeComputeBlockRectSizeFunction(10, 8, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR, makeComputeBlockRectSizeFunction(10, 8, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x10_KHR, makeComputeBlockRectSizeFunction(10, 10, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, makeComputeBlockRectSizeFunction(10, 10, 16) ],
    [ COMPRESSED_RGBA_ASTC_12x10_KHR, makeComputeBlockRectSizeFunction(12, 10, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR, makeComputeBlockRectSizeFunction(12, 10, 16) ],
    [ COMPRESSED_RGBA_ASTC_12x12_KHR, makeComputeBlockRectSizeFunction(12, 12, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR, makeComputeBlockRectSizeFunction(12, 12, 16) ],

    [ COMPRESSED_SRGB_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],

    [ COMPRESSED_RGBA_BPTC_UNORM_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],

    [ COMPRESSED_RED_RGTC1_EXT, makeComputeBlockRectSizeFunction( 4, 4, 8 ) ],
    [ COMPRESSED_SIGNED_RED_RGTC1_EXT, makeComputeBlockRectSizeFunction( 4, 4, 8 ) ],
    [ COMPRESSED_RED_GREEN_RGTC2_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
  ]);

  /**
   * Gets the number of bytes per element for a given internalFormat / type
   * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
   * @param {number} type The type parameter for texImage2D etc..
   * @return {number} the number of bytes per element for the given internalFormat, type combo
   * @memberOf module:twgl/textures
   */
  function getBytesPerElementForInternalFormat(internalFormat, type) {
    const info = getTextureInternalFormatInfo(internalFormat);
    if (!info) {
      throw "unknown internal format";
    }
    if (info.type) {
      const ndx = info.type.indexOf(type);
      if (ndx < 0) {
        throw new Error(`unsupported type ${type} for internalformat ${internalFormat}`);
      }
      return info.bytesPerElement[ndx];
    }
    return info.bytesPerElement[0];
  }

  function getBytesForMipUncompressed(internalFormat, width, height, depth, type) {
    const bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);
    return width * height * depth * bytesPerElement;
  }

  function getBytesForMip(internalFormat, width, height, depth, type) {
    const fn = compressedTextureFunctions.get(internalFormat);
    return fn ? fn(width, height, depth) : getBytesForMipUncompressed(internalFormat, width, height, depth, type);
  }

  function isTypedArray(v) {
    return v && v.buffer && v.buffer instanceof ArrayBuffer;
  }

  function isBufferSource(v) {
    return isTypedArray(v) || v instanceof ArrayBuffer;
  }

  function getDrawingbufferInfo(gl) {
    return {
      samples: gl.getParameter(gl.SAMPLES) || 1,
      depthBits: gl.getParameter(gl.DEPTH_BITS),
      stencilBits: gl.getParameter(gl.STENCIL_BITS),
      contextAttributes: gl.getContextAttributes(),
    };
  }

  function computeDepthStencilSize(drawingBufferInfo) {
    const {depthBits, stencilBits} = drawingBufferInfo;
    const depthSize = (depthBits + stencilBits + 7) / 8 | 0;
    return depthSize === 3 ? 4 : depthSize;
  }

  function computeDrawingbufferSize(gl, drawingBufferInfo) {
    if (gl.isContextLost()) {
      return 0;
    }
    const {samples} = drawingBufferInfo;
    // this will need to change for hi-color support
    const colorSize = 4;
    const size = gl.drawingBufferWidth * gl.drawingBufferHeight;
    const depthStencilSize = computeDepthStencilSize(drawingBufferInfo);
    return size * colorSize + size * samples * colorSize + size * depthStencilSize;
  }

  // I know this is not a full check
  function isNumber(v) {
    return typeof v === 'number';
  }

  /*
  The MIT License (MIT)

  Copyright (c) 2021 Gregg Tavares

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Software, and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */

  /* global console */
  /* global WebGL2RenderingContext */
  /* global WebGLUniformLocation */

  //------------ [ from https://github.com/KhronosGroup/WebGLDeveloperTools ]

  /*
  ** Copyright (c) 2012 The Khronos Group Inc.
  **
  ** Permission is hereby granted, free of charge, to any person obtaining a
  ** copy of this software and/or associated documentation files (the
  ** "Materials"), to deal in the Materials without restriction, including
  ** without limitation the rights to use, copy, modify, merge, publish,
  ** distribute, sublicense, and/or sell copies of the Materials, and to
  ** permit persons to whom the Materials are furnished to do so, subject to
  ** the following conditions:
  **
  ** The above copyright notice and this permission notice shall be included
  ** in all copies or substantial portions of the Materials.
  **
  ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
  */


  const augmentedSet = new Set();

  /**
   * Given a WebGL context replaces all the functions with wrapped functions
   * that call gl.getError after every command
   *
   * @param {WebGLRenderingContext|Extension} ctx The webgl context to wrap.
   * @param {string} nameOfClass (eg, webgl, webgl2, OES_texture_float)
   */
  function augmentAPI(ctx, nameOfClass, options = {}) {

    if (augmentedSet.has(ctx)) {
      return ctx;
    }
    augmentedSet.add(ctx);

    const origGLErrorFn = options.origGLErrorFn || ctx.getError;

    function createSharedState(ctx) {
      const drawingBufferInfo = getDrawingbufferInfo(ctx);
      const sharedState = {
        baseContext: ctx,
        config: options,
        apis: {
          // custom extension
          gman_webgl_memory: {
            ctx: {
              getMemoryInfo() {
                const drawingbuffer = computeDrawingbufferSize(ctx, drawingBufferInfo);
                return {
                  memory: {
                    ...memory,
                    drawingbuffer,
                    total: drawingbuffer + memory.buffer + memory.texture + memory.renderbuffer,
                  }, 
                  resources: {
                    ...resources,
                  }
                };
              },
            },
          },
        },
        resources: {},
        memory: {
          texture: 0,
          buffer: 0,
          renderbuffer: 0,
        },
        bindings: new Map(),
        defaultVertexArray: {},
        webglObjectToMemory: new Map(),
      };

      const unRestorableAPIs = new Set([
        'webgl',
        'webgl2',
        'webgl_lose_context',
      ]);

      function resetSharedState() {
        sharedState.bindings.clear();
        sharedState.webglObjectToMemory.clear();
        sharedState.webglObjectToMemory.set(sharedState.defaultVertexArray, {});
        sharedState.currentVertexArray = sharedState.defaultVertexArray;
        [sharedState.resources, sharedState.memory].forEach(function(obj) {
          for (let prop in obj) {
            obj[prop] = 0;
          }
        });
      }

      function handleContextLost() {
        // Issues:
        //   * all resources are lost.
        //     Solution: handled by resetSharedState
        //   * all functions are no-op
        //     Solutions: 
        //        * swap all functions for noop
        //          (not so easy because some functions return values)
        //        * wrap all functions is a isContextLost check forwarder
        //          (slow? and same as above)
        //        * have each function manually check for context lost
        //          (simple but repetitive)
        //   * all extensions are lost
        //      Solution: For these we go through and restore all the functions
        //         on each extension
        resetSharedState();
        sharedState.isContextLost = true;

        // restore all original functions for extensions since
        // user will have to get new extensions.
        for (const [name, {ctx, origFuncs}] of [...Object.entries(sharedState.apis)]) {
          if (!unRestorableAPIs.has(name) && origFuncs) {
            augmentedSet.delete(ctx);
            for (const [funcName, origFn] of Object.entries(origFuncs)) {
              ctx[funcName] = origFn;
            }
            delete apis[name];
          }
        }
      }

      function handleContextRestored() {
        sharedState.isContextLost = false;
      }

      if (ctx.canvas) {
        ctx.canvas.addEventListener('webglcontextlost', handleContextLost);
        ctx.canvas.addEventListener('webglcontextrestored', handleContextRestored);
      }

      resetSharedState();
      return sharedState;
    }

    const sharedState = options.sharedState || createSharedState(ctx);
    options.sharedState = sharedState;

    const {
      apis,
      baseContext,
      bindings,
      config,
      memory,
      resources,
      webglObjectToMemory,
    } = sharedState;

    const origFuncs = {};

    function noop() {
    }

    function makeCreateWrapper(ctx, typeName, _funcName) {
      const funcName = _funcName || `create${typeName[0].toUpperCase()}${typeName.substr(1)}`;
      if (!ctx[funcName]) {
        return;
      }
      resources[typeName] = 0;
      return function(ctx, funcName, args, webglObj) {
        if (sharedState.isContextLost) {
          return null;
        }
        ++resources[typeName];
        webglObjectToMemory.set(webglObj, {
          size: 0,
        });
      };
    }

    function makeDeleteWrapper(typeName, fn = noop, _funcName) {
      const funcName = _funcName || `delete${typeName[0].toUpperCase()}${typeName.substr(1)}`;
      if (!ctx[funcName]) {
        return;
      }
      return function(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [obj] = args;
        const info = webglObjectToMemory.get(obj);
        if (info) {
          --resources[typeName];
          fn(obj, info);
          // TODO: handle resource counts
          webglObjectToMemory.delete(obj);
        }
      };
    }

    function updateRenderbuffer(target, samples, internalFormat, width, height) {
      if (sharedState.isContextLost) {
        return;
      }
      const obj = bindings.get(target);
      if (!obj) {
        throw new Error(`no renderbuffer bound to ${target}`);
      }
      const info = webglObjectToMemory.get(obj);
      if (!info) {
        throw new Error(`unknown renderbuffer ${obj}`);
      }

      const bytesForMip = getBytesForMip(internalFormat, width, height, 1);
      const newSize = bytesForMip * samples;

      memory.renderbuffer -= info.size;
      info.size = newSize;
      memory.renderbuffer += newSize;
    }

    const ELEMENT_ARRAY_BUFFER           = 0x8893;

    const UNSIGNED_BYTE                  = 0x1401;
    const TEXTURE_CUBE_MAP               = 0x8513;
    const TEXTURE_2D_ARRAY               = 0x8C1A;
    const TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
    const TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
    const TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
    const TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
    const TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
    const TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;

    const TEXTURE_BASE_LEVEL             = 0x813C;
    const TEXTURE_MAX_LEVEL              = 0x813D;

    const cubemapTargets = new Set([
      TEXTURE_CUBE_MAP_POSITIVE_X,
      TEXTURE_CUBE_MAP_NEGATIVE_X,
      TEXTURE_CUBE_MAP_POSITIVE_Y,
      TEXTURE_CUBE_MAP_NEGATIVE_Y,
      TEXTURE_CUBE_MAP_POSITIVE_Z,
      TEXTURE_CUBE_MAP_NEGATIVE_Z,
    ]);

    function isCubemapFace(target) {
      return cubemapTargets.has(target);
    }

    function getTextureInfo(target) {
      target = isCubemapFace(target) ? TEXTURE_CUBE_MAP : target;
      const obj = bindings.get(target);
      if (!obj) {
        throw new Error(`no texture bound to ${target}`);
      }
      const info = webglObjectToMemory.get(obj);
      if (!info) {
        throw new Error(`unknown texture ${obj}`);
      }
      return info;
    }

    function updateMipLevel(info, target, level, internalFormat, width, height, depth, type) {
      const oldSize = info.size;
      const newMipSize = getBytesForMip(internalFormat, width, height, depth, type);

      const faceNdx = isCubemapFace(target)
        ? target - TEXTURE_CUBE_MAP_POSITIVE_X
        : 0;

      info.mips = info.mips || [];
      info.mips[level] = info.mips[level] || [];
      const mipFaceInfo = info.mips[level][faceNdx] || {};
      info.size -= mipFaceInfo.size || 0;

      mipFaceInfo.size = newMipSize;
      mipFaceInfo.internalFormat = internalFormat;
      mipFaceInfo.type = type;
      mipFaceInfo.width = width;
      mipFaceInfo.height = height;
      mipFaceInfo.depth = depth;

      info.mips[level][faceNdx] = mipFaceInfo;
      info.size += newMipSize;

      memory.texture -= oldSize;
      memory.texture += info.size;
    }

    function updateTexStorage(target, levels, internalFormat, width, height, depth) {
      const info = getTextureInfo(target);
      const numFaces = target === TEXTURE_CUBE_MAP ? 6 : 1;
      const baseFaceTarget = target === TEXTURE_CUBE_MAP ? TEXTURE_CUBE_MAP_POSITIVE_X : target;    for (let level = 0; level < levels; ++level) {
        for (let face = 0; face < numFaces; ++face) {
          updateMipLevel(info, baseFaceTarget + face, level, internalFormat, width, height, depth);
        }
        width = Math.ceil(Math.max(width / 2, 1));
        height = Math.ceil(Math.max(height / 2, 1));
        depth = target === TEXTURE_2D_ARRAY ? depth : Math.ceil(Math.max(depth / 2, 1));
      }
    }

    function handleBindVertexArray(gl, funcName, args) {
      if (sharedState.isContextLost) {
        return;
      }
      const [va] = args;
      sharedState.currentVertexArray = va ? va : sharedState.defaultVertexArray;
    }

    function handleBufferBinding(target, obj) {
      if (sharedState.isContextLost) {
        return;
      }
      switch (target) {
        case ELEMENT_ARRAY_BUFFER:
          const info = webglObjectToMemory.get(sharedState.currentVertexArray);
          info.elementArrayBuffer = obj;
          break;
        default:
          bindings.set(target, obj);
          break;
      }
    }

    const preChecks = {};
    const postChecks = {
      // WebGL1
      //   void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
      //   void bufferData(GLenum target, [AllowShared] BufferSource? srcData, GLenum usage);
      // WebGL2:
      //   void bufferData(GLenum target, [AllowShared] ArrayBufferView srcData, GLenum usage, GLuint srcOffset,
      //                   optional GLuint length = 0);
      bufferData(gl, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, src, /* usage */, srcOffset = 0, length = undefined] = args;
        let obj;
        switch (target) {
          case ELEMENT_ARRAY_BUFFER:
            {
              const info = webglObjectToMemory.get(sharedState.currentVertexArray);
              obj = info.elementArrayBuffer;
            }
            break;
          default:
            obj = bindings.get(target);
            break;
        }
        if (!obj) {
          throw new Error(`no buffer bound to ${target}`);
        }
        let newSize = 0;
        if (length !== undefined) {
          newSize = length * src.BYTES_PER_ELEMENT;
        } else if (isBufferSource(src)) {
          newSize = src.byteLength;
        } else if (isNumber(src)) {
          newSize = src;
        } else {
          throw new Error(`unsupported bufferData src type ${src}`);
        }

        const info = webglObjectToMemory.get(obj);
        if (!info) {
          throw new Error(`unknown buffer ${obj}`);
        }

        memory.buffer -= info.size;
        info.size = newSize;
        memory.buffer += newSize;
      },

      bindVertexArray: handleBindVertexArray,
      bindVertexArrayOES: handleBindVertexArray,

      bindBuffer(gl, funcName, args) {
        const [target, obj] = args;
        handleBufferBinding(target, obj);
      },

      bindBufferBase(gl, funcName, args) {
        const [target, ndx, obj] = args;
        handleBufferBinding(target, obj);
      },

      bindBufferRange(gl, funcName, args) {
        const [target, ndx, obj, offset, size] = args;
        handleBufferBinding(target, obj);
      },

      bindRenderbuffer(gl, funcName, args) {
        if (sharedState.isContextLost) {
         return;
        }
        const [target, obj] = args;
        bindings.set(target, obj);
      },

      bindTexture(gl, funcName, args) {
        if (sharedState.isContextLost) {
         return;
        }
        const [target, obj] = args;
        bindings.set(target, obj);
      },

      // void gl.copyTexImage2D(target, level, internalformat, x, y, width, height, border);
      copyTexImage2D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, x, y, width, height, border] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, 1, UNSIGNED_BYTE);
      },

      createBuffer: makeCreateWrapper(ctx, 'buffer'),
      createFramebuffer: makeCreateWrapper(ctx, 'framebuffer'),
      createRenderbuffer: makeCreateWrapper(ctx, 'renderbuffer'),
      createProgram: makeCreateWrapper(ctx, 'program'),
      createQuery: makeCreateWrapper(ctx, 'query'),
      createShader: makeCreateWrapper(ctx, 'shader'),
      createSampler: makeCreateWrapper(ctx, 'sampler'),
      createTexture: makeCreateWrapper(ctx, 'texture'),
      createTransformFeedback: makeCreateWrapper(ctx, 'transformFeedback'),
      createVertexArray: makeCreateWrapper(ctx, 'vertexArray'),
      createVertexArrayOES: makeCreateWrapper(ctx, 'vertexArray', 'createVertexArrayOES'),

      // WebGL 1:
      // void gl.compressedTexImage2D(target, level, internalformat, width, height, border, ArrayBufferView? pixels);
      //
      // Additionally available in WebGL 2:
      // read from buffer bound to gl.PIXEL_UNPACK_BUFFER
      // void gl.compressedTexImage2D(target, level, internalformat, width, height, border, GLsizei imageSize, GLintptr offset);
      // void gl.compressedTexImage2D(target, level, internalformat, width, height, border,
      //                              ArrayBufferView srcData, optional srcOffset, optional srcLengthOverride);
      compressedTexImage2D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, width, height] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, 1, UNSIGNED_BYTE);
      },

      // read from buffer bound to gl.PIXEL_UNPACK_BUFFER
      // void gl.compressedTexImage3D(target, level, internalformat, width, height, depth, border, GLsizei imageSize, GLintptr offset);
      // void gl.compressedTexImage3D(target, level, internalformat, width, height, depth, border,
      //                              ArrayBufferView srcData, optional srcOffset, optional srcLengthOverride);
      compressedTexImage3D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, width, height, depth] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, depth, UNSIGNED_BYTE);
      },

      deleteBuffer: makeDeleteWrapper('buffer', function(obj, info) {
        memory.buffer -= info.size;
      }),
      deleteFramebuffer: makeDeleteWrapper('framebuffer'),
      deleteProgram: makeDeleteWrapper('program'),
      deleteQuery: makeDeleteWrapper('query'),
      deleteRenderbuffer: makeDeleteWrapper('renderbuffer', function(obj, info) {
        memory.renderbuffer -= info.size;
      }),
      deleteSampler: makeDeleteWrapper('sampler'),
      deleteShader: makeDeleteWrapper('shader'),
      deleteSync: makeDeleteWrapper('sync'),
      deleteTexture: makeDeleteWrapper('texture', function(obj, info) {
        memory.texture -= info.size;
      }),
      deleteTransformFeedback: makeDeleteWrapper('transformFeedback'),
      deleteVertexArray: makeDeleteWrapper('vertexArray'),
      deleteVertexArrayOES: makeDeleteWrapper('vertexArray', noop, 'deleteVertexArrayOES'),

      fenceSync: function(ctx) {
        if (sharedState.isContextLost) {
          return;
        }
        if (!ctx.fenceSync) {
          return;
        }
        resources.sync = 0;
        return function(ctx, funcName, args, webglObj) {
          ++resources.sync;

          webglObjectToMemory.set(webglObj, {
            size: 0,
          });
        };
      }(ctx),

      generateMipmap(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target] = args;
        const info = getTextureInfo(target);
        const baseMipNdx = info.parameters ? info.parameters.get(TEXTURE_BASE_LEVEL) || 0 : 0;
        const maxMipNdx = info.parameters ? info.parameters.get(TEXTURE_MAX_LEVEL) || 1024 : 1024;
        let {width, height, depth, internalFormat, type} = info.mips[baseMipNdx][0];
        let level = baseMipNdx + 1;

        const numFaces = target === TEXTURE_CUBE_MAP ? 6 : 1;
        const baseFaceTarget = target === TEXTURE_CUBE_MAP ? TEXTURE_CUBE_MAP_POSITIVE_X : target;      while (level <= maxMipNdx && !(width === 1 && height === 1 && (depth === 1 || target === TEXTURE_2D_ARRAY))) {
          width = Math.ceil(Math.max(width / 2, 1));
          height = Math.ceil(Math.max(height / 2, 1));
          depth = target === TEXTURE_2D_ARRAY ? depth : Math.ceil(Math.max(depth / 2, 1));
          for (let face = 0; face < numFaces; ++face) {
            updateMipLevel(info, baseFaceTarget + face, level, internalFormat, width, height, depth, type);
          }
          ++level;
        }
      },

      getSupportedExtensions(ctx, funcName, args, result) {
        if (sharedState.isContextLost) {
          return;
        }
        result.push('GMAN_webgl_memory');
      },

      // void gl.renderbufferStorage(target, internalFormat, width, height);
      // gl.RGBA4: 4 red bits, 4 green bits, 4 blue bits 4 alpha bits.
      // gl.RGB565: 5 red bits, 6 green bits, 5 blue bits.
      // gl.RGB5_A1: 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.
      // gl.DEPTH_COMPONENT16: 16 depth bits.
      // gl.STENCIL_INDEX8: 8 stencil bits.
      // gl.DEPTH_STENCIL
      renderbufferStorage(ctx, funcName, args) {
        const [target, internalFormat, width, height] = args;
        updateRenderbuffer(target, 1, internalFormat, width, height);
      },

      // void gl.renderbufferStorageMultisample(target, samples, internalFormat, width, height);
      renderbufferStorageMultisample(ctx, funcName, args) {
        const [target, samples, internalFormat, width, height] = args;
        updateRenderbuffer(target, samples, internalFormat, width, height);
      },

      texImage2D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        // WebGL1:
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ArrayBufferView? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, ImageData? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, HTMLImageElement? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, HTMLCanvasElement? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, HTMLVideoElement? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, ImageBitmap? pixels// );

        // WebGL2:
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, GLintptr offset);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, HTMLCanvasElement source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, HTMLImageElement source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, HTMLVideoElement source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ImageBitmap source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ImageData source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ArrayBufferView srcData, srcOffset);
        let [target, level, internalFormat] = args;
        let width;
        let height;
        let type;
        if (args.length == 6) {
          const src = args[5];
          width = src.width;
          height = src.height;
          type = args[4];
        } else {
          width = args[3];
          height = args[4];
          type = args[7];
        }

        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, 1, type);
      },

      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, GLintptr offset);
      //
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, HTMLCanvasElement source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, HTMLImageElement source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, HTMLVideoElement source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ImageBitmap source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ImageData source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ArrayBufferView? srcData);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ArrayBufferView srcData, srcOffset);

      texImage3D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        let [target, level, internalFormat, width, height, depth, border, format, type] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, depth, type);
      },

      texParameteri(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        let [target, pname, value] = args;
        const info = getTextureInfo(target);
        info.parameters = info.parameters || new Map();
        info.parameters.set(pname, value);
      },

      // void gl.texStorage2D(target, levels, internalformat, width, height);
      texStorage2D(ctx, funcName, args) {
        let [target, levels, internalFormat, width, height] = args;
        updateTexStorage(target, levels, internalFormat, width, height, 1);
      },

      // void gl.texStorage3D(target, levels, internalformat, width, height, depth);
      texStorage3D(ctx, funcName, args) {
        let [target, levels, internalFormat, width, height, depth] = args;
        updateTexStorage(target, levels, internalFormat, width, height, depth);
      },
    };

    const extraWrappers = {
      getExtension(ctx, propertyName) {
        if (sharedState.isContextLost) {
          return null;
        }
        const origFn = ctx[propertyName];
        ctx[propertyName] = function(...args) {
          const extensionName = args[0].toLowerCase();
          const api = apis[extensionName];
          if (api) {
            return api.ctx;
          }
          const ext = origFn.call(ctx, ...args);
          if (ext) {
            augmentAPI(ext, extensionName, {...options, origGLErrorFn});
          }
          return ext;
        };
      },
    };

    // Makes a function that calls a WebGL function and then calls getError.
    function makeErrorWrapper(ctx, funcName) {
      const origFn = ctx[funcName];
      const preCheck = preChecks[funcName] || noop;
      const postCheck = postChecks[funcName] || noop;
      if (preCheck === noop && postChecks === noop) {
        return;
      }
      ctx[funcName] = function(...args) {
        preCheck(ctx, funcName, args);
        const result = origFn.call(ctx, ...args);
        postCheck(ctx, funcName, args, result);
        return result;
      };
      const extraWrapperFn = extraWrappers[funcName];
      if (extraWrapperFn) {
        extraWrapperFn(ctx, funcName, origGLErrorFn);
      }
    }

    // Wrap each function
    for (const propertyName in ctx) {
      if (typeof ctx[propertyName] === 'function') {
        origFuncs[propertyName] = ctx[propertyName];
        makeErrorWrapper(ctx, propertyName);
      }
    }

    apis[nameOfClass.toLowerCase()] = { ctx, origFuncs };
  }

  /*
  The MIT License (MIT)

  Copyright (c) 2021 Gregg Tavares

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Software, and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */

  /* global console */
  /* global document */
  /* global HTMLCanvasElement */
  /* global OffscreenCanvas */

  function wrapGetContext(Ctor) {
    const oldFn = Ctor.prototype.getContext;
    Ctor.prototype.getContext = function(type, ...args) {
      const ctx = oldFn.call(this, type, ...args);
      // Using bindTexture to see if it's WebGL. Could check for instanceof WebGLRenderingContext
      // but that might fail if wrapped by debugging extension
      if (ctx && ctx.bindTexture) {
        const config = {};
        augmentAPI(ctx, type, config);
        ctx.getExtension('GMAN_webgl_memory');
      }
      return ctx;
    };
  }

  if (typeof HTMLCanvasElement !== 'undefined') {
    wrapGetContext(HTMLCanvasElement);
  }
  if (typeof OffscreenCanvas !== 'undefined') {
    wrapGetContext(OffscreenCanvas);
  }

})));

class Stats {

    constructor ( renderer ) {

    	this.renderer = renderer;
    	this.memo = this.renderer.getContext().getExtension('GMAN_webgl_memory');
		
    }

    get(){

    	const info = this.memo.getMemoryInfo();
	    const eng = this.renderer.info;

	    info['engine'] = {

	    	geometries : eng.memory.geometries,
			textures : eng.memory.textures,

		    calls : eng.render.calls,
			triangles : eng.render.triangles,
			points : eng.render.points,
			lines : eng.render.lines,
			//frame : eng.render.frame,

	    };

	    // can't remove background geometry !!
	    if( info.engine.geometries === 1 ) info.engine.geometries = 0;

	    return this.format( info )

    }

    format( t ){

    	let txt = t;

        if( t!=='' ){

            for( let j in t.memory ){
                //t.memory[j] = Math.round( t.memory[j]*0.000976563 )

                if( j === 'drawingbuffer' || j === 'total' ) t.memory[j] = Math.round( t.memory[j]*0.000001 ) + ' Mb';
                else t.memory[j] = Math.round( t.memory[j]*0.001 ) + ' Kb';

                //if( j === 'drawingbuffer' || j === 'total' ) t.memory[j] = Math.round( (t.memory[j]*0.000001 )/8) + ' Mo'
                //else t.memory[j] = Math.round( (t.memory[j]*0.001)/8 ) + ' Ko'

                //t.memory[j] = Math.round( t.memory[j] / 1024/ 1024 )
            }

            txt = JSON.stringify(t, null, 2);
            txt = txt.replace(/[",.*+?^${}()|[\]\\]/g, '');

        }

        return txt

    }

}

function e(e,t,n,r){return new(n||(n=Promise))((function(o,a){function i(e){try{d(r.next(e));}catch(e){a(e);}}function c(e){try{d(r.throw(e));}catch(e){a(e);}}function d(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t);}))).then(i,c);}d((r=r.apply(e,t||[])).next());}))}const t$1=["geforce 320m","geforce 8600","geforce 8600m gt","geforce 8800 gs","geforce 8800 gt","geforce 9400","geforce 9400m g","geforce 9400m","geforce 9600m gt","geforce 9600m","geforce fx go5200","geforce gt 120","geforce gt 130","geforce gt 330m","geforce gtx 285","google swiftshader","intel g41","intel g45","intel gma 4500mhd","intel gma x3100","intel hd 3000","intel q45","legacy","mali-2","mali-3","mali-4","quadro fx 1500","quadro fx 4","quadro fx 5","radeon hd 2400","radeon hd 2600","radeon hd 4670","radeon hd 4850","radeon hd 4870","radeon hd 5670","radeon hd 5750","radeon hd 6290","radeon hd 6300","radeon hd 6310","radeon hd 6320","radeon hd 6490m","radeon hd 6630m","radeon hd 6750m","radeon hd 6770m","radeon hd 6970m","sgx 543","sgx543"];function n(e){return e=e.toLowerCase().replace(/.*angle ?\((.+)\)(?: on vulkan [0-9.]+)?$/i,"$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g,"").replace(/(?:vulkan|opengl) \d+\.\d+(?:\.\d+)?(?: \((.*)\))?/,"$1")}const r=16384,o=4,a=35044,i$2=34962,c=5121,d=5126,l=6408,s=35632,f=35633,u="undefined"==typeof window,h$1=(()=>{if(u)return;const{userAgent:e,platform:t,maxTouchPoints:n}=window.navigator,r=/(iphone|ipod|ipad)/i.test(e),o="iPad"===t||"MacIntel"===t&&n>0&&!window.MSStream;return {isIpad:o,isMobile:/android/i.test(e)||r||o,isSafari12:/Version\/12.+Safari/.test(e)}})();function g(e,t,n){if(!n)return [t];const u=function(e){const t="\n    precision highp float;\n    attribute vec3 aPosition;\n    varying float vvv;\n    void main() {\n      vvv = 0.31622776601683794;\n      gl_Position = vec4(aPosition, 1.0);\n    }\n  ",n="\n    precision highp float;\n    varying float vvv;\n    void main() {\n      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n      enc = fract(enc);\n      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n      gl_FragColor = enc;\n    }\n  ",u=e.createShader(f),h=e.createShader(s),g=e.createProgram();if(!(h&&u&&g))return;e.shaderSource(u,t),e.shaderSource(h,n),e.compileShader(u),e.compileShader(h),e.attachShader(g,u),e.attachShader(g,h),e.linkProgram(g),e.detachShader(g,u),e.detachShader(g,h),e.deleteShader(u),e.deleteShader(h),e.useProgram(g);const p=e.createBuffer();e.bindBuffer(i$2,p),e.bufferData(i$2,new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),a);const m=e.getAttribLocation(g,"aPosition");e.vertexAttribPointer(m,3,d,!1,0,0),e.enableVertexAttribArray(m),e.clearColor(1,1,1,1),e.clear(r),e.viewport(0,0,1,1),e.drawArrays(o,0,3);const v=new Uint8Array(4);return e.readPixels(0,0,1,1,l,c,v),e.deleteProgram(g),e.deleteBuffer(p),v.join("")}(e),g="801621810",p="8016218135",m="80162181161",v=(null==h$1?void 0:h$1.isIpad)?[["a7",m,12],["a8",p,15],["a8x",p,15],["a9",p,15],["a9x",p,15],["a10",p,15],["a10x",p,15],["a12",g,15],["a12x",g,15],["a12z",g,15],["a14",g,15],["m1",g,15]]:[["a7",m,12],["a8",p,12],["a9",p,15],["a10",p,15],["a11",g,15],["a12",g,15],["a13",g,15],["a14",g,15]];let w;"80162181255"===u?w=v.filter((([,,e])=>e>=14)):(w=v.filter((([,e])=>e===u)),w.length||(w=v));return w.map((([e])=>`apple ${e} gpu`))}class p extends Error{constructor(e){super(e),Object.setPrototypeOf(this,new.target.prototype);}}const m=[],v=[];function w$1(e,t){if(e===t)return 0;const n=e;e.length>t.length&&(e=t,t=n);let r=e.length,o=t.length;for(;r>0&&e.charCodeAt(~-r)===t.charCodeAt(~-o);)r--,o--;let a,i=0;for(;i<r&&e.charCodeAt(i)===t.charCodeAt(i);)i++;if(r-=i,o-=i,0===r)return o;let c,d,l=0,s=0,f=0;for(;s<r;)v[s]=e.charCodeAt(i+s),m[s]=++s;for(;f<o;)for(a=t.charCodeAt(i+f),c=f++,l=f,s=0;s<r;s++)d=a===v[s]?c:c+1,c=m[s],l=m[s]=c>l?d>l?l+1:d:d>c?c+1:d;return l}function x$1(e){return null!=e}const A$1=({mobileTiers:r=[0,15,30,60],desktopTiers:o=[0,15,30,60],override:a={},glContext:i,failIfMajorPerformanceCaveat:c=!1,benchmarksURL:d="https://unpkg.com/detect-gpu@5.0.15/dist/benchmarks"}={})=>e(void 0,void 0,void 0,(function*(){const l={};if(u)return {tier:0,type:"SSR"};const{isIpad:s=!!(null==h$1?void 0:h$1.isIpad),isMobile:f=!!(null==h$1?void 0:h$1.isMobile),screenSize:m=window.screen,loadBenchmarks:v=(t=>e(void 0,void 0,void 0,(function*(){const e=yield fetch(`${d}/${t}`).then((e=>e.json()));if(parseInt(e.shift().split(".")[0],10)<4)throw new p("Detect GPU benchmark data is out of date. Please update to version 4x");return e})))}=a;let{renderer:A}=a;const P=e=>{const t=f?["adreno","apple","mali-t","mali","nvidia","powervr","samsung"]:["intel","apple","amd","radeon","nvidia","geforce"];for(const n of t)if(e.includes(n))return n};const b=(e,t,n,r,o)=>({device:o,fps:r,gpu:n,isMobile:f,tier:e,type:t});let S,y="";if(A)A=n(A),S=[A];else {const e=i||function(e,t=!1){const n={alpha:!1,antialias:!1,depth:!1,failIfMajorPerformanceCaveat:t,powerPreference:"high-performance",stencil:!1};e&&delete n.powerPreference;const r=window.document.createElement("canvas"),o=r.getContext("webgl",n)||r.getContext("experimental-webgl",n);return null!=o?o:void 0}(null==h$1?void 0:h$1.isSafari12,c);if(!e)return b(0,"WEBGL_UNSUPPORTED");const t=e.getExtension("WEBGL_debug_renderer_info");if(t&&(A=e.getParameter(t.UNMASKED_RENDERER_WEBGL)),!A)return b(1,"FALLBACK");y=A,A=n(A),S=function(e,t,n){return "apple gpu"===t?g(e,t,n):[t]}(e,A,f);}const C=(yield Promise.all(S.map((function(t){var n;return e(this,void 0,void 0,(function*(){const e=P(t);if(!e)return;const r=`${f?"m":"d"}-${e}${s?"-ipad":""}.json`,o=l[r]=null!==(n=l[r])&&void 0!==n?n:v(r);let a;try{a=yield o;}catch(e){if(e instanceof p)throw e;return}const i=function(e){var t;const n=(e=e.replace(/\([^)]+\)/,"")).match(/\d+/)||e.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);return null!==(t=null==n?void 0:n.join("").replace(/\W|amd/g,""))&&void 0!==t?t:""}(t);let c=a.filter((([,e])=>e===i));c.length||(c=a.filter((([e])=>e.includes(t))));const d=c.length;if(0===d)return;const u=t.split(/[.,()\[\]/\s]/g).sort().filter(((e,t,n)=>0===t||e!==n[t-1])).join(" ");let h,[g,,,,x]=d>1?c.map((e=>[e,w$1(u,e[2])])).sort((([,e],[,t])=>e-t))[0][0]:c[0],A=Number.MAX_VALUE;const{devicePixelRatio:b}=window,S=m.width*b*m.height*b;for(const e of x){const[t,n]=e,r=t*n,o=Math.abs(S-r);o<A&&(A=o,h=e);}if(!h)return;const[,,y,C]=h;return [A,y,g,C]}))})))).filter(x$1).sort((([e=Number.MAX_VALUE,t],[n=Number.MAX_VALUE,r])=>e===n?t-r:e-n));if(!C.length){const e=t$1.find((e=>A.includes(e)));return e?b(0,"BLOCKLISTED",e):b(1,"FALLBACK",`${A} (${y})`)}const[,E,L,M]=C[0];if(-1===E)return b(0,"BLOCKLISTED",L,E,M);const $=f?r:o;let B=0;for(let e=0;e<$.length;e++)E>=$[e]&&(B=e);return b(B,"BENCHMARK",L,E,M)}));

/**
 * The Ease class provides a collection of easing functions for use with tween.js.
 */
var Easing = {
    Linear: {
        None: function (amount) {
            return amount;
        },
    },
    Quadratic: {
        In: function (amount) {
            return amount * amount;
        },
        Out: function (amount) {
            return amount * (2 - amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount;
            }
            return -0.5 * (--amount * (amount - 2) - 1);
        },
    },
    Cubic: {
        In: function (amount) {
            return amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount + 2);
        },
    },
    Quartic: {
        In: function (amount) {
            return amount * amount * amount * amount;
        },
        Out: function (amount) {
            return 1 - --amount * amount * amount * amount;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount;
            }
            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
        },
    },
    Quintic: {
        In: function (amount) {
            return amount * amount * amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
        },
    },
    Sinusoidal: {
        In: function (amount) {
            return 1 - Math.cos((amount * Math.PI) / 2);
        },
        Out: function (amount) {
            return Math.sin((amount * Math.PI) / 2);
        },
        InOut: function (amount) {
            return 0.5 * (1 - Math.cos(Math.PI * amount));
        },
    },
    Exponential: {
        In: function (amount) {
            return amount === 0 ? 0 : Math.pow(1024, amount - 1);
        },
        Out: function (amount) {
            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            if ((amount *= 2) < 1) {
                return 0.5 * Math.pow(1024, amount - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
        },
    },
    Circular: {
        In: function (amount) {
            return 1 - Math.sqrt(1 - amount * amount);
        },
        Out: function (amount) {
            return Math.sqrt(1 - --amount * amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
        },
    },
    Elastic: {
        In: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        },
        Out: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            amount *= 2;
            if (amount < 1) {
                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
        },
    },
    Back: {
        In: function (amount) {
            var s = 1.70158;
            return amount * amount * ((s + 1) * amount - s);
        },
        Out: function (amount) {
            var s = 1.70158;
            return --amount * amount * ((s + 1) * amount + s) + 1;
        },
        InOut: function (amount) {
            var s = 1.70158 * 1.525;
            if ((amount *= 2) < 1) {
                return 0.5 * (amount * amount * ((s + 1) * amount - s));
            }
            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
        },
    },
    Bounce: {
        In: function (amount) {
            return 1 - Easing.Bounce.Out(1 - amount);
        },
        Out: function (amount) {
            if (amount < 1 / 2.75) {
                return 7.5625 * amount * amount;
            }
            else if (amount < 2 / 2.75) {
                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
            }
            else if (amount < 2.5 / 2.75) {
                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
            }
            else {
                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
            }
        },
        InOut: function (amount) {
            if (amount < 0.5) {
                return Easing.Bounce.In(amount * 2) * 0.5;
            }
            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
        },
    },
};

var now;
// Include a performance.now polyfill.
// In node.js, use process.hrtime.
// eslint-disable-next-line
// @ts-ignore
if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
    now = function () {
        // eslint-disable-next-line
        // @ts-ignore
        var time = process.hrtime();
        // Convert [seconds, nanoseconds] to milliseconds.
        return time[0] * 1000 + time[1] / 1000000;
    };
}
// In a browser, use self.performance.now if it is available.
else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
    // This must be bound, because directly assigning this function
    // leads to an invocation exception in Chrome.
    now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
    now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
    now = function () {
        return new Date().getTime();
    };
}
var now$1 = now;

/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tween
 */
var Group = /** @class */ (function () {
    function Group() {
        this._tweens = {};
        this._tweensAddedDuringUpdate = {};
    }
    Group.prototype.getAll = function () {
        var _this = this;
        return Object.keys(this._tweens).map(function (tweenId) {
            return _this._tweens[tweenId];
        });
    };
    Group.prototype.removeAll = function () {
        this._tweens = {};
    };
    Group.prototype.add = function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group.prototype.remove = function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group.prototype.update = function (time, preserve) {
        if (time === void 0) { time = now$1(); }
        if (preserve === void 0) { preserve = false; }
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        // Tweens are updated in "batches". If you add a new tween during an
        // update, then the new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated.
        // However, if the removed tween was added during the current batch,
        // then it will not be updated.
        while (tweenIds.length > 0) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                var autoStart = !preserve;
                if (tween && tween.update(time, autoStart) === false && !preserve) {
                    delete this._tweens[tweenIds[i]];
                }
            }
            tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
        return true;
    };
    return Group;
}());

/**
 *
 */
var Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function (v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = Interpolation.Utils.Bernstein;
        for (var i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
    },
    CatmullRom: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0) {
                i = Math.floor((f = m * (1 + k)));
            }
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        }
        else {
            if (k < 0) {
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            }
            if (k > 1) {
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            }
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function (n, i) {
            var fc = Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: (function () {
            var a = [1];
            return function (n) {
                var s = 1;
                if (a[n]) {
                    return a[n];
                }
                for (var i = n; i > 1; i--) {
                    s *= i;
                }
                a[n] = s;
                return s;
            };
        })(),
        CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
    },
};

/**
 * Utils
 */
var Sequence = /** @class */ (function () {
    function Sequence() {
    }
    Sequence.nextId = function () {
        return Sequence._nextId++;
    };
    Sequence._nextId = 0;
    return Sequence;
}());

var mainGroup = new Group();

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var Tween = /** @class */ (function () {
    function Tween(_object, _group) {
        if (_group === void 0) { _group = mainGroup; }
        this._object = _object;
        this._group = _group;
        this._isPaused = false;
        this._pauseStart = 0;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._initialRepeat = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._isPlaying = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = 0;
        this._easingFunction = Easing.Linear.None;
        this._interpolationFunction = Interpolation.Linear;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._id = Sequence.nextId();
        this._isChainStopped = false;
        this._goToEnd = false;
    }
    Tween.prototype.getId = function () {
        return this._id;
    };
    Tween.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    Tween.prototype.isPaused = function () {
        return this._isPaused;
    };
    Tween.prototype.to = function (properties, duration) {
        // TODO? restore this, then update the 07_dynamic_to example to set fox
        // tween's to on each update. That way the behavior is opt-in (there's
        // currently no opt-out).
        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
        this._valuesEnd = Object.create(properties);
        if (duration !== undefined) {
            this._duration = duration;
        }
        return this;
    };
    Tween.prototype.duration = function (d) {
        this._duration = d;
        return this;
    };
    Tween.prototype.start = function (time) {
        if (this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.add(this);
        this._repeat = this._initialRepeat;
        if (this._reversed) {
            // If we were reversed (f.e. using the yoyo feature) then we need to
            // flip the tween direction back to forward.
            this._reversed = false;
            for (var property in this._valuesStartRepeat) {
                this._swapEndStartRepeatValues(property);
                this._valuesStart[property] = this._valuesStartRepeat[property];
            }
        }
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._isChainStopped = false;
        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();
        this._startTime += this._delayTime;
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
        return this;
    };
    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
        for (var property in _valuesEnd) {
            var startValue = _object[property];
            var startValueIsArray = Array.isArray(startValue);
            var propType = startValueIsArray ? 'array' : typeof startValue;
            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
            // If `to()` specifies a property that doesn't exist in the source object,
            // we should not set that property in the object
            if (propType === 'undefined' || propType === 'function') {
                continue;
            }
            // Check if an Array was provided as property value
            if (isInterpolationList) {
                var endValues = _valuesEnd[property];
                if (endValues.length === 0) {
                    continue;
                }
                // handle an array of relative values
                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                // Create a local copy of the Array with the start value at the front
                _valuesEnd[property] = [startValue].concat(endValues);
            }
            // handle the deepness of the values
            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                _valuesStart[property] = startValueIsArray ? [] : {};
                // eslint-disable-next-line
                for (var prop in startValue) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property][prop] = startValue[prop];
                }
                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
            }
            else {
                // Save the starting value, but only once.
                if (typeof _valuesStart[property] === 'undefined') {
                    _valuesStart[property] = startValue;
                }
                if (!startValueIsArray) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                }
                if (isInterpolationList) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                }
                else {
                    _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
            }
        }
    };
    Tween.prototype.stop = function () {
        if (!this._isChainStopped) {
            this._isChainStopped = true;
            this.stopChainedTweens();
        }
        if (!this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback) {
            this._onStopCallback(this._object);
        }
        return this;
    };
    Tween.prototype.end = function () {
        this._goToEnd = true;
        this.update(Infinity);
        return this;
    };
    Tween.prototype.pause = function (time) {
        if (time === void 0) { time = now$1(); }
        if (this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = true;
        this._pauseStart = time;
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        return this;
    };
    Tween.prototype.resume = function (time) {
        if (time === void 0) { time = now$1(); }
        if (!this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = false;
        this._startTime += time - this._pauseStart;
        this._pauseStart = 0;
        // eslint-disable-next-line
        this._group && this._group.add(this);
        return this;
    };
    Tween.prototype.stopChainedTweens = function () {
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].stop();
        }
        return this;
    };
    Tween.prototype.group = function (group) {
        this._group = group;
        return this;
    };
    Tween.prototype.delay = function (amount) {
        this._delayTime = amount;
        return this;
    };
    Tween.prototype.repeat = function (times) {
        this._initialRepeat = times;
        this._repeat = times;
        return this;
    };
    Tween.prototype.repeatDelay = function (amount) {
        this._repeatDelayTime = amount;
        return this;
    };
    Tween.prototype.yoyo = function (yoyo) {
        this._yoyo = yoyo;
        return this;
    };
    Tween.prototype.easing = function (easingFunction) {
        this._easingFunction = easingFunction;
        return this;
    };
    Tween.prototype.interpolation = function (interpolationFunction) {
        this._interpolationFunction = interpolationFunction;
        return this;
    };
    Tween.prototype.chain = function () {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tweens[_i] = arguments[_i];
        }
        this._chainedTweens = tweens;
        return this;
    };
    Tween.prototype.onStart = function (callback) {
        this._onStartCallback = callback;
        return this;
    };
    Tween.prototype.onUpdate = function (callback) {
        this._onUpdateCallback = callback;
        return this;
    };
    Tween.prototype.onRepeat = function (callback) {
        this._onRepeatCallback = callback;
        return this;
    };
    Tween.prototype.onComplete = function (callback) {
        this._onCompleteCallback = callback;
        return this;
    };
    Tween.prototype.onStop = function (callback) {
        this._onStopCallback = callback;
        return this;
    };
    /**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */
    Tween.prototype.update = function (time, autoStart) {
        if (time === void 0) { time = now$1(); }
        if (autoStart === void 0) { autoStart = true; }
        if (this._isPaused)
            return true;
        var property;
        var elapsed;
        var endTime = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
            if (time > endTime)
                return false;
            if (autoStart)
                this.start(time);
        }
        this._goToEnd = false;
        if (time < this._startTime) {
            return true;
        }
        if (this._onStartCallbackFired === false) {
            if (this._onStartCallback) {
                this._onStartCallback(this._object);
            }
            this._onStartCallbackFired = true;
        }
        elapsed = (time - this._startTime) / this._duration;
        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
        var value = this._easingFunction(elapsed);
        // properties transformations
        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
        if (this._onUpdateCallback) {
            this._onUpdateCallback(this._object, elapsed);
        }
        if (elapsed === 1) {
            if (this._repeat > 0) {
                if (isFinite(this._repeat)) {
                    this._repeat--;
                }
                // Reassign starting values, restart by making startTime = now
                for (property in this._valuesStartRepeat) {
                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                        this._valuesStartRepeat[property] =
                            // eslint-disable-next-line
                            // @ts-ignore FIXME?
                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                    }
                    if (this._yoyo) {
                        this._swapEndStartRepeatValues(property);
                    }
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
                if (this._yoyo) {
                    this._reversed = !this._reversed;
                }
                if (this._repeatDelayTime !== undefined) {
                    this._startTime = time + this._repeatDelayTime;
                }
                else {
                    this._startTime = time + this._delayTime;
                }
                if (this._onRepeatCallback) {
                    this._onRepeatCallback(this._object);
                }
                return true;
            }
            else {
                if (this._onCompleteCallback) {
                    this._onCompleteCallback(this._object);
                }
                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                    // Make the chained tweens start exactly at the time they should,
                    // even if the `update()` method was called way past the duration of the tween
                    this._chainedTweens[i].start(this._startTime + this._duration);
                }
                this._isPlaying = false;
                return false;
            }
        }
        return true;
    };
    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
        for (var property in _valuesEnd) {
            // Don't update properties that do not exist in the source object
            if (_valuesStart[property] === undefined) {
                continue;
            }
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];
            var startIsArray = Array.isArray(_object[property]);
            var endIsArray = Array.isArray(end);
            var isInterpolationList = !startIsArray && endIsArray;
            if (isInterpolationList) {
                _object[property] = this._interpolationFunction(end, value);
            }
            else if (typeof end === 'object' && end) {
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._updateProperties(_object[property], start, end, value);
            }
            else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                end = this._handleRelativeValue(start, end);
                // Protect against non numeric properties.
                if (typeof end === 'number') {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _object[property] = start + (end - start) * value;
                }
            }
        }
    };
    Tween.prototype._handleRelativeValue = function (start, end) {
        if (typeof end !== 'string') {
            return end;
        }
        if (end.charAt(0) === '+' || end.charAt(0) === '-') {
            return start + parseFloat(end);
        }
        else {
            return parseFloat(end);
        }
    };
    Tween.prototype._swapEndStartRepeatValues = function (property) {
        var tmp = this._valuesStartRepeat[property];
        var endValue = this._valuesEnd[property];
        if (typeof endValue === 'string') {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
        }
        else {
            this._valuesStartRepeat[property] = this._valuesEnd[property];
        }
        this._valuesEnd[property] = tmp;
    };
    return Tween;
}());
/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tweens.
 */
var TWEEN = mainGroup;
// This is the best way to export things in a way that's compatible with both ES
// Modules and CommonJS, without build hacks, and so as not to break the
// existing API.
// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
TWEEN.getAll.bind(TWEEN);
TWEEN.removeAll.bind(TWEEN);
TWEEN.add.bind(TWEEN);
var remove$1 = TWEEN.remove.bind(TWEEN);
TWEEN.update.bind(TWEEN);

// OrbitControls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };
const _ray = new Ray$1();
const _plane$1 = new Plane();
const TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );

class OrbitControls extends EventDispatcher {

	constructor( object, domElement ) {

		super();

		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push
		this.zoomToCursor = false;

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Mouse buttons
		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

		// Touch fingers
		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.getSpherical = function () {

			return spherical;

		};
		
		this.getState = function () {

			return state;

		};

		this.getDistance = function () {

			return this.object.position.distanceTo( this.target );

		};

		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.stopListenToKeyEvents = function () {

			this._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = null;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( _changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			const offset = new Vector3();

			// so camera.up is the orbit axis
			const quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
			const quatInverse = quat.clone().invert();

			const lastPosition = new Vector3();
			const lastQuaternion = new Quaternion();
			const lastTargetPosition = new Vector3();

			const twoPI = 2 * Math.PI;

			return function update() {

				const position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;

				if ( isFinite( min ) && isFinite( max ) ) {

					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

					if ( min <= max ) {

						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

					} else {

						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
							Math.max( min, spherical.theta ) :
							Math.min( max, spherical.theta );

					}

				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
				// we adjust zoom later in these cases
				if ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {

					spherical.radius = clampDistance( spherical.radius );

				} else {

					spherical.radius = clampDistance( spherical.radius * scale );

				}


				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

				// adjust camera position
				let zoomChanged = false;
				if ( scope.zoomToCursor && performCursorZoom ) {

					let newRadius = null;
					if ( scope.object.isPerspectiveCamera ) {

						// move the camera down the pointer ray
						// this method avoids floating point error
						const prevRadius = offset.length();
						newRadius = clampDistance( prevRadius * scale );

						const radiusDelta = prevRadius - newRadius;
						scope.object.position.addScaledVector( dollyDirection, radiusDelta );
						scope.object.updateMatrixWorld();

					} else if ( scope.object.isOrthographicCamera ) {

						// adjust the ortho camera position based on zoom changes
						const mouseBefore = new Vector3( mouse.x, mouse.y, 0 );
						mouseBefore.unproject( scope.object );

						scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );
						scope.object.updateProjectionMatrix();
						zoomChanged = true;

						const mouseAfter = new Vector3( mouse.x, mouse.y, 0 );
						mouseAfter.unproject( scope.object );

						scope.object.position.sub( mouseAfter ).add( mouseBefore );
						scope.object.updateMatrixWorld();

						newRadius = offset.length();

					} else {

						console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
						scope.zoomToCursor = false;

					}

					// handle the placement of the target
					if ( newRadius !== null ) {

						if ( this.screenSpacePanning ) {

							// position the orbit target in front of the new camera position
							scope.target.set( 0, 0, - 1 )
								.transformDirection( scope.object.matrix )
								.multiplyScalar( newRadius )
								.add( scope.object.position );

						} else {

							// get the ray and translation plane to compute target
							_ray.origin.copy( scope.object.position );
							_ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );

							// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
							// extremely large values
							if ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {

								object.lookAt( scope.target );

							} else {

								_plane$1.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );
								_ray.intersectPlane( _plane$1, scope.target );

							}

						}

					}

				} else if ( scope.object.isOrthographicCamera ) {

					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );
					scope.object.updateProjectionMatrix();
					zoomChanged = true;

				}

				scale = 1;
				performCursorZoom = false;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||
					lastTargetPosition.distanceToSquared( scope.target ) > 0 ) {

					scope.dispatchEvent( _changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					lastTargetPosition.copy( scope.target );

					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerUp );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.removeEventListener( 'pointerup', onPointerUp );


			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
				scope._domElementKeyEvents = null;

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new Spherical();
		const sphericalDelta = new Spherical();

		let scale = 1;
		const panOffset = new Vector3();

		const rotateStart = new Vector2();
		const rotateEnd = new Vector2();
		const rotateDelta = new Vector2();

		const panStart = new Vector2();
		const panEnd = new Vector2();
		const panDelta = new Vector2();

		const dollyStart = new Vector2();
		const dollyEnd = new Vector2();
		const dollyDelta = new Vector2();

		const dollyDirection = new Vector3();
		const mouse = new Vector2();
		let performCursorZoom = false;

		const pointers = [];
		const pointerPositions = {};

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		const panLeft = function () {

			const v = new Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		const panUp = function () {

			const v = new Vector3();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {

			const offset = new Vector3();

			return function pan( deltaX, deltaY ) {

				const element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					const position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale /= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale *= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function updateMouseParameters( event ) {

			if ( ! scope.zoomToCursor ) {

				return;

			}

			performCursorZoom = true;

			const rect = scope.domElement.getBoundingClientRect();
			const x = event.clientX - rect.left;
			const y = event.clientY - rect.top;
			const w = rect.width;
			const h = rect.height;

			mouse.x = ( x / w ) * 2 - 1;
			mouse.y = - ( y / h ) * 2 + 1;

			dollyDirection.set( mouse.x, mouse.y, 1 ).unproject( object ).sub( object.position ).normalize();

		}

		function clampDistance( dist ) {

			return Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			updateMouseParameters( event );
			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseWheel( event ) {

			updateMouseParameters( event );

			if ( event.deltaY < 0 ) {

				dollyIn( getZoomScale() );

			} else if ( event.deltaY > 0 ) {

				dollyOut( getZoomScale() );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			switch ( event.code ) {

				case scope.keys.UP:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, - scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.LEFT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

				case scope.keys.RIGHT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( - scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate() {

			if ( pointers.length === 1 ) {

				rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan() {

			if ( pointers.length === 1 ) {

				panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly() {

			const dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;
			const dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enablePan ) handleTouchStartPan();

		}

		function handleTouchStartDollyRotate() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enableRotate ) handleTouchStartRotate();

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.setPointerCapture( event.pointerId );

				scope.domElement.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.addEventListener( 'pointerup', onPointerUp );

			}

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

			removePointer( event );

			if ( pointers.length === 0 ) {

				scope.domElement.releasePointerCapture( event.pointerId );

				scope.domElement.removeEventListener( 'pointermove', onPointerMove );
				scope.domElement.removeEventListener( 'pointerup', onPointerUp );

			}

			scope.dispatchEvent( _endEvent );

			state = STATE.NONE;

		}

		function onMouseDown( event ) {

			let mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = - 1;

			}

			switch ( mouseAction ) {

				case MOUSE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case MOUSE.ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case MOUSE.PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onMouseMove( event ) {

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

			event.preventDefault();

			scope.dispatchEvent( _startEvent );

			handleMouseWheel( event );

			scope.dispatchEvent( _endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate();

							state = STATE.TOUCH_ROTATE;

							break;

						case TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan();

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan();

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate();

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ].pointerId == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new Vector2();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.pageX, event.pageY );

		}

		function getSecondPointerPosition( event ) {

			const pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointer.pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerUp );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		// force an update at start

		this.update();

	}

}

const math$1 = {

	torad: Math.PI / 180,
	todeg: 180 / Math.PI,
	Pi: Math.PI,
	TwoPI: Math.PI*2,
	PI90: Math.PI*0.5,
	PI45: Math.PI*0.25,
	PI270: (Math.PI*0.5)*3,
	inv255: 0.003921569,
	golden: 1.618033,
	epsilon: Math.pow( 2, - 52 ),

	randomSign: () => ( Math.random() < 0.5 ? -1 : 1 ),
	randSpread: ( range ) => ( range * ( 0.5 - Math.random() ) ),
	rand: ( low = 0, high = 1 ) => ( low + Math.random() * ( high - low ) ),
	randInt: ( low, high ) => ( low + Math.floor( Math.random() * ( high - low + 1 ) ) ),
	toFixed: ( x, n = 3 ) => ( x.toFixed(n) * 1 ),
	int: ( x ) => ( Math.floor(x) ),
	lerp: ( x, y, t ) => ( ( 1 - t ) * x + t * y ),
	clamp: ( v, min, max ) => ( Math.max( min, Math.min( max, v )) ),
	nearEquals: ( a, b, t ) => ( Math.abs(a - b) <= t ? true : false ),
	lerpAr: ( ar, arx, ary, t ) => {
		let i = ar.length;
		while( i-- ) ar[i] = math$1.lerp( arx[i], ary[i], t );
	},

    unwrapDeg: ( r ) => (r - (Math.floor((r + 180)/360))*360), 
	//unwrapRad: ( r ) => (r - (Math.floor((r + Math.PI)/(2*Math.PI)))*2*Math.PI),
	unwrapRad: ( r ) => ( Math.atan2(Math.sin(r), Math.cos(r)) ),


	scaleArray: ( ar, scale ) => {

		var i = ar.length;
		while( i-- ){ ar[i] *= scale; }		return ar;

	},

	addArray: ( ar, ar2 ) => {

		var r = [];
		var i = ar.length;
		while( i-- ){ r[i] = ar[i] + ar2[i]; }		return r;

	},

	angleDistance:(cur, prv)=> {
		var diff = (cur - prv + 180) % 360 - 180;
		return diff < -180 ? diff + 360 : diff;
	},




	/*map: ( value, in_min, in_max, out_min, out_max ) => ( (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min ),
	
	smoothLerp: ( a, b, c, t, k ) => {

        var f = a - b + (c - b) / (k * t);
        return c - (c - b) / ( k * t ) + f * Math.exp(-k*t);

    },

    smoothLerpV: ( a, b, c, t, k ) => {

    	let x = math.smoothLerp( a.x, b.x, c.x, t, k );
    	let y = math.smoothLerp( a.y, b.y, c.y, t, k );
    	let z = math.smoothLerp( a.z, b.z, c.z, t, k );

    	return { x:x, y:y, z:z }

    },

	minValue: ( ar ) => {

		let v = ar[0];
		for (let i = 1, l=ar.length; i<l; i++){ if( ar[i] < v ) v = ar[i]; }
		return v;

	},

	clamp: function (v, min, max) {

		//return Math.max( min, Math.min( max, value ) );
	    v = v < min ? min : v;
	    v = v > max ? max : v;
	    return v;
	},

	autoSize: ( o ) => {

		let s = o.size === undefined ? [ 1, 1, 1 ] : o.size;
		if ( s.length === 1 ) s[ 1 ] = s[ 0 ];

		let type = o.type === undefined ? 'box' : o.type;
		let radius = o.radius === undefined ? s[0] : o.radius;
		let height = o.height === undefined ? s[1] : o.height;

		if( type === 'sphere' ) s = [ radius, radius, radius ];
		if( type === 'cylinder' || type === 'wheel' || type === 'capsule' ) s = [ radius, height, radius ];
		if( type === 'cone' || type === 'pyramid' ) s = [ radius, height, 0 ];

	    if ( s.length === 2 ) s[ 2 ] = s[ 0 ];
	    return s;

	},

	correctSize: ( s ) => {

		if ( s.length === 1 ) s[ 1 ] = s[ 0 ];
	    if ( s.length === 2 ) s[ 2 ] = s[ 0 ];
	    return s;

	},*/

	tmpE: new Euler(),
	tmpM: new Matrix4(),
	tmpM2: new Matrix4(),
	tmpV: new Vector3(),
	tmpQ: new Quaternion(),

	fromTransformToQ: ( p, q, inv ) => {

		inv = inv || false;

		math$1.tmpM.compose( math$1.tmpV.fromArray( p ), math$1.tmpQ.fromArray( q ), { x:1, y:1, z:1 } );
		math$1.tmpM.decompose( math$1.tmpV, math$1.tmpQ, { x:1, y:1, z:1 } );

		//math.tmpQ.fromArray( q )

		if(inv) math$1.tmpQ.invert();

		return math$1.tmpQ.toArray();

	},

	fromTransform: ( p, q, p2, q2, inv ) => {

		inv = inv || false;
		q2 = q2 || [0,0,0,1];

		math$1.tmpM.compose( math$1.tmpV.fromArray( p ), math$1.tmpQ.fromArray( q ), { x:1, y:1, z:1 } );
		math$1.tmpM2.compose( math$1.tmpV.fromArray( p2 ), math$1.tmpQ.fromArray( q2 ), { x:1, y:1, z:1 } );
		if( inv ){
			//math.tmpM.getInverse( math.tmpM );
			math$1.tmpM.invert();
			math$1.tmpM.multiply( math$1.tmpM2 );
		} else {
			math$1.tmpM.multiply( math$1.tmpM2 );
		}

		math$1.tmpM.decompose( math$1.tmpV, math$1.tmpQ, { x:1, y:1, z:1 } );

		return math$1.tmpV.toArray();

	},

	arCopy: ( a, b ) => {

		[...b];

		//for( var i = 0; i< b.length; i++ ) a[i] = b[i];

	},

	axisToQuatArray: ( r, isdeg ) => { // r[0] array in degree

		isdeg = isdeg || false;
		return math$1.tmpQ.setFromAxisAngle( math$1.tmpV.fromArray( r, 1 ), isdeg ? r[0]*math$1.torad : r[0]).normalize().toArray();

	},

	toQuatArray: ( rotation ) => { // rotation array in degree

		return math$1.tmpQ.setFromEuler( math$1.tmpE.fromArray( math$1.vectorad( rotation ) ) ).toArray();

	},

	vectorad: ( r ) => {

		let i = 3, nr = [];
	    while ( i -- ) nr[ i ] = r[ i ] * math$1.torad;
	    nr[3] = r[3];
	    return nr;

	},
/*
	directionVector: ( a, b ) => {

	    var x = b.x-a.x;
	    var y = b.y-a.y;
	    var z = b.z-a.z;
	    var d = math.tmpV.set( x, 0, z ).normalize().toArray();
	    return d;

	},

	distanceVector: ( a, b ) => {

	    var x = b.x-a.x;
	    var y = b.y-a.y;
	    var z = b.z-a.z;
	    var d = Math.sqrt( x*x + y*y + z*z );
	    return d;

	},*/


	//--------------------
	//   COLORS
	//--------------------

	rgbToHex: ( rgb ) => {

	    return '0x' + ( '000000' + ( ( rgb[0] * 255 ) << 16 ^ ( rgb[1] * 255 ) << 8 ^ ( rgb[2] * 255 ) << 0 ).toString( 16 ) ).slice( - 6 );

	},

	hexToRgb: ( hex ) => {

	    hex = Math.floor( hex );
	    var r = ( hex >> 16 & 255 ) / 255;
	    var g = ( hex >> 8 & 255 ) / 255;
	    var b = ( hex & 255 ) / 255;
	    return [ r, g, b ];

	},

	htmlToHex: ( v ) => {

	    return v.toUpperCase().replace("#", "0x");

	},

	hexToHtml: ( v ) => {

	    v = v === undefined ? 0x000000 : v;
	    return "#" + ("000000" + v.toString(16)).substr(-6);

	},

	rgbToHtml: ( rgb ) => {

	    return '#' + ( '000000' + ( ( rgb[0] * 255 ) << 16 ^ ( rgb[1] * 255 ) << 8 ^ ( rgb[2] * 255 ) << 0 ).toString( 16 ) ).slice( - 6 );

	},


	//--------------------
	//   NOISE
	//--------------------

	perlin: null,

	resetPerlin:()=>{
		if( math$1.perlin !== null ) math$1.perlin = null;
	},

	noise: ( v, o ) => {

	    if( math$1.perlin === null ) math$1.perlin = new SimplexNoise$1();

	    o = o || {};

	    let level = o.level || [1,0.2,0.05];
	    let frequency  = o.frequency  || [0.016,0.05,0.2];

	    let i, f, c=0, d=0;

	    for(i=0; i<level.length; i++){

	        f = frequency [i];
	        c += level[i] * ( 0.5 + math$1.perlin.noise3d( v.x*f, v.y*f, v.z*f ) * 0.5 );
	        d += level[i];

	    }

	    c/=d;

	    return c;

	},

	/*radArray: (arr) => {
		var ret = [];
		for(var i = 0; i < 3; i++)
			ret[i] = arr[i] * math.torad;

		return ret;
	},

	degArray: (arr) => {
		var ret = [];
		for(var i = 0; i < 3; i++)
			ret[i] = arr[i] * math.todeg;

		return ret;
	},

	angleDistance: (cur, prv) =>{
		var diff = (cur - prv + 180) % 360 - 180;
		return diff < -180 ? diff + 360 : diff;
	}*/

};

class SimplexNoise$1 {

	constructor ( r ) {

		if (r == undefined) r = Math;
		this.grad3 = [[ 1,1,0 ],[ -1,1,0 ],[ 1,-1,0 ],[ -1,-1,0 ],
	        [ 1,0,1 ],[ -1,0,1 ],[ 1,0,-1 ],[ -1,0,-1 ],
	        [ 0,1,1 ],[ 0,-1,1 ],[ 0,1,-1 ],[ 0,-1,-1 ]];

		this.grad4 = [[ 0,1,1,1 ], [ 0,1,1,-1 ], [ 0,1,-1,1 ], [ 0,1,-1,-1 ],
		     [ 0,-1,1,1 ], [ 0,-1,1,-1 ], [ 0,-1,-1,1 ], [ 0,-1,-1,-1 ],
		     [ 1,0,1,1 ], [ 1,0,1,-1 ], [ 1,0,-1,1 ], [ 1,0,-1,-1 ],
		     [ -1,0,1,1 ], [ -1,0,1,-1 ], [ -1,0,-1,1 ], [ -1,0,-1,-1 ],
		     [ 1,1,0,1 ], [ 1,1,0,-1 ], [ 1,-1,0,1 ], [ 1,-1,0,-1 ],
		     [ -1,1,0,1 ], [ -1,1,0,-1 ], [ -1,-1,0,1 ], [ -1,-1,0,-1 ],
		     [ 1,1,1,0 ], [ 1,1,-1,0 ], [ 1,-1,1,0 ], [ 1,-1,-1,0 ],
		     [ -1,1,1,0 ], [ -1,1,-1,0 ], [ -1,-1,1,0 ], [ -1,-1,-1,0 ]];

		this.p = [];
		for (var i = 0; i < 256; i ++) {
			this.p[i] = Math.floor(r.random() * 256);
		}
	  // To remove the need for index wrapping, double the permutation table length
		this.perm = [];
		for (var i = 0; i < 512; i ++) {
			this.perm[i] = this.p[i & 255];
		}

	  // A lookup table to traverse the simplex around a given point in 4D.
	  // Details can be found where this table is used, in the 4D noise method.
		this.simplex = [
	    [ 0,1,2,3 ],[ 0,1,3,2 ],[ 0,0,0,0 ],[ 0,2,3,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,2,3,0 ],
	    [ 0,2,1,3 ],[ 0,0,0,0 ],[ 0,3,1,2 ],[ 0,3,2,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,3,2,0 ],
	    [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],
	    [ 1,2,0,3 ],[ 0,0,0,0 ],[ 1,3,0,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,3,0,1 ],[ 2,3,1,0 ],
	    [ 1,0,2,3 ],[ 1,0,3,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,0,3,1 ],[ 0,0,0,0 ],[ 2,1,3,0 ],
	    [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],
	    [ 2,0,1,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,0,1,2 ],[ 3,0,2,1 ],[ 0,0,0,0 ],[ 3,1,2,0 ],
	    [ 2,1,0,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,1,0,2 ],[ 0,0,0,0 ],[ 3,2,0,1 ],[ 3,2,1,0 ]];
	}

	dot (g, x, y) {
		return g[0] * x + g[1] * y;
	}

	dot3 (g, x, y, z) {
		return g[0] * x + g[1] * y + g[2] * z;
	}

	dot4 (g, x, y, z, w) {
		return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
	}

	noise (xin, yin) {
		var n0, n1, n2; // Noise contributions from the three corners
	  // Skew the input space to determine which simplex cell we're in
		var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
		var s = (xin + yin) * F2; // Hairy factor for 2D
		var i = Math.floor(xin + s);
		var j = Math.floor(yin + s);
		var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
		var t = (i + j) * G2;
		var X0 = i - t; // Unskew the cell origin back to (x,y) space
		var Y0 = j - t;
		var x0 = xin - X0; // The x,y distances from the cell origin
		var y0 = yin - Y0;
	  // For the 2D case, the simplex shape is an equilateral triangle.
	  // Determine which simplex we are in.
		var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
		if (x0 > y0) {i1 = 1; j1 = 0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
		else {i1 = 0; j1 = 1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1)
	  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	  // c = (3-sqrt(3))/6
		var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
		var y1 = y0 - j1 + G2;
		var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
		var y2 = y0 - 1.0 + 2.0 * G2;
	  // Work out the hashed gradient indices of the three simplex corners
		var ii = i & 255;
		var jj = j & 255;
		var gi0 = this.perm[ii + this.perm[jj]] % 12;
		var gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
		var gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
	  // Calculate the contribution from the three corners
		var t0 = 0.5 - x0 * x0 - y0 * y0;
		if (t0 < 0) n0 = 0.0;
		else {
			t0 *= t0;
			n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient
		}
		var t1 = 0.5 - x1 * x1 - y1 * y1;
		if (t1 < 0) n1 = 0.0;
		else {
			t1 *= t1;
			n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
		}
		var t2 = 0.5 - x2 * x2 - y2 * y2;
		if (t2 < 0) n2 = 0.0;
		else {
			t2 *= t2;
			n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
		}
	  // Add contributions from each corner to get the final noise value.
	  // The result is scaled to return values in the interval [-1,1].
		return 70.0 * (n0 + n1 + n2);
	}

	// 3D simplex noise
	noise3d (xin, yin, zin) {
		var n0, n1, n2, n3; // Noise contributions from the four corners
	  // Skew the input space to determine which simplex cell we're in
		var F3 = 1.0 / 3.0;
		var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
		var i = Math.floor(xin + s);
		var j = Math.floor(yin + s);
		var k = Math.floor(zin + s);
		var G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too
		var t = (i + j + k) * G3;
		var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
		var Y0 = j - t;
		var Z0 = k - t;
		var x0 = xin - X0; // The x,y,z distances from the cell origin
		var y0 = yin - Y0;
		var z0 = zin - Z0;
	  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
	  // Determine which simplex we are in.
		var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
		var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
		if (x0 >= y0) {
			if (y0 >= z0)
	      { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // X Y Z order
	      else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } // X Z Y order
			else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } // Z X Y order
		}
		else { // x0<y0
			if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } // Z Y X order
	    else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } // Y Z X order
			else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // Y X Z order
		}
	  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
	  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
	  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
	  // c = 1/6.
		var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
		var y1 = y0 - j1 + G3;
		var z1 = z0 - k1 + G3;
		var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
		var y2 = y0 - j2 + 2.0 * G3;
		var z2 = z0 - k2 + 2.0 * G3;
		var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
		var y3 = y0 - 1.0 + 3.0 * G3;
		var z3 = z0 - 1.0 + 3.0 * G3;
	  // Work out the hashed gradient indices of the four simplex corners
		var ii = i & 255;
		var jj = j & 255;
		var kk = k & 255;
		var gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
		var gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
		var gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
		var gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
	  // Calculate the contribution from the four corners
		var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
		if (t0 < 0) n0 = 0.0;
		else {
			t0 *= t0;
			n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
		}
		var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
		if (t1 < 0) n1 = 0.0;
		else {
			t1 *= t1;
			n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
		}
		var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
		if (t2 < 0) n2 = 0.0;
		else {
			t2 *= t2;
			n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);
		}
		var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
		if (t3 < 0) n3 = 0.0;
		else {
			t3 *= t3;
			n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
		}
	  // Add contributions from each corner to get the final noise value.
	  // The result is scaled to stay just inside [-1,1]
		return 32.0 * (n0 + n1 + n2 + n3);
	}

	// 4D simplex noise
	noise4d ( x, y, z, w ) {
		// For faster and easier lookups
		var grad4 = this.grad4;
		var simplex = this.simplex;
		var perm = this.perm;

	   // The skewing and unskewing factors are hairy again for the 4D case
		var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
		var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
		var n0, n1, n2, n3, n4; // Noise contributions from the five corners
	   // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
		var s = (x + y + z + w) * F4; // Factor for 4D skewing
		var i = Math.floor(x + s);
		var j = Math.floor(y + s);
		var k = Math.floor(z + s);
		var l = Math.floor(w + s);
		var t = (i + j + k + l) * G4; // Factor for 4D unskewing
		var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
		var Y0 = j - t;
		var Z0 = k - t;
		var W0 = l - t;
		var x0 = x - X0;  // The x,y,z,w distances from the cell origin
		var y0 = y - Y0;
		var z0 = z - Z0;
		var w0 = w - W0;

	   // For the 4D case, the simplex is a 4D shape I won't even try to describe.
	   // To find out which of the 24 possible simplices we're in, we need to
	   // determine the magnitude ordering of x0, y0, z0 and w0.
	   // The method below is a good way of finding the ordering of x,y,z,w and
	   // then find the correct traversal order for the simplex we’re in.
	   // First, six pair-wise comparisons are performed between each possible pair
	   // of the four coordinates, and the results are used to add up binary bits
	   // for an integer index.
		var c1 = (x0 > y0) ? 32 : 0;
		var c2 = (x0 > z0) ? 16 : 0;
		var c3 = (y0 > z0) ? 8 : 0;
		var c4 = (x0 > w0) ? 4 : 0;
		var c5 = (y0 > w0) ? 2 : 0;
		var c6 = (z0 > w0) ? 1 : 0;
		var c = c1 + c2 + c3 + c4 + c5 + c6;
		var i1, j1, k1, l1; // The integer offsets for the second simplex corner
		var i2, j2, k2, l2; // The integer offsets for the third simplex corner
		var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
	   // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
	   // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
	   // impossible. Only the 24 indices which have non-zero entries make any sense.
	   // We use a thresholding to set the coordinates in turn from the largest magnitude.
	   // The number 3 in the "simplex" array is at the position of the largest coordinate.
		i1 = simplex[c][0] >= 3 ? 1 : 0;
		j1 = simplex[c][1] >= 3 ? 1 : 0;
		k1 = simplex[c][2] >= 3 ? 1 : 0;
		l1 = simplex[c][3] >= 3 ? 1 : 0;
	   // The number 2 in the "simplex" array is at the second largest coordinate.
		i2 = simplex[c][0] >= 2 ? 1 : 0;
		j2 = simplex[c][1] >= 2 ? 1 : 0;    k2 = simplex[c][2] >= 2 ? 1 : 0;
		l2 = simplex[c][3] >= 2 ? 1 : 0;
	   // The number 1 in the "simplex" array is at the second smallest coordinate.
		i3 = simplex[c][0] >= 1 ? 1 : 0;
		j3 = simplex[c][1] >= 1 ? 1 : 0;
		k3 = simplex[c][2] >= 1 ? 1 : 0;
		l3 = simplex[c][3] >= 1 ? 1 : 0;
	   // The fifth corner has all coordinate offsets = 1, so no need to look that up.
		var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
		var y1 = y0 - j1 + G4;
		var z1 = z0 - k1 + G4;
		var w1 = w0 - l1 + G4;
		var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
		var y2 = y0 - j2 + 2.0 * G4;
		var z2 = z0 - k2 + 2.0 * G4;
		var w2 = w0 - l2 + 2.0 * G4;
		var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
		var y3 = y0 - j3 + 3.0 * G4;
		var z3 = z0 - k3 + 3.0 * G4;
		var w3 = w0 - l3 + 3.0 * G4;
		var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
		var y4 = y0 - 1.0 + 4.0 * G4;
		var z4 = z0 - 1.0 + 4.0 * G4;
		var w4 = w0 - 1.0 + 4.0 * G4;
	   // Work out the hashed gradient indices of the five simplex corners
		var ii = i & 255;
		var jj = j & 255;
		var kk = k & 255;
		var ll = l & 255;
		var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
		var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
		var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
		var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
		var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
	   // Calculate the contribution from the five corners
		var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
		if (t0 < 0) n0 = 0.0;
		else {
			t0 *= t0;
			n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
		}
		var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
		if (t1 < 0) n1 = 0.0;
		else {
			t1 *= t1;
			n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
		}
		var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
		if (t2 < 0) n2 = 0.0;
		else {
			t2 *= t2;
			n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);
		}   var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
		if (t3 < 0) n3 = 0.0;
		else {
			t3 *= t3;
			n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
		}
		var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
		if (t4 < 0) n4 = 0.0;
		else {
			t4 *= t4;
			n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
		}
	   // Sum up and scale the result to cover the range [-1,1]
		return 27.0 * (n0 + n1 + n2 + n3 + n4);
	}

}

/** __
*    _)_|_|_
*   __) |_| | 2022
* @author lo.th / https://github.com/lo-th
*/

class Controller extends OrbitControls {

    constructor( object, domElement, group ) {

        super( object, domElement );

    	this.followTarget = null;
        this.camTween = [];

        this.isDecal = false;
        this.isInDecal = false;

        this.tmpP =  new Vector3();
        this.tmpQ = new Quaternion();

    	this.cam = {

    		stiffness: 0.15,
    		stiffnessTarget: 1,

    	    theta:180,
            phi:20,
            distance:10,
            maxDistance:10,
    	    height:0.6,

    	    v: new Vector3(),
            d: new Vector3(),

            tmp: new Vector3(),
            oldp: new Vector3(),
            oldq: new Quaternion(),
            offset: new Vector3(),
            position: new Vector3(),
            decal: new Vector3(),

            multy:1,

            clipper: true,

            forceFree:false,

            simple:false,

            //pov:null,
            

    	};

        this.reverse = false;

    	this.followGroup = group;

        this.tmpMatrix = new Matrix4();
        this.tmpE = new Euler();
        this.tmpV = new Vector3();

        this.info = { x:0, y:0, z:0, distance: 0, phi: 0, theta:0, fov: 0, zoom: 0 };

        this.getInfo();

        this.isFree = true;

        this.rayClipper = null;

        this.tmpV1 = new Vector3();

    }

    upExtra (z){

        this.cam.distance *= z;

    }

    startFollow ( mesh, o ) {

        if(o.d !== undefined) o.distance = o.d;
        if(o.h !== undefined) o.theta = o.h;
        if(o.v !== undefined) o.phi = o.v;

        this.moveCam( o );

        let cam = this.cam;

        cam.simple = o.simple !== undefined ? o.simple : false;

        cam.stiffness = o.stiffness !== undefined ? o.stiffness : 0.15;
        cam.stiffnessTarget = o.stiffnessTarget !== undefined ? o.stiffnessTarget : 1;

        cam.height = o.height !== undefined ? o.height : 0.6;
        cam.d.set(0,this.cam.height,0);

        cam.theta = o.theta !== undefined ? o.theta : 180;
        cam.phi = o.phi !== undefined ? o.phi : 20;
        cam.distance = o.distance !== undefined ? o.distance : 10;
        cam.maxDistance = cam.distance;
        cam.rotation = o.rotation !== undefined ? o.rotation : true;
        cam.offset.set( 0,0,0 );
        cam.decal.fromArray( o.decal !== undefined ? o.decal : [0,0,0] );
        if( o.dx !== undefined ) cam.decal.x = o.dx;
        if( o.dy !== undefined ) cam.decal.y = o.dy;
        if( o.dz !== undefined ) cam.decal.z = o.dz;
        cam.clipper = o.clipper || false;
        cam.exr = o.exr || 0;


        cam.forceFree = o.forceFree || false;

        if( o.direct ){
            this.enablePan = false;
            this.initFollow( mesh, o );
            return;
        }

        //cam.pov = o.pov || null;


        let start = this.getTargetStart( mesh );

        o.target = start.p;
        o.theta = math$1.unwrapDeg( o.theta + start.r );

        var callback2 = o.callback;

        o.callback = function() {

            if(callback2) callback2();
            this.initFollow( mesh, o );

        }.bind( this );

        //this.moveCam( o );

    }

    getTargetStart ( mesh ){

        mesh.updateMatrix();
        this.tmpMatrix.makeRotationFromQuaternion( mesh.quaternion );
        let cam = this.cam;
        let r = Math.atan2( this.tmpMatrix.elements[8], this.tmpMatrix.elements[10] ) ;
        if( cam.decal.x !== 0 || cam.decal.z !== 0 ) cam.offset.copy( cam.position ).add( cam.decal ).applyAxisAngle( { x:0, y:1, z:0 }, r );
        let p = cam.tmp.copy( mesh.position ).add( cam.offset ).add( cam.d ).toArray();
        
        return { p:p, r:r * math$1.todeg }

    }

    initFollow ( mesh, o ) {

        this.enableDamping = false;
        this.screenSpacePanning = false;

        this.cam.oldp.copy( mesh.position );
        this.cam.oldq.copy( mesh.quaternion );

        //this.moveCam( this.cam )

        this.stopMoveCam();

        /*if( this.cam.clipper ){

            this.rayClipper = root.add( { name: 'cameraRayClipper', type:'ray', callback: (o) => { this.onRayClipper(o) }, visible:false, group: "all", filter: [o.clipperFilter || (-1 >>> 0)], isIntern:true } );

        }*/

        this.followTarget = mesh;

    }

    onRayClipper ( o ) {

        if( o.hit ) this.cam.distance = math$1.clamp( o.distance, this.minDistance, this.cam.maxDistance );
        else {
            if( this.cam.distance < this.cam.maxDistance ){
                this.cam.distance += this.cam.maxDistance/16;
            }
        }
        
        this.maxDistance = this.cam.distance;

    }


    resetAll () {
		
        this.enablePan = true;
        this.enableDamping = true;
        this.screenSpacePanning = true;
		this.stopMoveCam();
        this.resetFov();
        this.resetFollow();
        this.setLimite();
        this.reverse = false;

    }

    setLimite ( o ){

        o = o || {};

        this.minPolarAngle = o.minV !== undefined ? (90-o.minV) * math$1.torad : 0;
        this.maxPolarAngle = o.maxV !== undefined ? (90-o.maxV) * math$1.torad : Math.PI;

        this.minAzimuthAngle = o.minH !== undefined ? o.minH * math$1.torad : - Infinity;
        this.maxAzimuthAngle = o.maxH !== undefined ? o.maxH * math$1.torad : Infinity;

        this.minDistance = o.minD !== undefined ? o.minD : 0.01;
        this.maxDistance = o.maxD !== undefined ? o.maxD : Infinity;

    }

    resetFov () {

        this.object.fov = 50;
        this.object.zoom = 1;
        this.object.updateProjectionMatrix();

    }

	resetFollow () {

        this.followGroup.position.set(0,0,0);
		this.followTarget = null;
        this.enabled = true;


        /*if( this.rayClipper !== null ){ 
            root.remove( 'cameraRayClipper' );
            this.rayClipper = null;
        }*/
	}

    /*upPosition:function () {

        if( !this.followTarget ) return;

        this.tmpP.copy(this.followTarget.position );
        this.tmpQ.copy(this.followTarget.quaternion ) ;

        //this.tmpP.lerp(this.followTarget.position, 0.5 );
        //this.tmpQ.slerp(this.followTarget.quaternion, 0.5 ) ;

    },

    idealOffset () {
        const idealOffset = new Vector3(-0.15, 0.20, -0.30);
        idealOffset.applyQuaternion(this.tmpQ);
        idealOffset.add(this.tmpP);
        return idealOffset;
    }

    ideallLookat () {
        const idealLookat = new THREE.Vector3(0, 0.10, 0.50);
        idealLookat.applyQuaternion(this.tmpQ);
        idealLookat.add(this.tmpP);
        return idealLookat;
    }*/



	follow ( delta ) {

        if( !this.followTarget ) return;



        const cam = this.cam;
        const camera = this.object;
        const target = this.target;
        const sph = this.getSpherical();
        const state = this.getState();




        this.tmpP.copy( this.followTarget.position );
        this.tmpQ.copy( this.followTarget.quaternion );

        


        let p = this.tmpP;
        let q = this.tmpQ;

        

        
        let phi = ( ( 90 - cam.phi ) * math$1.torad ) ;
        //let theta = ( cam.theta * math.torad )
        let radius = cam.distance;

        //console.log(this.tmpP)


        if(cam.simple){

            this.tmpV.copy( cam.decal );//.applyAxisAngle( { x:1, y:0, z:0 }, phi - math.PI90 )
            this.tmpV.applyAxisAngle( { x:0, y:1, z:0 }, sph.theta );
            //cam.offset.copy( p ).add( this.tmpV ).applyAxisAngle( { x:0, y:1, z:0 }, cam.theta );

            target.copy( p ).add( this.tmpV );
            camera.position.setFromSpherical( sph ).add( target );
            camera.lookAt( target );

            this.updateFollowGroup();

            return;

        }



        


        //if( this.isDecal || this.isInDecal ){

           // cam.oldp.copy( this.tmpP );
           // cam.oldq.copy( this.tmpQ );

            /*var yy = camera.position.y;
            camera.position.sub( cam.oldp );
            camera.position.y = yy;
            this.target.copy( this.tmpP ).add( cam.d );
            camera.lookAt( this.target ); */

        //}


        this.tmpMatrix.makeRotationFromQuaternion( q );
        let tRotation = Math.atan2( this.tmpMatrix.elements[8], this.tmpMatrix.elements[10] );

        let theta = ( cam.theta * math$1.torad ) + tRotation;

        //theta+=tRotation


        this.isFree = false;
        

        var dist = p.distanceTo( cam.oldp );

        var qx = q.x - cam.oldq.x;
        var qy = q.y - cam.oldq.y;
        var qz = q.z - cam.oldq.z;
        var qw = q.w - cam.oldq.w;
        var qdist = Math.sqrt(qx * qx + qy * qy + qz * qz + qw * qw);

        




        if( this.enabled ){
            if( state === 0 || state === 3 || (dist < 0.01 && qdist < 0.001) ) this.isFree = true;
            else if( !cam.forceFree ) sph.set( radius, phi, theta );
        } else {
            sph.set( radius, phi, theta );
        }



        //if( cam.decal.x !== 0 || cam.decal.z !== 0 ) 
        //cam.offset.copy( cam.position ).add( cam.decal ).applyAxisAngle( { x:0, y:1, z:0 }, tRotation );


        //this.tmpE.set( 0, tRotation, 0, 'XYZ' ) 
        this.tmpV.copy( cam.decal ).applyAxisAngle( { x:1, y:0, z:0 }, phi - math$1.PI90 );
        cam.offset.copy( cam.position ).add( this.tmpV ).applyAxisAngle( { x:0, y:1, z:0 }, tRotation );
       
        cam.v.copy( p ).add( cam.offset ).add( cam.d );
        cam.tmp.setFromSpherical( sph ).add( cam.v );

        //camera.position.copy( cam.tmp );

        if( this.reverse ){

            if( cam.stiffnessTarget !== 1 ) camera.position.lerp( cam.v, cam.stiffnessTarget );
            else camera.position.copy( cam.v );

            if( !this.isDecal ) target.lerp( cam.tmp, cam.stiffness );
            else target.copy( cam.tmp );

        } else {

            if( !this.isDecal ) camera.position.lerp( cam.tmp, cam.stiffness );
            else camera.position.copy( cam.tmp );

            if( cam.stiffnessTarget !== 1 ) target.lerp( cam.v, cam.stiffnessTarget );
            else target.copy( cam.v );

        }
        

       // if( cam.rotation ) camera.lookAt( target );
        camera.lookAt( target );

        this.updateFollowGroup();

        cam.oldp.copy( p );
		cam.oldq.copy( q );


        if( this.isInDecal ){ this.isDecal = false; this.isInDecal = false; }
        if( this.isDecal ) this.isInDecal = true;


        if( !this.cam.clipper ) return;

        this.rayClipper.start.copy( p ).add( cam.offset).add( cam.d );
        this.tmpV1.set(0, 0, -1).applyQuaternion( camera.quaternion ).normalize().multiplyScalar( cam.maxDistance );
        this.rayClipper.end.copy(this.rayClipper.start).sub( this.tmpV1 );

    }


    updateFollowGroup(){

        this.followGroup.position.copy( this.target );

        //this.followGroup.position.set( this.target.x, 0, this.target.z );

    }

    getInfo () {

        this.update();

        var t = this.target;
        var c = this.object;
        var sph = this.getSpherical();

        this.info.x = t.x;
        this.info.y = t.y;
        this.info.z = t.z;

        this.object.dist = sph.radius;

        this.info.distance = sph.radius;

        this.info.phi = math$1.unwrapDeg(-Math.floor( sph.phi * math$1.todeg ) + 90);
        this.info.theta = math$1.unwrapDeg(Math.floor( sph.theta * math$1.todeg ));

        this.info.fov = c.fov;
        this.info.zoom = c.zoom;

    }

    stopMoveCam (){

        var i = this.camTween.length;
        while(i--){
            remove$1( this.camTween[i] );
            this.camTween[i] = null;
        }

        this.camTween = [];
        this.getInfo();

    }

    moveCam ( data = {} ) {

        if( this.followTarget ) this.resetFollow();

    	var self = this;
        this.getInfo();

        var o = {};

        if( data.phi !== undefined ) o.phi = data.phi;
        if( data.theta !== undefined ) o.theta = data.theta;
        if( data.distance !== undefined ) o.distance = data.distance;

        if( data.v !== undefined ) o.phi = data.v;
        if( data.h !== undefined ) o.theta = data.h;
        if( data.d !== undefined ) o.distance = data.d;

        if( data.fov !== undefined ) o.fov = data.fov;
        if( data.zoom !== undefined ) o.zoom = data.zoom;

        if( data.x !== undefined ) o.x = data.x;
        if( data.y !== undefined ) o.y = data.y;
        if( data.z !== undefined ) o.z = data.z;

        /*if( data.target ){
            //console.log(data.target)
            //o.target = data.target
            o.x = data.target[0];
            o.y = data.target[1];
            o.z = data.target[2];
        }*/

        var shortest = data.shortest !== undefined ? data.shortest : true;
		
		if( o.theta !== undefined && shortest ){ // get shortest distance
			var prvh = this.getSpherical().theta * math$1.todeg;
			o.theta = prvh + math$1.angleDistance(o.theta, prvh);
		}
		
        var time = data.time !== undefined ? data.time : 0;
        var tween = data.tween !== undefined ? data.tween : Easing.Quadratic.Out;//Easing.Linear.None;
        var delay = data.delay !== undefined ? data.delay : 0;

        this.enabled = false;

        var c = [];//[...this.info];
        for( var n in o ) c[n] = this.info[n];

		var callback = data.callback || function(){};

        if( time === 0 ){

            for( var n in o ) c[n] = o[n];
            this.stopMoveCam();
            this.orbit( c );
            this.enabled = true;
            callback();
            return;

        }


        var t = new Tween( c )
            .to( o, time )
            .delay( delay )
            .easing( tween )
            .onUpdate( function( o ) { self.orbit( o ); } )
            .onComplete( function() { self.enabled = true;  callback(); } )
            .start();

        this.camTween.push( t );

    }

    zommer ( p, time, callback ) {

        this.stopMoveCam();

        var cam = this.cam;
        var camera = this.object;
        var o = { 
            zoom:p.zoom, fov:p.fov, distance:p.distance,
            dx: p.dx !== undefined ? p.dx : cam.decal.x, 
            dy: p.dy !== undefined ? p.dy : cam.decal.y, 
            dz: p.dz !== undefined ? p.dz : cam.decal.z, 
            exr: p.exr !== undefined ? p.exr : cam.exr, 
            multy: p.multy !== undefined ? p.multy : cam.multy, 
        };


        var t = new Tween( { zoom:camera.zoom, fov:camera.fov, distance:cam.distance, dx:cam.decal.x, dy:cam.decal.y, dz:cam.decal.z, exr:cam.exr, multy:cam.multy } )
            .to( o, time || 300 )
            .onUpdate( function( o ) { 
                camera.fov = o.fov;
                camera.zoom = o.zoom;
                cam.distance = o.distance;
                cam.decal.x = o.dx; 
                cam.decal.y = o.dy; 
                cam.decal.z = o.dz;
                cam.exr = o.exr;
                cam.multy = o.multy;
                camera.updateProjectionMatrix();
            })
            .onComplete( function( ) {
                if( callback ) callback();
            }
            ).start();

        this.camTween.push( t );

    }

    orbit ( c ) {

        var o = this.info;
        for( var n in c ) o[n] = c[n];

    	var camera = this.object;
        var target = this.target;
        var sph = this.getSpherical();

        var upCam = false;
        if( camera.fov !== o.fov ){ camera.fov = o.fov; upCam = true; }
        if( camera.zoom !== o.zoom ){ camera.zoom = o.zoom; upCam = true; }
        if( upCam ) camera.updateProjectionMatrix();

        sph.set( o.distance, (-o.phi+90) * math$1.torad, o.theta * math$1.torad );
        sph.makeSafe();

        if( this.reverse ){
            //target.set( o.x, o.y, o.z );
            camera.position.set( o.x, o.y, o.z );
            target.setFromSpherical( sph ).add( camera.position );
            camera.lookAt( target );
        } else {
            target.set( o.x, o.y, o.z );
            //camera.position.set( 0,0,0 ).setFromSpherical( sph ).add( target );
            camera.position.setFromSpherical( sph ).add( target );
            camera.lookAt( target );
        }

        //this.updateFollowGroup();

    }

    getDirection () {

        return math$1.tmpV.subVectors( this.target, this.object.position ).normalize().toArray();//math.directionVector( this.object.position, this.target );

    }



}

/**
 * @param  {Array<BufferGeometry>} geometries
 * @param  {Boolean} useGroups
 * @return {BufferGeometry}
 */
function mergeGeometries( geometries, useGroups = false ) {

	const isIndexed = geometries[ 0 ].index !== null;

	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
	const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );

	const attributes = {};
	const morphAttributes = {};

	const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;

	const mergedGeometry = new BufferGeometry();

	let offset = 0;

	for ( let i = 0; i < geometries.length; ++ i ) {

		const geometry = geometries[ i ];
		let attributesCount = 0;

		// ensure that all geometries are indexed, or none

		if ( isIndexed !== ( geometry.index !== null ) ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );
			return null;

		}

		// gather attributes, exit early if they're different

		for ( const name in geometry.attributes ) {

			if ( ! attributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );
				return null;

			}

			if ( attributes[ name ] === undefined ) attributes[ name ] = [];

			attributes[ name ].push( geometry.attributes[ name ] );

			attributesCount ++;

		}

		// ensure geometries have the same number of attributes

		if ( attributesCount !== attributesUsed.size ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );
			return null;

		}

		// gather morph attributes, exit early if they're different

		if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );
			return null;

		}

		for ( const name in geometry.morphAttributes ) {

			if ( ! morphAttributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );
				return null;

			}

			if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];

			morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

		}

		if ( useGroups ) {

			let count;

			if ( isIndexed ) {

				count = geometry.index.count;

			} else if ( geometry.attributes.position !== undefined ) {

				count = geometry.attributes.position.count;

			} else {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );
				return null;

			}

			mergedGeometry.addGroup( offset, count, i );

			offset += count;

		}

	}

	// merge indices

	if ( isIndexed ) {

		let indexOffset = 0;
		const mergedIndex = [];

		for ( let i = 0; i < geometries.length; ++ i ) {

			const index = geometries[ i ].index;

			for ( let j = 0; j < index.count; ++ j ) {

				mergedIndex.push( index.getX( j ) + indexOffset );

			}

			indexOffset += geometries[ i ].attributes.position.count;

		}

		mergedGeometry.setIndex( mergedIndex );

	}

	// merge attributes

	for ( const name in attributes ) {

		const mergedAttribute = mergeAttributes( attributes[ name ] );

		if ( ! mergedAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );
			return null;

		}

		mergedGeometry.setAttribute( name, mergedAttribute );

	}

	// merge morph attributes

	for ( const name in morphAttributes ) {

		const numMorphTargets = morphAttributes[ name ][ 0 ].length;

		if ( numMorphTargets === 0 ) break;

		mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
		mergedGeometry.morphAttributes[ name ] = [];

		for ( let i = 0; i < numMorphTargets; ++ i ) {

			const morphAttributesToMerge = [];

			for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {

				morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

			}

			const mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );

			if ( ! mergedMorphAttribute ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );
				return null;

			}

			mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

		}

	}

	return mergedGeometry;

}

/**
 * @param {Array<BufferAttribute>} attributes
 * @return {BufferAttribute}
 */
function mergeAttributes( attributes ) {

	let TypedArray;
	let itemSize;
	let normalized;
	let gpuType = - 1;
	let arrayLength = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		const attribute = attributes[ i ];

		if ( attribute.isInterleavedBufferAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );
			return null;

		}

		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );
			return null;

		}

		if ( itemSize === undefined ) itemSize = attribute.itemSize;
		if ( itemSize !== attribute.itemSize ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );
			return null;

		}

		if ( normalized === undefined ) normalized = attribute.normalized;
		if ( normalized !== attribute.normalized ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );
			return null;

		}

		if ( gpuType === - 1 ) gpuType = attribute.gpuType;
		if ( gpuType !== attribute.gpuType ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );
			return null;

		}

		arrayLength += attribute.array.length;

	}

	const array = new TypedArray( arrayLength );
	let offset = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		array.set( attributes[ i ].array, offset );

		offset += attributes[ i ].array.length;

	}

	const result = new BufferAttribute( array, itemSize, normalized );
	if ( gpuType !== undefined ) {

		result.gpuType = gpuType;

	}

	return result;

}

/**
 * @param {BufferGeometry} geometry
 * @param {number} tolerance
 * @return {BufferGeometry}
 */
function mergeVertices( geometry, tolerance = 1e-4 ) {

	tolerance = Math.max( tolerance, Number.EPSILON );

	// Generate an index buffer if the geometry doesn't have one, or optimize it
	// if it's already available.
	const hashToIndex = {};
	const indices = geometry.getIndex();
	const positions = geometry.getAttribute( 'position' );
	const vertexCount = indices ? indices.count : positions.count;

	// next value for triangle indices
	let nextIndex = 0;

	// attributes and new attribute arrays
	const attributeNames = Object.keys( geometry.attributes );
	const tmpAttributes = {};
	const tmpMorphAttributes = {};
	const newIndices = [];
	const getters = [ 'getX', 'getY', 'getZ', 'getW' ];
	const setters = [ 'setX', 'setY', 'setZ', 'setW' ];

	// Initialize the arrays, allocating space conservatively. Extra
	// space will be trimmed in the last step.
	for ( let i = 0, l = attributeNames.length; i < l; i ++ ) {

		const name = attributeNames[ i ];
		const attr = geometry.attributes[ name ];

		tmpAttributes[ name ] = new BufferAttribute(
			new attr.array.constructor( attr.count * attr.itemSize ),
			attr.itemSize,
			attr.normalized
		);

		const morphAttr = geometry.morphAttributes[ name ];
		if ( morphAttr ) {

			tmpMorphAttributes[ name ] = new BufferAttribute(
				new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),
				morphAttr.itemSize,
				morphAttr.normalized
			);

		}

	}

	// convert the error tolerance to an amount of decimal places to truncate to
	const decimalShift = Math.log10( 1 / tolerance );
	const shiftMultiplier = Math.pow( 10, decimalShift );
	for ( let i = 0; i < vertexCount; i ++ ) {

		const index = indices ? indices.getX( i ) : i;

		// Generate a hash for the vertex attributes at the current index 'i'
		let hash = '';
		for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

			const name = attributeNames[ j ];
			const attribute = geometry.getAttribute( name );
			const itemSize = attribute.itemSize;

			for ( let k = 0; k < itemSize; k ++ ) {

				// double tilde truncates the decimal value
				hash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;

			}

		}

		// Add another reference to the vertex if it's already
		// used by another index
		if ( hash in hashToIndex ) {

			newIndices.push( hashToIndex[ hash ] );

		} else {

			// copy data to the new index in the temporary attributes
			for ( let j = 0, l = attributeNames.length; j < l; j ++ ) {

				const name = attributeNames[ j ];
				const attribute = geometry.getAttribute( name );
				const morphAttr = geometry.morphAttributes[ name ];
				const itemSize = attribute.itemSize;
				const newarray = tmpAttributes[ name ];
				const newMorphArrays = tmpMorphAttributes[ name ];

				for ( let k = 0; k < itemSize; k ++ ) {

					const getterFunc = getters[ k ];
					const setterFunc = setters[ k ];
					newarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );

					if ( morphAttr ) {

						for ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {

							newMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );

						}

					}

				}

			}

			hashToIndex[ hash ] = nextIndex;
			newIndices.push( nextIndex );
			nextIndex ++;

		}

	}

	// generate result BufferGeometry
	const result = geometry.clone();
	for ( const name in geometry.attributes ) {

		const tmpAttribute = tmpAttributes[ name ];

		result.setAttribute( name, new BufferAttribute(
			tmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),
			tmpAttribute.itemSize,
			tmpAttribute.normalized,
		) );

		if ( ! ( name in tmpMorphAttributes ) ) continue;

		for ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {

			const tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];

			result.morphAttributes[ name ][ j ] = new BufferAttribute(
				tmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),
				tmpMorphAttribute.itemSize,
				tmpMorphAttribute.normalized,
			);

		}

	}

	// indices

	result.setIndex( newIndices );

	return result;

}

/**
 * @param {BufferGeometry} geometry
 * @param {number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	if ( drawMode === TrianglesDrawMode ) {

		console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );
		return geometry;

	}

	if ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {

		let index = geometry.getIndex();

		// generate index if not present

		if ( index === null ) {

			const indices = [];

			const position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( let i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		}

		//

		const numberOfTriangles = index.count - 2;
		const newIndices = [];

		if ( drawMode === TriangleFanDrawMode ) {

			// gl.TRIANGLE_FAN

			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP

			for ( let i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );

				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

			console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		}

		// build final geometry

		const newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );
		newGeometry.clearGroups();

		return newGeometry;

	} else {

		console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );
		return geometry;

	}

}

function mergeBufferGeometries( geometries, useGroups = false ) {

	console.warn( 'THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().' ); // @deprecated, r151
	return mergeGeometries( geometries, useGroups );

}

class GLTFLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension$1( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureAVIFExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension$1( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension$1( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension$1( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension$1( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsEmissiveStrengthExtension$1( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension$1( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIridescenceExtension$1( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsAnisotropyExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshGpuInstancing( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let json;
		const extensions = {};
		const plugins = {};
		const textDecoder = new TextDecoder();

		if ( typeof data === 'string' ) {

			json = JSON.parse( data );

		} else if ( data instanceof ArrayBuffer ) {

			const magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				json = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );

			} else {

				json = JSON.parse( textDecoder.decode( data ) );

			}

		} else {

			json = data;

		}

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );
			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension$1();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
	KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_TEXTURE_AVIF: 'EXT_texture_avif',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
	EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new Color( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new DirectionalLight( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		assignExtrasToUserData( lightNode, lightDef );

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	getDependency( type, index ) {

		if ( type !== 'light' ) return;

		return this._loadLight( index );

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension$1 {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */
class GLTFMaterialsEmissiveStrengthExtension$1 {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;

		if ( emissiveStrength !== undefined ) {

			materialParams.emissiveIntensity = emissiveStrength;

		}

		return Promise.resolve();

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension$1 {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */
class GLTFMaterialsIridescenceExtension$1 {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.iridescenceFactor !== undefined ) {

			materialParams.iridescence = extension.iridescenceFactor;

		}

		if ( extension.iridescenceTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );

		}

		if ( extension.iridescenceIor !== undefined ) {

			materialParams.iridescenceIOR = extension.iridescenceIor;

		}

		if ( materialParams.iridescenceThicknessRange === undefined ) {

			materialParams.iridescenceThicknessRange = [ 100, 400 ];

		}

		if ( extension.iridescenceThicknessMinimum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;

		}

		if ( extension.iridescenceThicknessMaximum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;

		}

		if ( extension.iridescenceThicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension$1 {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new Color( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			materialParams.sheenColor.fromArray( extension.sheenColorFactor );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension$1 {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension$1 {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || Infinity;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension$1 {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension$1 {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials anisotropy Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy
 */
class GLTFMaterialsAnisotropyExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.anisotropyStrength !== undefined ) {

			materialParams.anisotropy = extension.anisotropyStrength;

		}

		if ( extension.anisotropyRotation !== undefined ) {

			materialParams.anisotropyRotation = extension.anisotropyRotation;

		}

		if ( extension.anisotropyTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * AVIF Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif
 */
class GLTFTextureAVIFExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image.
				image.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';
				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return buffer.then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const source = new Uint8Array( res, byteOffset, byteLength );

				if ( decoder.decodeGltfBufferAsync ) {

					return decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {

						return res.buffer;

					} );

				} else {

					// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync
					return decoder.ready.then( function () {

						const result = new ArrayBuffer( count * stride );
						decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
						return result;

					} );

				}

			} );

		} else {

			return null;

		}

	}

}

/**
 * GPU Instancing Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
 *
 */
class GLTFMeshGpuInstancing {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
		this.parser = parser;

	}

	createNodeMesh( nodeIndex ) {

		const json = this.parser.json;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||
			nodeDef.mesh === undefined ) {

			return null;

		}

		const meshDef = json.meshes[ nodeDef.mesh ];

		// No Points or Lines + Instancing support yet

		for ( const primitive of meshDef.primitives ) {

			if ( primitive.mode !== WEBGL_CONSTANTS$1.TRIANGLES &&
				 primitive.mode !== WEBGL_CONSTANTS$1.TRIANGLE_STRIP &&
				 primitive.mode !== WEBGL_CONSTANTS$1.TRIANGLE_FAN &&
				 primitive.mode !== undefined ) {

				return null;

			}

		}

		const extensionDef = nodeDef.extensions[ this.name ];
		const attributesDef = extensionDef.attributes;

		// @TODO: Can we support InstancedMesh + SkinnedMesh?

		const pending = [];
		const attributes = {};

		for ( const key in attributesDef ) {

			pending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {

				attributes[ key ] = accessor;
				return attributes[ key ];

			} ) );

		}

		if ( pending.length < 1 ) {

			return null;

		}

		pending.push( this.parser.createNodeMesh( nodeIndex ) );

		return Promise.all( pending ).then( results => {

			const nodeObject = results.pop();
			const meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];
			const count = results[ 0 ].count; // All attribute counts should be same
			const instancedMeshes = [];

			for ( const mesh of meshes ) {

				// Temporal variables
				const m = new Matrix4();
				const p = new Vector3();
				const q = new Quaternion();
				const s = new Vector3( 1, 1, 1 );

				const instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );

				for ( let i = 0; i < count; i ++ ) {

					if ( attributes.TRANSLATION ) {

						p.fromBufferAttribute( attributes.TRANSLATION, i );

					}

					if ( attributes.ROTATION ) {

						q.fromBufferAttribute( attributes.ROTATION, i );

					}

					if ( attributes.SCALE ) {

						s.fromBufferAttribute( attributes.SCALE, i );

					}

					instancedMesh.setMatrixAt( i, m.compose( p, q, s ) );

				}

				// Add instance attributes to the geometry, excluding TRS.
				for ( const attributeName in attributes ) {

					if ( attributeName !== 'TRANSLATION' &&
						 attributeName !== 'ROTATION' &&
						 attributeName !== 'SCALE' ) {

						mesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );

					}

				}

				// Just in case
				Object3D.prototype.copy.call( instancedMesh, mesh );

				this.parser.assignFinalMaterial( instancedMesh );

				instancedMeshes.push( instancedMesh );

			}

			if ( nodeObject.isGroup ) {

				nodeObject.clear();

				nodeObject.add( ... instancedMeshes );

				return nodeObject;

			}

			return instancedMeshes[ 0 ];

		} );

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
		const textDecoder = new TextDecoder();

		this.header = {
			magic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = textDecoder.decode( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType.name;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )
			&& transform.offset === undefined
			&& transform.rotation === undefined
			&& transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.texCoord !== undefined ) {

			texture.channel = transform.texCoord;

		}

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer;
		const values = this.sampleValues;
		const stride = this.valueSize;

		const stride2 = stride * 2;
		const stride3 = stride * 3;

		const td = t1 - t0;

		const p = ( t - t0 ) / td;
		const pp = p * p;
		const ppp = pp * p;

		const offset1 = i1 * stride3;
		const offset0 = offset1 - stride3;

		const s2 = - 2 * ppp + 3 * pp;
		const s3 = ppp - pp;
		const s0 = 1 - s2;
		const s1 = s3 - pp + p;

		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for ( let i = 0; i !== stride; i ++ ) {

			const p0 = values[ offset0 + i + stride ]; // splineVertex_k
			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	}

}

const _q$1 = new Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q$1.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS$1 = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: NearestFilter,
	9729: LinearFilter,
	9984: NearestMipmapNearestFilter,
	9985: LinearMipmapNearestFilter,
	9986: NearestMipmapLinearFilter,
	9987: LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: ClampToEdgeWrapping,
	33648: MirroredRepeatWrapping,
	10497: RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv1',
	TEXCOORD_2: 'uv2',
	TEXCOORD_3: 'uv3',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES$1 = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: InterpolateLinear,
	STEP: InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	let geometryKey;

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	if ( primitiveDef.targets !== undefined ) {

		for ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {

			geometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );

		}

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

	return 'image/png';

}

const _identityMatrix$1 = new Matrix4();

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Node cache
		this.nodeCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.

		let isSafari = false;
		let isFirefox = false;
		let firefoxVersion = - 1;

		if ( typeof navigator !== 'undefined' ) {

			isSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;
			isFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;
			firefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : - 1;

		}

		if ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {

			this.textureLoader = new TextureLoader( this.options.manager );

		} else {

			this.textureLoader = new ImageBitmapLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();
		this.nodeCache = {};

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadNode && ext.loadNode( index );

					} );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadAnimation && ext.loadAnimation( index );

					} );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					dependency = this._invokeOne( function ( ext ) {

						return ext != this && ext.getDependency && ext.getDependency( type, index );

					} );

					if ( ! dependency ) {

						throw new Error( 'Unknown type: ' + type );

					}

					break;

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
			const normalized = accessorDef.normalized === true;

			const array = new TypedArray( accessorDef.count * itemSize );
			return Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture|null>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			texture.name = textureDef.name || sourceDef.name || '';

			if ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {

				texture.name = sourceDef.uri;

			}

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef, colorSpace ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			if ( ! texture ) return null;

			if ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {

				texture = texture.clone();
				texture.channel = mapDef.texCoord;

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			if ( colorSpace !== undefined ) {

				texture.colorSpace = colorSpace;

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new PointsMaterial();
				Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new LineBasicMaterial();
				Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );
				lineMaterial.map = material.map;

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

			materialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );

		}

		return Promise.all( pending ).then( function () {

			const material = new materialType( materialParams );

			if ( materialDef.name ) material.name = materialDef.name;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

		if ( sanitizedName in this.nodeNamesUsed ) {

			return sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );

		} else {

			this.nodeNamesUsed[ sanitizedName ] = 0;

			return sanitizedName;

		}

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new SkinnedMesh( geometry, material )
						: new Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true ) {

						// normalize skin weights to fix malformed assets (see #15319)
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINES ) {

					mesh = new LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINE_STRIP ) {

					mesh = new Line$1( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINE_LOOP ) {

					mesh = new LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.POINTS ) {

					mesh = new Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );

				return meshes[ 0 ];

			}

			const group = new Group$1();

			if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Skeleton>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const pending = [];

		for ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {

			pending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );

		}

		if ( skinDef.inverseBindMatrices !== undefined ) {

			pending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );

		} else {

			pending.push( null );

		}

		return Promise.all( pending ).then( function ( results ) {

			const inverseBindMatrices = results.pop();
			const jointNodes = results;

			// Note that bones (joint nodes) may or may not be in the
			// scene graph at this time.

			const bones = [];
			const boneInverses = [];

			for ( let i = 0, il = jointNodes.length; i < il; i ++ ) {

				const jointNode = jointNodes[ i ];

				if ( jointNode ) {

					bones.push( jointNode );

					const mat = new Matrix4();

					if ( inverseBindMatrices !== null ) {

						mat.fromArray( inverseBindMatrices.array, i * 16 );

					}

					boneInverses.push( mat );

				} else {

					console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[ i ] );

				}

			}

			return new Skeleton( bones, boneInverses );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;
		const parser = this;

		const animationDef = json.animations[ animationIndex ];
		const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node;
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			if ( target.node === undefined ) continue;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				if ( node.updateMatrix ) {

					node.updateMatrix();
					node.matrixAutoUpdate = true;

				}

				const createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );

				if ( createdTracks ) {

					for ( let k = 0; k < createdTracks.length; k ++ ) {

						tracks.push( createdTracks[ k ] );

					}

				}

			}

			return new AnimationClip( animationName, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		const nodePending = parser._loadNodeShallow( nodeIndex );

		const childPending = [];
		const childrenDef = nodeDef.children || [];

		for ( let i = 0, il = childrenDef.length; i < il; i ++ ) {

			childPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );

		}

		const skeletonPending = nodeDef.skin === undefined
			? Promise.resolve( null )
			: parser.getDependency( 'skin', nodeDef.skin );

		return Promise.all( [
			nodePending,
			Promise.all( childPending ),
			skeletonPending
		] ).then( function ( results ) {

			const node = results[ 0 ];
			const children = results[ 1 ];
			const skeleton = results[ 2 ];

			if ( skeleton !== null ) {

				// This full traverse should be fine because
				// child glTF nodes have not been added to this node yet.
				node.traverse( function ( mesh ) {

					if ( ! mesh.isSkinnedMesh ) return;

					mesh.bind( skeleton, _identityMatrix$1 );

				} );

			}

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				node.add( children[ i ] );

			}

			return node;

		} );

	}

	// ._loadNodeShallow() parses a single node.
	// skin and child nodes are created and added in .loadNode() (no '_' prefix).
	_loadNodeShallow( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		// This method is called from .loadNode() and .loadSkin().
		// Cache a node to avoid duplication.

		if ( this.nodeCache[ nodeIndex ] !== undefined ) {

			return this.nodeCache[ nodeIndex ];

		}

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		const pending = [];

		const meshPromise = parser._invokeOne( function ( ext ) {

			return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

		} );

		if ( meshPromise ) {

			pending.push( meshPromise );

		}

		if ( nodeDef.camera !== undefined ) {

			pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

				return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

			} ) );

		}

		parser._invokeAll( function ( ext ) {

			return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

		} ).forEach( function ( promise ) {

			pending.push( promise );

		} );

		this.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new Bone();

			} else if ( objects.length > 1 ) {

				node = new Group$1();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

		return this.nodeCache[ nodeIndex ];

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new Group$1();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( parser.getDependency( 'node', nodeIds[ i ] ) );

		}

		return Promise.all( pending ).then( function ( nodes ) {

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				scene.add( nodes[ i ] );

			}

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof Material || key instanceof Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

	_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {

		const tracks = [];

		const targetName = node.name ? node.name : node.uuid;

		const targetNames = [];

		if ( PATH_PROPERTIES$1[ target.path ] === PATH_PROPERTIES$1.weights ) {

			node.traverse( function ( object ) {

				if ( object.morphTargetInfluences ) {

					targetNames.push( object.name ? object.name : object.uuid );

				}

			} );

		} else {

			targetNames.push( targetName );

		}

		let TypedKeyframeTrack;

		switch ( PATH_PROPERTIES$1[ target.path ] ) {

			case PATH_PROPERTIES$1.weights:

				TypedKeyframeTrack = NumberKeyframeTrack;
				break;

			case PATH_PROPERTIES$1.rotation:

				TypedKeyframeTrack = QuaternionKeyframeTrack;
				break;

			case PATH_PROPERTIES$1.position:
			case PATH_PROPERTIES$1.scale:
			default:
				switch ( outputAccessor.itemSize ) {

					case 1:
						TypedKeyframeTrack = NumberKeyframeTrack;
						break;
					case 2:
					case 3:
						TypedKeyframeTrack = VectorKeyframeTrack;
						break;

				}

				break;

		}

		const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;

		const outputArray = this._getArrayFromAccessor( outputAccessor );

		for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

			const track = new TypedKeyframeTrack(
				targetNames[ j ] + '.' + PATH_PROPERTIES$1[ target.path ],
				inputAccessor.array,
				outputArray,
				interpolation
			);

			// Override interpolation with custom factory method.
			if ( interpolation === 'CUBICSPLINE' ) {

				this._createCubicSplineTrackInterpolant( track );

			}

			tracks.push( track );

		}

		return tracks;

	}

	_getArrayFromAccessor( accessor ) {

		let outputArray = accessor.array;

		if ( accessor.normalized ) {

			const scale = getNormalizedComponentScale( outputArray.constructor );
			const scaled = new Float32Array( outputArray.length );

			for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

				scaled[ j ] = outputArray[ j ] * scale;

			}

			outputArray = scaled;

		}

		return outputArray;

	}

	_createCubicSplineTrackInterpolant( track ) {

		track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

			// A CUBICSPLINE keyframe in glTF has three output values for each input value,
			// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
			// must be divided by three to get the interpolant's sampleSize argument.

			const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

			return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

		};

		// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
		track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

	}

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new Vector3();
		const vector = new Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

const _taskCache = new WeakMap();

class DRACOLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.decoderPath = '';
		this.decoderConfig = {};
		this.decoderBinary = null;
		this.decoderPending = null;

		this.workerLimit = 4;
		this.workerPool = [];
		this.workerNextTaskID = 1;
		this.workerSourceURL = '';

		this.defaultAttributeIDs = {
			position: 'POSITION',
			normal: 'NORMAL',
			color: 'COLOR',
			uv: 'TEX_COORD'
		};
		this.defaultAttributeTypes = {
			position: 'Float32Array',
			normal: 'Float32Array',
			color: 'Float32Array',
			uv: 'Float32Array'
		};

	}

	setDecoderPath( path ) {

		this.decoderPath = path;

		return this;

	}

	setDecoderConfig( config ) {

		this.decoderConfig = config;

		return this;

	}

	setWorkerLimit( workerLimit ) {

		this.workerLimit = workerLimit;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			this.parse( buffer, onLoad, onError );

		}, onProgress, onError );

	}

	parse( buffer, onLoad, onError ) {

		this.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace ).catch( onError );

	}

	decodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace ) {

		const taskConfig = {
			attributeIDs: attributeIDs || this.defaultAttributeIDs,
			attributeTypes: attributeTypes || this.defaultAttributeTypes,
			useUniqueIDs: !! attributeIDs,
			vertexColorSpace: vertexColorSpace,
		};

		return this.decodeGeometry( buffer, taskConfig ).then( callback );

	}

	decodeGeometry( buffer, taskConfig ) {

		const taskKey = JSON.stringify( taskConfig );

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( _taskCache.has( buffer ) ) {

			const cachedTask = _taskCache.get( buffer );

			if ( cachedTask.key === taskKey ) {

				return cachedTask.promise;

			} else if ( buffer.byteLength === 0 ) {

				// Technically, it would be possible to wait for the previous task to complete,
				// transfer the buffer back, and decode again with the second configuration. That
				// is complex, and I don't know of any reason to decode a Draco buffer twice in
				// different ways, so this is left unimplemented.
				throw new Error(

					'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
					'settings. Buffer has already been transferred.'

				);

			}

		}

		//

		let worker;
		const taskID = this.workerNextTaskID ++;
		const taskCost = buffer.byteLength;

		// Obtain a worker and assign a task, and construct a geometry instance
		// when the task completes.
		const geometryPending = this._getWorker( taskID, taskCost )
			.then( ( _worker ) => {

				worker = _worker;

				return new Promise( ( resolve, reject ) => {

					worker._callbacks[ taskID ] = { resolve, reject };

					worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );

					// this.debug();

				} );

			} )
			.then( ( message ) => this._createGeometry( message.geometry ) );

		// Remove task from the task list.
		// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
		geometryPending
			.catch( () => true )
			.then( () => {

				if ( worker && taskID ) {

					this._releaseTask( worker, taskID );

					// this.debug();

				}

			} );

		// Cache the task result.
		_taskCache.set( buffer, {

			key: taskKey,
			promise: geometryPending

		} );

		return geometryPending;

	}

	_createGeometry( geometryData ) {

		const geometry = new BufferGeometry();

		if ( geometryData.index ) {

			geometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );

		}

		for ( let i = 0; i < geometryData.attributes.length; i ++ ) {

			const result = geometryData.attributes[ i ];
			const name = result.name;
			const array = result.array;
			const itemSize = result.itemSize;

			const attribute = new BufferAttribute( array, itemSize );

			if ( name === 'color' ) {

				this._assignVertexColorSpace( attribute, result.vertexColorSpace );

				attribute.normalized = ( array instanceof Float32Array ) === false;

			}

			geometry.setAttribute( name, attribute );

		}

		return geometry;

	}

	_assignVertexColorSpace( attribute, inputColorSpace ) {

		// While .drc files do not specify colorspace, the only 'official' tooling
		// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc
		// file is passed into .load() or .parse(). GLTFLoader uses internal APIs
		// to decode geometry, and vertex colors are already Linear-sRGB in there.

		if ( inputColorSpace !== SRGBColorSpace ) return;

		const _color = new Color();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			_color.fromBufferAttribute( attribute, i ).convertSRGBToLinear();
			attribute.setXYZ( i, _color.r, _color.g, _color.b );

		}

	}

	_loadLibrary( url, responseType ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.decoderPath );
		loader.setResponseType( responseType );
		loader.setWithCredentials( this.withCredentials );

		return new Promise( ( resolve, reject ) => {

			loader.load( url, resolve, undefined, reject );

		} );

	}

	preload() {

		this._initDecoder();

		return this;

	}

	_initDecoder() {

		if ( this.decoderPending ) return this.decoderPending;

		const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
		const librariesPending = [];

		if ( useJS ) {

			librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );

		} else {

			librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );
			librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );

		}

		this.decoderPending = Promise.all( librariesPending )
			.then( ( libraries ) => {

				const jsContent = libraries[ 0 ];

				if ( ! useJS ) {

					this.decoderConfig.wasmBinary = libraries[ 1 ];

				}

				const fn = DRACOWorker.toString();

				const body = [
					'/* draco decoder */',
					jsContent,
					'',
					'/* worker */',
					fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
				].join( '\n' );

				this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

			} );

		return this.decoderPending;

	}

	_getWorker( taskID, taskCost ) {

		return this._initDecoder().then( () => {

			if ( this.workerPool.length < this.workerLimit ) {

				const worker = new Worker( this.workerSourceURL );

				worker._callbacks = {};
				worker._taskCosts = {};
				worker._taskLoad = 0;

				worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );

				worker.onmessage = function ( e ) {

					const message = e.data;

					switch ( message.type ) {

						case 'decode':
							worker._callbacks[ message.id ].resolve( message );
							break;

						case 'error':
							worker._callbacks[ message.id ].reject( message );
							break;

						default:
							console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );

					}

				};

				this.workerPool.push( worker );

			} else {

				this.workerPool.sort( function ( a, b ) {

					return a._taskLoad > b._taskLoad ? - 1 : 1;

				} );

			}

			const worker = this.workerPool[ this.workerPool.length - 1 ];
			worker._taskCosts[ taskID ] = taskCost;
			worker._taskLoad += taskCost;
			return worker;

		} );

	}

	_releaseTask( worker, taskID ) {

		worker._taskLoad -= worker._taskCosts[ taskID ];
		delete worker._callbacks[ taskID ];
		delete worker._taskCosts[ taskID ];

	}

	debug() {

		console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

	}

	dispose() {

		for ( let i = 0; i < this.workerPool.length; ++ i ) {

			this.workerPool[ i ].terminate();

		}

		this.workerPool.length = 0;

		if ( this.workerSourceURL !== '' ) {

			URL.revokeObjectURL( this.workerSourceURL );

		}

		return this;

	}

}

/* WEB WORKER */

function DRACOWorker() {

	let decoderConfig;
	let decoderPending;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				const buffer = message.buffer;
				const taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					const draco = module.draco;
					const decoder = new draco.Decoder();

					try {

						const geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );

						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, array, taskConfig ) {

		const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType( array );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		const geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( const attributeName in attributeIDs ) {

			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and `.drc` files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === - 1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			const attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );

			if ( attributeName === 'color' ) {

				attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;

			}

			geometry.attributes.push( attributeResult );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType( draco, attributeType );

		const ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

}

/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var durl = function (c) { return URL.createObjectURL(new Blob([c], { type: 'text/javascript' })); };
try {
    URL.revokeObjectURL(durl(''));
}
catch (e) {
    // We're in Deno or a very old browser
    durl = function (c) { return 'data:application/javascript;charset=UTF-8,' + encodeURI(c); };
}

// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
// fixed length extra bits
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
// fixed distance extra bits
// see fleb note
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
// code length index map
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
// get base, reverse index map from extra bits
var freb = function (eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new u32(b[30]);
    for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = ((j - b[i]) << 5) | i;
        }
    }
    return [b, r];
};
var _a$1 = freb(fleb, 2), fl = _a$1[0], revfl = _a$1[1];
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b[0];
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for (var i$1 = 0; i$1 < 32768; ++i$1) {
    // reverse table algorithm from SO
    var x = ((i$1 & 0xAAAA) >>> 1) | ((i$1 & 0x5555) << 1);
    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);
    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);
    rev[i$1] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = (function (cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for (; i < s; ++i)
        ++l[cd[i] - 1];
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for (i = 0; i < mb; ++i) {
        le[i] = (le[i - 1] + l[i - 1]) << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = (i << 4) | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >>> rvb] = sv;
                }
            }
        }
    }
    else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
            }
        }
    }
    return co;
});
// fixed length tree
var flt = new u8(288);
for (var i$1 = 0; i$1 < 144; ++i$1)
    flt[i$1] = 8;
for (var i$1 = 144; i$1 < 256; ++i$1)
    flt[i$1] = 9;
for (var i$1 = 256; i$1 < 280; ++i$1)
    flt[i$1] = 7;
for (var i$1 = 280; i$1 < 288; ++i$1)
    flt[i$1] = 8;
// fixed distance tree
var fdt = new u8(32);
for (var i$1 = 0; i$1 < 32; ++i$1)
    fdt[i$1] = 5;
// fixed length map
var flrm = /*#__PURE__*/ hMap(flt, 9, 1);
// fixed distance map
var fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
// find max of array
var max = function (a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
        if (a[i] > m)
            m = a[i];
    }
    return m;
};
// read d, starting at bit p and mask with m
var bits = function (d, p, m) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
};
// read d, starting at bit p continuing for at least 16 bits
var bits16 = function (d, p) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
};
// get end of byte
var shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function (v, s, e) {
    if (s == null || s < 0)
        s = 0;
    if (e == null || e > v.length)
        e = v.length;
    // can't use .constructor in case user-supplied
    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
    n.set(v.subarray(s, e));
    return n;
};
// expands raw DEFLATE data
var inflt = function (dat, buf, st) {
    // source length
    var sl = dat.length;
    if (!sl || (st && !st.l && sl < 5))
        return buf || new u8(0);
    // have to estimate size
    var noBuf = !buf || st;
    // no state
    var noSt = !st || st.i;
    if (!st)
        st = {};
    // Assumes roughly 33% compression ratio average
    if (!buf)
        buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function (l) {
        var bl = buf.length;
        // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            var nbuf = new u8(Math.max(bl * 2, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    };
    //  last chunk         bitpos           bytes
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            st.f = final = bits(dat, pos, 1);
            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                if (t > sl) {
                    if (noSt)
                        throw 'unexpected EOF';
                    break;
                }
                // ensure size
                if (noBuf)
                    cbuf(bt + l);
                // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt);
                // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t * 8;
                continue;
            }
            else if (type == 1)
                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                // length+distance tree
                var ldt = new u8(tl);
                // code length tree
                var clt = new u8(19);
                for (var i = 0; i < hcLen; ++i) {
                    // use index map to get real code
                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
                }
                pos += hcLen * 3;
                // code lengths bits
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                // code lengths map
                var clm = hMap(clt, clb, 1);
                for (var i = 0; i < tl;) {
                    var r = clm[bits(dat, pos, clbmsk)];
                    // bits read
                    pos += r & 15;
                    // symbol
                    var s = r >>> 4;
                    // code length to copy
                    if (s < 16) {
                        ldt[i++] = s;
                    }
                    else {
                        //  copy   count
                        var c = 0, n = 0;
                        if (s == 16)
                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                        else if (s == 17)
                            n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s == 18)
                            n = 11 + bits(dat, pos, 127), pos += 7;
                        while (n--)
                            ldt[i++] = c;
                    }
                }
                //    length tree                 distance tree
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                // max length bits
                lbt = max(lt);
                // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            }
            else
                throw 'invalid block type';
            if (pos > tbts) {
                if (noSt)
                    throw 'unexpected EOF';
                break;
            }
        }
        // Make sure the buffer can hold this + the largest possible addition
        // Maximum chunk size (practically, theoretically infinite) is 2^17;
        if (noBuf)
            cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (;; lpos = pos) {
            // bits read, code
            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
            pos += c & 15;
            if (pos > tbts) {
                if (noSt)
                    throw 'unexpected EOF';
                break;
            }
            if (!c)
                throw 'invalid length/literal';
            if (sym < 256)
                buf[bt++] = sym;
            else if (sym == 256) {
                lpos = pos, lm = null;
                break;
            }
            else {
                var add = sym - 254;
                // no extra bits needed if less
                if (sym > 264) {
                    // index
                    var i = sym - 257, b = fleb[i];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                    pos += b;
                }
                // dist
                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                if (!d)
                    throw 'invalid distance';
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                    var b = fdeb[dsym];
                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
                }
                if (pos > tbts) {
                    if (noSt)
                        throw 'unexpected EOF';
                    break;
                }
                if (noBuf)
                    cbuf(bt + 131072);
                var end = bt + add;
                for (; bt < end; bt += 4) {
                    buf[bt] = buf[bt - dt];
                    buf[bt + 1] = buf[bt + 1 - dt];
                    buf[bt + 2] = buf[bt + 2 - dt];
                    buf[bt + 3] = buf[bt + 3 - dt];
                }
                bt = end;
            }
        }
        st.l = lm, st.p = lpos, st.b = bt;
        if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
};
// empty
var et = /*#__PURE__*/ new u8(0);
// zlib valid
var zlv = function (d) {
    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
        throw 'invalid zlib data';
    if (d[1] & 32)
        throw 'invalid zlib data: preset dictionaries not supported';
};
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */
function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
}
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et, { stream: true });
    tds = 1;
}
catch (e) { }

/**
 * NURBS utils
 *
 * See NURBSCurve and NURBSSurface.
 **/


/**************************************************************
 *	NURBS Utils
 **************************************************************/

/*
Finds knot vector span.

p : degree
u : parametric value
U : knot vector

returns the span
*/
function findSpan( p, u, U ) {

	const n = U.length - p - 1;

	if ( u >= U[ n ] ) {

		return n - 1;

	}

	if ( u <= U[ p ] ) {

		return p;

	}

	let low = p;
	let high = n;
	let mid = Math.floor( ( low + high ) / 2 );

	while ( u < U[ mid ] || u >= U[ mid + 1 ] ) {

		if ( u < U[ mid ] ) {

			high = mid;

		} else {

			low = mid;

		}

		mid = Math.floor( ( low + high ) / 2 );

	}

	return mid;

}


/*
Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2

span : span in which u lies
u    : parametric point
p    : degree
U    : knot vector

returns array[p+1] with basis functions values.
*/
function calcBasisFunctions( span, u, p, U ) {

	const N = [];
	const left = [];
	const right = [];
	N[ 0 ] = 1.0;

	for ( let j = 1; j <= p; ++ j ) {

		left[ j ] = u - U[ span + 1 - j ];
		right[ j ] = U[ span + j ] - u;

		let saved = 0.0;

		for ( let r = 0; r < j; ++ r ) {

			const rv = right[ r + 1 ];
			const lv = left[ j - r ];
			const temp = N[ r ] / ( rv + lv );
			N[ r ] = saved + rv * temp;
			saved = lv * temp;

		}

		N[ j ] = saved;

	}

	return N;

}


/*
Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

p : degree of B-Spline
U : knot vector
P : control points (x, y, z, w)
u : parametric point

returns point for given u
*/
function calcBSplinePoint( p, U, P, u ) {

	const span = findSpan( p, u, U );
	const N = calcBasisFunctions( span, u, p, U );
	const C = new Vector4( 0, 0, 0, 0 );

	for ( let j = 0; j <= p; ++ j ) {

		const point = P[ span - p + j ];
		const Nj = N[ j ];
		const wNj = point.w * Nj;
		C.x += point.x * wNj;
		C.y += point.y * wNj;
		C.z += point.z * wNj;
		C.w += point.w * Nj;

	}

	return C;

}


/*
Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

span : span in which u lies
u    : parametric point
p    : degree
n    : number of derivatives to calculate
U    : knot vector

returns array[n+1][p+1] with basis functions derivatives
*/
function calcBasisFunctionDerivatives( span, u, p, n, U ) {

	const zeroArr = [];
	for ( let i = 0; i <= p; ++ i )
		zeroArr[ i ] = 0.0;

	const ders = [];

	for ( let i = 0; i <= n; ++ i )
		ders[ i ] = zeroArr.slice( 0 );

	const ndu = [];

	for ( let i = 0; i <= p; ++ i )
		ndu[ i ] = zeroArr.slice( 0 );

	ndu[ 0 ][ 0 ] = 1.0;

	const left = zeroArr.slice( 0 );
	const right = zeroArr.slice( 0 );

	for ( let j = 1; j <= p; ++ j ) {

		left[ j ] = u - U[ span + 1 - j ];
		right[ j ] = U[ span + j ] - u;

		let saved = 0.0;

		for ( let r = 0; r < j; ++ r ) {

			const rv = right[ r + 1 ];
			const lv = left[ j - r ];
			ndu[ j ][ r ] = rv + lv;

			const temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];
			ndu[ r ][ j ] = saved + rv * temp;
			saved = lv * temp;

		}

		ndu[ j ][ j ] = saved;

	}

	for ( let j = 0; j <= p; ++ j ) {

		ders[ 0 ][ j ] = ndu[ j ][ p ];

	}

	for ( let r = 0; r <= p; ++ r ) {

		let s1 = 0;
		let s2 = 1;

		const a = [];
		for ( let i = 0; i <= p; ++ i ) {

			a[ i ] = zeroArr.slice( 0 );

		}

		a[ 0 ][ 0 ] = 1.0;

		for ( let k = 1; k <= n; ++ k ) {

			let d = 0.0;
			const rk = r - k;
			const pk = p - k;

			if ( r >= k ) {

				a[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];
				d = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];

			}

			const j1 = ( rk >= - 1 ) ? 1 : - rk;
			const j2 = ( r - 1 <= pk ) ? k - 1 : p - r;

			for ( let j = j1; j <= j2; ++ j ) {

				a[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];
				d += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];

			}

			if ( r <= pk ) {

				a[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];
				d += a[ s2 ][ k ] * ndu[ r ][ pk ];

			}

			ders[ k ][ r ] = d;

			const j = s1;
			s1 = s2;
			s2 = j;

		}

	}

	let r = p;

	for ( let k = 1; k <= n; ++ k ) {

		for ( let j = 0; j <= p; ++ j ) {

			ders[ k ][ j ] *= r;

		}

		r *= p - k;

	}

	return ders;

}


/*
	Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

	p  : degree
	U  : knot vector
	P  : control points
	u  : Parametric points
	nd : number of derivatives

	returns array[d+1] with derivatives
	*/
function calcBSplineDerivatives( p, U, P, u, nd ) {

	const du = nd < p ? nd : p;
	const CK = [];
	const span = findSpan( p, u, U );
	const nders = calcBasisFunctionDerivatives( span, u, p, du, U );
	const Pw = [];

	for ( let i = 0; i < P.length; ++ i ) {

		const point = P[ i ].clone();
		const w = point.w;

		point.x *= w;
		point.y *= w;
		point.z *= w;

		Pw[ i ] = point;

	}

	for ( let k = 0; k <= du; ++ k ) {

		const point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );

		for ( let j = 1; j <= p; ++ j ) {

			point.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );

		}

		CK[ k ] = point;

	}

	for ( let k = du + 1; k <= nd + 1; ++ k ) {

		CK[ k ] = new Vector4( 0, 0, 0 );

	}

	return CK;

}


/*
Calculate "K over I"

returns k!/(i!(k-i)!)
*/
function calcKoverI( k, i ) {

	let nom = 1;

	for ( let j = 2; j <= k; ++ j ) {

		nom *= j;

	}

	let denom = 1;

	for ( let j = 2; j <= i; ++ j ) {

		denom *= j;

	}

	for ( let j = 2; j <= k - i; ++ j ) {

		denom *= j;

	}

	return nom / denom;

}


/*
Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

Pders : result of function calcBSplineDerivatives

returns array with derivatives for rational curve.
*/
function calcRationalCurveDerivatives( Pders ) {

	const nd = Pders.length;
	const Aders = [];
	const wders = [];

	for ( let i = 0; i < nd; ++ i ) {

		const point = Pders[ i ];
		Aders[ i ] = new Vector3( point.x, point.y, point.z );
		wders[ i ] = point.w;

	}

	const CK = [];

	for ( let k = 0; k < nd; ++ k ) {

		const v = Aders[ k ].clone();

		for ( let i = 1; i <= k; ++ i ) {

			v.sub( CK[ k - i ].clone().multiplyScalar( calcKoverI( k, i ) * wders[ i ] ) );

		}

		CK[ k ] = v.divideScalar( wders[ 0 ] );

	}

	return CK;

}


/*
Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

p  : degree
U  : knot vector
P  : control points in homogeneous space
u  : parametric points
nd : number of derivatives

returns array with derivatives.
*/
function calcNURBSDerivatives( p, U, P, u, nd ) {

	const Pders = calcBSplineDerivatives( p, U, P, u, nd );
	return calcRationalCurveDerivatives( Pders );

}

/**
 * NURBS curve object
 *
 * Derives from Curve, overriding getPoint and getTangent.
 *
 * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.
 *
 **/

class NURBSCurve extends Curve {

	constructor(
		degree,
		knots /* array of reals */,
		controlPoints /* array of Vector(2|3|4) */,
		startKnot /* index in knots */,
		endKnot /* index in knots */
	) {

		super();

		this.degree = degree;
		this.knots = knots;
		this.controlPoints = [];
		// Used by periodic NURBS to remove hidden spans
		this.startKnot = startKnot || 0;
		this.endKnot = endKnot || ( this.knots.length - 1 );

		for ( let i = 0; i < controlPoints.length; ++ i ) {

			// ensure Vector4 for control points
			const point = controlPoints[ i ];
			this.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );

		}

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u

		// following results in (wx, wy, wz, w) homogeneous point
		const hpoint = calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );

		if ( hpoint.w !== 1.0 ) {

			// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)
			hpoint.divideScalar( hpoint.w );

		}

		return point.set( hpoint.x, hpoint.y, hpoint.z );

	}

	getTangent( t, optionalTarget = new Vector3() ) {

		const tangent = optionalTarget;

		const u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );
		const ders = calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );
		tangent.copy( ders[ 1 ] ).normalize();

		return tangent;

	}

}

/**
 * Loader loads FBX file and generates Group representing FBX scene.
 * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format
 * Versions lower than this may load but will probably have errors
 *
 * Needs Support:
 *  Morph normals / blend shape normals
 *
 * FBX format references:
 * 	https://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)
 *
 * Binary format specification:
 *	https://code.blender.org/2013/08/fbx-binary-file-format-specification/
 */


let fbxTree;
let connections;
let sceneGraph;

class FBXLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;

		const loader = new FileLoader( this.manager );
		loader.setPath( scope.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		loader.load( url, function ( buffer ) {

			try {

				onLoad( scope.parse( buffer, path ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( FBXBuffer, path ) {

		if ( isFbxFormatBinary( FBXBuffer ) ) {

			fbxTree = new BinaryParser().parse( FBXBuffer );

		} else {

			const FBXText = convertArrayBufferToString( FBXBuffer );

			if ( ! isFbxFormatASCII( FBXText ) ) {

				throw new Error( 'THREE.FBXLoader: Unknown format.' );

			}

			if ( getFbxVersion( FBXText ) < 7000 ) {

				throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );

			}

			fbxTree = new TextParser().parse( FBXText );

		}

		// console.log( fbxTree );

		const textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

		return new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );

	}

}

// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group
class FBXTreeParser {

	constructor( textureLoader, manager ) {

		this.textureLoader = textureLoader;
		this.manager = manager;

	}

	parse() {

		connections = this.parseConnections();

		const images = this.parseImages();
		const textures = this.parseTextures( images );
		const materials = this.parseMaterials( textures );
		const deformers = this.parseDeformers();
		const geometryMap = new GeometryParser().parse( deformers );

		this.parseScene( deformers, geometryMap, materials );

		return sceneGraph;

	}

	// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
	// and details the connection type
	parseConnections() {

		const connectionMap = new Map();

		if ( 'Connections' in fbxTree ) {

			const rawConnections = fbxTree.Connections.connections;

			rawConnections.forEach( function ( rawConnection ) {

				const fromID = rawConnection[ 0 ];
				const toID = rawConnection[ 1 ];
				const relationship = rawConnection[ 2 ];

				if ( ! connectionMap.has( fromID ) ) {

					connectionMap.set( fromID, {
						parents: [],
						children: []
					} );

				}

				const parentRelationship = { ID: toID, relationship: relationship };
				connectionMap.get( fromID ).parents.push( parentRelationship );

				if ( ! connectionMap.has( toID ) ) {

					connectionMap.set( toID, {
						parents: [],
						children: []
					} );

				}

				const childRelationship = { ID: fromID, relationship: relationship };
				connectionMap.get( toID ).children.push( childRelationship );

			} );

		}

		return connectionMap;

	}

	// Parse FBXTree.Objects.Video for embedded image data
	// These images are connected to textures in FBXTree.Objects.Textures
	// via FBXTree.Connections.
	parseImages() {

		const images = {};
		const blobs = {};

		if ( 'Video' in fbxTree.Objects ) {

			const videoNodes = fbxTree.Objects.Video;

			for ( const nodeID in videoNodes ) {

				const videoNode = videoNodes[ nodeID ];

				const id = parseInt( nodeID );

				images[ id ] = videoNode.RelativeFilename || videoNode.Filename;

				// raw image data is in videoNode.Content
				if ( 'Content' in videoNode ) {

					const arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );
					const base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );

					if ( arrayBufferContent || base64Content ) {

						const image = this.parseImage( videoNodes[ nodeID ] );

						blobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;

					}

				}

			}

		}

		for ( const id in images ) {

			const filename = images[ id ];

			if ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];
			else images[ id ] = images[ id ].split( '\\' ).pop();

		}

		return images;

	}

	// Parse embedded image data in FBXTree.Video.Content
	parseImage( videoNode ) {

		const content = videoNode.Content;
		const fileName = videoNode.RelativeFilename || videoNode.Filename;
		const extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();

		let type;

		switch ( extension ) {

			case 'bmp':

				type = 'image/bmp';
				break;

			case 'jpg':
			case 'jpeg':

				type = 'image/jpeg';
				break;

			case 'png':

				type = 'image/png';
				break;

			case 'tif':

				type = 'image/tiff';
				break;

			case 'tga':

				if ( this.manager.getHandler( '.tga' ) === null ) {

					console.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );

				}

				type = 'image/tga';
				break;

			default:

				console.warn( 'FBXLoader: Image type "' + extension + '" is not supported.' );
				return;

		}

		if ( typeof content === 'string' ) { // ASCII format

			return 'data:' + type + ';base64,' + content;

		} else { // Binary Format

			const array = new Uint8Array( content );
			return window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );

		}

	}

	// Parse nodes in FBXTree.Objects.Texture
	// These contain details such as UV scaling, cropping, rotation etc and are connected
	// to images in FBXTree.Objects.Video
	parseTextures( images ) {

		const textureMap = new Map();

		if ( 'Texture' in fbxTree.Objects ) {

			const textureNodes = fbxTree.Objects.Texture;
			for ( const nodeID in textureNodes ) {

				const texture = this.parseTexture( textureNodes[ nodeID ], images );
				textureMap.set( parseInt( nodeID ), texture );

			}

		}

		return textureMap;

	}

	// Parse individual node in FBXTree.Objects.Texture
	parseTexture( textureNode, images ) {

		const texture = this.loadTexture( textureNode, images );

		texture.ID = textureNode.id;

		texture.name = textureNode.attrName;

		const wrapModeU = textureNode.WrapModeU;
		const wrapModeV = textureNode.WrapModeV;

		const valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
		const valueV = wrapModeV !== undefined ? wrapModeV.value : 0;

		// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
		// 0: repeat(default), 1: clamp

		texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
		texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;

		if ( 'Scaling' in textureNode ) {

			const values = textureNode.Scaling.value;

			texture.repeat.x = values[ 0 ];
			texture.repeat.y = values[ 1 ];

		}

		if ( 'Translation' in textureNode ) {

			const values = textureNode.Translation.value;

			texture.offset.x = values[ 0 ];
			texture.offset.y = values[ 1 ];

		}

		return texture;

	}

	// load a texture specified as a blob or data URI, or via an external URL using TextureLoader
	loadTexture( textureNode, images ) {

		let fileName;

		const currentPath = this.textureLoader.path;

		const children = connections.get( textureNode.id ).children;

		if ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {

			fileName = images[ children[ 0 ].ID ];

			if ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {

				this.textureLoader.setPath( undefined );

			}

		}

		let texture;

		const extension = textureNode.FileName.slice( - 3 ).toLowerCase();

		if ( extension === 'tga' ) {

			const loader = this.manager.getHandler( '.tga' );

			if ( loader === null ) {

				console.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename );
				texture = new Texture();

			} else {

				loader.setPath( this.textureLoader.path );
				texture = loader.load( fileName );

			}

		} else if ( extension === 'psd' ) {

			console.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename );
			texture = new Texture();

		} else {

			texture = this.textureLoader.load( fileName );

		}

		this.textureLoader.setPath( currentPath );

		return texture;

	}

	// Parse nodes in FBXTree.Objects.Material
	parseMaterials( textureMap ) {

		const materialMap = new Map();

		if ( 'Material' in fbxTree.Objects ) {

			const materialNodes = fbxTree.Objects.Material;

			for ( const nodeID in materialNodes ) {

				const material = this.parseMaterial( materialNodes[ nodeID ], textureMap );

				if ( material !== null ) materialMap.set( parseInt( nodeID ), material );

			}

		}

		return materialMap;

	}

	// Parse single node in FBXTree.Objects.Material
	// Materials are connected to texture maps in FBXTree.Objects.Textures
	// FBX format currently only supports Lambert and Phong shading models
	parseMaterial( materialNode, textureMap ) {

		const ID = materialNode.id;
		const name = materialNode.attrName;
		let type = materialNode.ShadingModel;

		// Case where FBX wraps shading model in property object.
		if ( typeof type === 'object' ) {

			type = type.value;

		}

		// Ignore unused materials which don't have any connections.
		if ( ! connections.has( ID ) ) return null;

		const parameters = this.parseParameters( materialNode, textureMap, ID );

		let material;

		switch ( type.toLowerCase() ) {

			case 'phong':
				material = new MeshPhongMaterial();
				break;
			case 'lambert':
				material = new MeshLambertMaterial();
				break;
			default:
				console.warn( 'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type );
				material = new MeshPhongMaterial();
				break;

		}

		material.setValues( parameters );
		material.name = name;

		return material;

	}

	// Parse FBX material and return parameters suitable for a three.js material
	// Also parse the texture map and return any textures associated with the material
	parseParameters( materialNode, textureMap, ID ) {

		const parameters = {};

		if ( materialNode.BumpFactor ) {

			parameters.bumpScale = materialNode.BumpFactor.value;

		}

		if ( materialNode.Diffuse ) {

			parameters.color = new Color().fromArray( materialNode.Diffuse.value ).convertSRGBToLinear();

		} else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {

			// The blender exporter exports diffuse here instead of in materialNode.Diffuse
			parameters.color = new Color().fromArray( materialNode.DiffuseColor.value ).convertSRGBToLinear();

		}

		if ( materialNode.DisplacementFactor ) {

			parameters.displacementScale = materialNode.DisplacementFactor.value;

		}

		if ( materialNode.Emissive ) {

			parameters.emissive = new Color().fromArray( materialNode.Emissive.value ).convertSRGBToLinear();

		} else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {

			// The blender exporter exports emissive color here instead of in materialNode.Emissive
			parameters.emissive = new Color().fromArray( materialNode.EmissiveColor.value ).convertSRGBToLinear();

		}

		if ( materialNode.EmissiveFactor ) {

			parameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );

		}

		if ( materialNode.Opacity ) {

			parameters.opacity = parseFloat( materialNode.Opacity.value );

		}

		if ( parameters.opacity < 1.0 ) {

			parameters.transparent = true;

		}

		if ( materialNode.ReflectionFactor ) {

			parameters.reflectivity = materialNode.ReflectionFactor.value;

		}

		if ( materialNode.Shininess ) {

			parameters.shininess = materialNode.Shininess.value;

		}

		if ( materialNode.Specular ) {

			parameters.specular = new Color().fromArray( materialNode.Specular.value ).convertSRGBToLinear();

		} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {

			// The blender exporter exports specular color here instead of in materialNode.Specular
			parameters.specular = new Color().fromArray( materialNode.SpecularColor.value ).convertSRGBToLinear();

		}

		const scope = this;
		connections.get( ID ).children.forEach( function ( child ) {

			const type = child.relationship;

			switch ( type ) {

				case 'Bump':
					parameters.bumpMap = scope.getTexture( textureMap, child.ID );
					break;

				case 'Maya|TEX_ao_map':
					parameters.aoMap = scope.getTexture( textureMap, child.ID );
					break;

				case 'DiffuseColor':
				case 'Maya|TEX_color_map':
					parameters.map = scope.getTexture( textureMap, child.ID );
					if ( parameters.map !== undefined ) {

						parameters.map.colorSpace = SRGBColorSpace;

					}

					break;

				case 'DisplacementColor':
					parameters.displacementMap = scope.getTexture( textureMap, child.ID );
					break;

				case 'EmissiveColor':
					parameters.emissiveMap = scope.getTexture( textureMap, child.ID );
					if ( parameters.emissiveMap !== undefined ) {

						parameters.emissiveMap.colorSpace = SRGBColorSpace;

					}

					break;

				case 'NormalMap':
				case 'Maya|TEX_normal_map':
					parameters.normalMap = scope.getTexture( textureMap, child.ID );
					break;

				case 'ReflectionColor':
					parameters.envMap = scope.getTexture( textureMap, child.ID );
					if ( parameters.envMap !== undefined ) {

						parameters.envMap.mapping = EquirectangularReflectionMapping;
						parameters.envMap.colorSpace = SRGBColorSpace;

					}

					break;

				case 'SpecularColor':
					parameters.specularMap = scope.getTexture( textureMap, child.ID );
					if ( parameters.specularMap !== undefined ) {

						parameters.specularMap.colorSpace = SRGBColorSpace;

					}

					break;

				case 'TransparentColor':
				case 'TransparencyFactor':
					parameters.alphaMap = scope.getTexture( textureMap, child.ID );
					parameters.transparent = true;
					break;

				case 'AmbientColor':
				case 'ShininessExponent': // AKA glossiness map
				case 'SpecularFactor': // AKA specularLevel
				case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor
				default:
					console.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );
					break;

			}

		} );

		return parameters;

	}

	// get a texture from the textureMap for use by a material.
	getTexture( textureMap, id ) {

		// if the texture is a layered texture, just use the first layer and issue a warning
		if ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {

			console.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );
			id = connections.get( id ).children[ 0 ].ID;

		}

		return textureMap.get( id );

	}

	// Parse nodes in FBXTree.Objects.Deformer
	// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
	// Generates map of Skeleton-like objects for use later when generating and binding skeletons.
	parseDeformers() {

		const skeletons = {};
		const morphTargets = {};

		if ( 'Deformer' in fbxTree.Objects ) {

			const DeformerNodes = fbxTree.Objects.Deformer;

			for ( const nodeID in DeformerNodes ) {

				const deformerNode = DeformerNodes[ nodeID ];

				const relationships = connections.get( parseInt( nodeID ) );

				if ( deformerNode.attrType === 'Skin' ) {

					const skeleton = this.parseSkeleton( relationships, DeformerNodes );
					skeleton.ID = nodeID;

					if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );
					skeleton.geometryID = relationships.parents[ 0 ].ID;

					skeletons[ nodeID ] = skeleton;

				} else if ( deformerNode.attrType === 'BlendShape' ) {

					const morphTarget = {
						id: nodeID,
					};

					morphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );
					morphTarget.id = nodeID;

					if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );

					morphTargets[ nodeID ] = morphTarget;

				}

			}

		}

		return {

			skeletons: skeletons,
			morphTargets: morphTargets,

		};

	}

	// Parse single nodes in FBXTree.Objects.Deformer
	// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
	// Each skin node represents a skeleton and each cluster node represents a bone
	parseSkeleton( relationships, deformerNodes ) {

		const rawBones = [];

		relationships.children.forEach( function ( child ) {

			const boneNode = deformerNodes[ child.ID ];

			if ( boneNode.attrType !== 'Cluster' ) return;

			const rawBone = {

				ID: child.ID,
				indices: [],
				weights: [],
				transformLink: new Matrix4().fromArray( boneNode.TransformLink.a ),
				// transform: new Matrix4().fromArray( boneNode.Transform.a ),
				// linkMode: boneNode.Mode,

			};

			if ( 'Indexes' in boneNode ) {

				rawBone.indices = boneNode.Indexes.a;
				rawBone.weights = boneNode.Weights.a;

			}

			rawBones.push( rawBone );

		} );

		return {

			rawBones: rawBones,
			bones: []

		};

	}

	// The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
	parseMorphTargets( relationships, deformerNodes ) {

		const rawMorphTargets = [];

		for ( let i = 0; i < relationships.children.length; i ++ ) {

			const child = relationships.children[ i ];

			const morphTargetNode = deformerNodes[ child.ID ];

			const rawMorphTarget = {

				name: morphTargetNode.attrName,
				initialWeight: morphTargetNode.DeformPercent,
				id: morphTargetNode.id,
				fullWeights: morphTargetNode.FullWeights.a

			};

			if ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;

			rawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {

				return child.relationship === undefined;

			} )[ 0 ].ID;

			rawMorphTargets.push( rawMorphTarget );

		}

		return rawMorphTargets;

	}

	// create the main Group() to be returned by the loader
	parseScene( deformers, geometryMap, materialMap ) {

		sceneGraph = new Group$1();

		const modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );

		const modelNodes = fbxTree.Objects.Model;

		const scope = this;
		modelMap.forEach( function ( model ) {

			const modelNode = modelNodes[ model.ID ];
			scope.setLookAtProperties( model, modelNode );

			const parentConnections = connections.get( model.ID ).parents;

			parentConnections.forEach( function ( connection ) {

				const parent = modelMap.get( connection.ID );
				if ( parent !== undefined ) parent.add( model );

			} );

			if ( model.parent === null ) {

				sceneGraph.add( model );

			}


		} );

		this.bindSkeleton( deformers.skeletons, geometryMap, modelMap );

		this.createAmbientLight();

		sceneGraph.traverse( function ( node ) {

			if ( node.userData.transformData ) {

				if ( node.parent ) {

					node.userData.transformData.parentMatrix = node.parent.matrix;
					node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;

				}

				const transform = generateTransform( node.userData.transformData );

				node.applyMatrix4( transform );
				node.updateWorldMatrix();

			}

		} );

		const animations = new AnimationParser().parse();

		// if all the models where already combined in a single group, just return that
		if ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {

			sceneGraph.children[ 0 ].animations = animations;
			sceneGraph = sceneGraph.children[ 0 ];

		}

		sceneGraph.animations = animations;

	}

	// parse nodes in FBXTree.Objects.Model
	parseModels( skeletons, geometryMap, materialMap ) {

		const modelMap = new Map();
		const modelNodes = fbxTree.Objects.Model;

		for ( const nodeID in modelNodes ) {

			const id = parseInt( nodeID );
			const node = modelNodes[ nodeID ];
			const relationships = connections.get( id );

			let model = this.buildSkeleton( relationships, skeletons, id, node.attrName );

			if ( ! model ) {

				switch ( node.attrType ) {

					case 'Camera':
						model = this.createCamera( relationships );
						break;
					case 'Light':
						model = this.createLight( relationships );
						break;
					case 'Mesh':
						model = this.createMesh( relationships, geometryMap, materialMap );
						break;
					case 'NurbsCurve':
						model = this.createCurve( relationships, geometryMap );
						break;
					case 'LimbNode':
					case 'Root':
						model = new Bone();
						break;
					case 'Null':
					default:
						model = new Group$1();
						break;

				}

				model.name = node.attrName ? PropertyBinding.sanitizeNodeName( node.attrName ) : '';

				model.ID = id;

			}

			this.getTransformData( model, node );
			modelMap.set( id, model );

		}

		return modelMap;

	}

	buildSkeleton( relationships, skeletons, id, name ) {

		let bone = null;

		relationships.parents.forEach( function ( parent ) {

			for ( const ID in skeletons ) {

				const skeleton = skeletons[ ID ];

				skeleton.rawBones.forEach( function ( rawBone, i ) {

					if ( rawBone.ID === parent.ID ) {

						const subBone = bone;
						bone = new Bone();

						bone.matrixWorld.copy( rawBone.transformLink );

						// set name and id here - otherwise in cases where "subBone" is created it will not have a name / id

						bone.name = name ? PropertyBinding.sanitizeNodeName( name ) : '';
						bone.ID = id;

						skeleton.bones[ i ] = bone;

						// In cases where a bone is shared between multiple meshes
						// duplicate the bone here and and it as a child of the first bone
						if ( subBone !== null ) {

							bone.add( subBone );

						}

					}

				} );

			}

		} );

		return bone;

	}

	// create a PerspectiveCamera or OrthographicCamera
	createCamera( relationships ) {

		let model;
		let cameraAttribute;

		relationships.children.forEach( function ( child ) {

			const attr = fbxTree.Objects.NodeAttribute[ child.ID ];

			if ( attr !== undefined ) {

				cameraAttribute = attr;

			}

		} );

		if ( cameraAttribute === undefined ) {

			model = new Object3D();

		} else {

			let type = 0;
			if ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {

				type = 1;

			}

			let nearClippingPlane = 1;
			if ( cameraAttribute.NearPlane !== undefined ) {

				nearClippingPlane = cameraAttribute.NearPlane.value / 1000;

			}

			let farClippingPlane = 1000;
			if ( cameraAttribute.FarPlane !== undefined ) {

				farClippingPlane = cameraAttribute.FarPlane.value / 1000;

			}


			let width = window.innerWidth;
			let height = window.innerHeight;

			if ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {

				width = cameraAttribute.AspectWidth.value;
				height = cameraAttribute.AspectHeight.value;

			}

			const aspect = width / height;

			let fov = 45;
			if ( cameraAttribute.FieldOfView !== undefined ) {

				fov = cameraAttribute.FieldOfView.value;

			}

			const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;

			switch ( type ) {

				case 0: // Perspective
					model = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );
					if ( focalLength !== null ) model.setFocalLength( focalLength );
					break;

				case 1: // Orthographic
					model = new OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );
					break;

				default:
					console.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );
					model = new Object3D();
					break;

			}

		}

		return model;

	}

	// Create a DirectionalLight, PointLight or SpotLight
	createLight( relationships ) {

		let model;
		let lightAttribute;

		relationships.children.forEach( function ( child ) {

			const attr = fbxTree.Objects.NodeAttribute[ child.ID ];

			if ( attr !== undefined ) {

				lightAttribute = attr;

			}

		} );

		if ( lightAttribute === undefined ) {

			model = new Object3D();

		} else {

			let type;

			// LightType can be undefined for Point lights
			if ( lightAttribute.LightType === undefined ) {

				type = 0;

			} else {

				type = lightAttribute.LightType.value;

			}

			let color = 0xffffff;

			if ( lightAttribute.Color !== undefined ) {

				color = new Color().fromArray( lightAttribute.Color.value ).convertSRGBToLinear();

			}

			let intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;

			// light disabled
			if ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {

				intensity = 0;

			}

			let distance = 0;
			if ( lightAttribute.FarAttenuationEnd !== undefined ) {

				if ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {

					distance = 0;

				} else {

					distance = lightAttribute.FarAttenuationEnd.value;

				}

			}

			// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
			const decay = 1;

			switch ( type ) {

				case 0: // Point
					model = new PointLight( color, intensity, distance, decay );
					break;

				case 1: // Directional
					model = new DirectionalLight( color, intensity );
					break;

				case 2: // Spot
					let angle = Math.PI / 3;

					if ( lightAttribute.InnerAngle !== undefined ) {

						angle = MathUtils.degToRad( lightAttribute.InnerAngle.value );

					}

					let penumbra = 0;
					if ( lightAttribute.OuterAngle !== undefined ) {

						// TODO: this is not correct - FBX calculates outer and inner angle in degrees
						// with OuterAngle > InnerAngle && OuterAngle <= Math.PI
						// while three.js uses a penumbra between (0, 1) to attenuate the inner angle
						penumbra = MathUtils.degToRad( lightAttribute.OuterAngle.value );
						penumbra = Math.max( penumbra, 1 );

					}

					model = new SpotLight( color, intensity, distance, angle, penumbra, decay );
					break;

				default:
					console.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );
					model = new PointLight( color, intensity );
					break;

			}

			if ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {

				model.castShadow = true;

			}

		}

		return model;

	}

	createMesh( relationships, geometryMap, materialMap ) {

		let model;
		let geometry = null;
		let material = null;
		const materials = [];

		// get geometry and materials(s) from connections
		relationships.children.forEach( function ( child ) {

			if ( geometryMap.has( child.ID ) ) {

				geometry = geometryMap.get( child.ID );

			}

			if ( materialMap.has( child.ID ) ) {

				materials.push( materialMap.get( child.ID ) );

			}

		} );

		if ( materials.length > 1 ) {

			material = materials;

		} else if ( materials.length > 0 ) {

			material = materials[ 0 ];

		} else {

			material = new MeshPhongMaterial( { color: 0xcccccc } );
			materials.push( material );

		}

		if ( 'color' in geometry.attributes ) {

			materials.forEach( function ( material ) {

				material.vertexColors = true;

			} );

		}

		if ( geometry.FBX_Deformer ) {

			model = new SkinnedMesh( geometry, material );
			model.normalizeSkinWeights();

		} else {

			model = new Mesh( geometry, material );

		}

		return model;

	}

	createCurve( relationships, geometryMap ) {

		const geometry = relationships.children.reduce( function ( geo, child ) {

			if ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );

			return geo;

		}, null );

		// FBX does not list materials for Nurbs lines, so we'll just put our own in here.
		const material = new LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );
		return new Line$1( geometry, material );

	}

	// parse the model node for transform data
	getTransformData( model, modelNode ) {

		const transformData = {};

		if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );

		if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );
		else transformData.eulerOrder = 'ZYX';

		if ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;

		if ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;
		if ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;
		if ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;

		if ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;

		if ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;
		if ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;

		if ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;
		if ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;

		model.userData.transformData = transformData;

	}

	setLookAtProperties( model, modelNode ) {

		if ( 'LookAtProperty' in modelNode ) {

			const children = connections.get( model.ID ).children;

			children.forEach( function ( child ) {

				if ( child.relationship === 'LookAtProperty' ) {

					const lookAtTarget = fbxTree.Objects.Model[ child.ID ];

					if ( 'Lcl_Translation' in lookAtTarget ) {

						const pos = lookAtTarget.Lcl_Translation.value;

						// DirectionalLight, SpotLight
						if ( model.target !== undefined ) {

							model.target.position.fromArray( pos );
							sceneGraph.add( model.target );

						} else { // Cameras and other Object3Ds

							model.lookAt( new Vector3().fromArray( pos ) );

						}

					}

				}

			} );

		}

	}

	bindSkeleton( skeletons, geometryMap, modelMap ) {

		const bindMatrices = this.parsePoseNodes();

		for ( const ID in skeletons ) {

			const skeleton = skeletons[ ID ];

			const parents = connections.get( parseInt( skeleton.ID ) ).parents;

			parents.forEach( function ( parent ) {

				if ( geometryMap.has( parent.ID ) ) {

					const geoID = parent.ID;
					const geoRelationships = connections.get( geoID );

					geoRelationships.parents.forEach( function ( geoConnParent ) {

						if ( modelMap.has( geoConnParent.ID ) ) {

							const model = modelMap.get( geoConnParent.ID );

							model.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );

						}

					} );

				}

			} );

		}

	}

	parsePoseNodes() {

		const bindMatrices = {};

		if ( 'Pose' in fbxTree.Objects ) {

			const BindPoseNode = fbxTree.Objects.Pose;

			for ( const nodeID in BindPoseNode ) {

				if ( BindPoseNode[ nodeID ].attrType === 'BindPose' && BindPoseNode[ nodeID ].NbPoseNodes > 0 ) {

					const poseNodes = BindPoseNode[ nodeID ].PoseNode;

					if ( Array.isArray( poseNodes ) ) {

						poseNodes.forEach( function ( poseNode ) {

							bindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a );

						} );

					} else {

						bindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a );

					}

				}

			}

		}

		return bindMatrices;

	}

	// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
	createAmbientLight() {

		if ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {

			const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
			const r = ambientColor[ 0 ];
			const g = ambientColor[ 1 ];
			const b = ambientColor[ 2 ];

			if ( r !== 0 || g !== 0 || b !== 0 ) {

				const color = new Color( r, g, b ).convertSRGBToLinear();
				sceneGraph.add( new AmbientLight( color, 1 ) );

			}

		}

	}

}

// parse Geometry data from FBXTree and return map of BufferGeometries
class GeometryParser {

	constructor() {

		this.negativeMaterialIndices = false;

	}

	// Parse nodes in FBXTree.Objects.Geometry
	parse( deformers ) {

		const geometryMap = new Map();

		if ( 'Geometry' in fbxTree.Objects ) {

			const geoNodes = fbxTree.Objects.Geometry;

			for ( const nodeID in geoNodes ) {

				const relationships = connections.get( parseInt( nodeID ) );
				const geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );

				geometryMap.set( parseInt( nodeID ), geo );

			}

		}

		// report warnings

		if ( this.negativeMaterialIndices === true ) {

			console.warn( 'THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.' );

		}

		return geometryMap;

	}

	// Parse single node in FBXTree.Objects.Geometry
	parseGeometry( relationships, geoNode, deformers ) {

		switch ( geoNode.attrType ) {

			case 'Mesh':
				return this.parseMeshGeometry( relationships, geoNode, deformers );

			case 'NurbsCurve':
				return this.parseNurbsGeometry( geoNode );

		}

	}

	// Parse single node mesh geometry in FBXTree.Objects.Geometry
	parseMeshGeometry( relationships, geoNode, deformers ) {

		const skeletons = deformers.skeletons;
		const morphTargets = [];

		const modelNodes = relationships.parents.map( function ( parent ) {

			return fbxTree.Objects.Model[ parent.ID ];

		} );

		// don't create geometry if it is not associated with any models
		if ( modelNodes.length === 0 ) return;

		const skeleton = relationships.children.reduce( function ( skeleton, child ) {

			if ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];

			return skeleton;

		}, null );

		relationships.children.forEach( function ( child ) {

			if ( deformers.morphTargets[ child.ID ] !== undefined ) {

				morphTargets.push( deformers.morphTargets[ child.ID ] );

			}

		} );

		// Assume one model and get the preRotation from that
		// if there is more than one model associated with the geometry this may cause problems
		const modelNode = modelNodes[ 0 ];

		const transformData = {};

		if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );
		if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );

		if ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;
		if ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;
		if ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;

		const transform = generateTransform( transformData );

		return this.genGeometry( geoNode, skeleton, morphTargets, transform );

	}

	// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
	genGeometry( geoNode, skeleton, morphTargets, preTransform ) {

		const geo = new BufferGeometry();
		if ( geoNode.attrName ) geo.name = geoNode.attrName;

		const geoInfo = this.parseGeoNode( geoNode, skeleton );
		const buffers = this.genBuffers( geoInfo );

		const positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 );

		positionAttribute.applyMatrix4( preTransform );

		geo.setAttribute( 'position', positionAttribute );

		if ( buffers.colors.length > 0 ) {

			geo.setAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) );

		}

		if ( skeleton ) {

			geo.setAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) );

			geo.setAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) );

			// used later to bind the skeleton to the model
			geo.FBX_Deformer = skeleton;

		}

		if ( buffers.normal.length > 0 ) {

			const normalMatrix = new Matrix3().getNormalMatrix( preTransform );

			const normalAttribute = new Float32BufferAttribute( buffers.normal, 3 );
			normalAttribute.applyNormalMatrix( normalMatrix );

			geo.setAttribute( 'normal', normalAttribute );

		}

		buffers.uvs.forEach( function ( uvBuffer, i ) {

			// subsequent uv buffers are called 'uv1', 'uv2', ...
			let name = 'uv' + ( i + 1 ).toString();

			// the first uv buffer is just called 'uv'
			if ( i === 0 ) {

				name = 'uv';

			}

			geo.setAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) );

		} );

		if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

			// Convert the material indices of each vertex into rendering groups on the geometry.
			let prevMaterialIndex = buffers.materialIndex[ 0 ];
			let startIndex = 0;

			buffers.materialIndex.forEach( function ( currentIndex, i ) {

				if ( currentIndex !== prevMaterialIndex ) {

					geo.addGroup( startIndex, i - startIndex, prevMaterialIndex );

					prevMaterialIndex = currentIndex;
					startIndex = i;

				}

			} );

			// the loop above doesn't add the last group, do that here.
			if ( geo.groups.length > 0 ) {

				const lastGroup = geo.groups[ geo.groups.length - 1 ];
				const lastIndex = lastGroup.start + lastGroup.count;

				if ( lastIndex !== buffers.materialIndex.length ) {

					geo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );

				}

			}

			// case where there are multiple materials but the whole geometry is only
			// using one of them
			if ( geo.groups.length === 0 ) {

				geo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );

			}

		}

		this.addMorphTargets( geo, geoNode, morphTargets, preTransform );

		return geo;

	}

	parseGeoNode( geoNode, skeleton ) {

		const geoInfo = {};

		geoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];
		geoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];

		if ( geoNode.LayerElementColor ) {

			geoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );

		}

		if ( geoNode.LayerElementMaterial ) {

			geoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );

		}

		if ( geoNode.LayerElementNormal ) {

			geoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );

		}

		if ( geoNode.LayerElementUV ) {

			geoInfo.uv = [];

			let i = 0;
			while ( geoNode.LayerElementUV[ i ] ) {

				if ( geoNode.LayerElementUV[ i ].UV ) {

					geoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );

				}

				i ++;

			}

		}

		geoInfo.weightTable = {};

		if ( skeleton !== null ) {

			geoInfo.skeleton = skeleton;

			skeleton.rawBones.forEach( function ( rawBone, i ) {

				// loop over the bone's vertex indices and weights
				rawBone.indices.forEach( function ( index, j ) {

					if ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];

					geoInfo.weightTable[ index ].push( {

						id: i,
						weight: rawBone.weights[ j ],

					} );

				} );

			} );

		}

		return geoInfo;

	}

	genBuffers( geoInfo ) {

		const buffers = {
			vertex: [],
			normal: [],
			colors: [],
			uvs: [],
			materialIndex: [],
			vertexWeights: [],
			weightsIndices: [],
		};

		let polygonIndex = 0;
		let faceLength = 0;
		let displayedWeightsWarning = false;

		// these will hold data for a single face
		let facePositionIndexes = [];
		let faceNormals = [];
		let faceColors = [];
		let faceUVs = [];
		let faceWeights = [];
		let faceWeightIndices = [];

		const scope = this;
		geoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {

			let materialIndex;
			let endOfFace = false;

			// Face index and vertex index arrays are combined in a single array
			// A cube with quad faces looks like this:
			// PolygonVertexIndex: *24 {
			//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
			//  }
			// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
			// to find index of last vertex bit shift the index: ^ - 1
			if ( vertexIndex < 0 ) {

				vertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1
				endOfFace = true;

			}

			let weightIndices = [];
			let weights = [];

			facePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );

			if ( geoInfo.color ) {

				const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );

				faceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );

			}

			if ( geoInfo.skeleton ) {

				if ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {

					geoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {

						weights.push( wt.weight );
						weightIndices.push( wt.id );

					} );


				}

				if ( weights.length > 4 ) {

					if ( ! displayedWeightsWarning ) {

						console.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );
						displayedWeightsWarning = true;

					}

					const wIndex = [ 0, 0, 0, 0 ];
					const Weight = [ 0, 0, 0, 0 ];

					weights.forEach( function ( weight, weightIndex ) {

						let currentWeight = weight;
						let currentIndex = weightIndices[ weightIndex ];

						Weight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {

							if ( currentWeight > comparedWeight ) {

								comparedWeightArray[ comparedWeightIndex ] = currentWeight;
								currentWeight = comparedWeight;

								const tmp = wIndex[ comparedWeightIndex ];
								wIndex[ comparedWeightIndex ] = currentIndex;
								currentIndex = tmp;

							}

						} );

					} );

					weightIndices = wIndex;
					weights = Weight;

				}

				// if the weight array is shorter than 4 pad with 0s
				while ( weights.length < 4 ) {

					weights.push( 0 );
					weightIndices.push( 0 );

				}

				for ( let i = 0; i < 4; ++ i ) {

					faceWeights.push( weights[ i ] );
					faceWeightIndices.push( weightIndices[ i ] );

				}

			}

			if ( geoInfo.normal ) {

				const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );

				faceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );

			}

			if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

				materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];

				if ( materialIndex < 0 ) {

					scope.negativeMaterialIndices = true;
					materialIndex = 0; // fallback

				}

			}

			if ( geoInfo.uv ) {

				geoInfo.uv.forEach( function ( uv, i ) {

					const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );

					if ( faceUVs[ i ] === undefined ) {

						faceUVs[ i ] = [];

					}

					faceUVs[ i ].push( data[ 0 ] );
					faceUVs[ i ].push( data[ 1 ] );

				} );

			}

			faceLength ++;

			if ( endOfFace ) {

				if ( faceLength > 4 ) console.warn( 'THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export.' );

				scope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );

				polygonIndex ++;
				faceLength = 0;

				// reset arrays for the next face
				facePositionIndexes = [];
				faceNormals = [];
				faceColors = [];
				faceUVs = [];
				faceWeights = [];
				faceWeightIndices = [];

			}

		} );

		return buffers;

	}

	// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
	genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {

		for ( let i = 2; i < faceLength; i ++ ) {

			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );

			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );

			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );
			buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );

			if ( geoInfo.skeleton ) {

				buffers.vertexWeights.push( faceWeights[ 0 ] );
				buffers.vertexWeights.push( faceWeights[ 1 ] );
				buffers.vertexWeights.push( faceWeights[ 2 ] );
				buffers.vertexWeights.push( faceWeights[ 3 ] );

				buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );
				buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );
				buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );
				buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );

				buffers.vertexWeights.push( faceWeights[ i * 4 ] );
				buffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );
				buffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );
				buffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );

				buffers.weightsIndices.push( faceWeightIndices[ 0 ] );
				buffers.weightsIndices.push( faceWeightIndices[ 1 ] );
				buffers.weightsIndices.push( faceWeightIndices[ 2 ] );
				buffers.weightsIndices.push( faceWeightIndices[ 3 ] );

				buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );
				buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );
				buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );
				buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );

				buffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );
				buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );

			}

			if ( geoInfo.color ) {

				buffers.colors.push( faceColors[ 0 ] );
				buffers.colors.push( faceColors[ 1 ] );
				buffers.colors.push( faceColors[ 2 ] );

				buffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );
				buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );
				buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );

				buffers.colors.push( faceColors[ i * 3 ] );
				buffers.colors.push( faceColors[ i * 3 + 1 ] );
				buffers.colors.push( faceColors[ i * 3 + 2 ] );

			}

			if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

				buffers.materialIndex.push( materialIndex );
				buffers.materialIndex.push( materialIndex );
				buffers.materialIndex.push( materialIndex );

			}

			if ( geoInfo.normal ) {

				buffers.normal.push( faceNormals[ 0 ] );
				buffers.normal.push( faceNormals[ 1 ] );
				buffers.normal.push( faceNormals[ 2 ] );

				buffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );
				buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );
				buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );

				buffers.normal.push( faceNormals[ i * 3 ] );
				buffers.normal.push( faceNormals[ i * 3 + 1 ] );
				buffers.normal.push( faceNormals[ i * 3 + 2 ] );

			}

			if ( geoInfo.uv ) {

				geoInfo.uv.forEach( function ( uv, j ) {

					if ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];

					buffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );
					buffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );

					buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );
					buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );

					buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );
					buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );

				} );

			}

		}

	}

	addMorphTargets( parentGeo, parentGeoNode, morphTargets, preTransform ) {

		if ( morphTargets.length === 0 ) return;

		parentGeo.morphTargetsRelative = true;

		parentGeo.morphAttributes.position = [];
		// parentGeo.morphAttributes.normal = []; // not implemented

		const scope = this;
		morphTargets.forEach( function ( morphTarget ) {

			morphTarget.rawTargets.forEach( function ( rawTarget ) {

				const morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];

				if ( morphGeoNode !== undefined ) {

					scope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );

				}

			} );

		} );

	}

	// a morph geometry node is similar to a standard  node, and the node is also contained
	// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
	// and a special attribute Index defining which vertices of the original geometry are affected
	// Normal and position attributes only have data for the vertices that are affected by the morph
	genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {

		const vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];

		const morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];
		const indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];

		const length = parentGeo.attributes.position.count * 3;
		const morphPositions = new Float32Array( length );

		for ( let i = 0; i < indices.length; i ++ ) {

			const morphIndex = indices[ i ] * 3;

			morphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];
			morphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];
			morphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];

		}

		// TODO: add morph normal support
		const morphGeoInfo = {
			vertexIndices: vertexIndices,
			vertexPositions: morphPositions,

		};

		const morphBuffers = this.genBuffers( morphGeoInfo );

		const positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 );
		positionAttribute.name = name || morphGeoNode.attrName;

		positionAttribute.applyMatrix4( preTransform );

		parentGeo.morphAttributes.position.push( positionAttribute );

	}

	// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
	parseNormals( NormalNode ) {

		const mappingType = NormalNode.MappingInformationType;
		const referenceType = NormalNode.ReferenceInformationType;
		const buffer = NormalNode.Normals.a;
		let indexBuffer = [];
		if ( referenceType === 'IndexToDirect' ) {

			if ( 'NormalIndex' in NormalNode ) {

				indexBuffer = NormalNode.NormalIndex.a;

			} else if ( 'NormalsIndex' in NormalNode ) {

				indexBuffer = NormalNode.NormalsIndex.a;

			}

		}

		return {
			dataSize: 3,
			buffer: buffer,
			indices: indexBuffer,
			mappingType: mappingType,
			referenceType: referenceType
		};

	}

	// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
	parseUVs( UVNode ) {

		const mappingType = UVNode.MappingInformationType;
		const referenceType = UVNode.ReferenceInformationType;
		const buffer = UVNode.UV.a;
		let indexBuffer = [];
		if ( referenceType === 'IndexToDirect' ) {

			indexBuffer = UVNode.UVIndex.a;

		}

		return {
			dataSize: 2,
			buffer: buffer,
			indices: indexBuffer,
			mappingType: mappingType,
			referenceType: referenceType
		};

	}

	// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
	parseVertexColors( ColorNode ) {

		const mappingType = ColorNode.MappingInformationType;
		const referenceType = ColorNode.ReferenceInformationType;
		const buffer = ColorNode.Colors.a;
		let indexBuffer = [];
		if ( referenceType === 'IndexToDirect' ) {

			indexBuffer = ColorNode.ColorIndex.a;

		}

		for ( let i = 0, c = new Color(); i < buffer.length; i += 4 ) {

			c.fromArray( buffer, i ).convertSRGBToLinear().toArray( buffer, i );

		}

		return {
			dataSize: 4,
			buffer: buffer,
			indices: indexBuffer,
			mappingType: mappingType,
			referenceType: referenceType
		};

	}

	// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
	parseMaterialIndices( MaterialNode ) {

		const mappingType = MaterialNode.MappingInformationType;
		const referenceType = MaterialNode.ReferenceInformationType;

		if ( mappingType === 'NoMappingInformation' ) {

			return {
				dataSize: 1,
				buffer: [ 0 ],
				indices: [ 0 ],
				mappingType: 'AllSame',
				referenceType: referenceType
			};

		}

		const materialIndexBuffer = MaterialNode.Materials.a;

		// Since materials are stored as indices, there's a bit of a mismatch between FBX and what
		// we expect.So we create an intermediate buffer that points to the index in the buffer,
		// for conforming with the other functions we've written for other data.
		const materialIndices = [];

		for ( let i = 0; i < materialIndexBuffer.length; ++ i ) {

			materialIndices.push( i );

		}

		return {
			dataSize: 1,
			buffer: materialIndexBuffer,
			indices: materialIndices,
			mappingType: mappingType,
			referenceType: referenceType
		};

	}

	// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
	parseNurbsGeometry( geoNode ) {

		const order = parseInt( geoNode.Order );

		if ( isNaN( order ) ) {

			console.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );
			return new BufferGeometry();

		}

		const degree = order - 1;

		const knots = geoNode.KnotVector.a;
		const controlPoints = [];
		const pointsValues = geoNode.Points.a;

		for ( let i = 0, l = pointsValues.length; i < l; i += 4 ) {

			controlPoints.push( new Vector4().fromArray( pointsValues, i ) );

		}

		let startKnot, endKnot;

		if ( geoNode.Form === 'Closed' ) {

			controlPoints.push( controlPoints[ 0 ] );

		} else if ( geoNode.Form === 'Periodic' ) {

			startKnot = degree;
			endKnot = knots.length - 1 - startKnot;

			for ( let i = 0; i < degree; ++ i ) {

				controlPoints.push( controlPoints[ i ] );

			}

		}

		const curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );
		const points = curve.getPoints( controlPoints.length * 12 );

		return new BufferGeometry().setFromPoints( points );

	}

}

// parse animation data from FBXTree
class AnimationParser {

	// take raw animation clips and turn them into three.js animation clips
	parse() {

		const animationClips = [];

		const rawClips = this.parseClips();

		if ( rawClips !== undefined ) {

			for ( const key in rawClips ) {

				const rawClip = rawClips[ key ];

				const clip = this.addClip( rawClip );

				animationClips.push( clip );

			}

		}

		return animationClips;

	}

	parseClips() {

		// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
		// if this is undefined we can safely assume there are no animations
		if ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;

		const curveNodesMap = this.parseAnimationCurveNodes();

		this.parseAnimationCurves( curveNodesMap );

		const layersMap = this.parseAnimationLayers( curveNodesMap );
		const rawClips = this.parseAnimStacks( layersMap );

		return rawClips;

	}

	// parse nodes in FBXTree.Objects.AnimationCurveNode
	// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
	// and is referenced by an AnimationLayer
	parseAnimationCurveNodes() {

		const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;

		const curveNodesMap = new Map();

		for ( const nodeID in rawCurveNodes ) {

			const rawCurveNode = rawCurveNodes[ nodeID ];

			if ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {

				const curveNode = {

					id: rawCurveNode.id,
					attr: rawCurveNode.attrName,
					curves: {},

				};

				curveNodesMap.set( curveNode.id, curveNode );

			}

		}

		return curveNodesMap;

	}

	// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
	// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
	// axis ( e.g. times and values of x rotation)
	parseAnimationCurves( curveNodesMap ) {

		const rawCurves = fbxTree.Objects.AnimationCurve;

		// TODO: Many values are identical up to roundoff error, but won't be optimised
		// e.g. position times: [0, 0.4, 0. 8]
		// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]
		// clearly, this should be optimised to
		// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]
		// this shows up in nearly every FBX file, and generally time array is length > 100

		for ( const nodeID in rawCurves ) {

			const animationCurve = {

				id: rawCurves[ nodeID ].id,
				times: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),
				values: rawCurves[ nodeID ].KeyValueFloat.a,

			};

			const relationships = connections.get( animationCurve.id );

			if ( relationships !== undefined ) {

				const animationCurveID = relationships.parents[ 0 ].ID;
				const animationCurveRelationship = relationships.parents[ 0 ].relationship;

				if ( animationCurveRelationship.match( /X/ ) ) {

					curveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;

				} else if ( animationCurveRelationship.match( /Y/ ) ) {

					curveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;

				} else if ( animationCurveRelationship.match( /Z/ ) ) {

					curveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;

				} else if ( animationCurveRelationship.match( /DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {

					curveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;

				}

			}

		}

	}

	// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
	// to various AnimationCurveNodes and is referenced by an AnimationStack node
	// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
	parseAnimationLayers( curveNodesMap ) {

		const rawLayers = fbxTree.Objects.AnimationLayer;

		const layersMap = new Map();

		for ( const nodeID in rawLayers ) {

			const layerCurveNodes = [];

			const connection = connections.get( parseInt( nodeID ) );

			if ( connection !== undefined ) {

				// all the animationCurveNodes used in the layer
				const children = connection.children;

				children.forEach( function ( child, i ) {

					if ( curveNodesMap.has( child.ID ) ) {

						const curveNode = curveNodesMap.get( child.ID );

						// check that the curves are defined for at least one axis, otherwise ignore the curveNode
						if ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {

							if ( layerCurveNodes[ i ] === undefined ) {

								const modelID = connections.get( child.ID ).parents.filter( function ( parent ) {

									return parent.relationship !== undefined;

								} )[ 0 ].ID;

								if ( modelID !== undefined ) {

									const rawModel = fbxTree.Objects.Model[ modelID.toString() ];

									if ( rawModel === undefined ) {

										console.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );
										return;

									}

									const node = {

										modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',
										ID: rawModel.id,
										initialPosition: [ 0, 0, 0 ],
										initialRotation: [ 0, 0, 0 ],
										initialScale: [ 1, 1, 1 ],

									};

									sceneGraph.traverse( function ( child ) {

										if ( child.ID === rawModel.id ) {

											node.transform = child.matrix;

											if ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;

										}

									} );

									if ( ! node.transform ) node.transform = new Matrix4();

									// if the animated model is pre rotated, we'll have to apply the pre rotations to every
									// animation value as well
									if ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;
									if ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;

									layerCurveNodes[ i ] = node;

								}

							}

							if ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;

						} else if ( curveNode.curves.morph !== undefined ) {

							if ( layerCurveNodes[ i ] === undefined ) {

								const deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {

									return parent.relationship !== undefined;

								} )[ 0 ].ID;

								const morpherID = connections.get( deformerID ).parents[ 0 ].ID;
								const geoID = connections.get( morpherID ).parents[ 0 ].ID;

								// assuming geometry is not used in more than one model
								const modelID = connections.get( geoID ).parents[ 0 ].ID;

								const rawModel = fbxTree.Objects.Model[ modelID ];

								const node = {

									modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',
									morphName: fbxTree.Objects.Deformer[ deformerID ].attrName,

								};

								layerCurveNodes[ i ] = node;

							}

							layerCurveNodes[ i ][ curveNode.attr ] = curveNode;

						}

					}

				} );

				layersMap.set( parseInt( nodeID ), layerCurveNodes );

			}

		}

		return layersMap;

	}

	// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
	// hierarchy. Each Stack node will be used to create a AnimationClip
	parseAnimStacks( layersMap ) {

		const rawStacks = fbxTree.Objects.AnimationStack;

		// connect the stacks (clips) up to the layers
		const rawClips = {};

		for ( const nodeID in rawStacks ) {

			const children = connections.get( parseInt( nodeID ) ).children;

			if ( children.length > 1 ) {

				// it seems like stacks will always be associated with a single layer. But just in case there are files
				// where there are multiple layers per stack, we'll display a warning
				console.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );

			}

			const layer = layersMap.get( children[ 0 ].ID );

			rawClips[ nodeID ] = {

				name: rawStacks[ nodeID ].attrName,
				layer: layer,

			};

		}

		return rawClips;

	}

	addClip( rawClip ) {

		let tracks = [];

		const scope = this;
		rawClip.layer.forEach( function ( rawTracks ) {

			tracks = tracks.concat( scope.generateTracks( rawTracks ) );

		} );

		return new AnimationClip( rawClip.name, - 1, tracks );

	}

	generateTracks( rawTracks ) {

		const tracks = [];

		let initialPosition = new Vector3();
		let initialRotation = new Quaternion();
		let initialScale = new Vector3();

		if ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale );

		initialPosition = initialPosition.toArray();
		initialRotation = new Euler().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();
		initialScale = initialScale.toArray();

		if ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {

			const positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );
			if ( positionTrack !== undefined ) tracks.push( positionTrack );

		}

		if ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {

			const rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );
			if ( rotationTrack !== undefined ) tracks.push( rotationTrack );

		}

		if ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {

			const scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );
			if ( scaleTrack !== undefined ) tracks.push( scaleTrack );

		}

		if ( rawTracks.DeformPercent !== undefined ) {

			const morphTrack = this.generateMorphTrack( rawTracks );
			if ( morphTrack !== undefined ) tracks.push( morphTrack );

		}

		return tracks;

	}

	generateVectorTrack( modelName, curves, initialValue, type ) {

		const times = this.getTimesForAllAxes( curves );
		const values = this.getKeyframeTrackValues( times, curves, initialValue );

		return new VectorKeyframeTrack( modelName + '.' + type, times, values );

	}

	generateRotationTrack( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {

		if ( curves.x !== undefined ) {

			this.interpolateRotations( curves.x );
			curves.x.values = curves.x.values.map( MathUtils.degToRad );

		}

		if ( curves.y !== undefined ) {

			this.interpolateRotations( curves.y );
			curves.y.values = curves.y.values.map( MathUtils.degToRad );

		}

		if ( curves.z !== undefined ) {

			this.interpolateRotations( curves.z );
			curves.z.values = curves.z.values.map( MathUtils.degToRad );

		}

		const times = this.getTimesForAllAxes( curves );
		const values = this.getKeyframeTrackValues( times, curves, initialValue );

		if ( preRotation !== undefined ) {

			preRotation = preRotation.map( MathUtils.degToRad );
			preRotation.push( eulerOrder );

			preRotation = new Euler().fromArray( preRotation );
			preRotation = new Quaternion().setFromEuler( preRotation );

		}

		if ( postRotation !== undefined ) {

			postRotation = postRotation.map( MathUtils.degToRad );
			postRotation.push( eulerOrder );

			postRotation = new Euler().fromArray( postRotation );
			postRotation = new Quaternion().setFromEuler( postRotation ).invert();

		}

		const quaternion = new Quaternion();
		const euler = new Euler();

		const quaternionValues = [];

		for ( let i = 0; i < values.length; i += 3 ) {

			euler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );

			quaternion.setFromEuler( euler );

			if ( preRotation !== undefined ) quaternion.premultiply( preRotation );
			if ( postRotation !== undefined ) quaternion.multiply( postRotation );

			quaternion.toArray( quaternionValues, ( i / 3 ) * 4 );

		}

		return new QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );

	}

	generateMorphTrack( rawTracks ) {

		const curves = rawTracks.DeformPercent.curves.morph;
		const values = curves.values.map( function ( val ) {

			return val / 100;

		} );

		const morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];

		return new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );

	}

	// For all animated objects, times are defined separately for each axis
	// Here we'll combine the times into one sorted array without duplicates
	getTimesForAllAxes( curves ) {

		let times = [];

		// first join together the times for each axis, if defined
		if ( curves.x !== undefined ) times = times.concat( curves.x.times );
		if ( curves.y !== undefined ) times = times.concat( curves.y.times );
		if ( curves.z !== undefined ) times = times.concat( curves.z.times );

		// then sort them
		times = times.sort( function ( a, b ) {

			return a - b;

		} );

		// and remove duplicates
		if ( times.length > 1 ) {

			let targetIndex = 1;
			let lastValue = times[ 0 ];
			for ( let i = 1; i < times.length; i ++ ) {

				const currentValue = times[ i ];
				if ( currentValue !== lastValue ) {

					times[ targetIndex ] = currentValue;
					lastValue = currentValue;
					targetIndex ++;

				}

			}

			times = times.slice( 0, targetIndex );

		}

		return times;

	}

	getKeyframeTrackValues( times, curves, initialValue ) {

		const prevValue = initialValue;

		const values = [];

		let xIndex = - 1;
		let yIndex = - 1;
		let zIndex = - 1;

		times.forEach( function ( time ) {

			if ( curves.x ) xIndex = curves.x.times.indexOf( time );
			if ( curves.y ) yIndex = curves.y.times.indexOf( time );
			if ( curves.z ) zIndex = curves.z.times.indexOf( time );

			// if there is an x value defined for this frame, use that
			if ( xIndex !== - 1 ) {

				const xValue = curves.x.values[ xIndex ];
				values.push( xValue );
				prevValue[ 0 ] = xValue;

			} else {

				// otherwise use the x value from the previous frame
				values.push( prevValue[ 0 ] );

			}

			if ( yIndex !== - 1 ) {

				const yValue = curves.y.values[ yIndex ];
				values.push( yValue );
				prevValue[ 1 ] = yValue;

			} else {

				values.push( prevValue[ 1 ] );

			}

			if ( zIndex !== - 1 ) {

				const zValue = curves.z.values[ zIndex ];
				values.push( zValue );
				prevValue[ 2 ] = zValue;

			} else {

				values.push( prevValue[ 2 ] );

			}

		} );

		return values;

	}

	// Rotations are defined as Euler angles which can have values  of any size
	// These will be converted to quaternions which don't support values greater than
	// PI, so we'll interpolate large rotations
	interpolateRotations( curve ) {

		for ( let i = 1; i < curve.values.length; i ++ ) {

			const initialValue = curve.values[ i - 1 ];
			const valuesSpan = curve.values[ i ] - initialValue;

			const absoluteSpan = Math.abs( valuesSpan );

			if ( absoluteSpan >= 180 ) {

				const numSubIntervals = absoluteSpan / 180;

				const step = valuesSpan / numSubIntervals;
				let nextValue = initialValue + step;

				const initialTime = curve.times[ i - 1 ];
				const timeSpan = curve.times[ i ] - initialTime;
				const interval = timeSpan / numSubIntervals;
				let nextTime = initialTime + interval;

				const interpolatedTimes = [];
				const interpolatedValues = [];

				while ( nextTime < curve.times[ i ] ) {

					interpolatedTimes.push( nextTime );
					nextTime += interval;

					interpolatedValues.push( nextValue );
					nextValue += step;

				}

				curve.times = inject$1( curve.times, i, interpolatedTimes );
				curve.values = inject$1( curve.values, i, interpolatedValues );

			}

		}

	}

}

// parse an FBX file in ASCII format
class TextParser {

	getPrevNode() {

		return this.nodeStack[ this.currentIndent - 2 ];

	}

	getCurrentNode() {

		return this.nodeStack[ this.currentIndent - 1 ];

	}

	getCurrentProp() {

		return this.currentProp;

	}

	pushStack( node ) {

		this.nodeStack.push( node );
		this.currentIndent += 1;

	}

	popStack() {

		this.nodeStack.pop();
		this.currentIndent -= 1;

	}

	setCurrentProp( val, name ) {

		this.currentProp = val;
		this.currentPropName = name;

	}

	parse( text ) {

		this.currentIndent = 0;

		this.allNodes = new FBXTree();
		this.nodeStack = [];
		this.currentProp = [];
		this.currentPropName = '';

		const scope = this;

		const split = text.split( /[\r\n]+/ );

		split.forEach( function ( line, i ) {

			const matchComment = line.match( /^[\s\t]*;/ );
			const matchEmpty = line.match( /^[\s\t]*$/ );

			if ( matchComment || matchEmpty ) return;

			const matchBeginning = line.match( '^\\t{' + scope.currentIndent + '}(\\w+):(.*){', '' );
			const matchProperty = line.match( '^\\t{' + ( scope.currentIndent ) + '}(\\w+):[\\s\\t\\r\\n](.*)' );
			const matchEnd = line.match( '^\\t{' + ( scope.currentIndent - 1 ) + '}}' );

			if ( matchBeginning ) {

				scope.parseNodeBegin( line, matchBeginning );

			} else if ( matchProperty ) {

				scope.parseNodeProperty( line, matchProperty, split[ ++ i ] );

			} else if ( matchEnd ) {

				scope.popStack();

			} else if ( line.match( /^[^\s\t}]/ ) ) {

				// large arrays are split over multiple lines terminated with a ',' character
				// if this is encountered the line needs to be joined to the previous line
				scope.parseNodePropertyContinued( line );

			}

		} );

		return this.allNodes;

	}

	parseNodeBegin( line, property ) {

		const nodeName = property[ 1 ].trim().replace( /^"/, '' ).replace( /"$/, '' );

		const nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {

			return attr.trim().replace( /^"/, '' ).replace( /"$/, '' );

		} );

		const node = { name: nodeName };
		const attrs = this.parseNodeAttr( nodeAttrs );

		const currentNode = this.getCurrentNode();

		// a top node
		if ( this.currentIndent === 0 ) {

			this.allNodes.add( nodeName, node );

		} else { // a subnode

			// if the subnode already exists, append it
			if ( nodeName in currentNode ) {

				// special case Pose needs PoseNodes as an array
				if ( nodeName === 'PoseNode' ) {

					currentNode.PoseNode.push( node );

				} else if ( currentNode[ nodeName ].id !== undefined ) {

					currentNode[ nodeName ] = {};
					currentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];

				}

				if ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;

			} else if ( typeof attrs.id === 'number' ) {

				currentNode[ nodeName ] = {};
				currentNode[ nodeName ][ attrs.id ] = node;

			} else if ( nodeName !== 'Properties70' ) {

				if ( nodeName === 'PoseNode' )	currentNode[ nodeName ] = [ node ];
				else currentNode[ nodeName ] = node;

			}

		}

		if ( typeof attrs.id === 'number' ) node.id = attrs.id;
		if ( attrs.name !== '' ) node.attrName = attrs.name;
		if ( attrs.type !== '' ) node.attrType = attrs.type;

		this.pushStack( node );

	}

	parseNodeAttr( attrs ) {

		let id = attrs[ 0 ];

		if ( attrs[ 0 ] !== '' ) {

			id = parseInt( attrs[ 0 ] );

			if ( isNaN( id ) ) {

				id = attrs[ 0 ];

			}

		}

		let name = '', type = '';

		if ( attrs.length > 1 ) {

			name = attrs[ 1 ].replace( /^(\w+)::/, '' );
			type = attrs[ 2 ];

		}

		return { id: id, name: name, type: type };

	}

	parseNodeProperty( line, property, contentLine ) {

		let propName = property[ 1 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();
		let propValue = property[ 2 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();

		// for special case: base64 image data follows "Content: ," line
		//	Content: ,
		//	 "/9j/4RDaRXhpZgAATU0A..."
		if ( propName === 'Content' && propValue === ',' ) {

			propValue = contentLine.replace( /"/g, '' ).replace( /,$/, '' ).trim();

		}

		const currentNode = this.getCurrentNode();
		const parentName = currentNode.name;

		if ( parentName === 'Properties70' ) {

			this.parseNodeSpecialProperty( line, propName, propValue );
			return;

		}

		// Connections
		if ( propName === 'C' ) {

			const connProps = propValue.split( ',' ).slice( 1 );
			const from = parseInt( connProps[ 0 ] );
			const to = parseInt( connProps[ 1 ] );

			let rest = propValue.split( ',' ).slice( 3 );

			rest = rest.map( function ( elem ) {

				return elem.trim().replace( /^"/, '' );

			} );

			propName = 'connections';
			propValue = [ from, to ];
			append( propValue, rest );

			if ( currentNode[ propName ] === undefined ) {

				currentNode[ propName ] = [];

			}

		}

		// Node
		if ( propName === 'Node' ) currentNode.id = propValue;

		// connections
		if ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {

			currentNode[ propName ].push( propValue );

		} else {

			if ( propName !== 'a' ) currentNode[ propName ] = propValue;
			else currentNode.a = propValue;

		}

		this.setCurrentProp( currentNode, propName );

		// convert string to array, unless it ends in ',' in which case more will be added to it
		if ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {

			currentNode.a = parseNumberArray( propValue );

		}

	}

	parseNodePropertyContinued( line ) {

		const currentNode = this.getCurrentNode();

		currentNode.a += line;

		// if the line doesn't end in ',' we have reached the end of the property value
		// so convert the string to an array
		if ( line.slice( - 1 ) !== ',' ) {

			currentNode.a = parseNumberArray( currentNode.a );

		}

	}

	// parse "Property70"
	parseNodeSpecialProperty( line, propName, propValue ) {

		// split this
		// P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
		// into array like below
		// ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
		const props = propValue.split( '",' ).map( function ( prop ) {

			return prop.trim().replace( /^\"/, '' ).replace( /\s/, '_' );

		} );

		const innerPropName = props[ 0 ];
		const innerPropType1 = props[ 1 ];
		const innerPropType2 = props[ 2 ];
		const innerPropFlag = props[ 3 ];
		let innerPropValue = props[ 4 ];

		// cast values where needed, otherwise leave as strings
		switch ( innerPropType1 ) {

			case 'int':
			case 'enum':
			case 'bool':
			case 'ULongLong':
			case 'double':
			case 'Number':
			case 'FieldOfView':
				innerPropValue = parseFloat( innerPropValue );
				break;

			case 'Color':
			case 'ColorRGB':
			case 'Vector3D':
			case 'Lcl_Translation':
			case 'Lcl_Rotation':
			case 'Lcl_Scaling':
				innerPropValue = parseNumberArray( innerPropValue );
				break;

		}

		// CAUTION: these props must append to parent's parent
		this.getPrevNode()[ innerPropName ] = {

			'type': innerPropType1,
			'type2': innerPropType2,
			'flag': innerPropFlag,
			'value': innerPropValue

		};

		this.setCurrentProp( this.getPrevNode(), innerPropName );

	}

}

// Parse an FBX file in Binary format
class BinaryParser {

	parse( buffer ) {

		const reader = new BinaryReader( buffer );
		reader.skip( 23 ); // skip magic 23 bytes

		const version = reader.getUint32();

		if ( version < 6400 ) {

			throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );

		}

		const allNodes = new FBXTree();

		while ( ! this.endOfContent( reader ) ) {

			const node = this.parseNode( reader, version );
			if ( node !== null ) allNodes.add( node.name, node );

		}

		return allNodes;

	}

	// Check if reader has reached the end of content.
	endOfContent( reader ) {

		// footer size: 160bytes + 16-byte alignment padding
		// - 16bytes: magic
		// - padding til 16-byte alignment (at least 1byte?)
		//	(seems like some exporters embed fixed 15 or 16bytes?)
		// - 4bytes: magic
		// - 4bytes: version
		// - 120bytes: zero
		// - 16bytes: magic
		if ( reader.size() % 16 === 0 ) {

			return ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();

		} else {

			return reader.getOffset() + 160 + 16 >= reader.size();

		}

	}

	// recursively parse nodes until the end of the file is reached
	parseNode( reader, version ) {

		const node = {};

		// The first three data sizes depends on version.
		const endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();
		const numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();

		( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used

		const nameLen = reader.getUint8();
		const name = reader.getString( nameLen );

		// Regards this node as NULL-record if endOffset is zero
		if ( endOffset === 0 ) return null;

		const propertyList = [];

		for ( let i = 0; i < numProperties; i ++ ) {

			propertyList.push( this.parseProperty( reader ) );

		}

		// Regards the first three elements in propertyList as id, attrName, and attrType
		const id = propertyList.length > 0 ? propertyList[ 0 ] : '';
		const attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';
		const attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';

		// check if this node represents just a single property
		// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
		node.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;

		while ( endOffset > reader.getOffset() ) {

			const subNode = this.parseNode( reader, version );

			if ( subNode !== null ) this.parseSubNode( name, node, subNode );

		}

		node.propertyList = propertyList; // raw property list used by parent

		if ( typeof id === 'number' ) node.id = id;
		if ( attrName !== '' ) node.attrName = attrName;
		if ( attrType !== '' ) node.attrType = attrType;
		if ( name !== '' ) node.name = name;

		return node;

	}

	parseSubNode( name, node, subNode ) {

		// special case: child node is single property
		if ( subNode.singleProperty === true ) {

			const value = subNode.propertyList[ 0 ];

			if ( Array.isArray( value ) ) {

				node[ subNode.name ] = subNode;

				subNode.a = value;

			} else {

				node[ subNode.name ] = value;

			}

		} else if ( name === 'Connections' && subNode.name === 'C' ) {

			const array = [];

			subNode.propertyList.forEach( function ( property, i ) {

				// first Connection is FBX type (OO, OP, etc.). We'll discard these
				if ( i !== 0 ) array.push( property );

			} );

			if ( node.connections === undefined ) {

				node.connections = [];

			}

			node.connections.push( array );

		} else if ( subNode.name === 'Properties70' ) {

			const keys = Object.keys( subNode );

			keys.forEach( function ( key ) {

				node[ key ] = subNode[ key ];

			} );

		} else if ( name === 'Properties70' && subNode.name === 'P' ) {

			let innerPropName = subNode.propertyList[ 0 ];
			let innerPropType1 = subNode.propertyList[ 1 ];
			const innerPropType2 = subNode.propertyList[ 2 ];
			const innerPropFlag = subNode.propertyList[ 3 ];
			let innerPropValue;

			if ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );
			if ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );

			if ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {

				innerPropValue = [
					subNode.propertyList[ 4 ],
					subNode.propertyList[ 5 ],
					subNode.propertyList[ 6 ]
				];

			} else {

				innerPropValue = subNode.propertyList[ 4 ];

			}

			// this will be copied to parent, see above
			node[ innerPropName ] = {

				'type': innerPropType1,
				'type2': innerPropType2,
				'flag': innerPropFlag,
				'value': innerPropValue

			};

		} else if ( node[ subNode.name ] === undefined ) {

			if ( typeof subNode.id === 'number' ) {

				node[ subNode.name ] = {};
				node[ subNode.name ][ subNode.id ] = subNode;

			} else {

				node[ subNode.name ] = subNode;

			}

		} else {

			if ( subNode.name === 'PoseNode' ) {

				if ( ! Array.isArray( node[ subNode.name ] ) ) {

					node[ subNode.name ] = [ node[ subNode.name ] ];

				}

				node[ subNode.name ].push( subNode );

			} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {

				node[ subNode.name ][ subNode.id ] = subNode;

			}

		}

	}

	parseProperty( reader ) {

		const type = reader.getString( 1 );
		let length;

		switch ( type ) {

			case 'C':
				return reader.getBoolean();

			case 'D':
				return reader.getFloat64();

			case 'F':
				return reader.getFloat32();

			case 'I':
				return reader.getInt32();

			case 'L':
				return reader.getInt64();

			case 'R':
				length = reader.getUint32();
				return reader.getArrayBuffer( length );

			case 'S':
				length = reader.getUint32();
				return reader.getString( length );

			case 'Y':
				return reader.getInt16();

			case 'b':
			case 'c':
			case 'd':
			case 'f':
			case 'i':
			case 'l':

				const arrayLength = reader.getUint32();
				const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed
				const compressedLength = reader.getUint32();

				if ( encoding === 0 ) {

					switch ( type ) {

						case 'b':
						case 'c':
							return reader.getBooleanArray( arrayLength );

						case 'd':
							return reader.getFloat64Array( arrayLength );

						case 'f':
							return reader.getFloat32Array( arrayLength );

						case 'i':
							return reader.getInt32Array( arrayLength );

						case 'l':
							return reader.getInt64Array( arrayLength );

					}

				}

				const data = unzlibSync( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) );
				const reader2 = new BinaryReader( data.buffer );

				switch ( type ) {

					case 'b':
					case 'c':
						return reader2.getBooleanArray( arrayLength );

					case 'd':
						return reader2.getFloat64Array( arrayLength );

					case 'f':
						return reader2.getFloat32Array( arrayLength );

					case 'i':
						return reader2.getInt32Array( arrayLength );

					case 'l':
						return reader2.getInt64Array( arrayLength );

				}

				break; // cannot happen but is required by the DeepScan

			default:
				throw new Error( 'THREE.FBXLoader: Unknown property type ' + type );

		}

	}

}

class BinaryReader {

	constructor( buffer, littleEndian ) {

		this.dv = new DataView( buffer );
		this.offset = 0;
		this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;
		this._textDecoder = new TextDecoder();

	}

	getOffset() {

		return this.offset;

	}

	size() {

		return this.dv.buffer.byteLength;

	}

	skip( length ) {

		this.offset += length;

	}

	// seems like true/false representation depends on exporter.
	// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
	// then sees LSB.
	getBoolean() {

		return ( this.getUint8() & 1 ) === 1;

	}

	getBooleanArray( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getBoolean() );

		}

		return a;

	}

	getUint8() {

		const value = this.dv.getUint8( this.offset );
		this.offset += 1;
		return value;

	}

	getInt16() {

		const value = this.dv.getInt16( this.offset, this.littleEndian );
		this.offset += 2;
		return value;

	}

	getInt32() {

		const value = this.dv.getInt32( this.offset, this.littleEndian );
		this.offset += 4;
		return value;

	}

	getInt32Array( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getInt32() );

		}

		return a;

	}

	getUint32() {

		const value = this.dv.getUint32( this.offset, this.littleEndian );
		this.offset += 4;
		return value;

	}

	// JavaScript doesn't support 64-bit integer so calculate this here
	// 1 << 32 will return 1 so using multiply operation instead here.
	// There's a possibility that this method returns wrong value if the value
	// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
	// TODO: safely handle 64-bit integer
	getInt64() {

		let low, high;

		if ( this.littleEndian ) {

			low = this.getUint32();
			high = this.getUint32();

		} else {

			high = this.getUint32();
			low = this.getUint32();

		}

		// calculate negative value
		if ( high & 0x80000000 ) {

			high = ~ high & 0xFFFFFFFF;
			low = ~ low & 0xFFFFFFFF;

			if ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;

			low = ( low + 1 ) & 0xFFFFFFFF;

			return - ( high * 0x100000000 + low );

		}

		return high * 0x100000000 + low;

	}

	getInt64Array( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getInt64() );

		}

		return a;

	}

	// Note: see getInt64() comment
	getUint64() {

		let low, high;

		if ( this.littleEndian ) {

			low = this.getUint32();
			high = this.getUint32();

		} else {

			high = this.getUint32();
			low = this.getUint32();

		}

		return high * 0x100000000 + low;

	}

	getFloat32() {

		const value = this.dv.getFloat32( this.offset, this.littleEndian );
		this.offset += 4;
		return value;

	}

	getFloat32Array( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getFloat32() );

		}

		return a;

	}

	getFloat64() {

		const value = this.dv.getFloat64( this.offset, this.littleEndian );
		this.offset += 8;
		return value;

	}

	getFloat64Array( size ) {

		const a = [];

		for ( let i = 0; i < size; i ++ ) {

			a.push( this.getFloat64() );

		}

		return a;

	}

	getArrayBuffer( size ) {

		const value = this.dv.buffer.slice( this.offset, this.offset + size );
		this.offset += size;
		return value;

	}

	getString( size ) {

		const start = this.offset;
		let a = new Uint8Array( this.dv.buffer, start, size );

		this.skip( size );

		const nullByte = a.indexOf( 0 );
		if ( nullByte >= 0 ) a = new Uint8Array( this.dv.buffer, start, nullByte );

		return this._textDecoder.decode( a );

	}

}

// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
// and BinaryParser( FBX Binary format)
class FBXTree {

	add( key, val ) {

		this[ key ] = val;

	}

}

// ************** UTILITY FUNCTIONS **************

function isFbxFormatBinary( buffer ) {

	const CORRECT = 'Kaydara\u0020FBX\u0020Binary\u0020\u0020\0';

	return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );

}

function isFbxFormatASCII( text ) {

	const CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\' ];

	let cursor = 0;

	function read( offset ) {

		const result = text[ offset - 1 ];
		text = text.slice( cursor + offset );
		cursor ++;
		return result;

	}

	for ( let i = 0; i < CORRECT.length; ++ i ) {

		const num = read( 1 );
		if ( num === CORRECT[ i ] ) {

			return false;

		}

	}

	return true;

}

function getFbxVersion( text ) {

	const versionRegExp = /FBXVersion: (\d+)/;
	const match = text.match( versionRegExp );

	if ( match ) {

		const version = parseInt( match[ 1 ] );
		return version;

	}

	throw new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );

}

// Converts FBX ticks into real time seconds.
function convertFBXTimeToSeconds( time ) {

	return time / 46186158000;

}

const dataArray = [];

// extracts the data from the correct position in the FBX array based on indexing type
function getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

	let index;

	switch ( infoObject.mappingType ) {

		case 'ByPolygonVertex' :
			index = polygonVertexIndex;
			break;
		case 'ByPolygon' :
			index = polygonIndex;
			break;
		case 'ByVertice' :
			index = vertexIndex;
			break;
		case 'AllSame' :
			index = infoObject.indices[ 0 ];
			break;
		default :
			console.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );

	}

	if ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];

	const from = index * infoObject.dataSize;
	const to = from + infoObject.dataSize;

	return slice$1( dataArray, infoObject.buffer, from, to );

}

const tempEuler = new Euler();
const tempVec = new Vector3();

// generate transformation from FBX transform data
// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e
function generateTransform( transformData ) {

	const lTranslationM = new Matrix4();
	const lPreRotationM = new Matrix4();
	const lRotationM = new Matrix4();
	const lPostRotationM = new Matrix4();

	const lScalingM = new Matrix4();
	const lScalingPivotM = new Matrix4();
	const lScalingOffsetM = new Matrix4();
	const lRotationOffsetM = new Matrix4();
	const lRotationPivotM = new Matrix4();

	const lParentGX = new Matrix4();
	const lParentLX = new Matrix4();
	const lGlobalT = new Matrix4();

	const inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;

	if ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );

	if ( transformData.preRotation ) {

		const array = transformData.preRotation.map( MathUtils.degToRad );
		array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );
		lPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

	}

	if ( transformData.rotation ) {

		const array = transformData.rotation.map( MathUtils.degToRad );
		array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );
		lRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

	}

	if ( transformData.postRotation ) {

		const array = transformData.postRotation.map( MathUtils.degToRad );
		array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );
		lPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );
		lPostRotationM.invert();

	}

	if ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );

	// Pivots and offsets
	if ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );
	if ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );
	if ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );
	if ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );

	// parent transform
	if ( transformData.parentMatrixWorld ) {

		lParentLX.copy( transformData.parentMatrix );
		lParentGX.copy( transformData.parentMatrixWorld );

	}

	const lLRM = lPreRotationM.clone().multiply( lRotationM ).multiply( lPostRotationM );
	// Global Rotation
	const lParentGRM = new Matrix4();
	lParentGRM.extractRotation( lParentGX );

	// Global Shear*Scaling
	const lParentTM = new Matrix4();
	lParentTM.copyPosition( lParentGX );

	const lParentGRSM = lParentTM.clone().invert().multiply( lParentGX );
	const lParentGSM = lParentGRM.clone().invert().multiply( lParentGRSM );
	const lLSM = lScalingM;

	const lGlobalRS = new Matrix4();

	if ( inheritType === 0 ) {

		lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );

	} else if ( inheritType === 1 ) {

		lGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );

	} else {

		const lParentLSM = new Matrix4().scale( new Vector3().setFromMatrixScale( lParentLX ) );
		const lParentLSM_inv = lParentLSM.clone().invert();
		const lParentGSM_noLocal = lParentGSM.clone().multiply( lParentLSM_inv );

		lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );

	}

	const lRotationPivotM_inv = lRotationPivotM.clone().invert();
	const lScalingPivotM_inv = lScalingPivotM.clone().invert();
	// Calculate the local transform matrix
	let lTransform = lTranslationM.clone().multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );

	const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition( lTransform );

	const lGlobalTranslation = lParentGX.clone().multiply( lLocalTWithAllPivotAndOffsetInfo );
	lGlobalT.copyPosition( lGlobalTranslation );

	lTransform = lGlobalT.clone().multiply( lGlobalRS );

	// from global to local
	lTransform.premultiply( lParentGX.invert() );

	return lTransform;

}

// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html
function getEulerOrder( order ) {

	order = order || 0;

	const enums = [
		'ZYX', // -> XYZ extrinsic
		'YZX', // -> XZY extrinsic
		'XZY', // -> YZX extrinsic
		'ZXY', // -> YXZ extrinsic
		'YXZ', // -> ZXY extrinsic
		'XYZ', // -> ZYX extrinsic
		//'SphericXYZ', // not possible to support
	];

	if ( order === 6 ) {

		console.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );
		return enums[ 0 ];

	}

	return enums[ order ];

}

// Parses comma separated list of numbers and returns them an array.
// Used internally by the TextParser
function parseNumberArray( value ) {

	const array = value.split( ',' ).map( function ( val ) {

		return parseFloat( val );

	} );

	return array;

}

function convertArrayBufferToString( buffer, from, to ) {

	if ( from === undefined ) from = 0;
	if ( to === undefined ) to = buffer.byteLength;

	return new TextDecoder().decode( new Uint8Array( buffer, from, to ) );

}

function append( a, b ) {

	for ( let i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {

		a[ j ] = b[ i ];

	}

}

function slice$1( a, b, from, to ) {

	for ( let i = from, j = 0; i < to; i ++, j ++ ) {

		a[ j ] = b[ i ];

	}

	return a;

}

// inject array a2 into array a1 at index
function inject$1( a1, index, a2 ) {

	return a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );

}

// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

class RGBELoader extends DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = HalfFloatType;

	}

	// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

	parse( buffer ) {

		const
			/* return codes for rgbe routines */
			//RGBE_RETURN_SUCCESS = 0,
			RGBE_RETURN_FAILURE = - 1,

			/* default error routine.  change this to change error handling */
			rgbe_read_error = 1,
			rgbe_write_error = 2,
			rgbe_format_error = 3,
			rgbe_memory_error = 4,
			rgbe_error = function ( rgbe_error_code, msg ) {

				switch ( rgbe_error_code ) {

					case rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );
						break;
					case rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );
						break;
					case rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );
						break;
					default:
					case rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );

				}

				return RGBE_RETURN_FAILURE;

			},

			/* offsets to red, green, and blue components in a data (float) pixel */
			//RGBE_DATA_RED = 0,
			//RGBE_DATA_GREEN = 1,
			//RGBE_DATA_BLUE = 2,

			/* number of floats per pixel, use 4 since stored in rgba image format */
			//RGBE_DATA_SIZE = 4,

			/* flags indicating which fields in an rgbe_header_info are valid */
			RGBE_VALID_PROGRAMTYPE = 1,
			RGBE_VALID_FORMAT = 2,
			RGBE_VALID_DIMENSIONS = 4,

			NEWLINE = '\n',

			fgets = function ( buffer, lineLimit, consume ) {

				const chunkSize = 128;

				lineLimit = ! lineLimit ? 1024 : lineLimit;
				let p = buffer.pos,
					i = - 1, len = 0, s = '',
					chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

					s += chunk; len += chunk.length;
					p += chunkSize;
					chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				}

				if ( - 1 < i ) {

					/*for (i=l-1; i>=0; i--) {
						byteCode = m.charCodeAt(i);
						if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
						else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
						if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
					}*/
					if ( false !== consume ) buffer.pos += len + i + 1;
					return s + chunk.slice( 0, i );

				}

				return false;

			},

			/* minimal header reading.  modify if you want to parse more information */
			RGBE_ReadHeader = function ( buffer ) {


				// regexes to parse header info fields
				const magic_token_re = /^#\?(\S+)/,
					gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

					// RGBE format header struct
					header = {

						valid: 0, /* indicate which fields are valid */

						string: '', /* the actual header string */

						comments: '', /* comments found in header */

						programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

						format: '', /* RGBE format, default 32-bit_rle_rgbe */

						gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

						exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

						width: 0, height: 0 /* image dimensions, width/height */

					};

				let line, match;

				if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

					return rgbe_error( rgbe_read_error, 'no header found' );

				}

				/* if you want to require the magic token then uncomment the next line */
				if ( ! ( match = line.match( magic_token_re ) ) ) {

					return rgbe_error( rgbe_format_error, 'bad initial token' );

				}

				header.valid |= RGBE_VALID_PROGRAMTYPE;
				header.programtype = match[ 1 ];
				header.string += line + '\n';

				while ( true ) {

					line = fgets( buffer );
					if ( false === line ) break;
					header.string += line + '\n';

					if ( '#' === line.charAt( 0 ) ) {

						header.comments += line + '\n';
						continue; // comment line

					}

					if ( match = line.match( gamma_re ) ) {

						header.gamma = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( exposure_re ) ) {

						header.exposure = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( format_re ) ) {

						header.valid |= RGBE_VALID_FORMAT;
						header.format = match[ 1 ];//'32-bit_rle_rgbe';

					}

					if ( match = line.match( dimensions_re ) ) {

						header.valid |= RGBE_VALID_DIMENSIONS;
						header.height = parseInt( match[ 1 ], 10 );
						header.width = parseInt( match[ 2 ], 10 );

					}

					if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;

				}

				if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

					return rgbe_error( rgbe_format_error, 'missing format specifier' );

				}

				if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

					return rgbe_error( rgbe_format_error, 'missing image size specifier' );

				}

				return header;

			},

			RGBE_ReadPixels_RLE = function ( buffer, w, h ) {

				const scanline_width = w;

				if (
					// run length encoding is not allowed so read flat
					( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
					// this file is not run length encoded
					( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
				) {

					// return the flat buffer
					return new Uint8Array( buffer );

				}

				if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

					return rgbe_error( rgbe_format_error, 'wrong scanline width' );

				}

				const data_rgba = new Uint8Array( 4 * w * h );

				if ( ! data_rgba.length ) {

					return rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );

				}

				let offset = 0, pos = 0;

				const ptr_end = 4 * scanline_width;
				const rgbeStart = new Uint8Array( 4 );
				const scanline_buffer = new Uint8Array( ptr_end );
				let num_scanlines = h;

				// read in each successive scanline
				while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

					if ( pos + 4 > buffer.byteLength ) {

						return rgbe_error( rgbe_read_error );

					}

					rgbeStart[ 0 ] = buffer[ pos ++ ];
					rgbeStart[ 1 ] = buffer[ pos ++ ];
					rgbeStart[ 2 ] = buffer[ pos ++ ];
					rgbeStart[ 3 ] = buffer[ pos ++ ];

					if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

						return rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );

					}

					// read each of the four channels for the scanline into the buffer
					// first red, then green, then blue, then exponent
					let ptr = 0, count;

					while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

						count = buffer[ pos ++ ];
						const isEncodedRun = count > 128;
						if ( isEncodedRun ) count -= 128;

						if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

							return rgbe_error( rgbe_format_error, 'bad scanline data' );

						}

						if ( isEncodedRun ) {

							// a (encoded) run of the same value
							const byteValue = buffer[ pos ++ ];
							for ( let i = 0; i < count; i ++ ) {

								scanline_buffer[ ptr ++ ] = byteValue;

							}
							//ptr += count;

						} else {

							// a literal-run
							scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
							ptr += count; pos += count;

						}

					}


					// now convert data from buffer into rgba
					// first red, then green, then blue, then exponent (alpha)
					const l = scanline_width; //scanline_buffer.byteLength;
					for ( let i = 0; i < l; i ++ ) {

						let off = 0;
						data_rgba[ offset ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
						offset += 4;

					}

					num_scanlines --;

				}

				return data_rgba;

			};

		const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
			destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
			destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;
			destArray[ destOffset + 3 ] = 1;

		};

		const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			// clamping to 65504, the maximum representable value in float16
			destArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );
			destArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );
			destArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );
			destArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );

		};

		const byteArray = new Uint8Array( buffer );
		byteArray.pos = 0;
		const rgbe_header_info = RGBE_ReadHeader( byteArray );

		if ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {

			const w = rgbe_header_info.width,
				h = rgbe_header_info.height,
				image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );

			if ( RGBE_RETURN_FAILURE !== image_rgba_data ) {

				let data, type;
				let numElements;

				switch ( this.type ) {

					case FloatType:

						numElements = image_rgba_data.length / 4;
						const floatArray = new Float32Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );

						}

						data = floatArray;
						type = FloatType;
						break;

					case HalfFloatType:

						numElements = image_rgba_data.length / 4;
						const halfArray = new Uint16Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );

						}

						data = halfArray;
						type = HalfFloatType;
						break;

					default:

						console.error( 'THREE.RGBELoader: unsupported type: ', this.type );
						break;

				}

				return {
					width: w, height: h,
					data: data,
					header: rgbe_header_info.string,
					gamma: rgbe_header_info.gamma,
					exposure: rgbe_header_info.exposure,
					type: type
				};

			}

		}

		return null;

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			switch ( texture.type ) {

				case FloatType:
				case HalfFloatType:

					texture.colorSpace = LinearSRGBColorSpace;
					texture.minFilter = LinearFilter;
					texture.magFilter = LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;

					break;

			}

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}

/**
 * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.
 * Supports reading as UnsignedByte, HalfFloat and Float type data texture.
 *
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation, so I have preserved their copyright notices.
 */

// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */

// // TinyEXR contains some OpenEXR code, which is licensed under ------------

// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////

// // End of OpenEXR license -------------------------------------------------

class EXRLoader extends DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = HalfFloatType;

	}

	parse( buffer ) {

		const USHORT_RANGE = ( 1 << 16 );
		const BITMAP_SIZE = ( USHORT_RANGE >> 3 );

		const HUF_ENCBITS = 16; // literal (value) bit length
		const HUF_DECBITS = 14; // decoding bit size (>= 8)

		const HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size
		const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size
		const HUF_DECMASK = HUF_DECSIZE - 1;

		const NBITS = 16;
		const A_OFFSET = 1 << ( NBITS - 1 );
		const MOD_MASK = ( 1 << NBITS ) - 1;

		const SHORT_ZEROCODE_RUN = 59;
		const LONG_ZEROCODE_RUN = 63;
		const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;

		const ULONG_SIZE = 8;
		const FLOAT32_SIZE = 4;
		const INT32_SIZE = 4;
		const INT16_SIZE = 2;
		const INT8_SIZE = 1;

		const STATIC_HUFFMAN = 0;
		const DEFLATE = 1;

		const UNKNOWN = 0;
		const LOSSY_DCT = 1;
		const RLE = 2;

		const logBase = Math.pow( 2.7182818, 2.2 );

		function reverseLutFromBitmap( bitmap, lut ) {

			let k = 0;

			for ( let i = 0; i < USHORT_RANGE; ++ i ) {

				if ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {

					lut[ k ++ ] = i;

				}

			}

			const n = k - 1;

			while ( k < USHORT_RANGE ) lut[ k ++ ] = 0;

			return n;

		}

		function hufClearDecTable( hdec ) {

			for ( let i = 0; i < HUF_DECSIZE; i ++ ) {

				hdec[ i ] = {};
				hdec[ i ].len = 0;
				hdec[ i ].lit = 0;
				hdec[ i ].p = null;

			}

		}

		const getBitsReturn = { l: 0, c: 0, lc: 0 };

		function getBits( nBits, c, lc, uInt8Array, inOffset ) {

			while ( lc < nBits ) {

				c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
				lc += 8;

			}

			lc -= nBits;

			getBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );
			getBitsReturn.c = c;
			getBitsReturn.lc = lc;

		}

		const hufTableBuffer = new Array( 59 );

		function hufCanonicalCodeTable( hcode ) {

			for ( let i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;
			for ( let i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;

			let c = 0;

			for ( let i = 58; i > 0; -- i ) {

				const nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );
				hufTableBuffer[ i ] = c;
				c = nc;

			}

			for ( let i = 0; i < HUF_ENCSIZE; ++ i ) {

				const l = hcode[ i ];
				if ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );

			}

		}

		function hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {

			const p = inOffset;
			let c = 0;
			let lc = 0;

			for ( ; im <= iM; im ++ ) {

				if ( p.value - inOffset.value > ni ) return false;

				getBits( 6, c, lc, uInt8Array, p );

				const l = getBitsReturn.l;
				c = getBitsReturn.c;
				lc = getBitsReturn.lc;

				hcode[ im ] = l;

				if ( l == LONG_ZEROCODE_RUN ) {

					if ( p.value - inOffset.value > ni ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					getBits( 8, c, lc, uInt8Array, p );

					let zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
					c = getBitsReturn.c;
					lc = getBitsReturn.lc;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				} else if ( l >= SHORT_ZEROCODE_RUN ) {

					let zerun = l - SHORT_ZEROCODE_RUN + 2;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				}

			}

			hufCanonicalCodeTable( hcode );

		}

		function hufLength( code ) {

			return code & 63;

		}

		function hufCode( code ) {

			return code >> 6;

		}

		function hufBuildDecTable( hcode, im, iM, hdecod ) {

			for ( ; im <= iM; im ++ ) {

				const c = hufCode( hcode[ im ] );
				const l = hufLength( hcode[ im ] );

				if ( c >> l ) {

					throw new Error( 'Invalid table entry' );

				}

				if ( l > HUF_DECBITS ) {

					const pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];

					if ( pl.len ) {

						throw new Error( 'Invalid table entry' );

					}

					pl.lit ++;

					if ( pl.p ) {

						const p = pl.p;
						pl.p = new Array( pl.lit );

						for ( let i = 0; i < pl.lit - 1; ++ i ) {

							pl.p[ i ] = p[ i ];

						}

					} else {

						pl.p = new Array( 1 );

					}

					pl.p[ pl.lit - 1 ] = im;

				} else if ( l ) {

					let plOffset = 0;

					for ( let i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {

						const pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];

						if ( pl.len || pl.p ) {

							throw new Error( 'Invalid table entry' );

						}

						pl.len = l;
						pl.lit = im;

						plOffset ++;

					}

				}

			}

			return true;

		}

		const getCharReturn = { c: 0, lc: 0 };

		function getChar( c, lc, uInt8Array, inOffset ) {

			c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
			lc += 8;

			getCharReturn.c = c;
			getCharReturn.lc = lc;

		}

		const getCodeReturn = { c: 0, lc: 0 };

		function getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {

			if ( po == rlc ) {

				if ( lc < 8 ) {

					getChar( c, lc, uInt8Array, inOffset );
					c = getCharReturn.c;
					lc = getCharReturn.lc;

				}

				lc -= 8;

				let cs = ( c >> lc );
				cs = new Uint8Array( [ cs ] )[ 0 ];

				if ( outBufferOffset.value + cs > outBufferEndOffset ) {

					return false;

				}

				const s = outBuffer[ outBufferOffset.value - 1 ];

				while ( cs -- > 0 ) {

					outBuffer[ outBufferOffset.value ++ ] = s;

				}

			} else if ( outBufferOffset.value < outBufferEndOffset ) {

				outBuffer[ outBufferOffset.value ++ ] = po;

			} else {

				return false;

			}

			getCodeReturn.c = c;
			getCodeReturn.lc = lc;

		}

		function UInt16( value ) {

			return ( value & 0xFFFF );

		}

		function Int16( value ) {

			const ref = UInt16( value );
			return ( ref > 0x7FFF ) ? ref - 0x10000 : ref;

		}

		const wdec14Return = { a: 0, b: 0 };

		function wdec14( l, h ) {

			const ls = Int16( l );
			const hs = Int16( h );

			const hi = hs;
			const ai = ls + ( hi & 1 ) + ( hi >> 1 );

			const as = ai;
			const bs = ai - hi;

			wdec14Return.a = as;
			wdec14Return.b = bs;

		}

		function wdec16( l, h ) {

			const m = UInt16( l );
			const d = UInt16( h );

			const bb = ( m - ( d >> 1 ) ) & MOD_MASK;
			const aa = ( d + bb - A_OFFSET ) & MOD_MASK;

			wdec14Return.a = aa;
			wdec14Return.b = bb;

		}

		function wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {

			const w14 = mx < ( 1 << 14 );
			const n = ( nx > ny ) ? ny : nx;
			let p = 1;
			let p2;
			let py;

			while ( p <= n ) p <<= 1;

			p >>= 1;
			p2 = p;
			p >>= 1;

			while ( p >= 1 ) {

				py = 0;
				const ey = py + oy * ( ny - p2 );
				const oy1 = oy * p;
				const oy2 = oy * p2;
				const ox1 = ox * p;
				const ox2 = ox * p2;
				let i00, i01, i10, i11;

				for ( ; py <= ey; py += oy2 ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px <= ex; px += ox2 ) {

						const p01 = px + ox1;
						const p10 = px + oy1;
						const p11 = p10 + ox1;

						if ( w14 ) {

							wdec14( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec14( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec14( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec14( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;

						} else {

							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec16( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec16( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec16( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;


						}

					}

					if ( nx & p ) {

						const p10 = px + oy1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p10 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

						i00 = wdec14Return.a;
						buffer[ p10 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				if ( ny & p ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px <= ex; px += ox2 ) {

						const p01 = px + ox1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p01 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p01 + j ] );

						i00 = wdec14Return.a;
						buffer[ p01 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				p2 = p;
				p >>= 1;

			}

			return py;

		}

		function hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {

			let c = 0;
			let lc = 0;
			const outBufferEndOffset = no;
			const inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );

			while ( inOffset.value < inOffsetEnd ) {

				getChar( c, lc, uInt8Array, inOffset );

				c = getCharReturn.c;
				lc = getCharReturn.lc;

				while ( lc >= HUF_DECBITS ) {

					const index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;
					const pl = decodingTable[ index ];

					if ( pl.len ) {

						lc -= pl.len;

						getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

						c = getCodeReturn.c;
						lc = getCodeReturn.lc;

					} else {

						if ( ! pl.p ) {

							throw new Error( 'hufDecode issues' );

						}

						let j;

						for ( j = 0; j < pl.lit; j ++ ) {

							const l = hufLength( encodingTable[ pl.p[ j ] ] );

							while ( lc < l && inOffset.value < inOffsetEnd ) {

								getChar( c, lc, uInt8Array, inOffset );

								c = getCharReturn.c;
								lc = getCharReturn.lc;

							}

							if ( lc >= l ) {

								if ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {

									lc -= l;

									getCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

									c = getCodeReturn.c;
									lc = getCodeReturn.lc;

									break;

								}

							}

						}

						if ( j == pl.lit ) {

							throw new Error( 'hufDecode issues' );

						}

					}

				}

			}

			const i = ( 8 - ni ) & 7;

			c >>= i;
			lc -= i;

			while ( lc > 0 ) {

				const pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];

				if ( pl.len ) {

					lc -= pl.len;

					getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

					c = getCodeReturn.c;
					lc = getCodeReturn.lc;

				} else {

					throw new Error( 'hufDecode issues' );

				}

			}

			return true;

		}

		function hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {

			const outOffset = { value: 0 };
			const initialInOffset = inOffset.value;

			const im = parseUint32( inDataView, inOffset );
			const iM = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			const nBits = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			if ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {

				throw new Error( 'Something wrong with HUF_ENCSIZE' );

			}

			const freq = new Array( HUF_ENCSIZE );
			const hdec = new Array( HUF_DECSIZE );

			hufClearDecTable( hdec );

			const ni = nCompressed - ( inOffset.value - initialInOffset );

			hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );

			if ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {

				throw new Error( 'Something wrong with hufUncompress' );

			}

			hufBuildDecTable( freq, im, iM, hdec );

			hufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );

		}

		function applyLut( lut, data, nData ) {

			for ( let i = 0; i < nData; ++ i ) {

				data[ i ] = lut[ data[ i ] ];

			}

		}

		function predictor( source ) {

			for ( let t = 1; t < source.length; t ++ ) {

				const d = source[ t - 1 ] + source[ t ] - 128;
				source[ t ] = d;

			}

		}

		function interleaveScalar( source, out ) {

			let t1 = 0;
			let t2 = Math.floor( ( source.length + 1 ) / 2 );
			let s = 0;
			const stop = source.length - 1;

			while ( true ) {

				if ( s > stop ) break;
				out[ s ++ ] = source[ t1 ++ ];

				if ( s > stop ) break;
				out[ s ++ ] = source[ t2 ++ ];

			}

		}

		function decodeRunLength( source ) {

			let size = source.byteLength;
			const out = new Array();
			let p = 0;

			const reader = new DataView( source );

			while ( size > 0 ) {

				const l = reader.getInt8( p ++ );

				if ( l < 0 ) {

					const count = - l;
					size -= count + 1;

					for ( let i = 0; i < count; i ++ ) {

						out.push( reader.getUint8( p ++ ) );

					}


				} else {

					const count = l;
					size -= 2;

					const value = reader.getUint8( p ++ );

					for ( let i = 0; i < count + 1; i ++ ) {

						out.push( value );

					}

				}

			}

			return out;

		}

		function lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {

			let dataView = new DataView( outBuffer.buffer );

			const width = channelData[ cscSet.idx[ 0 ] ].width;
			const height = channelData[ cscSet.idx[ 0 ] ].height;

			const numComp = 3;

			const numFullBlocksX = Math.floor( width / 8.0 );
			const numBlocksX = Math.ceil( width / 8.0 );
			const numBlocksY = Math.ceil( height / 8.0 );
			const leftoverX = width - ( numBlocksX - 1 ) * 8;
			const leftoverY = height - ( numBlocksY - 1 ) * 8;

			const currAcComp = { value: 0 };
			const currDcComp = new Array( numComp );
			const dctData = new Array( numComp );
			const halfZigBlock = new Array( numComp );
			const rowBlock = new Array( numComp );
			const rowOffsets = new Array( numComp );

			for ( let comp = 0; comp < numComp; ++ comp ) {

				rowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];
				currDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;
				dctData[ comp ] = new Float32Array( 64 );
				halfZigBlock[ comp ] = new Uint16Array( 64 );
				rowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );

			}

			for ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {

				let maxY = 8;

				if ( blocky == numBlocksY - 1 )
					maxY = leftoverY;

				let maxX = 8;

				for ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {

					if ( blockx == numBlocksX - 1 )
						maxX = leftoverX;

					for ( let comp = 0; comp < numComp; ++ comp ) {

						halfZigBlock[ comp ].fill( 0 );

						// set block DC component
						halfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];
						// set block AC components
						unRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );

						// UnZigZag block to float
						unZigZag( halfZigBlock[ comp ], dctData[ comp ] );
						// decode float dct
						dctInverse( dctData[ comp ] );

					}

					{

						csc709Inverse( dctData );

					}

					for ( let comp = 0; comp < numComp; ++ comp ) {

						convertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );

					}

				} // blockx

				let offset = 0;

				for ( let comp = 0; comp < numComp; ++ comp ) {

					const type = channelData[ cscSet.idx[ comp ] ].type;

					for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {

						offset = rowOffsets[ comp ][ y ];

						for ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {

							const src = blockx * 64 + ( ( y & 0x7 ) * 8 );

							dataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );
							dataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );
							dataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );
							dataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );

							dataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );
							dataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );
							dataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );
							dataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );

							offset += 8 * INT16_SIZE * type;

						}

					}

					// handle partial X blocks
					if ( numFullBlocksX != numBlocksX ) {

						for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {

							const offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;
							const src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );

							for ( let x = 0; x < maxX; ++ x ) {

								dataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );

							}

						}

					}

				} // comp

			} // blocky

			const halfRow = new Uint16Array( width );
			dataView = new DataView( outBuffer.buffer );

			// convert channels back to float, if needed
			for ( let comp = 0; comp < numComp; ++ comp ) {

				channelData[ cscSet.idx[ comp ] ].decoded = true;
				const type = channelData[ cscSet.idx[ comp ] ].type;

				if ( channelData[ comp ].type != 2 ) continue;

				for ( let y = 0; y < height; ++ y ) {

					const offset = rowOffsets[ comp ][ y ];

					for ( let x = 0; x < width; ++ x ) {

						halfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );

					}

					for ( let x = 0; x < width; ++ x ) {

						dataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );

					}

				}

			}

		}

		function unRleAC( currAcComp, acBuffer, halfZigBlock ) {

			let acValue;
			let dctComp = 1;

			while ( dctComp < 64 ) {

				acValue = acBuffer[ currAcComp.value ];

				if ( acValue == 0xff00 ) {

					dctComp = 64;

				} else if ( acValue >> 8 == 0xff ) {

					dctComp += acValue & 0xff;

				} else {

					halfZigBlock[ dctComp ] = acValue;
					dctComp ++;

				}

				currAcComp.value ++;

			}

		}

		function unZigZag( src, dst ) {

			dst[ 0 ] = decodeFloat16( src[ 0 ] );
			dst[ 1 ] = decodeFloat16( src[ 1 ] );
			dst[ 2 ] = decodeFloat16( src[ 5 ] );
			dst[ 3 ] = decodeFloat16( src[ 6 ] );
			dst[ 4 ] = decodeFloat16( src[ 14 ] );
			dst[ 5 ] = decodeFloat16( src[ 15 ] );
			dst[ 6 ] = decodeFloat16( src[ 27 ] );
			dst[ 7 ] = decodeFloat16( src[ 28 ] );
			dst[ 8 ] = decodeFloat16( src[ 2 ] );
			dst[ 9 ] = decodeFloat16( src[ 4 ] );

			dst[ 10 ] = decodeFloat16( src[ 7 ] );
			dst[ 11 ] = decodeFloat16( src[ 13 ] );
			dst[ 12 ] = decodeFloat16( src[ 16 ] );
			dst[ 13 ] = decodeFloat16( src[ 26 ] );
			dst[ 14 ] = decodeFloat16( src[ 29 ] );
			dst[ 15 ] = decodeFloat16( src[ 42 ] );
			dst[ 16 ] = decodeFloat16( src[ 3 ] );
			dst[ 17 ] = decodeFloat16( src[ 8 ] );
			dst[ 18 ] = decodeFloat16( src[ 12 ] );
			dst[ 19 ] = decodeFloat16( src[ 17 ] );

			dst[ 20 ] = decodeFloat16( src[ 25 ] );
			dst[ 21 ] = decodeFloat16( src[ 30 ] );
			dst[ 22 ] = decodeFloat16( src[ 41 ] );
			dst[ 23 ] = decodeFloat16( src[ 43 ] );
			dst[ 24 ] = decodeFloat16( src[ 9 ] );
			dst[ 25 ] = decodeFloat16( src[ 11 ] );
			dst[ 26 ] = decodeFloat16( src[ 18 ] );
			dst[ 27 ] = decodeFloat16( src[ 24 ] );
			dst[ 28 ] = decodeFloat16( src[ 31 ] );
			dst[ 29 ] = decodeFloat16( src[ 40 ] );

			dst[ 30 ] = decodeFloat16( src[ 44 ] );
			dst[ 31 ] = decodeFloat16( src[ 53 ] );
			dst[ 32 ] = decodeFloat16( src[ 10 ] );
			dst[ 33 ] = decodeFloat16( src[ 19 ] );
			dst[ 34 ] = decodeFloat16( src[ 23 ] );
			dst[ 35 ] = decodeFloat16( src[ 32 ] );
			dst[ 36 ] = decodeFloat16( src[ 39 ] );
			dst[ 37 ] = decodeFloat16( src[ 45 ] );
			dst[ 38 ] = decodeFloat16( src[ 52 ] );
			dst[ 39 ] = decodeFloat16( src[ 54 ] );

			dst[ 40 ] = decodeFloat16( src[ 20 ] );
			dst[ 41 ] = decodeFloat16( src[ 22 ] );
			dst[ 42 ] = decodeFloat16( src[ 33 ] );
			dst[ 43 ] = decodeFloat16( src[ 38 ] );
			dst[ 44 ] = decodeFloat16( src[ 46 ] );
			dst[ 45 ] = decodeFloat16( src[ 51 ] );
			dst[ 46 ] = decodeFloat16( src[ 55 ] );
			dst[ 47 ] = decodeFloat16( src[ 60 ] );
			dst[ 48 ] = decodeFloat16( src[ 21 ] );
			dst[ 49 ] = decodeFloat16( src[ 34 ] );

			dst[ 50 ] = decodeFloat16( src[ 37 ] );
			dst[ 51 ] = decodeFloat16( src[ 47 ] );
			dst[ 52 ] = decodeFloat16( src[ 50 ] );
			dst[ 53 ] = decodeFloat16( src[ 56 ] );
			dst[ 54 ] = decodeFloat16( src[ 59 ] );
			dst[ 55 ] = decodeFloat16( src[ 61 ] );
			dst[ 56 ] = decodeFloat16( src[ 35 ] );
			dst[ 57 ] = decodeFloat16( src[ 36 ] );
			dst[ 58 ] = decodeFloat16( src[ 48 ] );
			dst[ 59 ] = decodeFloat16( src[ 49 ] );

			dst[ 60 ] = decodeFloat16( src[ 57 ] );
			dst[ 61 ] = decodeFloat16( src[ 58 ] );
			dst[ 62 ] = decodeFloat16( src[ 62 ] );
			dst[ 63 ] = decodeFloat16( src[ 63 ] );

		}

		function dctInverse( data ) {

			const a = 0.5 * Math.cos( 3.14159 / 4.0 );
			const b = 0.5 * Math.cos( 3.14159 / 16.0 );
			const c = 0.5 * Math.cos( 3.14159 / 8.0 );
			const d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );
			const e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );
			const f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );
			const g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );

			const alpha = new Array( 4 );
			const beta = new Array( 4 );
			const theta = new Array( 4 );
			const gamma = new Array( 4 );

			for ( let row = 0; row < 8; ++ row ) {

				const rowPtr = row * 8;

				alpha[ 0 ] = c * data[ rowPtr + 2 ];
				alpha[ 1 ] = f * data[ rowPtr + 2 ];
				alpha[ 2 ] = c * data[ rowPtr + 6 ];
				alpha[ 3 ] = f * data[ rowPtr + 6 ];

				beta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];
				beta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];
				beta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];
				beta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];

				theta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );
				theta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );
				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];
				data[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];
				data[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];
				data[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];

				data[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];
				data[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];
				data[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];
				data[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];

			}

			for ( let column = 0; column < 8; ++ column ) {

				alpha[ 0 ] = c * data[ 16 + column ];
				alpha[ 1 ] = f * data[ 16 + column ];
				alpha[ 2 ] = c * data[ 48 + column ];
				alpha[ 3 ] = f * data[ 48 + column ];

				beta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];
				beta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];
				beta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];
				beta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];

				theta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );
				theta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );

				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];
				data[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];
				data[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];
				data[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];

				data[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];
				data[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];
				data[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];
				data[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];

			}

		}

		function csc709Inverse( data ) {

			for ( let i = 0; i < 64; ++ i ) {

				const y = data[ 0 ][ i ];
				const cb = data[ 1 ][ i ];
				const cr = data[ 2 ][ i ];

				data[ 0 ][ i ] = y + 1.5747 * cr;
				data[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;
				data[ 2 ][ i ] = y + 1.8556 * cb;

			}

		}

		function convertToHalf( src, dst, idx ) {

			for ( let i = 0; i < 64; ++ i ) {

				dst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) );

			}

		}

		function toLinear( float ) {

			if ( float <= 1 ) {

				return Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );

			} else {

				return Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );

			}

		}

		function uncompressRAW( info ) {

			return new DataView( info.array.buffer, info.offset.value, info.size );

		}

		function uncompressRLE( info ) {

			const compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = new Uint8Array( decodeRunLength( compressed ) );
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressZIP( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = unzlibSync( compressed );
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPIZ( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };

			const outBuffer = new Uint16Array( info.width * info.scanlineBlockSize * ( info.channels * info.type ) );
			const bitmap = new Uint8Array( BITMAP_SIZE );

			// Setup channel info
			let outBufferEnd = 0;
			const pizChannelData = new Array( info.channels );
			for ( let i = 0; i < info.channels; i ++ ) {

				pizChannelData[ i ] = {};
				pizChannelData[ i ][ 'start' ] = outBufferEnd;
				pizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];
				pizChannelData[ i ][ 'nx' ] = info.width;
				pizChannelData[ i ][ 'ny' ] = info.lines;
				pizChannelData[ i ][ 'size' ] = info.type;

				outBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;

			}

			// Read range compression data

			const minNonZero = parseUint16( inDataView, inOffset );
			const maxNonZero = parseUint16( inDataView, inOffset );

			if ( maxNonZero >= BITMAP_SIZE ) {

				throw new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );

			}

			if ( minNonZero <= maxNonZero ) {

				for ( let i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {

					bitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );

				}

			}

			// Reverse LUT
			const lut = new Uint16Array( USHORT_RANGE );
			const maxValue = reverseLutFromBitmap( bitmap, lut );

			const length = parseUint32( inDataView, inOffset );

			// Huffman decoding
			hufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );

			// Wavelet decoding
			for ( let i = 0; i < info.channels; ++ i ) {

				const cd = pizChannelData[ i ];

				for ( let j = 0; j < pizChannelData[ i ].size; ++ j ) {

					wav2Decode(
						outBuffer,
						cd.start + j,
						cd.nx,
						cd.size,
						cd.ny,
						cd.nx * cd.size,
						maxValue
					);

				}

			}

			// Expand the pixel data to their original range
			applyLut( lut, outBuffer, outBufferEnd );

			// Rearrange the pixel data into the format expected by the caller.
			let tmpOffset = 0;
			const tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );
			for ( let y = 0; y < info.lines; y ++ ) {

				for ( let c = 0; c < info.channels; c ++ ) {

					const cd = pizChannelData[ c ];

					const n = cd.nx * cd.size;
					const cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );

					tmpBuffer.set( cp, tmpOffset );
					tmpOffset += n * INT16_SIZE;
					cd.end += n;

				}

			}

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPXR( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = unzlibSync( compressed );

			const sz = info.lines * info.channels * info.width;
			const tmpBuffer = ( info.type == 1 ) ? new Uint16Array( sz ) : new Uint32Array( sz );

			let tmpBufferEnd = 0;
			let writePtr = 0;
			const ptr = new Array( 4 );

			for ( let y = 0; y < info.lines; y ++ ) {

				for ( let c = 0; c < info.channels; c ++ ) {

					let pixel = 0;

					switch ( info.type ) {

						case 1:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.width;
							tmpBufferEnd = ptr[ 1 ] + info.width;

							for ( let j = 0; j < info.width; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 8 ) | rawBuffer[ ptr[ 1 ] ++ ];

								pixel += diff;

								tmpBuffer[ writePtr ] = pixel;
								writePtr ++;

							}

							break;

						case 2:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.width;
							ptr[ 2 ] = ptr[ 1 ] + info.width;
							tmpBufferEnd = ptr[ 2 ] + info.width;

							for ( let j = 0; j < info.width; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] << 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] << 8 );

								pixel += diff;

								tmpBuffer[ writePtr ] = pixel;
								writePtr ++;

							}

							break;

					}

				}

			}

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressDWA( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };
			const outBuffer = new Uint8Array( info.width * info.lines * ( info.channels * info.type * INT16_SIZE ) );

			// Read compression header information
			const dwaHeader = {

				version: parseInt64( inDataView, inOffset ),
				unknownUncompressedSize: parseInt64( inDataView, inOffset ),
				unknownCompressedSize: parseInt64( inDataView, inOffset ),
				acCompressedSize: parseInt64( inDataView, inOffset ),
				dcCompressedSize: parseInt64( inDataView, inOffset ),
				rleCompressedSize: parseInt64( inDataView, inOffset ),
				rleUncompressedSize: parseInt64( inDataView, inOffset ),
				rleRawSize: parseInt64( inDataView, inOffset ),
				totalAcUncompressedCount: parseInt64( inDataView, inOffset ),
				totalDcUncompressedCount: parseInt64( inDataView, inOffset ),
				acCompression: parseInt64( inDataView, inOffset )

			};

			if ( dwaHeader.version < 2 )
				throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );

			// Read channel ruleset information
			const channelRules = new Array();
			let ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;

			while ( ruleSize > 0 ) {

				const name = parseNullTerminatedString( inDataView.buffer, inOffset );
				const value = parseUint8( inDataView, inOffset );
				const compression = ( value >> 2 ) & 3;
				const csc = ( value >> 4 ) - 1;
				const index = new Int8Array( [ csc ] )[ 0 ];
				const type = parseUint8( inDataView, inOffset );

				channelRules.push( {
					name: name,
					index: index,
					type: type,
					compression: compression,
				} );

				ruleSize -= name.length + 3;

			}

			// Classify channels
			const channels = EXRHeader.channels;
			const channelData = new Array( info.channels );

			for ( let i = 0; i < info.channels; ++ i ) {

				const cd = channelData[ i ] = {};
				const channel = channels[ i ];

				cd.name = channel.name;
				cd.compression = UNKNOWN;
				cd.decoded = false;
				cd.type = channel.pixelType;
				cd.pLinear = channel.pLinear;
				cd.width = info.width;
				cd.height = info.lines;

			}

			const cscSet = {
				idx: new Array( 3 )
			};

			for ( let offset = 0; offset < info.channels; ++ offset ) {

				const cd = channelData[ offset ];

				for ( let i = 0; i < channelRules.length; ++ i ) {

					const rule = channelRules[ i ];

					if ( cd.name == rule.name ) {

						cd.compression = rule.compression;

						if ( rule.index >= 0 ) {

							cscSet.idx[ rule.index ] = offset;

						}

						cd.offset = offset;

					}

				}

			}

			let acBuffer, dcBuffer, rleBuffer;

			// Read DCT - AC component data
			if ( dwaHeader.acCompressedSize > 0 ) {

				switch ( dwaHeader.acCompression ) {

					case STATIC_HUFFMAN:

						acBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );
						hufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );
						break;

					case DEFLATE:

						const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );
						const data = unzlibSync( compressed );
						acBuffer = new Uint16Array( data.buffer );
						inOffset.value += dwaHeader.totalAcUncompressedCount;
						break;

				}


			}

			// Read DCT - DC component data
			if ( dwaHeader.dcCompressedSize > 0 ) {

				const zlibInfo = {
					array: info.array,
					offset: inOffset,
					size: dwaHeader.dcCompressedSize
				};
				dcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );
				inOffset.value += dwaHeader.dcCompressedSize;

			}

			// Read RLE compressed data
			if ( dwaHeader.rleRawSize > 0 ) {

				const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );
				const data = unzlibSync( compressed );
				rleBuffer = decodeRunLength( data.buffer );

				inOffset.value += dwaHeader.rleCompressedSize;

			}

			// Prepare outbuffer data offset
			let outBufferEnd = 0;
			const rowOffsets = new Array( channelData.length );
			for ( let i = 0; i < rowOffsets.length; ++ i ) {

				rowOffsets[ i ] = new Array();

			}

			for ( let y = 0; y < info.lines; ++ y ) {

				for ( let chan = 0; chan < channelData.length; ++ chan ) {

					rowOffsets[ chan ].push( outBufferEnd );
					outBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;

				}

			}

			// Lossy DCT decode RGB channels
			lossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );

			// Decode other channels
			for ( let i = 0; i < channelData.length; ++ i ) {

				const cd = channelData[ i ];

				if ( cd.decoded ) continue;

				switch ( cd.compression ) {

					case RLE:

						let row = 0;
						let rleOffset = 0;

						for ( let y = 0; y < info.lines; ++ y ) {

							let rowOffsetBytes = rowOffsets[ i ][ row ];

							for ( let x = 0; x < cd.width; ++ x ) {

								for ( let byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {

									outBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];

								}

								rleOffset ++;

							}

							row ++;

						}

						break;

					case LOSSY_DCT: // skip

					default:
						throw new Error( 'EXRLoader.parse: unsupported channel compression' );

				}

			}

			return new DataView( outBuffer.buffer );

		}

		function parseNullTerminatedString( buffer, offset ) {

			const uintBuffer = new Uint8Array( buffer );
			let endOffset = 0;

			while ( uintBuffer[ offset.value + endOffset ] != 0 ) {

				endOffset += 1;

			}

			const stringValue = new TextDecoder().decode(
				uintBuffer.slice( offset.value, offset.value + endOffset )
			);

			offset.value = offset.value + endOffset + 1;

			return stringValue;

		}

		function parseFixedLengthString( buffer, offset, size ) {

			const stringValue = new TextDecoder().decode(
				new Uint8Array( buffer ).slice( offset.value, offset.value + size )
			);

			offset.value = offset.value + size;

			return stringValue;

		}

		function parseRational( dataView, offset ) {

			const x = parseInt32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseTimecode( dataView, offset ) {

			const x = parseUint32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseInt32( dataView, offset ) {

			const Int32 = dataView.getInt32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Int32;

		}

		function parseUint32( dataView, offset ) {

			const Uint32 = dataView.getUint32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Uint32;

		}

		function parseUint8Array( uInt8Array, offset ) {

			const Uint8 = uInt8Array[ offset.value ];

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		function parseUint8( dataView, offset ) {

			const Uint8 = dataView.getUint8( offset.value );

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		const parseInt64 = function ( dataView, offset ) {

			let int;

			if ( 'getBigInt64' in DataView.prototype ) {

				int = Number( dataView.getBigInt64( offset.value, true ) );

			} else {

				int = dataView.getUint32( offset.value + 4, true ) + Number( dataView.getUint32( offset.value, true ) << 32 );

			}

			offset.value += ULONG_SIZE;

			return int;

		};

		function parseFloat32( dataView, offset ) {

			const float = dataView.getFloat32( offset.value, true );

			offset.value += FLOAT32_SIZE;

			return float;

		}

		function decodeFloat32( dataView, offset ) {

			return DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );

		}

		// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript
		function decodeFloat16( binary ) {

			const exponent = ( binary & 0x7C00 ) >> 10,
				fraction = binary & 0x03FF;

			return ( binary >> 15 ? - 1 : 1 ) * (
				exponent ?
					(
						exponent === 0x1F ?
							fraction ? NaN : Infinity :
							Math.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )
					) :
					6.103515625e-5 * ( fraction / 0x400 )
			);

		}

		function parseUint16( dataView, offset ) {

			const Uint16 = dataView.getUint16( offset.value, true );

			offset.value += INT16_SIZE;

			return Uint16;

		}

		function parseFloat16( buffer, offset ) {

			return decodeFloat16( parseUint16( buffer, offset ) );

		}

		function parseChlist( dataView, buffer, offset, size ) {

			const startOffset = offset.value;
			const channels = [];

			while ( offset.value < ( startOffset + size - 1 ) ) {

				const name = parseNullTerminatedString( buffer, offset );
				const pixelType = parseInt32( dataView, offset );
				const pLinear = parseUint8( dataView, offset );
				offset.value += 3; // reserved, three chars
				const xSampling = parseInt32( dataView, offset );
				const ySampling = parseInt32( dataView, offset );

				channels.push( {
					name: name,
					pixelType: pixelType,
					pLinear: pLinear,
					xSampling: xSampling,
					ySampling: ySampling
				} );

			}

			offset.value += 1;

			return channels;

		}

		function parseChromaticities( dataView, offset ) {

			const redX = parseFloat32( dataView, offset );
			const redY = parseFloat32( dataView, offset );
			const greenX = parseFloat32( dataView, offset );
			const greenY = parseFloat32( dataView, offset );
			const blueX = parseFloat32( dataView, offset );
			const blueY = parseFloat32( dataView, offset );
			const whiteX = parseFloat32( dataView, offset );
			const whiteY = parseFloat32( dataView, offset );

			return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };

		}

		function parseCompression( dataView, offset ) {

			const compressionCodes = [
				'NO_COMPRESSION',
				'RLE_COMPRESSION',
				'ZIPS_COMPRESSION',
				'ZIP_COMPRESSION',
				'PIZ_COMPRESSION',
				'PXR24_COMPRESSION',
				'B44_COMPRESSION',
				'B44A_COMPRESSION',
				'DWAA_COMPRESSION',
				'DWAB_COMPRESSION'
			];

			const compression = parseUint8( dataView, offset );

			return compressionCodes[ compression ];

		}

		function parseBox2i( dataView, offset ) {

			const xMin = parseUint32( dataView, offset );
			const yMin = parseUint32( dataView, offset );
			const xMax = parseUint32( dataView, offset );
			const yMax = parseUint32( dataView, offset );

			return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };

		}

		function parseLineOrder( dataView, offset ) {

			const lineOrders = [
				'INCREASING_Y'
			];

			const lineOrder = parseUint8( dataView, offset );

			return lineOrders[ lineOrder ];

		}

		function parseV2f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );

			return [ x, y ];

		}

		function parseV3f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );
			const z = parseFloat32( dataView, offset );

			return [ x, y, z ];

		}

		function parseValue( dataView, buffer, offset, type, size ) {

			if ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {

				return parseFixedLengthString( buffer, offset, size );

			} else if ( type === 'chlist' ) {

				return parseChlist( dataView, buffer, offset, size );

			} else if ( type === 'chromaticities' ) {

				return parseChromaticities( dataView, offset );

			} else if ( type === 'compression' ) {

				return parseCompression( dataView, offset );

			} else if ( type === 'box2i' ) {

				return parseBox2i( dataView, offset );

			} else if ( type === 'lineOrder' ) {

				return parseLineOrder( dataView, offset );

			} else if ( type === 'float' ) {

				return parseFloat32( dataView, offset );

			} else if ( type === 'v2f' ) {

				return parseV2f( dataView, offset );

			} else if ( type === 'v3f' ) {

				return parseV3f( dataView, offset );

			} else if ( type === 'int' ) {

				return parseInt32( dataView, offset );

			} else if ( type === 'rational' ) {

				return parseRational( dataView, offset );

			} else if ( type === 'timecode' ) {

				return parseTimecode( dataView, offset );

			} else if ( type === 'preview' ) {

				offset.value += size;
				return 'skipped';

			} else {

				offset.value += size;
				return undefined;

			}

		}

		function parseHeader( dataView, buffer, offset ) {

			const EXRHeader = {};

			if ( dataView.getUint32( 0, true ) != 20000630 ) { // magic

				throw new Error( 'THREE.EXRLoader: provided file doesn\'t appear to be in OpenEXR format.' );

			}

			EXRHeader.version = dataView.getUint8( 4 );

			const spec = dataView.getUint8( 5 ); // fullMask

			EXRHeader.spec = {
				singleTile: !! ( spec & 2 ),
				longName: !! ( spec & 4 ),
				deepFormat: !! ( spec & 8 ),
				multiPart: !! ( spec & 16 ),
			};

			// start of header

			offset.value = 8; // start at 8 - after pre-amble

			let keepReading = true;

			while ( keepReading ) {

				const attributeName = parseNullTerminatedString( buffer, offset );

				if ( attributeName == 0 ) {

					keepReading = false;

				} else {

					const attributeType = parseNullTerminatedString( buffer, offset );
					const attributeSize = parseUint32( dataView, offset );
					const attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );

					if ( attributeValue === undefined ) {

						console.warn( `EXRLoader.parse: skipped unknown header attribute type \'${attributeType}\'.` );

					} else {

						EXRHeader[ attributeName ] = attributeValue;

					}

				}

			}

			if ( ( spec & ~ 0x04 ) != 0 ) { // unsupported tiled, deep-image, multi-part

				console.error( 'EXRHeader:', EXRHeader );
				throw new Error( 'THREE.EXRLoader: provided file is currently unsupported.' );

			}

			return EXRHeader;

		}

		function setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {

			const EXRDecoder = {
				size: 0,
				viewer: dataView,
				array: uInt8Array,
				offset: offset,
				width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,
				height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,
				channels: EXRHeader.channels.length,
				bytesPerLine: null,
				lines: null,
				inputSize: null,
				type: EXRHeader.channels[ 0 ].pixelType,
				uncompress: null,
				getter: null,
				format: null,
				colorSpace: LinearSRGBColorSpace,
			};

			switch ( EXRHeader.compression ) {

				case 'NO_COMPRESSION':
					EXRDecoder.lines = 1;
					EXRDecoder.uncompress = uncompressRAW;
					break;

				case 'RLE_COMPRESSION':
					EXRDecoder.lines = 1;
					EXRDecoder.uncompress = uncompressRLE;
					break;

				case 'ZIPS_COMPRESSION':
					EXRDecoder.lines = 1;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'ZIP_COMPRESSION':
					EXRDecoder.lines = 16;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'PIZ_COMPRESSION':
					EXRDecoder.lines = 32;
					EXRDecoder.uncompress = uncompressPIZ;
					break;

				case 'PXR24_COMPRESSION':
					EXRDecoder.lines = 16;
					EXRDecoder.uncompress = uncompressPXR;
					break;

				case 'DWAA_COMPRESSION':
					EXRDecoder.lines = 32;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				case 'DWAB_COMPRESSION':
					EXRDecoder.lines = 256;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				default:
					throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );

			}

			EXRDecoder.scanlineBlockSize = EXRDecoder.lines;

			if ( EXRDecoder.type == 1 ) {

				// half
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat16;
						EXRDecoder.inputSize = INT16_SIZE;
						break;

					case HalfFloatType:
						EXRDecoder.getter = parseUint16;
						EXRDecoder.inputSize = INT16_SIZE;
						break;

				}

			} else if ( EXRDecoder.type == 2 ) {

				// float
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat32;
						EXRDecoder.inputSize = FLOAT32_SIZE;
						break;

					case HalfFloatType:
						EXRDecoder.getter = decodeFloat32;
						EXRDecoder.inputSize = FLOAT32_SIZE;

				}

			} else {

				throw new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );

			}

			EXRDecoder.blockCount = ( EXRHeader.dataWindow.yMax + 1 ) / EXRDecoder.scanlineBlockSize;

			for ( let i = 0; i < EXRDecoder.blockCount; i ++ )
				parseInt64( dataView, offset ); // scanlineOffset

			// we should be passed the scanline offset table, ready to start reading pixel data.

			// RGB images will be converted to RGBA format, preventing software emulation in select devices.
			EXRDecoder.outputChannels = ( ( EXRDecoder.channels == 3 ) ? 4 : EXRDecoder.channels );
			const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;

			switch ( outputType ) {

				case FloatType:
					EXRDecoder.byteArray = new Float32Array( size );

					// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten
					if ( EXRDecoder.channels < EXRDecoder.outputChannels )
						EXRDecoder.byteArray.fill( 1, 0, size );

					break;

				case HalfFloatType:
					EXRDecoder.byteArray = new Uint16Array( size );

					if ( EXRDecoder.channels < EXRDecoder.outputChannels )
						EXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1

					break;

				default:
					console.error( 'THREE.EXRLoader: unsupported type: ', outputType );
					break;

			}

			EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;

			if ( EXRDecoder.outputChannels == 4 ) {

				EXRDecoder.format = RGBAFormat;
				EXRDecoder.colorSpace = LinearSRGBColorSpace;

			} else {

				EXRDecoder.format = RedFormat;
				EXRDecoder.colorSpace = NoColorSpace;

			}

			return EXRDecoder;

		}

		// start parsing file [START]

		const bufferDataView = new DataView( buffer );
		const uInt8Array = new Uint8Array( buffer );
		const offset = { value: 0 };

		// get header information and validate format.
		const EXRHeader = parseHeader( bufferDataView, buffer, offset );

		// get input compression information and prepare decoding.
		const EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );

		const tmpOffset = { value: 0 };
		const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };

		for ( let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx ++ ) {

			const line = parseUint32( bufferDataView, offset ); // line_no
			EXRDecoder.size = parseUint32( bufferDataView, offset ); // data_len
			EXRDecoder.lines = ( ( line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.scanlineBlockSize );

			const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;
			const viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );

			offset.value += EXRDecoder.size;

			for ( let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y ++ ) {

				const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;
				if ( true_y >= EXRDecoder.height ) break;

				for ( let channelID = 0; channelID < EXRDecoder.channels; channelID ++ ) {

					const cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];

					for ( let x = 0; x < EXRDecoder.width; x ++ ) {

						tmpOffset.value = ( line_y * ( EXRDecoder.channels * EXRDecoder.width ) + channelID * EXRDecoder.width + x ) * EXRDecoder.inputSize;
						const outIndex = ( EXRDecoder.height - 1 - true_y ) * ( EXRDecoder.width * EXRDecoder.outputChannels ) + x * EXRDecoder.outputChannels + cOff;
						EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );

					}

				}

			}

		}

		return {
			header: EXRHeader,
			width: EXRDecoder.width,
			height: EXRDecoder.height,
			data: EXRDecoder.byteArray,
			format: EXRDecoder.format,
			colorSpace: EXRDecoder.colorSpace,
			type: this.type,
		};

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			texture.colorSpace = texData.colorSpace;
			texture.minFilter = LinearFilter;
			texture.magFilter = LinearFilter;
			texture.generateMipmaps = false;
			texture.flipY = false;

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}

var action_compress   = 1, action_decompress = 2, action_progress   = 3;

  class LZMA {

    constructor( lzma_path ) {
   // export class LZMA = function (lzma_path) {
        
            
            this.callback_obj = {};
            
            ///NOTE: Node.js needs something like "./" or "../" at the beginning.
            this.lzma_worker = new Worker(lzma_path || "./lzma_worker-min.js");
        
        this.lzma_worker.onmessage = function onmessage(e) {
            if (e.data.action === action_progress) {
                if (this.callback_obj[e.data.cbn] && typeof this.callback_obj[e.data.cbn].on_progress === "function") {
                    this.callback_obj[e.data.cbn].on_progress(e.data.result);
                }
            } else {
                if (this.callback_obj[e.data.cbn] && typeof this.callback_obj[e.data.cbn].on_finish === "function") {
                    this.callback_obj[e.data.cbn].on_finish(e.data.result, e.data.error);
                    
                    /// Since the (de)compression is complete, the callbacks are no longer needed.
                    delete this.callback_obj[e.data.cbn];
                }
            }
        }.bind(this);
        
        /// Very simple error handling.
        this.lzma_worker.onerror = function(event) {
            var err = new Error(event.message + " (" + event.filename + ":" + event.lineno + ")");
            
            for (var cbn in this.callback_obj) {
                this.callback_obj[cbn].on_finish(null, err);
            }
            
            console.error('Uncaught error in lzma_worker', err);
        }.bind(this);
        
    }

    send_to_worker(action, data, mode, on_finish, on_progress) {
        var cbn;
        
        do {
            cbn = Math.floor(Math.random() * (10000000));
        } while(typeof this.callback_obj[cbn] !== "undefined");
        
        this.callback_obj[cbn] = {
            on_finish:   on_finish,
            on_progress: on_progress
        };
        
        this.lzma_worker.postMessage({
            action: action, /// action_compress = 1, action_decompress = 2, action_progress = 3
            cbn:    cbn,    /// callback number
            data:   data,
            mode:   mode
        });
    }

    compress(mixed, mode, on_finish, on_progress) {
        this.send_to_worker(action_compress, mixed, mode, on_finish, on_progress);
    }
    decompress(byte_arr, on_finish, on_progress) {
        this.send_to_worker(action_decompress, byte_arr, false, on_finish, on_progress);
    }
    worker() {
        return this.lzma_worker;
    }
}

/** __
*    _)_|_|_
*   __) |_| | 2022
* @author lo.th / https://github.com/lo-th
*/

let isGL2 = true;
let isInit = false;

let renderer$2 = null;
//let mode = ''

//const mats = {}

const materials = new Map();

const uniforms = {

	renderMode: { value: 0 },
    fogMode: { value: 1 },
    depthPacking: { value: 1 },

	time: { value: 0.0 },

	shadow: { value: 0.5 },
    shadowGamma: { value: 0.25 },//1
    shadowLuma: { value: 0 },//0.75
    shadowContrast: { value: 1 },//2.5
    
	//shadowAlpha: { value: 1.0 }

    lightSizeUV: { value: 1.3 },
    nearPlane: { value: 9.5 },
    rings:{ value: 11 },
    nSample:{ value: 17 },
    
    noiseIntensity:{ value: 1 },
    softness:{ value: 3 },
    
};


class Shader {

    get renderer() { return renderer$2; }
    set renderer( r ) { renderer$2 = r; }

    static setGl2 ( b ) { isGL2 = b; }
    static getGl2 ( b ) { return isGL2 }

    static setting ( ) {
        return uniforms
    }

    static getRandomUv(){
        return randomUV;
    }

    static addParsFragment( s, adds ){
        s.fragmentShader = s.fragmentShader.replace( '#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>' + adds );
    }

    /*static addToParsFragment( fragment, adds ){
        return fragment.replace( '#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>' + adds );
    }*/


	static init ( o = {} ) {

        // Set CustomToneMapping to Uncharted2
        // source: http://filmicworlds.com/blog/filmic-tonemapping-operators/

        ShaderChunk.tonemapping_pars_fragment = ShaderChunk.tonemapping_pars_fragment.replace(
            'vec3 CustomToneMapping( vec3 color ) { return color; }',
            `#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
            float toneMappingWhitePoint = 1.0;
            vec3 CustomToneMapping( vec3 color ) {
                color *= toneMappingExposure;
                return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
            }`
        );

        

        //mode = o.mode

        //if( mode === 'LOW' ) return

        let s;

        this.up( o );

        {

            //defines['NUM_SAMPLES'] = 17
            //defines['NUM_RINGS'] = 11

            s = ShaderChunk.shadowmap_pars_fragment;

            s = s.replace(
                '#ifdef USE_SHADOWMAP', shadowPCSS
            );

            s = s.replace(//BasicShadowMap
                'shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );',`
                return PCSS( shadowMap, shadowCoord );
            `);

            /*s = s.replace(
                '#if defined( SHADOWMAP_TYPE_PCF )',`
                return PCSS( shadowMap, shadowCoord );
                #if defined( SHADOWMAP_TYPE_PCF )
            `)*/

            ShaderChunk.shadowmap_pars_fragment = s;

        }

		//return;

		s = ShaderChunk.common;
        s = s.replace( '#define EPSILON 1e-6', `
        	#define EPSILON 1e-6
        	uniform float shadow;
            uniform float shadowLuma;
            uniform float shadowContrast;
            uniform float shadowGamma;

            uniform int renderMode;
            uniform int fogMode;
            uniform int depthPacking;

            varying vec2 vZW;
            varying vec3 rayDir;
            varying vec3 rayDir2;
            varying vec3 rayOri;
            //varying float fDist;

            float shadowValue = 1.0;
            float shadowTmp = 1.0;
            vec3 shadowColor = vec3(1.0);
            
            float color_distance( vec3 a, vec3 b){
                vec3 s = vec3( a - b );
                float dist = sqrt( s.r * s.r + s.g * s.g + s.b * s.b );
                return clamp(dist, 0.0, 1.0);
            }

            vec3 adjustContrast(vec3 color, float value) {
                const vec3 zero = vec3(0.);
                return max(zero, 0.5 + value * (color - 0.5));
            }

            vec3 hsv2rgb(vec3 c){
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            vec3 rgb2hsv(vec3 rgb) {
                float Cmax = max(rgb.r, max(rgb.g, rgb.b));
                float Cmin = min(rgb.r, min(rgb.g, rgb.b));
                float delta = Cmax - Cmin;
                vec3 hsv = vec3(0., 0., Cmax);
                if (Cmax > Cmin) {
                    hsv.y = delta / Cmax;
                    if (rgb.r == Cmax) hsv.x = (rgb.g - rgb.b) / delta;
                    else {
                        if (rgb.g == Cmax) hsv.x = 2. + (rgb.b - rgb.r) / delta;
                        else hsv.x = 4. + (rgb.r - rgb.g) / delta;
                    }
                    hsv.x = fract(hsv.x / 6.);
                }
                return hsv;
            }

            /*
            vec3 rgb2hsv(vec3 c){
                vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }

            vec3 brightnessContrastCorrection(vec3 value, float brightness, float contrast){
                return (value - 0.5) * contrast + 0.5 + brightness;
            }

            vec3 GammaCorrection(vec3 value, float param){
                return vec3(pow(abs(value.r), param),pow(abs(value.g), param),pow(abs(value.b), param));
            }
            */
            

        `);

        ShaderChunk.common = s;

        /*ShaderChunk.project_vertex = `
            vec4 mvPosition = vec4( transformed, 1.0 );

            #ifdef USE_INSTANCING
                mvPosition = instanceMatrix * mvPosition;
            #endif

            mvPosition = modelViewMatrix * mvPosition;
            gl_Position = projectionMatrix * mvPosition;
        `;*/





        /*ShaderChunk.begin_vertex = `
        vZW = gl_Position.zw;
        vec3 transformed = vec3( position );
        `;*/


        ShaderChunk.clipping_planes_vertex = `
            #if NUM_CLIPPING_PLANES > 0
                vClipPosition = - mvPosition.xyz;
            #endif
            vZW = gl_Position.zw;
        `;

        s = ShaderChunk.lights_fragment_begin;

        // point
        s = s.replace( 'directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;', `
            shadowTmp = 1.0;
            shadowTmp *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;;
            //directLight.color *= shadowTmp;
            shadowValue *= shadowTmp;
        `);

        // spot
        s = s.replace( 'directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;', `
            shadowTmp = 1.0;
            shadowTmp *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
            //directLight.color *= shadowTmp;
            shadowValue *= shadowTmp;
        `);

        // directional
        s = s.replace( 'directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;', `
            shadowTmp = 1.0;
            shadowTmp *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
            //directLight.color *= shadowTmp;
            shadowValue *= shadowTmp;
        `);

        ShaderChunk.lights_fragment_begin = s;

       /* s = ShaderChunk.tonemapping_fragment;

        s = s.replace( '#if defined( TONE_MAPPING )', `
            #if defined( USE_SHADOWMAP )
            gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * shadowR, Shadow);
            #endif

            #if defined( TONE_MAPPING )
        `);

        ShaderChunk.tonemapping_fragment = s;*/

        {
            ShaderChunk.fog_vertex = FogVertex;
            ShaderChunk.fog_fragment = FogFragment;
        }

        
        




        s = ShaderChunk.opaque_fragment;//output_fragment;

        s = s.replace( 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', `

            gl_FragColor = vec4( outgoingLight, diffuseColor.a );

        	#if defined( USE_SHADOWMAP )

            shadowValue = (shadowValue - 0.5) * shadowContrast + 0.5 + shadowLuma;
            shadowValue = pow(abs(shadowValue), shadowGamma );
            shadowValue = clamp( shadowValue, 0.0, 1.0 );

            shadowColor = vec3( shadowValue );

            ///shadowColor = vec3( 0.0,0.0,1.0-shadowValue );

            //vec3 sColor = vec3( 0.1, 0.1, 0.8 );
            //shadowColor.b += 1.0-shadowValue ;



            // TODO find better shadow variation

            vec3 invert = vec3( 1.0 - gl_FragColor.rgb );
            vec3 dd = vec3(0.38,0.42,0.63);
            float gray = ((gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0);
            vec3 invColor = gray * dd;
            invColor = invColor * mix( invColor, invert, 1.0-gray*0.5 );




                    


            //gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * shadowColor, (1.0-shadowValue) * shadow );

            //gl_FragColor.rgb *= ((1.0-shadowValue) * (1.0-shadow)) + shadowColor;

            //gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * invColor, (1.0-shadowValue) * shadow );
            gl_FragColor.rgb = mix( gl_FragColor.rgb, invColor, (1.0-shadowValue) * shadow );

            //gl_FragColor.rgb = invColor;

            //gl_FragColor.rgb = gl_FragColor.rgb * shadowColor;

            //gl_FragColor.rgb *= ((1.0-shadowValue) * shadow) * invColor;


        	#endif
            
        `);

        //ShaderChunk.fog_fragment = s;
        ShaderChunk.opaque_fragment = s;//output_fragment = s

      //  ShaderChunk.tonemapping_fragment = s;


        //console.log('shadow modif on')

        s = ShaderChunk.dithering_fragment;

        s = s.replace( '#endif', `

            #endif

            #ifdef STANDARD

            if( renderMode == 1 ){ 
                float fz = 0.5 * vZW[0] / vZW[1] + 0.5;
                gl_FragColor = depthPacking == 1 ? packDepthToRGBA( fz ) : vec4( vec3( 1.0 - fz ), opacity );// depth render
            }
            if( renderMode == 2 ) gl_FragColor = vec4(  packNormalToRGB( normal ), opacity );// normal render
            if( renderMode == 3 ) gl_FragColor = vec4(  shadowColor, opacity );// normal render

            #else

            if( renderMode != 0 ) discard;

            #endif

        `);

        ShaderChunk.dithering_fragment = s;



        s = ShaderChunk.color_vertex;
        s = s.replace( 'vColor.xyz *= instanceColor.xyz;', `vColor.xyz = instanceColor.xyz;`);
        ShaderChunk.color_vertex = s;


        isInit = true;






		//this.shaders=[];
		//this.uniforms = {};

	}

    static add ( m, beforeCompile = null ) {

        if( !isInit ) return

        if( !m ) return

        let name = m.name;
        if ( materials.has( name ) ) { 
            console.log('already add', name);
            return 
        }

        //console.log('add', name)
        materials.set( name, true );
        
        if( m.shadowSide === null ) m.shadowSide = DoubleSide;

        //m.format = sRGBEncoding;
        /*if(!m.isEncod){
            if( m.map ) m.map.colorSpace = SRGBColorSpace
            m.color.convertSRGBToLinear()
            m.isEncod = true
        }*/

        m.onBeforeCompile = function ( shader ) {
            Shader.modify( shader );
            if(beforeCompile) beforeCompile(shader);
        };

        /*if(!m.defines){ 
            m.defines = defines
        } else {
            Shader.setDefines( m )
        }*/
         //

    } 

    static refresh () {

      /* console.log( 'refresh', materials )

        materials.forEach( (value, key)=>{


            //console.log( value, key )



            value.needsUpdate = true 

        })*/
    }

    static setDefines ( m ) {
        
        //for( var o in defines ) m.defines[o] = defines[o]

        //if(!mats[m.name]) mats[m.name] = m

       // console.log(m.name)

    }


    static modify ( s ) {

        if( !isInit ) return

       // if( mode === 'LOW' ) return

       //shaders.push( s );
       // apply global uniform
       for( let n in uniforms ){

       	    s.uniforms[n] = uniforms[n];

       }

       // start add

       /*let fragment = s.fragmentShader;

        fragment.replace( 'vec4 diffuseColor = vec4( diffuse, opacity );', `
            vec4 diffuseColor = vec4( diffuse, opacity );
            vec3 shadowR = vec3(1.0);
        `);
        s.fragmentShader = fragment;*/

    }

    static up ( o ) {

        //if( mode === 'LOW' ) return

        for( let n in o ){

            if( uniforms[n] ){ 
                if( uniforms[n].value.isColor ) uniforms[n].value.setHex( o[n] );
                else uniforms[n].value = o[n];

            }

            /*if( defines[n] ){

                for( let m in mats ){ 
                    console.log(m)
                    mats[m].defines[n] = o[n]
                }

            }*/
            

        }

    	/*for ( let s of shaders ){

    		for( let n in o ){

    			if( s.uniforms[n] ){ 
                    if( s.uniforms[n].value.isColor ) s.uniforms[n].value.setHex( o[n] );
                    else s.uniforms[n].value = o[n];

                }
    		}

    	}*/

    }

    static reset (){
        materials.clear();
    }

}
/*THREE.ShaderChunk.fog_fragment = THREE.ShaderChunk.fog_fragment.replace(
                    'gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',
                    `
                    vec4 CCF = vec4(fogColor, 1.0);
                    #if defined( TONE_MAPPING )
                    CCF.rgb = toneMapping( CCF.rgb );
                    CCF = linearToOutputTexel( CCF );
                    #endif
                    gl_FragColor.rgb = mix( gl_FragColor.rgb, CCF.rgb, fogFactor );
                    `
                );*/

// https://iquilezles.org/articles/fog/
const FogVertex = `
#ifdef USE_FOG

    vFogDepth = - mvPosition.z;

    rayDir2 = normalize( worldPosition.xyz - cameraPosition );
    rayDir = normalize( mvPosition.xyz );
    rayOri = cameraPosition.xyz;

    //rayOri = worldPosition.xyz; //( cameraPosition-worldPosition.xyz  );
    //vec3 tt = vec3(cameraPosition-mvPosition);
    //float fDist = sqrt(tt.x*tt.x+tt.y*tt.y+tt.z*tt.z);
    //fDist = distance(cameraPosition.xyz, mvPosition.xyz);

#endif
`;

const FogFragment = `
#ifdef USE_FOG

    #ifdef FOG_EXP2

        float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

    #else

        float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
        float fogDensity = 0.01;

    #endif

    

    /*vec4 CCF = vec4(fogColor, 1.0);
    #if defined( TONE_MAPPING )
        CCF.rgb = toneMapping( CCF.rgb );
        //CCF = linearToOutputTexel( CCF );
    #endif*/

    if( fogMode == 0 ){

        gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
    } 

    if( fogMode == 1 ){

        vec3 fcolor = fogColor;

        #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

            float aa = fogDensity * fogDensity * 1.0;
            float bb = fogDensity * fogDensity * 12.0;
            //bb = pow(bb, 0.8);
            float distance = vFogDepth * vFogDepth;

            fogFactor = 1.0 - exp( -distance*bb );
            fogFactor = (aa/bb) * exp(-rayOri.y*bb) * (1.0-exp( -distance*rayDir2.y*bb ))/rayDir2.y;
            fogFactor = clamp( fogFactor, 0.0, 1.0 );

            vec3 sunDir = normalize( directionalLights[ 0 ].direction );
            vec3 sunColor = directionalLights[ 0 ].color;
            // sunColor = vec3(1,0,0);
            float sunAmount = max( dot( rayDir, sunDir ), 0.0 );
            //float sunAdd = clamp( pow(sunAmount, 60.0), 0.0, 1.0 );
            float sunAdd = pow(sunAmount, 16.0);
            fcolor = mix( fogColor, sunColor, sunAdd ); // 8.0

        #endif

        gl_FragColor.rgb = gl_FragColor.rgb * (1.0-fogFactor) + fcolor * fogFactor;

    }

#endif
`;


const shadowPCSS = `
#ifdef USE_SHADOWMAP

uniform float lightSizeUV;
uniform float nearPlane;
uniform float rings;
uniform int nSample;
uniform float noiseIntensity;
uniform float softness;

//#define LIGHT_WORLD_SIZE 0.005
//#define LIGHT_FRUSTUM_WIDTH 3.75
//#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)
//#define NEAR_PLANE 9.5

#define NUM_SAMPLES 17

vec2 poissonDisk[32];

void initPoissonSamples( const in vec2 randomSeed ) {

    int numSample = nSample;

    float ANGLE_STEP = PI2 * rings / float( numSample );
    float INV_NUM_SAMPLES = 1.0 / float( numSample );

    // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
    float angle = rand( randomSeed ) * PI2 * noiseIntensity;
    float radius = INV_NUM_SAMPLES;
    float radiusStep = radius;

    for( int i = 0; i < numSample; i ++ ) {
        poissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );
        radius += radiusStep;
        angle += ANGLE_STEP;
    }
}

float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
    return (zReceiver - zBlocker) / zBlocker;
}

float findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver, float ls ) {

    // This uses similar triangles to compute what
    // area of the shadow map we should search
    float searchRadius = ls * ( zReceiver - nearPlane ) / zReceiver;
    float blockerDepthSum = 0.0;
    int numBlockers = 0;
    int numSample = nSample;
    float shadowMapDepth = 0.0;

    for( int i = 0; i < numSample; i++ ) {
        shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));
        if ( shadowMapDepth < zReceiver ) {
            blockerDepthSum += shadowMapDepth;
            numBlockers ++;
        }
    }

    if( numBlockers == 0 ) return -1.0;

    return blockerDepthSum / float( numBlockers );

}

float PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {
    
    /*int numSample = nSample;
    float sum = 0.0;
    float depth;
    #pragma unroll_loop_start
    for( int i = 0; i < 17; i ++ ) {
        depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );
        if( zReceiver <= depth ) sum += 1.0;
    }
    #pragma unroll_loop_end
    #pragma unroll_loop_start
    for( int i = 0; i < 17; i ++ ) {
        depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );
        if( zReceiver <= depth ) sum += 1.0;
    }
    #pragma unroll_loop_end
    return sum / ( 2.0 * float( 17 ) );*/

    int numSample = nSample;
    float sum = 0.0;
    float top = 0.0;
    float low = 0.0;
    #pragma unroll_loop_start
    for( int i = 0; i < 17; i ++ ) {
        top = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );
        low = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );
        if( zReceiver <= top ) sum += 1.0;
        if( zReceiver <= low ) sum += 1.0;
    }
    #pragma unroll_loop_end
    return sum / ( 2.0 * float( 17 ) );
}

float PCSS ( sampler2D shadowMap, vec4 coords ) {

    vec2 uv = coords.xy;
    float zReceiver = coords.z; // Assumed to be eye-space z in this code
    //float lightSizeUV = LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH;

    float ls = lightSizeUV * 0.001;

    initPoissonSamples( uv );
    // STEP 1: blocker search
    float avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver, ls );

    //There are no occluders so early out (this saves filtering)
    if( avgBlockerDepth == -1.0 ) return 1.0;

    // STEP 2: penumbra size
    float penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );
    float filterRadius = penumbraRatio * ls * nearPlane / zReceiver;

    // STEP 3: filtering
    //return avgBlockerDepth;
    return PCF_Filter( shadowMap, uv, zReceiver, filterRadius );
}
`;

const randomUV = `

float directNoise(vec2 p){
    vec2 ip = floor(p);
    vec2 u = fract(p);
    u = u*u*(3.0-2.0*u);
    
    float res = mix(
        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
    return res*res;
}

float sum( vec4 v ) { return v.x+v.y+v.z; }

vec4 textureNoTile( sampler2D mapper, in vec2 uv ){

    // sample variation pattern    
    //float k = texture2D( noise, 0.005*uv ).x; // cheap (cache friendly) lookup    
    float k = directNoise( uv );
    
    // compute index    
    float index = k*8.0;
    float f = fract( index );

    float ia = floor( index );
    float ib = ia + 1.0;
    // or
    //float ia = floor(index+0.5); // suslik's method (see comments)
    //float ib = floor(index);
    //f = min(f, 1.0-f)*2.0;

    // offsets for the different virtual patterns    
    vec2 offa = sin(vec2(3.0,7.0)*ia); // can replace with any other hash    
    vec2 offb = sin(vec2(3.0,7.0)*ib); // can replace with any other hash    

    // compute derivatives for mip-mapping    
    vec2 dx = dFdx(uv);
    vec2 dy = dFdy(uv);
    
    // sample the two closest virtual patterns    
    vec4 cola = textureGrad( mapper, uv + offa, dx, dy );
    vec4 colb = textureGrad( mapper, uv + offb, dx, dy );

    // interpolate between the two virtual patterns    
    return mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );

}
`;

const GlbTool = {

	getMesh:( scene, keepMaterial ) => {
        let meshs = {};
        //if( keepMaterial ) GlbTool.keepMaterial( scene )
        scene.traverse( ( child ) => {
            if ( child.isMesh ) meshs[ child.name ] = child;
        });
        return meshs;
    },

    keepMaterial: ( scene ) => {

        let Mats = {}, m; 

        scene.traverse( ( child ) => {
            if ( child.isMesh ){ 
                m = child.material;
                if( !Mats[m.name] ){
                    Shader.add( m );
                    //console.log(m.name)
                    Mats[m.name] = true;
                }
            }
        });

    },

    getGroup:( scene, autoMesh, autoMaterial ) => {
        const groups = {};
        let mats = null;
        if( autoMaterial ) mats = GlbTool.getMaterial( scene, true ); 
        scene.traverse( ( child ) => {
            if ( child.isGroup ){ 
            	//if( autoMaterial ) mats = GlbTool.getMaterial( scene, true ) 
            	groups[ child.name ] = autoMesh ? GlbTool.groupToMesh(child, mats) : child;
            }
        });
        return groups;
    },

    // Material should be name like 
    // 0_concret
    // 10_silver ...

    getMaterial:( scene, toArray ) => {
    	const Mats = {};
        const mats = []; 
        let m, n;
        scene.traverse( ( child ) => {
            if ( child.isMesh ){ 
            	m = child.material;
            	if( !Mats[m.name] ){
            		Shader.add( m );
            		Mats[m.name] = m;
            		n = Number( m.name.substring( 0, m.name.lastIndexOf('_') )  );
            		mats[n] = m;
            	}
            }
        });
        return toArray ? mats : Mats;
    },

    groupToMesh: ( group, autoMaterial ) => {

    	if( group.children[0].name !== (group.name + '_1') ) return group
    	if( !group.children[0].isMesh ) return group

    	let g = [];
		let lng = group.children.length, n = 0, mName;

		for( let i = 0; i<lng; i++ ){

			mName = group.children[i].material.name;
		
			n = Number( mName.substring( 0, mName.lastIndexOf('_') )  );
			group.children[i].material.dispose();

			g[i] = group.children[i].geometry;
			g[i].forceMatId = n;
		}

		let mesh = new THREE.Mesh( new mergeGeometries( g, true ), autoMaterial );
		mesh.name = group.name;

		return mesh

    },

    symetric: ( g ) => {

		if( g.isMesh ) g = g.geometry;

        let uv = g.attributes.uv.array;
        let i = uv.length*0.5;

        while( i-- ){
        	if( uv[i*2] < 0 ) uv[i*2]*=-1;
        }
        g.attributes.uv.needsUpdate = true;

    },

    uv2: ( g ) => {

		if( g.isMesh ) g = g.geometry;
        g.setAttribute( 'uv2', g.attributes.uv );

    },


    autoMorph: ( mod, meshs, normal = true, relative = false ) => {

    	let morph = {};
    	let tmpMesh = [];
        mod.traverse( ( node ) => { 
            if ( node.isMesh && node.name.search('__M__') !== -1){ 
            	morph[ node.name ] = node.geometry;
            	tmpMesh.push(node);
            }
        });

		let oName, tName, target, id, g, gm, j, dp, dn, ar, m;
		

		for ( let name in morph ){

			oName = name.substring( 0, name.indexOf('__') );
            tName = name.substring( name.lastIndexOf('__') + 2 );

            target = meshs[ oName ];

			if( target ){

				g = target.geometry;
				gm = morph[name];

				g.morphTargetsRelative = relative;

				if( g.attributes.position.count === gm.attributes.position.count ){

					if( !g.morphAttributes.position ){
                        g.morphAttributes.position = [];
                        if( normal ) g.morphAttributes.normal = [];
                        target.morphTargetInfluences = [];
                        target.morphTargetDictionary = {};
                    }

                    id = g.morphAttributes.position.length;

                    // position
                    if( relative ){
                        j = gm.attributes.position.array.length;
                        ar = []; 
                        while(j--) ar[j] = gm.attributes.position.array[j] - g.attributes.position.array[j];
                        dp = new Float32BufferAttribute( ar, 3 );
                    } else {
                        dp = new Float32BufferAttribute( gm.attributes.position.array, 3 );
                    }

                    g.morphAttributes.position.push( dp );

                    // normal
                    if( normal ){
                        /*if( relative ){
                            j = gm.attributes.normal.length;
                            ar = [];
                            while(j--) ar[j] = gm.attributes.normal.array[j] - g.attributes.normal.array[j]
                            dn = new Float32BufferAttribute( ar, 3 );
                        } else {
                            dn = new Float32BufferAttribute( gm.attributes.normal.array, 3 );
                        }*/

                        dn = new Float32BufferAttribute( gm.attributes.normal.array, 3 );

                        g.morphAttributes.normal.push( dn );

                    }

                    target.morphTargetInfluences.push(0);
                    target.morphTargetDictionary[ tName ] = id;

                    /*if( !target.morph ) {
                        target.morph = function ( name, value ){
                            //console.log(this.morphTargetInfluences)
                            if(!this.morphTargetInfluences) return
                            if(this.morphTargetDictionary[name] === undefined ) return
                            this.morphTargetInfluences[ this.morphTargetDictionary[name] ] = value;
                        }

                        
                    }*/
                    //console.log( target.name + ' have morph call '+ tName )

				} else {
					console.warn( 'Morph '+ tName + ' target is no good on ' + target.name );
				}

			}

		}

		morph = {};

		// claer garbege
		j = tmpMesh.length;
		while(j--){
            m = tmpMesh[j];
			if( m.parent ) m.parent.remove( m );
			if( m.material ) m.material.dispose();
			if( m.geometry ) m.geometry.dispose();
		}

	},


};

/** __
*    _)_|_|_
*   __) |_| | 2023
* @author lo.th / https://github.com/lo-th
*/

const Pool = {

    msg:'',
    inLoad:false,

    clip:[],
    data: new Map(),
    tmp: [],
    //extraTexture: [],
    dracoLoader: null,
    dracoLoaderType:'js',
    dracoPath:'./src/libs/draco/',

    onLoad:() => {},
    onEnd:() => {},
    log: ( msg ) => {},

    materialRoot:(n) => {console.log( n );},

    setLoadEvent:( onload, onend ) => {
        Pool.onLoad = onload;
        Pool.onEnd = onend;
    },

    prefix:( type ) => {
        let p = '';
        switch( type ){
            case 'S': case 'sound': case 'mp3': case 'wav': case 'ogg': p = 'S_';  break;
            case 'I': case 'image': case 'jpg': case 'png': p = 'I_';  break;
            case 'E': case 'hdr': case 'env': p = 'T_';  break;
            case 'J': case 'json': p = 'J_';  break;
            case 'JS': case 'js': p = 'JS_';  break;
            
            case 'O': case 'object3d': p = 'O_';  break;
            case 'M': case 'material': p = 'M_';  break;
            case 'T': case 'texture': p = 'T_';  break;
        }
        return p
    },

    dispose:() => {

        Pool.data.forEach( function( node, key ) {

            if( node.isMaterial || node.isTexture ){ 
                node.dispose();
                Pool.data.delete( key );
                //console.log( key + ' is delete')
            }

            if( node.isObject3D ){
                node.traverse( function ( snode ) {
                    if ( snode.isMesh ){
                        if( snode.geometry ) snode.geometry.dispose();
                        if( snode.material ) snode.material.dispose();
                    }
                });
                Pool.data.delete( key );
            }
           

        });

        //console.log('clear extra texture !!')
        /*let i = Pool.extraTexture.length
        while(i--){
            let p = Pool.get( Pool.extraTexture[i], 'T' )
            if(p) p.dispose();
            Pool.delete( Pool.extraTexture[i], 'T' )
        }
        Pool.extraTexture = [];*/
    
    },
    
    createElementNS: ( name ) => ( document.createElementNS( 'http://www.w3.org/1999/xhtml', name ) ),
    exist: ( name, type = '' ) => ( Pool.get( name, type ) ? true : false ),
    delete: ( name, type = '' ) => ( Pool.data.delete( Pool.prefix( type ) + name ) ),
    get: ( name, type = '' ) => ( Pool.data.get( Pool.prefix( type ) + name ) ),

    set: ( name, node, type = '', direct ) => {
        if( node.isMaterial ){ 
            type = 'material';
            node.name = name;

            Pool.materialRoot( node, direct );
        }
        if( node.isTexture ) type = 'texture';
        if( node.isObject3D ) type = 'object3d';
        
        if( Pool.get( name, type ) ) return
        Pool.data.set( Pool.prefix( type ) + name, node );
    },

    getScript: ( name ) => ( Pool.data.get( Pool.prefix( 'js' ) + name ) ),

    getMaterials:( obj, toArray ) => {
        if( typeof obj === 'string' ) obj = Pool.get( obj, 'O' );
        return GlbTool.getMaterial( obj, toArray )
    },

    getMesh:( obj, keepMaterial ) => {
        if( typeof obj === 'string' ) obj = Pool.get( obj, 'O' );
        return GlbTool.getMesh( obj, keepMaterial )
    },

    getGroup:( obj, autoMesh, autoMaterial ) => {
        if( typeof obj === 'string' ) obj = Pool.get( obj, 'O' );
        return GlbTool.getGroup( obj, autoMesh, autoMaterial )
    },

    applyMorph( modelName, meshs = null, normal = true, relative = true ){

        let model;
        if( modelName.isObject3D ) model = modelName;
        else model = Pool.get( modelName, 'O' );

        if( !meshs ) meshs = Pool.getMesh( modelName );
        if( !model || !meshs ) return 
        GlbTool.autoMorph( model, meshs, normal, relative );

    },

    uv2( model ){
        GlbTool.uv2( model );
    },

    add: ( name, node, type ) => {
        Pool.set( name, node, type );
        Pool.next();
        //console.log( name, type )
    },

    getMaterial:( name ) => ( Pool.data.get( 'M_' + name ) ),

    //getMap:( name, o = {} ) => ( Pool.getTexture(name, o) ),


    //--------------------
    //   TEXTURES
    //--------------------

    texture:( o = {} ) => {

        if( !Pool.loaderMap ) Pool.loaderMap = new TextureLoader();

        let name = o.url.substring( o.url.lastIndexOf('/')+1, o.url.lastIndexOf('.') );

        if( name.search('_c') !== -1 || name.search('_l') !== -1 || name.search('_u') !== -1|| name.search('_d') !== -1) o.srgb = true;

        if( Pool.exist( name, 'texture') ) return Pool.get( name, 'texture' );
        if( Pool.exist( name, 'image') ) return Pool.getTexture( name, o );
            
        return Pool.loaderMap.load( o.url, function ( t ) { 

            Pool.setTextureOption( t, o );
            Pool.data.set( 'T_' + name, t );
            if( o.callback ) o.callback();
            return t
            
        })

    },

    getTexture:( name, o = {} ) => {

        let t = Pool.get( name, 'texture' );
        if(!t){
            let im = Pool.data.get( 'I_' + name );
            if(!im) return null
            t = new Texture( im );
            if( name.search('_c') !== -1 || name.search('_d') !== -1 || name.search('_l') !== -1 || name.search('_u') !== -1 ) o.srgb = true;
            Pool.data.set( 'T_' + name, t );
        }
        Pool.setTextureOption( t, o );
        return t
    },

    setTextureOption:( t, o = {} ) => {

        //if( o.colorSpace ) t.colorSpace = o.colorSpace;
        if( o.encoding ) t.colorSpace = SRGBColorSpace;
        if( o.srgb ) t.colorSpace = SRGBColorSpace;
        t.flipY = ( o.flipY || o.flip ) !== undefined ? o.flipY : false;
        if( o.anisotropy !== undefined ) t.anisotropy = o.anisotropy;
        if( o.generateMipmaps !== undefined ) t.generateMipmaps = o.generateMipmaps;
        if( o.repeat ){
            t.repeat.fromArray( o.repeat );
            t.wrapS = t.wrapT = RepeatWrapping;
        }
        if( o.filter ){
            if( o.filter === 'near' ){
                t.minFilter = NearestFilter;
                t.magFilter = NearestFilter;
            }
        }

        if( o.channel ) t.channel = o.channel;
        t.needsUpdate = true;

    },

    

    ///

    

    ///

    load: ( Urls, Callback, Path = '', msg = '' ) => {

        Pool.msg = msg;

        let urls = [];
        let callback = Callback || function(){};
        let start = ( typeof performance === 'undefined' ? Date : performance ).now();

        if ( typeof Urls === 'string' || Urls instanceof String ) urls.push( Urls );
        else urls = urls.concat( Urls );

        Pool.tmp.push( { urls:urls, path:Path, callback:callback, start:start } );

        if( !Pool.inLoad ) Pool.loadOne();

    },

    loadOne: () => {

        Pool.inLoad = true;
        Pool.onLoad();

        let url = Pool.tmp[0].path + Pool.tmp[0].urls[0];
        let name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        let type = url.substring( url.lastIndexOf('.')+1 ).toLowerCase();

        if( Pool.exist( name, type ) ) Pool.next();
        else Pool.loading( url, name, type );

    },

    next: () => {

        Pool.tmp[0].urls.shift();

        if( Pool.tmp[0].urls.length === 0 ){

            Math.floor(( typeof performance === 'undefined' ? Date : performance ).now() - Pool.tmp[0].start);

            //if( end !== 0 ) console.log( 'pool load time:', end, 'ms' );
            
            Pool.tmp[0].callback();
            Pool.tmp.shift();

            if( Pool.tmp.length > 0 ) Pool.loadOne();
            else {
                Pool.inLoad = false;
                Pool.onEnd();
            }

        } else {

            Pool.loadOne();

        }

    },

    loading: ( url, name, type ) => {

        Pool.log( Pool.msg );

        switch( type ){
            case 'glb': case 'gltf': Pool.load_GLTF( url, name );  break;
            case 'fbx': case 'FBX': Pool.load_FBX( url, name ); break;
            case 'hdr': Pool.load_RGBE( url, name ); break;
            case 'exr': Pool.load_EXR( url, name ); break;
            default: Pool.extand( url, name, type );
        }

    },

    extand: ( url, name, type ) => {

        if( !Pool.XHTTP ) Pool.XHTTP = new XMLHttpRequest();
        const xml = Pool.XHTTP;

        xml.open('GET', url, true );
        if(type === "json") xml.overrideMimeType( "application/json");

        switch( type ){

            case 'hex': case 'wasm': case 'mp3': case 'wav': case 'ogg': case 'jpg': case 'png': xml.responseType = "arraybuffer"; break;
            case 'bvh': case 'glsl': case 'js':  case 'json': xml.responseType = 'text'; break;

        }

        xml.onreadystatechange = function () {

            if ( xml.readyState === 4 ) {
            	if (xml.status >= 300) {
                    console.log("Error, status code = " + xml.status);
                } else {
                	Pool.direct( xml.response, name, type );
                    //Pool.add( name, JSON.parse( xhr.responseText ), 'json' )
                }
                //if ( Pool.XML.status === 200 || Pool.XML.status === 0 ) Pool.load_direct( Pool.XML.response, name, type );
                //else console.error( "Couldn't load ["+ name + "] [" + Pool.XML.status + "]" );
            }

        };

        if ('onprogress' in xml){
            xml.onprogress = function(e) {
                //console.log( parseInt((e.loaded / e.total) * 100) );
            };
        }

        xml.send(null);

    },

    direct: ( response, name, type ) => {

        switch( type ){
        	case 'jpg': case 'png':
        	    let img = Pool.createElementNS('img');
	            img.src = window.URL.createObjectURL( new Blob([response]) );
	            Pool.add( name, img, 'image' );
        	break;
            case 'mp3': case 'wav': case 'ogg':
                AudioContext.getContext().decodeAudioData(
                    response.slice( 0 ),
                    function( buffer ){ Pool.add( name, buffer, 'sound' ); },
                    function( error ){ console.error('decodeAudioData error', error); }
                );
            break;
            case 'hex': LzmaUnpack.parse( response, function ( result ) { Pool.add( name, result, type ); }); break;
            case 'wasm': Pool.add( name, new Uint8Array( response ), type ); break;
            case 'json': Pool.add( name, JSON.parse( response ), type ); break;
            case 'js': Pool.add( name, response, type ); break;
            default: Pool.add( name, response, type );

        }

    },

    //////////////////////////////////

    loaderDRACO: () => {

        if( Pool.dracoLoader ) return Pool.dracoLoader

        if( !Pool.dracoLoaderType ){
            if ( navigator.userAgentData ) Pool.dracoLoaderType = 'wasm';
            else {
              let ua = navigator.userAgent.toLowerCase();
              Pool.dracoLoaderType = (ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1) ? 'js' : 'wasm';
            }
        }

        Pool.dracoLoader = new DRACOLoader().setDecoderPath( Pool.dracoPath );
        Pool.dracoLoader.setDecoderConfig( { type: Pool.dracoLoaderType } );
        return Pool.dracoLoader

    },

    loaderGLTF: () => {

        if( !Pool.GLTF ){
            Pool.GLTF = new GLTFLoader();
            Pool.GLTF.setDRACOLoader( Pool.loaderDRACO() );
        }
        return Pool.GLTF

    },

    loaderFBX: () => {

        if( !Pool.FBX ) Pool.FBX = new FBXLoader();
        return Pool.FBX

    },

    loaderRGBE: () => {

        if( !Pool.RGBE ) Pool.RGBE = new RGBELoader();
        return Pool.RGBE

    },

    loaderEXR: () => {

        if( !Pool.EXR ) Pool.EXR = new EXRLoader();
        return Pool.EXR

    },

    //////////////////////////////////

    load_GLTF: ( url, name ) => {

        /*Pool.loaderGLTF().setDRACOLoader( Pool.loaderDRACO() ).load( url, function ( gltf ) { 
            Pool.add( name, gltf.scene )
            Pool.dracoLoader.dispose()
        })*/

        Pool.loaderGLTF().load( url, function ( gltf ) {

            const model = gltf.scene;

            //console.log(gltf.animations)

            if( gltf.animations ){ 
                const animations = gltf.animations;
                const mixer = new AnimationMixer( gltf.scene );
                model.mixer = mixer;
                model.actions = {};
                for ( let i = 0; i < animations.length; i ++ ) {
                    let anim = animations[ i ];
                    model.actions[ anim.name ] = mixer.clipAction( anim );
                    //model.actions[ anim.name ].play()
                }

                model.play = (name) => {
                    if(model.actions[ name ]){ 
                        model.actions[ name ].paused = false;
                        model.actions[ name ].time = 0;
                        model.actions[ name ].play();
                    }
                };
                model.pause = (name, v=true) => {
                    if(model.actions[ name ]) model.actions[ name ].paused = v;
                };
            }
            
            Pool.add( name, model );
        });

    },

    load_FBX: ( url, name ) => {

        Pool.loaderFBX().load( url, function ( node ) { Pool.add( name, node ); });

    },

    load_RGBE: ( url, name ) => {

        Pool.loaderRGBE().load( url, function ( texture ) {
            texture.mapping = EquirectangularReflectionMapping; 
            Pool.add( name, texture ); 
        });

    },

    load_EXR: ( url, name, cb ) => {

        Pool.loaderEXR().load( url, function ( texture ) {
            //Pool.add( name, texture ) 
            console.log(texture);
            if(cb) cb(texture);
            return texture
        });

    },

    direct_EXR: ( data, name ) => {

        Pool.loaderEXR().parse( url, function ( texture ) {
            Pool.add( name, texture ); 

            return texture
        });

    },

};

const PI = Math.PI;
const torad$1 = PI / 180;
const todeg$1 = 180 / PI;
const EPSILON = Number.EPSILON;//0.00001;
const PI90 = PI*0.5;


const MathTool = {

    todeg:todeg$1,
    torad:torad$1,


    toFixed: ( x, n = 3 ) => ( x.toFixed(n) * 1 ),

    clamp: ( v, min, max ) => {
        v = v < min ? min : v;
        v = v > max ? max : v;
        return v;
    },

    clampA: ( v, min, max ) => { 
        return Math.max( min, Math.min( max, v ))
    },

    lerp: ( x, y, t ) => ( ( 1 - t ) * x + t * y ),
    damp: ( x, y, lambda, dt ) => ( MathTool.lerp( x, y, 1 - Math.exp( - lambda * dt ) ) ),

    nearAngle: ( s1, s2, deg = false ) => ( s2 + Math.atan2(Math.sin(s1-s2), Math.cos(s1-s2)) * (deg ? todeg$1 : 1) ),

    unwrapDeg: ( r ) => ( r - (Math.floor((r + 180)/360))*360 ), 
    //unwrapRad: ( r ) => (r - (Math.floor((r + Math.PI)/(2*Math.PI)))*2*Math.PI),
    unwrapRad: ( r ) => ( Math.atan2(Math.sin(r), Math.cos(r)) ),

    nearEquals: ( a, b, t ) => ( Math.abs(a - b) <= t ? true : false ),

    autoSize: ( s = [ 1, 1, 1 ], type = 'box' ) => {

        if ( s.length === 1 ) s[ 1 ] = s[ 0 ];
        let radius = s[0];
        let height = s[1];
        if( type === 'sphere' ) s = [ radius, radius, radius ];
        if( type === 'cylinder' || type === 'wheel' || type === 'capsule' ) s = [ radius, height, radius ];
        if( type === 'cone' || type === 'pyramid' ) s = [ radius, height, radius ];
        if ( s.length === 2 ) s[ 2 ] = s[ 0 ];
        return s;

    },

    /*distance: ( a, b = { x:0, y:0, z:0 } ) => { // rotation array in degree

        const dx = a.x ? a.x - b.x : 0
        const dy = a.y ? a.y - b.y : 0
        const dz = a.z ? a.z - b.z : 0
        return Math.sqrt( dx * dx + dy * dy + dz * dz );

    },*/

    // RANDOM

    randomSign: () => ( Math.random() < 0.5 ? -1 : 1 ),
    randSpread: ( range ) => ( range * ( 0.5 - Math.random() ) ),
    rand: ( low = 0, high = 1 ) => ( low + Math.random() * ( high - low ) ),
    randInt: ( low, high ) => ( low + Math.floor( Math.random() * ( high - low + 1 ) ) ),

    // ARRAY

    equalArray:(a, b)=>{
        let i = a.length;
        while(i--){ if(a[i]!==b[i]) return false }
        return true
    },

    // MATRIX

    composeMatrixArray: ( p, q, s = [1,1,1] ) => {
        const x = q[0], y = q[1], z = q[2], w = q[3];
        const x2 = x + x,  y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        const sx = s[0], sy = s[1], sz = s[2];
        return [
            ( 1 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0,
            ( xy - wz ) * sy, ( 1 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0,
            ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1 - ( xx + yy ) ) * sz, 0,
            p[0], p[1], p[2], 1
        ]
    },

    decomposeMatrixArray: ( m ) => {

        return [
            m[12],m[13],m[14],
            
        ]
    },

    // for physx substep 

    applyTransformArray: ( v, p, q, s = [1,1,1] ) => {
        const e = MathTool.composeMatrixArray( p, q, s );
        const x = v[0], y = v[1], z = v[2];
        const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );
        return [
            ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w, 
            ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w,
            ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w
        ]
    },

    equalArray:( a, b ) => {
        let i = a.length;
        while(i--){ if(a[i]!==b[i]) return false }
        return true
    },
    
    lerpArray:( a, b, t ) => {
        if ( t === 0 ) return a;
        if ( t === 1 ) return b;
        let i = a.length;
        let r = [];
        while(i--){ r[i] = a[i]; r[i] += ( b[i] - r[i] ) * t; }
        return r 
    },

    slerpQuatArray:( a, b, t ) => {

        if ( t === 0 ) return a;
        if ( t === 1 ) return b;
        let r = [...a];
        const x = a[0], y = a[1], z = a[2], w = a[3];
        const qx = b[0], qy = b[1], qz = b[2], qw = b[3];
        let cosHalfTheta = w * qw + x * qx + y * qy + z * qz;

        if ( cosHalfTheta < 0 ) {
            r = [ -qx, -qy, -qz, -qw ];
            cosHalfTheta = - cosHalfTheta;
        } else {
            r = [...b];
        }

        if ( cosHalfTheta >= 1.0 ) return a
        
        const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

        if ( sqrSinHalfTheta <= EPSILON ) {

            const s = 1 - t;
            r[3] = s * w + t * r[3];
            r[0] = s * x + t * r[0];
            r[1] = s * y + t * r[1];
            r[2] = s * z + t * r[2];
            return MathTool.quatNomalize(r);

        }

        const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
        const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
        const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta, ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

        r[3] = ( w * ratioA + r[3] * ratioB );
        r[0] = ( x * ratioA + r[0] * ratioB );
        r[1] = ( y * ratioA + r[1] * ratioB );
        r[2] = ( z * ratioA + r[2] * ratioB );

        return r;

    },

    // QUAT

    toLocalQuatArray: ( rot = [0,0,0], b ) => { // rotation array in degree

        let q1 = MathTool.quatFromEuler( rot );
        let q2 = MathTool.quatInvert( b.quaternion.toArray() );
        return MathTool.quatMultiply( q2, q1 )

        /*quat.setFromEuler( euler.fromArray( math.vectorad( rot ) ) )
        quat.premultiply( b.quaternion.invert() );
        return quat.toArray();*/

    },

    quatFromEuler:( r = [0,0,0], isDeg = true ) => {

        const cos = Math.cos;
        const sin = Math.sin;
        const n = isDeg ? torad$1 : 1; 
        const x = (r[0]*n) * 0.5, y = (r[1]*n) * 0.5, z = (r[2]*n) * 0.5;
        const c1 = cos( x ), c2 = cos( y ), c3 = cos( z );
        const s1 = sin( x ), s2 = sin( y ), s3 = sin( z );

        return [
            s1 * c2 * c3 + c1 * s2 * s3,
            c1 * s2 * c3 - s1 * c2 * s3,
            c1 * c2 * s3 + s1 * s2 * c3,
            c1 * c2 * c3 - s1 * s2 * s3
        ]
        
    },

    quatFromAxis:( r = [0,0,0], angle, isDeg = true ) => {

        const n = isDeg ? torad$1 : 1; 
        const halfAngle = (angle * 0.5) * n, s = Math.sin( halfAngle );
        return [
            r[0] * s,
            r[1] * s,
            r[2] * s,
            Math.cos( halfAngle )
        ]
        
    },

    quatNomalize:( q ) => {
        let l = MathTool.lengthArray( q );
        if ( l === 0 ) {
            return [0,0,0,1]
        } else {
            l = 1 / l;
            return MathTool.scaleArray(q, l, 4)
        }
    },

    quatInvert:( q ) => {
        return [-q[0],-q[1],-q[2], q[3]]
    },

    quatMultiply:( a, b ) => {
        const qax = a[0], qay = a[1], qaz = a[2], qaw = a[3];
        const qbx = b[0], qby = b[1], qbz = b[2], qbw = b[3];
        return [
            qax * qbw + qaw * qbx + qay * qbz - qaz * qby,
            qay * qbw + qaw * qby + qaz * qbx - qax * qbz,
            qaz * qbw + qaw * qbz + qax * qby - qay * qbx,
            qaw * qbw - qax * qbx - qay * qby - qaz * qbz
        ]
    },

    quatToAxis:( q ) => {

        let w = 2 * Math.acos( q[3] );
        const s = Math.sqrt( 1 - q[3] * q[3] );
        if ( s < 0.0001 ) {
            return [1,0,0]
        } else {
             return [ q[0] / s, q[1] / s, q[2] / s, w ]
        }
    },

    eulerFromMatrix: (te) => {

        const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
        te[ 1 ]; const m22 = te[ 5 ], m23 = te[ 9 ];
        te[ 2 ]; const m32 = te[ 6 ], m33 = te[ 10 ];

        let ar = [0,0,0];
        ar[1] = Math.asin( MathTool.clamp( m13, - 1, 1 ) );
        if ( Math.abs( m13 ) < 0.9999999 ) {
            ar[0] = Math.atan2( - m23, m33 );
            ar[2] = Math.atan2( - m12, m11 );
        } else {
            ar[0] = Math.atan2( m32, m22 );
            ar[2] = 0;
        }
        return ar

    },

    angleTo:( a, b ) => {

        return 2 * Math.acos( Math.abs( MathTool.clamp( MathTool.dotArray(a,b), - 1, 1 ) ) );

    },

    lengthArray:( r ) => {
        let i = r.length, l=0;
        while(i--) l += r[i] * r[i];
        return Math.sqrt( l )
    },

    dotArray: ( a, b ) => {
        let i = a.length, r = 0;
        while ( i -- ) r += a[ i ] * b[ i ];
        return r;
    },

    addArray: ( a, b, i ) => {
        i = i ?? a.length;
        let r = [];
        while ( i -- ) r[i] = a[ i ] + b[ i ];
        return r
    },

    subArray: ( a, b, i ) => {
        i = i ?? a.length; 
        let r = [];
        while ( i -- ) r[i] = a[ i ] - b[ i ];
        return r
    },

    //

    mulArray: ( r, s, i ) => {
        i = i ?? r.length;
        while ( i -- ) r[i] *= s;
        return r
    },

    divArray: ( r, s, i ) => {
        return MathTool.scaleArray( r, 1/s, i )
    },


    scaleArray: ( r, scale, i ) => {
        i = i ?? r.length;
        while( i-- ) r[i] *= scale;
        return r
    },

    fillArray ( ar, ar2, n, i ) { 
        n = n || 0;
        i = i ?? ar.length;
        while(i--) ar2[n+i] = ar[i];
    },

    copyArray: ( a, b ) => {
        [...b];
    },

    //

    distanceArray: ( a, b = [0,0,0] ) => ( MathTool.lengthArray( MathTool.subArray( a, b ) ) ),



    // VOLUME

    getVolume: ( type, size, vertex = null ) => {

        let volume = 1;
        let s = size;

        switch(type){
            
            case 'sphere' : volume = (4*Math.PI*s[0]*s[0]*s[0])/3; break;
            case 'cone' : volume = Math.PI * s[0] * (s[1] * 0.5) * 2; break;
            case 'box' : volume = 8 * (s[0]*0.5)*(s[1]*0.5)*(s[2]*0.5); break;
            case 'cylinder' : volume = Math.PI * s[0] * s[0] * (s[1] * 0.5) * 2; break;
            case 'capsule' : volume = ( (4*Math.PI*s[0]*s[0]*s[0])/3) + ( Math.PI * s[0] * s[0] * (s[1] * 0.5) * 2 ); break;
            case 'convex' : case 'mesh' : volume = MathTool.getConvexVolume( vertex ); break;

        }

        return volume;

    },

    getConvexVolume: ( v ) => {

        let i = v.length / 3, n;
        let min = [0, 0, 0];
        let max = [0, 0, 0];

        while(i--){

            n = i*3;
            if ( v[n] < min[0] ) min[0] = v[n];
            else if (v[n] > max[0]) max[0] = v[n];
            if ( v[n+1] < min[1] ) min[1] = v[n+1];
            else if (v[n+1] > max[1]) max[1] = v[n+1];
            if ( v[n+2] < min[2] ) min[2] = v[n+2];
            else if (v[n+2] > max[2]) max[2] = v[n+2];

        }

        let s = [ max[0]-min[0], max[1]-min[1], max[2]-min[2] ];

        return 8 * (s[0]*0.5)*(s[1]*0.5)*(s[2]*0.5);
        //return (max[0]-min[0])*(max[1]-min[1])*(max[2]-min[2])

    },

    massFromDensity: ( density, volume ) =>  ( density * volume ),
    densityFromMass: ( mass, volume ) =>  ( mass / volume ),


    // GEOMETRY

    getIndex: ( g ) => {

        if(!g.index) return null
        return g.index.array || null

    },

    getVertex: ( g, noIndex ) => {
        
        let c = g.attributes.position.array;

        if( noIndex ){
            let h = g.clone().toNonIndexed();
            c = h.attributes.position.array;
        }

        return c;

    },

    reduce: ( x ) => {
    },

    barycentric: ( simplex, point ) => {
        

    },

    solve: ( simplex, point ) => {
    }

};

// point weight blend space javascript

/*
get_blend_space_2d_node_influences :: (using space : *Blend_Space_2d, position : Vec2) -> []f32 #must
{
    weights           := alloc_array (f32, nodes.count, temp_allocator);
    sqrd_distances    := alloc_array (f32, nodes.count, temp_allocator);
    angular_distances := alloc_array (f32, nodes.count, temp_allocator);

    total_sqrd_distance, total_angular_distance := 0.0;
    for nodes
    {
        sqrd_distance := dot (position - it.position, position - it.position);
        if sqrd_distance > 0
        {
            angular_distance := -(clamp (dot (normalize (position), normalize (it.position)), -1, 1) - 1) * 0.5;
            total_sqrd_distance += 1 / sqrd_distance;
            if angular_distance > 0 then total_angular_distance += 1 / angular_distance;
            sqrd_distances[it_index] = sqrd_distance;
            angular_distances[it_index] = angular_distance;
        }
        else    // The distance is 0 so it.position == position
        {
            // Weights are already initialized to 0
            weights[it_index] = 1;

            return weights;
        }
    }

    for i : 0..nodes.count - 1
    {
        sqrd_distance    := total_sqrd_distance    * sqrd_distances[i];
        angular_distance := total_angular_distance * angular_distances[i];
        if sqrd_distance > 0 && angular_distance > 0
            weights[i] = (1 / sqrd_distance) * 0.5 + (1 / angular_distance) * 0.5;
        else if sqrd_distance > 0
            weights[i] = (1 / sqrd_distance) * 0.5 + 0.5;
        else
            weight = 0;
    }

    return weights;
}
*/

const Max = {
	body:2000,
    joint:500,
    contact:50,
    ray:100,
    character:50,
    vehicle:50,
    solver:20,
    //terrain:10,
};

const Num = {
	bodyFull:14,
    body:8,
    joint:16,
    contact:8,
    ray:11,
    character:16,
    vehicle:72,//max 8 wheels
    solver:128,//256,
    //terrain:1,
};

const getArray = function ( engine, full = false ){

    let ArPos = {};

    let counts = {
        body: Max.body * ( full ? Num.bodyFull : Num.body ),
        joint: Max.joint * Num.joint,
        ray: Max.ray * Num.ray,
        contact: Max.contact * Num.contact,
        character: Max.character * Num.character
    };

    if( engine === 'PHYSX' || engine === 'AMMO' ){ 
        counts['vehicle'] = Max.vehicle * Num.vehicle;
    }

    if( engine === 'PHYSX' ){ 
        counts['solver'] = Max.solver * Num.solver;
    }

    if( engine === 'HAVOK' || engine === 'RAPIER' ){ 
        Num.joint = 0;
    }

    let prev = 0;

    for( let m in counts ){ 

        ArPos[m] = prev;
        prev += counts[m];

    }

    ArPos['total'] = prev;

    return ArPos

};

const getType = function (o){
    switch(o.type){
        case 'plane': case 'box': case 'sphere': case 'highSphere': case 'cylinder': case 'stair':case 'particle':
        case 'cone': case 'capsule': case 'mesh': case 'convex': case 'compound': case 'null':
        if ( !o.mass && !o.density && !o.kinematic ) return 'solid'
        else return 'body'
        default: 
            return o.type 
    }
};

//import { CircleHelper } from '../3TH/helpers/CircleHelper.js';
//import { CarbonTexture } from '../3TH/textures/CarbonTexture.js';


const map = new Map();

//-------------------
//
//  ROOT
//
//-------------------

const root = {

	AR:null,

	viewSize:null,

	engine:'OIMO',
	motor: null,
	scene : null,
	scenePlus : null,
	threeScene : null,
	post : null,
	//up:null,
	//update:null,
	//change:null,
	jointVisible:false,
	delta:0,
	add:null,
	remove:null,
	items:null,
	tmpMesh : [],
	instanceMesh : {},
	tmpTex : [],
	//tmpMat : [],

	//hideMaterial: null,
	//lineMaterial: null,

	mouseDown:false,
	
	flow:{
		stamp:0,
		current:'',
		key:[],
		tmp:[],
		add:[],
		remove:[]
	},
	reflow:{
		ray:[],
		stat:{ fps:0 },
		point:{},
	},

	extraMaterial:() => {},
	
	disposeTmp:() => {

		// clear temporary mesh
		let i, j, m;
		for( i in root.tmpMesh ) {
			m = root.tmpMesh[i];
			if( m.children ){
				for( j in m.children ) root.disposeMesh( m.children[j] );
			}
			root.disposeMesh( m );
			if( m.parent ) m.parent.remove( m );
		}
		root.tmpMesh = [];

		// clear temporary textures
		for( i in root.tmpTex ) root.tmpTex[i].dispose();

	},

	disposeMesh:( m ) => {
		if( m.geometry ) m.geometry.dispose();
		if( m.dispose ) m.dispose();
	},

};


//-------------------
//
//  UTILS
//
//-------------------

const Utils = {

	byName: ( name ) => {

		if ( !map.has( name ) ) return null;
		return map.get( name );

	},

	add: ( b, parent ) => {

		if( b.type !== 'contact' && !b.isInstance && b.isObject3D ){

			//console.log('add', b.name, b.type )

			if(!parent){
				if(b.isButton){ root.scene.add( b ); }
				else {
					switch( b.type ){
						case 'terrain': case 'solid': case 'joint': case 'ray': case 'articulation': root.scenePlus.add( b ); break;
						default: root.scene.add( b ); break;
					}
				}
				
			} else {
				parent.add( b );
			}

		}

		//console.log('add', b.name, b.type )

		map.set( b.name, b );

	},

	remove:( b ) => {

		if( b.dispose ) b.dispose();
		if( b.parent ) b.parent.remove( b );
		if( b.instance ) b.instance.remove( b.id );
		map.delete( b.name );

	},

	noRay:( b ) => {
		if( b.isObject3D ){
			b.raycast = () => {return};
			b.traverse( ( child ) => {
				if ( child.isObject3D ) child.raycast = () => {return};
			});

		}
	},

    morph: ( obj, name, value ) => {
        
        if(!obj.morphTargetInfluences) return
        if(obj.morphTargetDictionary[name] === undefined ) return
        obj.morphTargetInfluences[ obj.morphTargetDictionary[name] ] = value;
    
    },


    toLocal: ( v, obj, isAxe = false ) => {

    	//if( obj.isObject3D ) obj.updateWorldMatrix( true, false )
    	// apply position
    	if(!isAxe) v.sub( obj.position );
    	// apply invers rotation
    	let q = obj.quaternion;
    	//v.applyQuaternion(q.clone().invert())
    	//v.applyQuaternion({x:-q.x, y:-q.y, z:-q.z, w:q.w})
    	v.applyQuaternion({x:-q._x, y:-q._y, z:-q._z, w:q._w});
    	//if(isAxe) v.normalize()
    	return v

    },

    quatLocal: ( q, obj ) => {

    	if( obj.isObject3D ) obj.updateWorldMatrix( true, false );
    	// apply position
    	//if(!isAxe) v.sub( obj.position )
    	// apply invers rotation
    	let q1 = new Quaternion().fromArray(q);
    	let q2 = obj.quaternion.clone().invert();
    	q1.premultiply(q2);
    	//v.applyQuaternion({x:-q.x, y:-q.y, z:-q.z, w:q.w})
    	return q1.normalize().toArray()

    },

    axisLocal: ( v, obj ) => {

    	if( obj.isObject3D ) obj.updateWorldMatrix( true, false );
    	// apply position

        let m3 = new Matrix3().setFromMatrix4( obj.matrixWorld );//.invert()
        //m3.invert()
        let vv = new Vector3().fromArray(v).applyMatrix3( m3 );

        //let vv = new Vector3().fromArray(v).applyMatrix4( obj.matrixWorld.clone().invert() );

    	return vv.toArray()

    },


    quatToAngular: ( qb, qa ) => {

    	/*const qq1 = new Quaternion().fromArray(qa);
    	const qq2 = new Quaternion().fromArray(qb);
    	//qq1.normalize()
    	//qq2.normalize();



    	qq2.multiply( qq1.invert() )*/

    	// invert
    	qa[0] *= -1;
    	qa[1] *= -1;
    	qa[2] *= -1;

    	let x = qa[0] * qb[3] + qa[3] * qb[0] + qa[1] * qb[2] - qa[2] * qb[1];
		let y = qa[1] * qb[3] + qa[3] * qb[1] + qa[2] * qb[0] - qa[0] * qb[2];
		let z = qa[2] * qb[3] + qa[3] * qb[2] + qa[0] * qb[1] - qa[1] * qb[0];
		let w = qa[3] * qb[3] - qa[0] * qb[0] - qa[1] * qb[1] - qa[2] * qb[2];

    	let angle = 2 * Math.acos(w), ax;
	    let s = Math.sqrt(1-w*w); // assuming quaternion normalised then w is less than 1, so term always positive.
	    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
	        // if s close to zero then direction of axis not important
	        // if it is important that axis is normalised then replace with x=1; y=z=0;
	        ax = [0,0,0];
	    } else {
	        //x = q[0] / s; // normalise axis
	        ax =  [x / s,y / s,z / s];
        }



    	/*const matrix1 = new Matrix4().makeRotationFromQuaternion(qq1);
    	const matrix2 = new Matrix4().makeRotationFromQuaternion(qq2);

    	matrix2.multiply(matrix1.invert())

    	const v = new Vector3().applyMatrix4(matrix2);
    	const angle = Math.acos((matrix2.elements[0] + matrix2.elements[5] + matrix2.elements[10] - 1) / 2);
*/
        const v = new Vector3().fromArray(ax);
    	const timeDiff = 1;//time2 - time1;
    	v.multiplyScalar( angle / timeDiff );

    	//console.log('result',v)

    },

   /* matrixToAxix: ( m ) => {

    	let p = new Vector3(1,0,0).transformDirection( m )
    	return p.toArray()

    },*/

    refAxis:( m, axe ) => {

    	let zAxis = new Vector3().fromArray(axe);
	    let xAxis = new Vector3(1, 0, 0);
	    let yAxis = new Vector3(0, 1, 0);
	    if ( Math.abs( axe[1] ) > 0.9999 ){
			yAxis.copy( xAxis ).cross( zAxis ).normalize();
		} else {
			xAxis.copy( zAxis ).cross( yAxis ).normalize();
			yAxis.copy( xAxis ).cross( zAxis ).normalize();
		}

		m.makeBasis( xAxis, yAxis, zAxis );

    }



};

class CircleHelper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		let size=0.6;

		const indices = new Uint16Array( [ 
			0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 0,   
			6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 6,
			12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 12,
			18,19, 20,21, 22, 23,
			] );
		const positions = [

		

		 0.5, 0.0, 0.0,
		0.25, 0.433, 0.0,
		-0.25, 0.433, 0.0,
		-0.5, 0.0, 0.0,
		-0.25, -0.433, 0.0,
		0.25, -0.433, 0.0, 

		 0.5, 0.0,0.0, 
		0.25,  0.0,0.433,
		-0.25,  0.0,0.433,
		-0.5, 0.0, 0.0,
		-0.25,0.0, -0.433, 
		0.25, 0.0, -0.433, 

		0.0,0.5, 0.0,
		0.0,0.25, 0.433, 
		0.0,-0.25, 0.433, 
		0.0,-0.5, 0.0, 
		0.0,-0.25, -0.433, 
		0.0,0.25, -0.433, 

		0, 0, 0,	size, 0, 0,
		0, 0, 0,	0, size, 0,
		0, 0, 0,	0, 0, size,

		
		];

		const colors = [

		

		0, 0, 1,
		0, 0, 1,
		0, 0, 1,
		0, 0, 1,
		0, 0, 1,
		0, 0, 1,
		
		0, 1, 0,
		0, 1, 0,
		0, 1, 0,
		0, 1, 0,
		0, 1, 0,
		0, 1, 0,

        1, 0, 0,
		1, 0, 0,
		1, 0, 0,
		1, 0, 0,
		1, 0, 0,
		1, 0, 0,

		1, 0, 0,	1,0, 0,
		0, 1, 0,	0, 1, 0,
		0, 0, 1,	0, 0, 1,

		

		
		];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } ) );

		this.box = box;

		this.type = 'CircleHelper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

//-------------------
//
//  GEOMETRY
//
//-------------------


let geoN = 0;
let geo = {};

const Geo = {

	unic: ( g ) => {

		geo[ 'geo' + geoN++ ] = g;

	},

	set: ( g ) => {

		geo[g.name] = g;

	},

	get: ( name, o = {} ) => {

		if( !geo[name] ){
			let g;
			switch( name ){
				case 'plane':    g = new PlaneGeometry(1,1); g.rotateX( -Math.PI * 0.5 ); break
				case 'box':      g = new BoxGeometry(1,1,1); break
				case 'sphere':   g = new SphereGeometry( 1, 16, 12 ); break
				case 'cylinder': g = new CylinderGeometry( 1, 1, 1 , 16 ); break
				//case 'wheel':    g = new CylinderGeometry( 1, 1, 1 , 16 ); g.rotateX( -Math.PI * 0.5 ); break
				case 'cone':     g = new CylinderGeometry( 0.001, 1, 1 , 16 ); break
				//case 'joint':    g = new Box3Helper().geometry; g.scale( 0.05,0.05,0.05 ); break
				case 'particle':   g = new SphereGeometry( 1, 3, 2 ); break
				case 'joint':    g = new CircleHelper().geometry; break
				default: return null;
			}
			geo[name] = g;
		}

		return geo[name]
		
	},

	dispose: () => {
		//console.log( geo )
		for( let n in geo ) geo[n].dispose();
		geo = {};
		geoN = 0;

	}

};

class CarbonTexture {

	constructor( normal, c1='rgb(69,69,69)', c2='rgb(39,39,39)'  ) {

		let s = 128;

		const canvas = document.createElement( 'canvas' );
		canvas.width = canvas.height = s;

		const ctx = canvas.getContext( '2d' );
		ctx.fillStyle = c1;
		ctx.fillRect( 0, 0, s, s );

		if( !normal ){

			ctx.beginPath();
			ctx.fillStyle = c2;
		    ctx.rect(0, 0, 32, 64);
		    ctx.rect(32, 32, 32, 64);
		    ctx.rect(64, 64, 32, 64);
		    ctx.rect(96, 96, 32, 64);
		    ctx.rect(96, -32, 32, 64);
		    ctx.fill();

	    } else {

	    	let i, j, n, d;
	    	let pos = [ [0, 0], [32, 32],[64, 64],[96, 96],[96, -32] ];
	    	let deg = [ [0, 64], [32, 96],[64, 128],[96, 160],[-32, 32] ];

	    	let f1 = normal ? 'rgb(128,128,255)' : c1;
	    	let f2 = normal ? 'rgb(160,100,255)' : c2;
	    	let f3 = normal ? 'rgba(100,160,255, 0.5)' : 'rgba(0,0,0, 0.1)';

	    	ctx.strokeStyle = f3;
	    	ctx.lineWidth = 1;

	    	for( i = 0; i<5; i++ ){

	    		d = ctx.createLinearGradient(0, deg[i][0], 0, deg[i][1]);
				d.addColorStop(0, f2);
				d.addColorStop(1, f1);

				ctx.beginPath();
				ctx.fillStyle = d;
				ctx.rect(pos[i][0], pos[i][1], 32, 64);
				ctx.fill();

				for( let j = 0; j<8; j++ ){   

					n = (Math.random()-0.5) * 2; 
				           
				    ctx.beginPath();
					ctx.moveTo(pos[i][0]+n+2+j*4, pos[i][1]);
					ctx.lineTo(pos[i][0]+n+2+j*4, pos[i][1]+64);
					ctx.stroke();
				}

	    	}

	    	pos = [ [32, 0], [64, 32],[96, 64],[-32, 64],[0, 96] ];
	    	deg = [ [32, 96], [64, 128],[96, 160],[-32, 32],[0, 64] ];

	    	for( i = 0; i<5; i++ ){

	    		d = ctx.createLinearGradient(deg[i][0], 0, deg[i][1], 0);
				d.addColorStop(0, f1);
				d.addColorStop(1, f2);

				ctx.beginPath();
				ctx.fillStyle = d;
				ctx.rect(pos[i][0], pos[i][1], 64, 32);
				ctx.fill();

				for( j = 0; j<8; j++ ){

					n = (Math.random()-0.5) * 2; 
					ctx.beginPath();
					ctx.moveTo(pos[i][0], pos[i][1]+n+2+j*4);
					ctx.lineTo(pos[i][0]+64, pos[i][1]+n+2+j*4);
					ctx.stroke();
				}

	    	}

	    }

		//return canvas;

		const texture = new CanvasTexture( canvas ); //new CarbonTexture('#ffffff', '#CCCCCC') )
		texture.wrapS = texture.wrapT = RepeatWrapping;
		texture.repeat.x = texture.repeat.y = 60;

		if(!normal) texture.colorSpace = SRGBColorSpace;

		return texture;

	}

}

//-------------------
//
//  MATERIAL
//
//-------------------

//const mat = new Map()
const mat = {};

let TmpMat = [];

const matExtra = {

	//clearcoat:1.0,
	//clearcoatRoughness:0.1,
	metalness: 0.6,
	roughness: 0.3,
	//normalScale: new Vector2(0.25,0.25),

};

const Colors = {
    body:new Color( 0xefefd4 ),
    sleep:new Color( 0xBFBFAD ),
    solid:new Color( 0x6C6A68 ),
    base:new Color( 0xFFFFFF ),
    black:new Color( 0x222222 ),
    gold:new Color( 0.944, 0.776, 0.373 ),
    gold2:new Color( 0.998, 0.981, 0.751 ),
    copper:new Color( 0.96467984, 0.37626296, 0.25818297 ),
    carPaint:new Color( 0.1037792, 0.59212029, 0.85064936 ),
    clay:new Color( 0.604,0.584,0.497 ),
    concrete:new Color( 0xabafb8 ),
};

const Mat = {

	extendShader:() =>{},

	addToTmp:( m ) => {

		TmpMat.push( m );
	},

	create:( o ) => {

		let m, beforeCompile = null;

		if( o.isMaterial ){
			m = o;
		} else {

			let type = o.type !== undefined ? o.type : 'Standard';
			if( o.type ) delete o.type;

			beforeCompile = o.beforeCompile || null;
		    if( o.beforeCompile ) delete o.beforeCompile;


			if( o.thickness || o.sheen || o.clearcoat || o.transmission || o.specularColor ) type = 'Physical';

			if(o.normalScale){
				if( !o.normalScale.isVector2 ) o.normalScale = new Vector2().fromArray(o.normalScale);
			}

		    type = type.toLowerCase();

		    switch( type ){

				case 'physical': 
					m = new MeshPhysicalMaterial( o ); 
					m.defines = {
						'STANDARD': '',
						'PHYSICAL': '',
						'USE_UV':'',
						'USE_SPECULAR':''
					};
				break;
				case 'phong': m = new MeshPhongMaterial( o ); break;
				case 'lambert': m = new MeshLambertMaterial( o ); break;
				case 'basic': m = new MeshBasicMaterial( o ); break;
				case 'line': m = new LineBasicMaterial( o ); break;
				case 'toon': m = new MeshToonMaterial( o ); break;
				default: m = new MeshStandardMaterial( o ); break;
			}

		} 

		if( mat[ m.name ] ) return null;
	    Mat.set( m, false, beforeCompile );
		return m;

	},

	set:( m, direct, beforeCompile ) => {

		if(!direct) Mat.extendShader( m, beforeCompile );
		mat[m.name] = m;

	},

	changeType:() => {



	},

	setEnvmapIntensity: (v) => { 
		let m;
		for(let name in mat){
			m = mat[name];
			if( !m.userData.envp ) m.userData.envp = m.envMapIntensity;
			m.envMapIntensity = m.userData.envp * v;
		}
		
	},
	
	getList: () => {

		return mat

	},

	get:( name ) => {

		if( !mat[name] ){
			switch( name ){

				case 'body': Mat.create({name:'body', color:Colors.body, ...matExtra }); break

			    //case 'body':   m = new MeshStandardMaterial({ color:Colors.body, ...matExtra }); break//0xFFF1D2
			    case 'sleep':  Mat.create({ name:'sleep', color:Colors.sleep, ...matExtra }); break//0x46B1C9
			    case 'solid':  Mat.create({ name:'solid', color:Colors.solid, metalness: 0.1, roughness: 0.8, }); break
			    case 'clay':  Mat.create({ name:'clay', color:Colors.clay, metalness: 0.0, roughness: 0.9, }); break
			    case 'base':   Mat.create({ name:'base', color:Colors.base, ...matExtra }); break

			    case 'concrete':  Mat.create({ name:'concrete', color:Colors.concrete, metalness: 0.0, roughness: 0.9, }); break

			    case 'black':   Mat.create({ name:'black', color:Colors.black, metalness: 0, roughness: 0.25 }); break

			    // metal
			    case 'chrome': Mat.create({ name:'chrome', color:0xCCCCCC, metalness: 1, roughness:0.075 }); break
			    case 'gold': Mat.create({ name:'gold', color:Colors.gold, specularColor:Colors.gold2, metalness: 1, roughness:0.02 }); break
			    case 'copper': Mat.create({ name:'copper', color:Colors.copper, metalness: 1, roughness:0.25, clearcoat: 1.0, clearcoatRoughness: 0.2 }); break

			    case 'carPaint': Mat.create({ name:'carPaint', color:Colors.carPaint, metalness: 0, anisotropy:new Vector2(0.5,0.5), roughness:0.4, clearcoat: 1.0, clearcoatRoughness: 0, }); break

				//case 'simple': m = Mat.create({ name:'simple', color:0x808080, metalness: 0, roughness: 1 }); break

				case 'carbon': Mat.create({ name:'carbon', map:new CarbonTexture(), normalMap:new CarbonTexture(true), clearcoat: 1.0, clearcoatRoughness: 0.1, roughness: 0.5 }); break
				case 'cloth': Mat.create({ name:'cloth', color:0x8009cf, roughness: 0.5, sheenColor:0xcb7cff, sheen:1, sheenRoughness:0.2 }); break


				//case 'clear':  m = new MeshStandardMaterial({ color:0xFFFFFF, metalness: 0.5, roughness: 0 }); break
				
				//case 'hero':   m = new MeshStandardMaterial({ color:0x00FF88, ...matExtra }); break
				case 'skinny':   Mat.create({ name:'skinny', color:0xe0ac69, ...matExtra }); break
				
				case 'glass':  Mat.create({ name:'glass', color:0xFFFFff, transparent:true, opacity:0.8, depthTest:true, depthWrite:true, roughness:0.02, metalness:0.0, /*side:DoubleSide,*/ alphaToCoverage:true, premultipliedAlpha:true, transmission:1, clearcoat:1, thickness:0.02  }); break
				case 'glassX':  Mat.create({ name:'glassX', color:0xeeeeee, transparent:false, opacity:1.0, roughness:0.03, metalness:0, side:DoubleSide, transmission:1.0, clearcoat:1, clearcoatRoughness:0.0, thickness:0.6, ior:1.52, envMapIntensity:1.0, shadowSide:1, reflectivity:0.5, iridescence:0 }); break
				case 'plexi':  Mat.create({ name:'plexi', color:0xFFFFff, transparent:true, opacity:0.4, metalness:1, roughness:0, clearcoat:1, side:DoubleSide }); break
				case 'glass2': Mat.create({ name:'glass2', color:0xCCCCff, transparent:true, opacity:0.3  }); break
				
				case 'car':   Mat.create({ name:'car', color:0x303030, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03, sheen: 0.5 }); break
				case 'carGlass':   Mat.create({ name:'carGlass', color: 0xffffff, metalness: 0, roughness: 0, transmission: 1.0, ior:1.52 }); break


				case 'debug': Mat.create({ name:'debug', type:'Basic', color:0xF37042, wireframe:true, toneMapped: false, transparent:true, opacity:0.25 }); break
				
				//case 'debug2': m = Mat.create({ name:'debug2', type:'Basic', color:0x00FFFF, wireframe:true, toneMapped: false }); break
				//case 'debug3':  m = Mat.create({ name:'debug3', type:'Basic', color:0x000000, wireframe:true, transparent:true, opacity:0.1, toneMapped: false }); break
				//case 'shadows': m = Mat.create({ name:'shadows', type:'Basic', transparent:true, opacity:0.01 }); break

				//case 'simple': m = Mat.create({ name:'simple', type:'basic'  }); break


				case 'bones':  Mat.create({ name:'bones', color:0xCCAA33,  wireframe:true }); break
				case 'bones2':  Mat.create({ name:'bones2', color:0x7777ff }); break

				
				case 'button':  Mat.create({ name:'button', color:0xFF404B, ...matExtra }); break
				//case 'hide': m = new MeshBasicMaterial({ visible:false }); break

				case 'line':
				    Mat.create({ name:'line', type:'line', vertexColors: true, toneMapped: false });
			    break
				case 'hide':
				    Mat.create({ name:'hide', type:'basic', visible:false });
			    break
			    case 'particle':
				    Mat.create({ name:'particle', type:'basic', toneMapped: false, color:0x00ff00 });
			    break


				

			}
			
		}

		return mat[name]



	},

	dispose:() => {

		for(let m in mat){
			mat[m].dispose();
			delete mat[m];
		}

		let i = TmpMat.length;
		while( i-- ) { TmpMat[i].dispose(); }
		TmpMat = [];

	}

};

class Timer {

	constructor( framerate = -1 ) {

		this.time = { now:0, delta:0, then:0, interval: 0, tmp:0, n:0, dt:0 };
		this.fps = 0;
		this.delta = 0;
		this.elapsedTime = 0;
		this.unlimited = false;
		this.setFramerate( framerate );
		this.force = false;

	} 

	up ( stamp = 0 ) {

		let t = this.time;

		if(this.unlimited) this.force = true;

		t.now = stamp;// !== undefined ? stamp : Date.now();
		t.delta = t.now - t.then;

		if( this.force ) {
			t.delta = t.interval;
			this.force = false;
		}
		
		if ( t.delta >= t.interval || this.unlimited ) {

		    t.then = this.unlimited ? t.now : t.now - ( t.delta % t.interval );
		    //if(t.delta>)
		    //this.delta = t.delta * 0.001 // bug on outside
		    this.delta = t.interval * 0.001;
		    //if(this.delta>this.time.interval)this.delta=this.time.interval
		    this.elapsedTime += this.delta;
		    
		    //if ( t.now - 1000 > t.tmp ){ t.tmp = t.now; this.fps = t.n; t.n = 0; }; t.n++;
			return true

		}

		return false

	}

	setFramerate ( framerate ){
		
		this.elapsedTime = 0;
		this.framerate = framerate;
		this.unlimited = this.framerate < 0;
		this.time.interval = 1000 / framerate;
		if( framerate === 60 ) this.time.interval = 16.67;

	}
	
}

class User {

	// key map
    // 0 : axe L | left:right  -1>1
    // 1 : axe L | top:down    -1>1
    // 2 : axe R | left:right  -1>1
    // 3 : axe R | top:down    -1>1
    // 4 : bouton A             0-1  jump / space
    // 5 : bouton B             0-1  roulade / shift ctrl
    // 6 : bouton X             0-1  arme principale / E
    // 7 : bouton Y             0-1  arme secondaire
    // 8 : gachette L up        0-1  
    // 9 : gachette R up        0-1
    // 10 : gachette L down     0>1
    // 11 : gachette R down     0>1
    // 12 : bouton setup        0-1
    // 13 : bouton menu         0-1
    // 14 : axe button left     0-1
    // 15 : axe button right    0-1
    // 16 : Xcross axe top      0-1
    // 17 : Xcross axe down     0-1
    // 18 : Xcross axe left     0-1
    // 19 : Xcross axe right    0-1

    // 20 : Keyboard or Gamepad    0-1

	constructor () {

		this.key = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        this.key2 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

		this.gamepad = new Gamepad( this.key ); 

		this.useGamepad = false;
		this.sameAxis = true;

		document.addEventListener( 'keydown', function(e){this.keyDown(e);}.bind(this), false );
        document.addEventListener( 'keyup', function(e){this.keyUp(e);}.bind(this), false );

	}

    setKey( i, v ){
        this.key[i] = v;
    }

	update () {

		this.gamepad.update();

        if( this.gamepad.ready ){ 
            if( !this.useGamepad ) this.useGamepad = true;
            this.gamepad.getValue(0);
        }

        if( this.sameAxis ){
            this.key[ 2 ] = this.key[ 0 ];
            this.key[ 3 ] = this.key[ 1 ];
        }

        //this.axeL[ 0 ] = this.key[ 0 ];
        //this.axeL[ 1 ] = this.key[ 1 ];

        return this.key

	}

	keyDown (e) {

		var key = this.key;
        var key2 = this.key2;
        e = e || window.event;

        if( this.sameAxis ){

            switch ( e.which ) {
                // axe L
                case 65: case 81: case 37: key[0] = -1; key2[0] = 1; break;//key[0]<=-1 ? -1:key[0]-= 0.1; break; // left, A, Q
                case 68:  case 39:         key[0] = 1;  key2[1] = 1; break; // right, D
                case 87: case 90:  case 38: key[1] = -1; break; // up, W, Z
                case 83: case 40:          key[1] = 1;  break; // down, S

                case 32:          key[4] = 1; break; // space
                case 17: case 67: key[5] = 1; break; // ctrl, C
                case 69:          key[6] = 1; break; // E
                
                case 16:          key[7] = 1; break; // shift
                //case 71:          view.hideGrid(); break; // G
                //case 121:         noui(); break; // f10
                //case 122:         fscreen(); break; // f11
            }

        } else {

            switch ( e.which ) {
                // axe L
                case 65: case 81: key[0] = -1; key2[0] = 1; break;//key[0]<=-1 ? -1:key[0]-= 0.1; break; // left, A, Q
                case 68:          key[0] = 1; key2[1] = 1; break; // right, D
                case 87: case 90: key[1] = -1; break; // up, W, Z
                case 83:          key[1] = 1;  break; // down, S
                // axe R
                case 37:          key[2] = -1;  key2[0] = 1;break; // left
                case 39:          key[2] = 1;  key2[1] = 1;break; // right
                case 38:          key[3] = -1; break; // up
                case 40:          key[3] = 1;  break; // down
                

                case 32:          key[4] = 1; break; // space
                case 17: case 67: key[5] = 1; break; // ctrl, C
                case 69:          key[6] = 1; break; // E
                
                case 16:          key[7] = 1; break; // shift
                //case 121:         noui(); break; // f10
                //case 122:         fscreen(); break; // f11
                
                //case 71:          view.hideGrid(); break; // G
            }
        }

        this.gamepad.reset();
        //e.preventDefault();

	}

	keyUp (e) {

		var key = this.key;
        var key2 = this.key2;
        e = e || window.event;

        if( this.sameAxis ){

            switch ( e.which ) {
                 // axe L
                case 65: case 81: case 37: key[0] = key[0]<0 ? 0:key[0]; key2[0] = 0; break; // left, A, Q
                case 68: case 39:         key[0] = key[0]>0 ? 0:key[0]; key2[1] = 0; break; // right, D
                case 87: case 90: case 38:key[1] = key[1]<0 ? 0:key[1]; break; // up, W, Z
                case 83: case 40:         key[1] = key[1]>0 ? 0:key[1]; break; // down, S

                case 32:          key[4] = 0; break; // space
                case 17: case 67: key[5] = 0; break; // ctrl, C
                case 69:          key[6] = 0; break; // E
                
                case 16:          key[7] = 0; break; // shift
            }

        } else {

            switch( e.which ) {
                
                // axe L
                case 65: case 81: key[0] = key[0]<0 ? 0:key[0]; key2[0] = 0; break; // left, A, Q
                case 68:          key[0] = key[0]>0 ? 0:key[0]; key2[1] = 0; break; // right, D
                case 87: case 90: key[1] = key[1]<0 ? 0:key[1]; break; // up, W, Z
                case 83:          key[1] = key[1]>0 ? 0:key[1]; break; // down, S
                // axe R
                case 37:          key[2] = key[2]<0 ? 0:key[2]; key2[0] = 0;break; // left
                case 39:          key[2] = key[2]>0 ? 0:key[2]; key2[1] = 0;break; // right
                case 38:          key[3] = key[3]<0 ? 0:key[3]; break; // up
                case 40:          key[3] = key[3]>0 ? 0:key[3]; break; // down

                case 32:          key[4] = 0; break; // space
                case 17: case 67: key[5] = 0; break; // ctrl, C
                case 69:          key[6] = 0; break; // E
                
                case 16:          key[7] = 0; break; // shift

                
            }
        }

        //e.preventDefault();
		
	}


}


class Gamepad {

	constructor ( key ) {

		this.values = []; 
        this.ready = 0;
        this.key = key;

	}

	update () {

		var i,j,k,l, v, pad;
        var fix = this.fix;
        var gamepads = navigator.getGamepads();

        for (i = 0; i < gamepads.length; i++) {

            pad = gamepads[i];
            if(pad){
                k = pad.axes.length;
                l = pad.buttons.length;
                if(l){
                    if(!this.values[i]) this.values[i] = [];
                    // axe
                    for (j = 0; j < k; j++) {
                        v = fix(pad.axes[j], 0.08 );
                        if(this.ready == 0 && v !== 0 ) this.ready = 1;
                        this.values[i][j] = v;
                        //if(i==0) this.key[j] = fix( pad.axes[j], 0.08 );
                    }
                    // button
                    for (j = 0; j < l; j++) {
                        v = fix(pad.buttons[j].value); 
                        if(this.ready == 0 && v !== 0 ) this.ready = 1;
                        this.values[i][k+j] = v;
                        //if(i==0) this.key[k+j] = fix( pad.buttons[j].value );
                    }
                    //info += 'gamepad '+i+'| ' + this.values[i]+ '<br>';
                } else {
                    if(this.values[i]) this.values[i] = null;
                }
            }
        }

	}

	getValue (n) {

		var i = 19, v;
        while(i--){
            v = this.values[n][i];
            if(this.ready == 0 && v !== 0 ) this.ready = 1;
            this.key[i] = v;
        }

	}

	reset () {

		this.ready = 0;
		
	}

	fix (v, dead) {

		let n = Number((v.toString()).substring(0, 5));
        if(dead && n<dead && n>-dead) n = 0;
        return n;
		
	}


}

class Item {

	constructor () {

		this.id = 0;
		this.list = [];
		this.type = 'item';
		this.Utils = null;

	}

	reset () {

		let i = this.list.length;
		while( i-- ) this.dispose( this.list[i] );

		this.id = 0;
		this.list = [];

	}

	///

	byName ( name ) {

		return this.Utils.byName( name )

	}

	setName ( o = {} ) {

		let name = o.name !== undefined ? o.name : this.type + this.id ++;

		// clear old item if existe keep id
		o.id = this.remove( name, true );
		o.name = name;

		return name

	}

	addToWorld ( b, id = -1 ) {

		this.Utils.add( b );
		if( id !== -1 ) this.list[id] = b;
		else this.list.push( b );

	}

	remove ( name, remplace ) {

		let b = this.byName( name );
		if( !b ) return -1
		return this.clear( b, remplace )

	}

	clear ( b, remplace ) {

		let n = this.list.indexOf( b );
		if ( n !== - 1 && !remplace ) this.list.splice( n, 1 );
		else this.list[n] = null;
		this.dispose( b );
		return n

	}

	dispose ( b ) {

		if( b !== null ) this.Utils.remove( b );

	}




    vecZero ( ar, n, i ) { while ( i -- ) ar[n+i] = 0; }

    fillArray ( ar, ar2, n, i ) { 
    	n = n || 0;
    	i = i ?? ar.length;
    	while(i--) ar2[n+i] = ar[i];
    }

    arLength ( ar ) { 
    	let v = Math.sqrt( ar[0] * ar[0] + ar[1] * ar[1] + ar[2] * ar[2] );
    	if( v < 0.001 ) v = 0;
    	return v
    }

    multiplyScalar ( ar, v, i ) { 
    	i = i ?? ar.length;
    	while(i--) ar[i] *= v;
    }

    divideScalar ( ar, v, i ) { 
    	this.multiplyScalar( ar, 1/v, i );
    }



	add ( o = {} ) { }

	set ( o = {} ) { }

	step ( AR, N ) { }

}

// THREE RAY

class Ray extends Item {

	constructor () {

		super();

		this.Utils = Utils;
		this.type = 'ray';

	}

	step ( AR, N ) {

		let i = this.list.length, r, n;
		
		while( i-- ){

			r = this.list[i];
			n = N + ( i * Num.ray );
			r.update( AR, n, root.reflow.ray[i] || null );

		}

	}

	add ( o = {} ) {

		this.setName( o );

		let r = new ExtraRay( o );

		r.visible = o.visible !== undefined ? o.visible : true;


		// add to world
		this.addToWorld( r, o.id );

		if(o.parent){
			if( typeof o.parent !== 'string' ) o.parent = o.parent.name;
		}

		if( o.callback ) delete o.callback;

		

		// add to worker 
		root.post( { m:'add', o:o } );

		return r;

	}

	set ( o = {}, r = null ) {

		if( r === null ) r = this.byName( o.name );
		if( r === null ) return;

		r.setRay(o);

	}

}


class ExtraRay extends Line$1 {

	constructor( o = {} ) {

	    super(  new BufferGeometry(), Mat.get('line') );

	    this.data = {

			hit:false,
			body: '',
			point: [0,0,0],
			normal: [0,0,0],
			distance: 0,
			angle:0

		};

	    this.type = 'ray';
	    this.name = o.name;

	    this.parentMesh = null;
	    if(o.parent){
	    	this.parentMesh = typeof o.parent === 'string' ?  Utils.byName( o.parent ) : o.parent;
	    }

	    this.callback = o.callback || function () {};

	    // color
		this.c0 = [ 0.1, 0.1, 0.3 ];
		this.c1 = [ 0.1, 0.4, 0.6 ];
		this.c2 = [ 1.0, 0.1, 0.1 ];
		this.c3 = [ 0.1, 1.0, 0.1 ];

	    this.begin = new Vector3();
	    this.end = new Vector3(0,1,0);
	    this.fullDistance = 0;

	    this.setRay( o );

	    this.tmp = new Vector3();
	    this.normal = new Vector3();


	    this.vv1 = new Vector3();
	    this.vv2 = new Vector3();
	    
	    const positions = [0,0,0, 0,0,0, 0,0,0];
	    const colors = [0,0,0, 0,0,0, 0,0,0];

	    //this.geometry = new BufferGeometry();
	    this.geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	    this.geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	    //this.geometry.computeBoundingSphere();

	    this.vertices = this.geometry.attributes.position;
	    this.colors = this.geometry.attributes.color;
	    this.local = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];

	    this.matrixAutoUpdate = false;
	    this.frustumCulled = false;

	}

	setRay( o ){

		if( o.begin ) this.begin.fromArray( o.begin );
	    if( o.end ) this.end.fromArray( o.end );
	    this.fullDistance = this.begin.distanceTo( this.end );

	}

	update ( r, n = 0, body = null ) {

		this.data.hit = r[n] !== 0 ? true : false;
		this.data.body = body ? body : '';

		this.data.distance = r[n+1];

		if( this.data.hit ){

			this.local[0] = r[n+2];
			this.local[1] = r[n+3];
			this.local[2] = r[n+4];

			this.tmp.fromArray( r, n+5 );
			this.normal.fromArray( r, n+8 );

			this.data.point = this.tmp.toArray();
			this.data.normal = this.normal.toArray();
			//this.data.distance = this._begin.distanceTo( this.tmp )

			this.tmp.toArray( this.local, 3 );
			this.vv1.fromArray( this.local ).sub(this.tmp).normalize(); 
			this.tmp.addScaledVector( this.normal, this.fullDistance - this.data.distance );
			this.tmp.toArray( this.local, 6 );

			
			//vv1.fromArray( r, n+5 ); 

			this.data.angle = Math.floor( MathTool.angleTo( this.vv1.toArray(), this.data.normal ) * todeg$1 );
			//let angle = MathTool.angleTo( [this.local[0], this.local[2], this.local[2]], [this.local[3], this.local[4], this.local[5]] ) * todeg
			//console.log(this.data.angle)

		} else {
			if( this.parentMesh ){
				//this.parentMesh.updateWorldMatrix(false,false )
				const mtx = this.parentMesh.matrixWorld;
				this.tmp.copy( this.begin ).applyMatrix4(mtx).toArray( this.local, 0 );
				this.tmp.copy( this.end ).applyMatrix4(mtx);
				this.tmp.toArray( this.local, 3 );
				this.tmp.toArray( this.local, 6 );
			} else {
				this.begin.toArray( this.local, 0 );
				this.end.toArray( this.local, 3 );
				this.end.toArray( this.local, 6 );
			}
		}

		this.updateGeometry();
		//this.updateMatrix()

		this.callback( this.data );

	}

	dispose(){
		this.geometry.dispose();
	}

	raycast(){
		return
	}

	updateGeometry(){

		if ( !this.visible ) return;

		let v = this.vertices.array;
		let c = this.colors.array;
		let l = this.local;
		let hit = this.data.hit;
		let c1 = hit ? this.c2 : this.c1;
		let c2 = hit ? this.c3 : this.c1;

		c[ 3 ] = c1[0];
		c[ 4 ] = c1[1];
		c[ 5 ] = c1[2];

		c[ 6 ] = c2[0];
		c[ 7 ] = c2[1];
		c[ 8 ] = c2[2];

		v[ 0 ] = l[ 0 ];
		v[ 1 ] = l[ 1 ];
		v[ 2 ] = l[ 2 ];

		v[ 3 ] = l[ 3 ];
		v[ 4 ] = l[ 4 ];
		v[ 5 ] = l[ 5 ];
		
		v[ 6 ] = l[ 6 ];
		v[ 7 ] = l[ 7 ];
		v[ 8 ] = l[ 8 ];

		this.vertices.needsUpdate = true;
	    this.colors.needsUpdate = true;
	}

}

ExtraRay.prototype.isRay = true;

let _object3DId = 0;

const _v1$2 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position = /*@__PURE__*/ new Vector3();
const _scale = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

class Basic3D extends EventDispatcher {

	constructor() {

		super();

		this.isObject3D = true;

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );
		this.uuid = MathUtils.generateUUID();
		
	    this.isRay = true;
	    this.matrix = new Matrix4();
	    this.matrixWorld = new Matrix4();
		
		this.name = '';
		this.type = 'Object3D';

		this.children = [];
		this.parent = null;
		
		
		this.position = new Vector3();
		this.quaternion = new Quaternion();
		this.scale = new Vector3( 1, 1, 1 );

		this.isKinematic = false;
		
		this.matrixAutoUpdate = false;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;
		this.isVisible = true;

		//this.castShadow = false;
		//this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		//this.animations = [];

		this.userData = {};

		
		this.shapetype = 'box';
		this.size = [1,1,1];
		//this.data = {}
		//this._size = new Vector3(1,1,1)
		this.velocity = new Vector3();
		this.angular = new Vector3();
		this.defMat = false;
		this.actif = false;
		this.auto = false;
		this.sleep = false;
		// only for high mesh
		this.mesh = null;
		// if object is link by joint
		this.linked = [];

	}

	// ADD

	select ( b ) {

    }

    dispose () {

    	this.traverse( function ( node ) {
			if( node.isMesh && node.unic ) node.geometry.dispose();
		});

		this.children = [];

    }

	/*set size( value ){
		this._size.fromArray( value )
	}

	get size(){
		return this._size.toArray()
	}*/

	set receiveShadow( value ){
		this.traverse( function ( node ) {
			if( node.isMesh ) node.receiveShadow = value;
		});
	}

	get receiveShadow(){
		if( this.children[0] ) return this.children[0].receiveShadow;
		else return false
	}

	set castShadow( value ){
		this.traverse( function ( node ) {
			if( node.isMesh ) node.castShadow = value;
		});
	}

	get castShadow(){
		if( this.children[0] ) return this.children[0].castShadow;
		else return false
	}

	set material( value ){
		this.traverse( function ( node ) {
			if( node.isMesh ) node.material = value;
		});
	}

	get material(){
		this.children;
		if( this.children[0] ) return this.children[0].material;
		else return null
	}

    //////


	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$2.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$2.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		return vector.applyMatrix4( _m1.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1.lookAt( _position, _target, this.up );

		} else {

			_m1.lookAt( _target, _position, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1 );

		if ( parent ) {

			_m1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		const children = this.children;
		let i = children.length;

		while( i-- ){
		//for ( let i = 0; i < this.children.length; i ++ ) {

			const object = children[ i ];
			object.parent = null;
			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform
		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		const children = this.children;
		let i = children.length;

		while( i-- ){
		//for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, target, _scale );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, _quaternion, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	setRaycast(v){
		if( v !== undefined ) this.isRay = v;
		if(!this.isRay){
			let i =  this.children.length;
			while( i-- ) this.children[i].raycast = () => {};
		}
	}

	// direct raycast avoid recursive !!
	raycast( raycaster, intersects ) {

		if( !this.isRay ) return

		const children = this.children;
		let i = children.length;

		while( i-- ){

			if ( children[i].layers.test( raycaster.layers ) ) {

				children[i].raycast( raycaster, intersects );

			}

		}
	}

	traverse( callback ) {

		callback( this );

		const children = this.children;
		let i = children.length;

		//for ( let i = 0, l = children.length; i < l; i ++ ) {
		while( i-- ){

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;
		let i = children.length;

		//for ( let i = 0, l = children.length; i < l; i ++ ) {
		while( i-- ){

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	/*setTransform( p, q, s ) {

		this.position.fromArray( p )
		this.quaternion.fromArray( q )

		this.matrix.copy( m );
		this.matrix.decompose( this.position, this.quaternion, this.scale );
		this.matrixWorldNeedsUpdate = true;

	}

	setColor( color ) {

		if( this.isInstance ){
		    this.instance.setColorAt( this.instanceId, color );
		}
		
	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );
	    this.matrixWorldNeedsUpdate = true;

		if( this.isInstance ) {
			this.instance.setTransformAt( this.instanceId, this.position.toArray(), this.quaternion.toArray(), this.size )
			return;
		} else {
			
		}

		

		//if( this.isInstance ) this.instance.setMatrixAt( this.instanceId, this.matrix );
		//else this.matrixWorldNeedsUpdate = true;

	}*/

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );
		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;
		let i = children.length;

		while( i-- ){
		//for ( let i = 0, l = children.length; i < l; i ++ ) {
			children[ i ].updateMatrixWorld( force );

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;
			let i = children.length;

			while( i-- ){
			//for ( let i = 0, l = children.length; i < l; i ++ ) {
				children[ i ].updateWorldMatrix( false, true );

			}

		}

	}

}

class Instance extends InstancedMesh {

	constructor( geometry, material, count = 0 ) {

        super( geometry, material, count );

        //this.instanceMatrix = null;
        this.matrixAutoUpdate = false; 
        this.tmpMatrix = new Matrix4();
        this.tmpQuat = new Quaternion();

        //this.instanceUv = null;

        this.needSphereUp = false;

        this.isRay = true; 
        
    }

    getInfo( id )
    {
        this.tmpMatrix.fromArray( this.instanceMatrix.array, id*16 );
        let pos = {x:0, y:0, z:0 };
        let scale = { x:0, y:0, z:0 };
        this.tmpMatrix.decompose( pos, this.tmpQuat, scale );
        return {
            pos:[pos.x, pos.y, pos.z],
            quat:this.tmpQuat.toArray(),
            scale:[scale.x, scale.y, scale.z],
            //worldMatrix:this.tmpMatrix.toArray(),
        }
    }

    add( position = [0,0,0], rotation = [0,0,0,1], scale = [1,1,1], color = null, uv = null )
    {
        if( rotation.length === 3 ) rotation = this.tmpQuat.setFromEuler( {_x:rotation[0], _y:rotation[1], _z:rotation[2], _order:'XYZ'}, false ).toArray();
        if(color){ 
            if( color.isColor ) color = color.toArray();
            if ( this.instanceColor === null ) this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );
        }
        /*if(uv){ 
            if( uv.isVector2 ) uv = uv.toArray()
            if ( this.instanceUv === null ) this.instanceUv = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 2 ), 2 );
        }*/
        this.expand( position, rotation, scale, color, uv );
    }

    setColorAt( index, color ) {

        if ( this.instanceColor === null ) {

            this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );

        }
        if( color.isColor ) color = color.toArray();
        
        let id = index * 3;
        this.instanceColor.array[id] = color[0];
        this.instanceColor.array[id +1] = color[1];
        this.instanceColor.array[id +2] = color[2];
        //color.toArray( this.instanceColor.array, index * 3 );

    }

    /*setUvAt( index, uv ) {

        if ( this.instanceUv === null ) this.instanceUv = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 2 ), 2 );
        
        if( uv.isVector2 ) uv = uv.toArray()
        let id = index * 2
        this.instanceUv.array[id] = uv[0]
        this.instanceUv.array[id +1] = uv[1]

    }*/

    remove( id ) {

        if(!this.count) return;
        let old = [...this.instanceMatrix.array];
        old.splice( id*16, 16 );
        this.instanceMatrix = new InstancedBufferAttribute( new Float32Array(old), 16 );

        if ( this.instanceColor !== null ) {
            old = [...this.instanceColor.array];
            old.splice( id*3, 3 );
            this.instanceColor = new InstancedBufferAttribute( new Float32Array(old), 3 );
        }

        if ( this.instanceUv !== null ) {
            old = [...this.instanceUv.array];
            old.splice( id*2, 2 );
            this.instanceUv = new InstancedBufferAttribute( new Float32Array(old), 2 );
        }
        this.count --;
    }

    expand( p, q, s, c = [1,1,1], uv ) {

        let old = this.instanceMatrix !== null ? this.instanceMatrix.array : [];
        this.tmpMatrix.compose({x:p[0], y:p[1], z:p[2]}, {_x:q[0], _y:q[1], _z:q[2], _w:q[3]}, {x:s[0], y:s[1], z:s[2]});
        this.instanceMatrix = new InstancedBufferAttribute( new Float32Array([...old, ...this.tmpMatrix.toArray()]), 16 );
        //this.instanceMatrix.setUsage( DynamicDrawUsage );
        if ( this.instanceColor !== null ) {
            old = this.instanceColor.array;
            this.instanceColor = new InstancedBufferAttribute( new Float32Array([...old, ...c ]), 3 );
        }
       /* if ( this.instanceUv !== null ) {
            old = this.instanceUv.array;
            this.instanceUv = new InstancedBufferAttribute( new Float32Array([...old, ...uv ]), 2 );
        }*/
        this.count ++;
    }

    setTransformAt( index, p, q, s ) {
        this.tmpMatrix.compose({x:p[0], y:p[1], z:p[2]}, {_x:q[0], _y:q[1], _z:q[2], _w:q[3]}, {x:s[0], y:s[1], z:s[2]});
        this.tmpMatrix.toArray( this.instanceMatrix.array, index * 16 );
        this.needSphereUp = true;
    }

    dispose() {
        this.parent.remove(this);
        this.geometry.dispose();
        //this.instanceMatrix = null;
        this.instanceColor = null;
        this.count = 0;
        //console.log(this.name+" is dispose")
        this.dispatchEvent( { type: 'dispose' } );

    }

    setRaycast(v){
        if( v !== undefined ) this.isRay = v;
    }

    raycast( raycaster, intersects ) {
        if(!this.isRay) return
        super.raycast( raycaster, intersects );
    }

    update(){
        if( this.needSphereUp ) this.computeBoundingSphere();
        if( this.instanceMatrix ) this.instanceMatrix.needsUpdate = true;
        if( this.instanceColor ) this.instanceColor.needsUpdate = true;
        //if( this.instanceUv ) this.instanceUv.needsUpdate = true;
        this.needSphereUp = false;
    }

}

/**
* SPHERE BOX GEOMETRY
*/
class SphereBox extends BufferGeometry {

    constructor( radius=1, widthSegs=10, heightSegs=10, depthSegs=10, roundness=1 ) {

        super();

        this.type = 'SphereBox';
        this.name = 'SphereBox_' + radius +'_'+widthSegs+'_'+heightSegs+'_'+depthSegs+'_'+roundness;

        radius = radius || 1;

        // segments

        widthSegs = Math.floor( widthSegs );
        heightSegs = Math.floor( heightSegs );
        depthSegs = Math.floor( depthSegs );        
        let g = new BoxGeometry( 1,1,1, widthSegs, heightSegs, depthSegs ), v = new Vector3(), r = new Vector3(), n;

        let ar = g.attributes.position.array;
        let nm = g.attributes.normal.array;

        for ( let i = 0, l = g.attributes.position.count; i < l; i ++ ) {

            n = i*3;
            v.set( ar[n], ar[n+1], ar[n+2] );
            r.copy( v ).normalize();

            v.lerp( r, roundness ).multiplyScalar( radius );

            ar[n] = v.x;
            ar[n+1] = v.y;
            ar[n+2] = v.z;

            v.normalize();

            nm[n] = v.x;
            nm[n+1] = v.y;
            nm[n+2] = v.z;
            
        }

        this.copy(g);

    }
}

/**
* CAPSULE GEOMETRY
*/
class Capsule extends BufferGeometry {

    constructor( radius = 1, height = 1, radialSegs = 12, heightSegs = 1 ) {

        super();

    	this.type = 'CapsuleGeometry';
        //this.name = 'Capsule_' + radius +'_'+height+'_'+radialSegs+'_'+heightSegs;

        let pi = Math.PI;

        let th = (radius*2) + height;
        let sy = radius / th;
        let hy = 1 - (2*sy);

        radialSegs = Math.floor( radialSegs );
        heightSegs = Math.floor( heightSegs );

        let sHeight = Math.floor( radialSegs * 0.5 );
        let o0 = Math.PI * 2;
        let o1 = Math.PI * 0.5;
        let m0 = new CylinderGeometry( radius, radius, height, radialSegs, heightSegs, true );
        //let m0 = new CylinderGeometryFix2( radius, radius, height, radialSegs, heightSegs, true );
        //let m0 = new CylinderGeometry( radius, radius, height, radialSegs, heightSegs, true );
        scaleUV( m0, 0, sy, 1, hy );
        let m1 = new SphereGeometry( radius, radialSegs, sHeight, 0, o0, 0, o1);
        scaleUV( m1, 0, 1-sy, 1, sy );
        let m2 = new SphereGeometry( radius, radialSegs, sHeight, 0, o0, o1, o1);
        scaleUV( m2, 0, 0, 1, sy );
        let mtx0 = new Matrix4().makeRotationY( -pi*0.5 );
        let mtx1 = new Matrix4().makeTranslation(0, height*0.5,0);
        let mtx2 = new Matrix4().makeTranslation(0, -height*0.5,0);
        m0.applyMatrix4( mtx0 );
        m1.applyMatrix4( mtx1 );
        m2.applyMatrix4( mtx2 );


        let g = mergeVertices( mergeGeometries( [ m0, m1, m2] ) );
        this.copy( g );

        /*m0.dispose()
        m1.dispose()
        m2.dispose()
        g.dispose()*/

    }
}


/**
* TORUS EXTRA GEOMETRY
*/
class TorusGeometryFix extends BufferGeometry {

    constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc= Math.PI * 2, thetaStart=0, thetaLength=Math.PI ) {

        super();

        this.type = 'TorusGeometryFix';

        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };

        radialSegments = Math.floor( radialSegments );
        tubularSegments = Math.floor( tubularSegments );

        // buffers

        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];

        // helper variables

        const center = new Vector3();
        const vertex = new Vector3();
        const normal = new Vector3();

        let j, i;

        // generate vertices, normals and uvs

        for ( j = 0; j <= radialSegments; j ++ ) {

            for ( i = 0; i <= tubularSegments; i ++ ) {

                const u = i / tubularSegments * arc;
                //const v = j / radialSegments * Math.PI * 2;

                const v = (j / radialSegments) * thetaLength + thetaStart;

                // vertex

                vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
                vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
                vertex.z = tube * Math.sin( v );

                vertices.push( vertex.x, vertex.y, vertex.z );

                // normal

                center.x = radius * Math.cos( u );
                center.y = radius * Math.sin( u );
                normal.subVectors( vertex, center ).normalize();

                normals.push( normal.x, normal.y, normal.z );

                // uv

                uvs.push( i / tubularSegments );
                uvs.push( j / radialSegments );

            }

        }

        // generate indices

        for ( j = 1; j <= radialSegments; j ++ ) {

            for ( i = 1; i <= tubularSegments; i ++ ) {

                // indices

                const a = ( tubularSegments + 1 ) * j + i - 1;
                const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
                const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
                const d = ( tubularSegments + 1 ) * j + i;

                // faces

                indices.push( a, b, d );
                indices.push( b, c, d );

            }

        }

        // build geometry

        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    }
}


/**
* CHAMFER CYLINDRE GEOMETRY
*/
class ChamferCyl extends BufferGeometry {

    constructor( radiusTop = 1, radiusBottom = 1, height = 1, filet =0.01, radialSegs = 12, heightSegs = 1, filetSegs = 2 ) {

        super();

        this.type = 'ChamferCyl';
        //this.name = 'ChamferCyl_' + radiusTop +'_'+radiusBottom+'_'+height+'_'+filet+'_'+radialSegs+'_'+heightSegs+'_'+filetSegs;

        radialSegs = Math.floor( radialSegs );
        heightSegs = Math.floor( heightSegs );
        filetSegs = Math.floor( filetSegs );

        let mr = new Matrix4();
        let mt = new Matrix4();

        let pi = Math.PI;
        let p90 = pi * 0.5;
        let twoPi = pi * 2;

        let start = 0;//(twoPi / radialSegs)*(3/radialSegs)//;

        let th = height;
        let sy = filet / th;
        let hy = 1 - (2*sy);
        //console.log(start)

        //let mid = new CylinderGeometryFix( radiusBottom, radiusTop, height-(filet*2), radialSegs, heightSegs, true, start );
        let mid = new CylinderGeometry( radiusTop, radiusBottom, height-(filet*2), radialSegs, heightSegs, true, start );
        mr.makeRotationY( p90 );
        mid.applyMatrix4( mr );

        scaleUV( mid, 0, sy, 1, hy );

        // top
        let c1 = new TorusGeometryFix( radiusTop-filet, filet, filetSegs, radialSegs, twoPi, 0, p90 );
        let c2 = new CircleGeometry( radiusTop-filet, radialSegs );

        mt.makeTranslation( 0,0, filet );
        c2.applyMatrix4( mt );

        scaleUV( c1, 0, 1-sy, 1, sy );

        let top = mergeGeometries( [ c1, c2 ] );

        mr.makeTranslation( 0,0,( (height*0.5) - filet) );
        mt.makeRotationX( -p90 );

        top.applyMatrix4( mt.multiply(mr) );

        /*c1.dispose();
        c2.dispose();*/

        // bottom
        c1 = new TorusGeometryFix( radiusBottom-filet, filet, filetSegs, radialSegs, twoPi, 0, p90 );
        c2 = new CircleGeometry( radiusBottom-filet, radialSegs );

        mt.makeTranslation( 0,0, filet );
        c2.applyMatrix4( mt );

        scaleUV( c1, 0, 1-sy, 1, sy, true );

        let low = mergeGeometries( [ c1, c2 ] );

        mr.makeTranslation( 0,0,( (height*0.5) - filet) );
        mt.makeRotationX( p90 );
        low.applyMatrix4( mt.multiply(mr) );

        /*c1.dispose();
        c2.dispose();*/

        let g = mergeVertices( mergeGeometries( [ top, mid, low ] ) );

        /*mid.dispose();
        top.dispose();
        low.dispose();*/

        this.copy(g);
        //g.dispose();

    }
}

//ChamferCyl.prototype = Object.create( THREE.BufferGeometry.prototype );

/**
* CHAMFER BOX GEOMETRY
*/
class ChamferBox extends BufferGeometry {

    constructor( width  = 1, height = 1, depth = 1, filet = 0.01, widthSegs = 1, heightSegs = 1, depthSegs = 1, filetSegs = 2 ) {

        super();

        this.type = 'ChamferBox';
        //this.name = 'ChamferBox_' + width +'_'+height+'_'+depth+'_'+filet+'_'+widthSegs+'_'+heightSegs+'_'+depthSegs+'_'+filetSegs;

        widthSegs = Math.floor( widthSegs );
        heightSegs = Math.floor( heightSegs );
        depthSegs = Math.floor( depthSegs );
        filetSegs = Math.floor( filetSegs );

        let pi = Math.PI;
        let p90 = pi * 0.5;
        let twoFilet = filet * 2;

        let midWidth = width * 0.5;
        let midHeight = height * 0.5;
        let midDepth = depth * 0.5;

        let mr = new Matrix4();
        let mt = new Matrix4();
        let mp = new Matrix4();

        // uv calc

        let tw = width;
        let sw = filet / tw;
        let vw = 1 - (2*sw);

        let th = height;
        let sh = filet / th;
        let vh = 1 - (2*sw);

        let td = depth;
        let sd = filet / td;
        let vd = 1 - (2*sd);

        let f = new PlaneGeometry( width-twoFilet, height-twoFilet, widthSegs, heightSegs );
        let c1 = new CylinderGeometry( filet, filet, width-twoFilet, filetSegs, widthSegs, true, 0, p90 );
        let c2 = new CylinderGeometry( filet, filet, height-twoFilet, filetSegs, heightSegs, true, 0, p90 );
        let s1 = new SphereGeometryFix( filet, filetSegs, filetSegs, 0, p90, 0, -p90 );
        let s2 = new SphereGeometryFix( filet, filetSegs, filetSegs, 0, p90, 0, -p90 );

        scaleUV( f, -sw, sh, vw, vh );
        scaleUV( c1, 0, sw, sh, vw );
       //scaleUV( c2, 0, -sw, vw, sw )

        mt.makeTranslation( 0, midHeight - filet, 0 );
        mr.makeRotationX( p90 );
        s1.applyMatrix4( mt.multiply(mr) );

        mt.makeTranslation( 0, -midHeight + filet, 0 );
        mr.makeRotationX( p90 );
        mp.makeRotationY( -p90 );
        s2.applyMatrix4( mt.multiply(mr).multiply(mp) );

        let tra = mergeGeometries( [ c2, s1, s2 ] );
        let trc = tra.clone();

        /*c2.dispose();
        s1.dispose();
        s2.dispose();*/
        
        mt.makeTranslation( midWidth - filet, 0, -filet );

        tra.applyMatrix4( mt );

        mt.makeTranslation( -midWidth + filet, 0, -filet );
        mr.makeRotationZ( pi );

        trc.applyMatrix4( mt.multiply(mr) );

        // cylinder

        let c3 = c1.clone();

        mr.makeRotationZ( p90 );
        mt.makeTranslation( 0, midHeight - filet, -filet );
        c1.applyMatrix4( mt.multiply(mr) );
        mt.makeTranslation( 0, -midHeight + filet, -filet );
        mr.makeRotationZ( -p90 );
        c3.applyMatrix4( mt.multiply(mr) );

        let rf = mergeGeometries( [ c1, c3, f, tra, trc ] );
        let rg = rf.clone();

        mt.makeTranslation( 0, 0, midDepth );
        rf.applyMatrix4( mt );

        mt.makeTranslation( 0, 0, -midDepth );
        mr.makeRotationY( pi );
        rg.applyMatrix4( mt.multiply(mr) );

        // side left

        /*f.dispose();
        c1.dispose();
        c3.dispose();*/

        f = new PlaneGeometry( depth-twoFilet, height-twoFilet, depthSegs, heightSegs );
        c1 = new CylinderGeometry( filet, filet, depth-twoFilet, filetSegs, depthSegs, true, 0, p90 );
        c3 = c1.clone();

        scaleUV( f, -sd, sh, vd, vh );

        mt.makeTranslation( 0, -(midHeight - filet), -filet, 0 );
        mr.makeRotationZ( -p90 );

        c1.applyMatrix4( mt.multiply(mr) );

        mt.makeTranslation( 0, midHeight - filet, -filet, 0 );
        mr.makeRotationZ( p90 );

        c3.applyMatrix4( mt.multiply(mr) );


        let rr = mergeGeometries( [ c1, c3, f ] );
        let rb = rr.clone();

        /*f.dispose();
        c1.dispose();
        c3.dispose()*/

        mt.makeTranslation( -midWidth, 0, 0 );
        mr.makeRotationY( -p90 );

        rr.applyMatrix4( mt.multiply(mr) );

        // side right

        mt.makeTranslation( midWidth, 0, 0 );
        mr.makeRotationY( p90 );

        rb.applyMatrix4( mt.multiply(mr) );

        // top
        f = new PlaneGeometry( width-twoFilet, depth-twoFilet, widthSegs, depthSegs );
        scaleUV( f, -sw, sd, vw, vd );
        let f2 = f.clone();



        mt.makeTranslation( 0, midHeight, 0);
        mr.makeRotationX( -p90 );
        f.applyMatrix4( mt.multiply(mr) );

        // bottom
        mt.makeTranslation( 0, -midHeight, 0);
        mr.makeRotationX( p90 );
        f2.applyMatrix4( mt.multiply(mr) );

        let g = mergeVertices( mergeGeometries( [ rf, rg, rr, rb, f, f2 ] ) );

        /*rf.dispose();
        rg.dispose();
        rr.dispose();
        rb.dispose();
        f2.dispose();
        f.dispose();*/
        //g.computeVertexNormals()
        //g = g.toNonIndexed()
        //

        createUV(g, 'box');

        this.copy(g);
        /*g.dispose();*/

    }
}

class SphereGeometryFix extends BufferGeometry {

    constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

        super();

        this.type = 'SphereGeometryFix';

        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        widthSegments =  Math.floor( widthSegments );
        heightSegments =  Math.floor( heightSegments );

        const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

        let index = 0;
        const grid = [];

        const vertex = new Vector3();
        const normal = new Vector3();

        // buffers

        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];

        // generate vertices, normals and uvs

        for ( let iy = 0; iy <= heightSegments; iy ++ ) {

            const verticesRow = [];

            const v = iy / heightSegments;

            // special case for the poles

            let uOffset = 0;

            if ( iy == 0 && thetaStart == 0 ) {

                uOffset = 0.5 / widthSegments;

            } else if ( iy == heightSegments && thetaEnd == Math.PI ) {

                uOffset = - 0.5 / widthSegments;

            }

            for ( let ix = 0; ix <= widthSegments; ix ++ ) {

                const u = ix / widthSegments;

                // vertex

                vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
                vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
                vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

                vertices.push( vertex.x, vertex.y, vertex.z );

                // normal

                normal.copy( vertex ).normalize();
                normals.push( normal.x, normal.y, normal.z );

                // uv

                uvs.push( u + uOffset, 1 - v );

                verticesRow.push( index ++ );

            }

            grid.push( verticesRow );

        }

        // indices

        for ( let iy = 0; iy < heightSegments; iy ++ ) {

            for ( let ix = 0; ix < widthSegments; ix ++ ) {

                const a = grid[ iy ][ ix + 1 ];
                const b = grid[ iy ][ ix ];
                const c = grid[ iy + 1 ][ ix ];
                const d = grid[ iy + 1 ][ ix + 1 ];

                if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
                if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

            }

        }

        // build geometry

        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

    }

}

// { SphereGeometryFix };


// UV 

function scaleUV( geometry, x=0, y=0, dx=1, dy=1, reverse ) {

    let uv = geometry.attributes.uv;
    let ar = uv.array;
    let i = uv.count, n =0;

    while( i-- ){
        n=i*2;
        ar[n] = (ar[n]*dx)-x;
        ar[n+1] = (ar[n+1]*dy)+y;

        if(reverse){
            ar[n] = 1 - ar[n];
            ar[n+1] = 1 - ar[n+1];
        }
    }


}

function createUV( geometry, type = 'sphere', boxSize, pos = [0,0,0], quat = [0,0,0,1], transformMatrix ) {

    //type = type || 'sphere';

    if ( transformMatrix === undefined ) transformMatrix = new Matrix4();
    transformMatrix.compose( {x:pos[0], y:pos[1], z:pos[2] }, { _x:quat[0], _y:quat[1], _z:quat[2], _w:quat[3] }, {x:1, y:1, z:1 });



    if ( boxSize === undefined ) {
        if( !geometry.boundingBox ) geometry.computeBoundingBox();
        let bbox = geometry.boundingBox;
        boxSize = Math.max( bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y, bbox.max.z - bbox.min.z );
    }

    //.expandByScalar(0.9);//new THREE.Box3( new THREE.Vector3(-boxSize / 2, -boxSize / 2, -boxSize / 2), new THREE.Vector3(boxSize / 2, boxSize / 2, boxSize / 2));
    //_applyBoxUV( bufferGeometry, transformMatrix, uvBbox, boxSize );

    let uvBbox = new Box3(new Vector3(-boxSize / 2, -boxSize / 2, -boxSize / 2), new Vector3(boxSize / 2, boxSize / 2, boxSize / 2));
    //let uvBbox = bbox
    


    let coords = [];
    //coords.length = 2 * geometry.attributes.position.array.length / 3;
    coords.length = 2 * geometry.attributes.position.count;

    //if ( geometry.attributes.uv === undefined ) geometry.addAttribute('uv', new Float32BufferAttribute(coords, 2));
    if ( geometry.attributes.uv === undefined ) geometry.setAttribute('uv', new Float32BufferAttribute(coords, 2));
    
    let makeSphereUVs = function( v0, v1, v2 ) {

        //pre-rotate the model so that cube sides match world axis
        v0.applyMatrix4(transformMatrix);
        v1.applyMatrix4(transformMatrix);
        v2.applyMatrix4(transformMatrix);

        let invTwoPi = 1 / (2.0 * Math.PI);
        let invPi = 1 / Math.PI;

        v0.normalize();
        v1.normalize();
        v2.normalize();

        return {
            uv0: new Vector2( .5 - Math.atan( v0.z, - v0.x ) * invTwoPi, .5 - Math.asin( v0.y ) * invPi ),
            uv1: new Vector2( .5 - Math.atan( v1.z, - v1.x ) * invTwoPi, .5 - Math.asin( v1.y ) * invPi ),
            uv2: new Vector2( .5 - Math.atan( v2.z, - v2.x ) * invTwoPi, .5 - Math.asin( v2.y ) * invPi ),
        };

    };


  
    //maps 3 verts of 1 face on the better side of the cube
    //side of the cube can be XY, XZ or YZ
    let makeCubeUVs = function( v0, v1, v2 ) {

        //pre-rotate the model so that cube sides match world axis
        v0.applyMatrix4(transformMatrix);
        v1.applyMatrix4(transformMatrix);
        v2.applyMatrix4(transformMatrix);

        //get normal of the face, to know into which cube side it maps better
        let n = new Vector3();
        n.crossVectors( v1.clone().sub(v0), v1.clone().sub(v2) ).normalize();
        if(n.x<0 || n.y<0 || n.z<0) ;

        n.x = Math.abs(n.x);
        n.y = Math.abs(n.y);
        n.z = Math.abs(n.z);

        let uv0 = new Vector2();
        let uv1 = new Vector2();
        let uv2 = new Vector2();
        let max = 1/boxSize;

        
        // xz mapping
        if ( n.y > n.x && n.y > n.z ) {

            uv0.set( v0.x - uvBbox.min.x, uvBbox.max.z - v0.z ).multiplyScalar( max );
            uv1.set( v1.x - uvBbox.min.x, uvBbox.max.z - v1.z ).multiplyScalar( max );
            uv2.set( v2.x - uvBbox.min.x, uvBbox.max.z - v2.z ).multiplyScalar( max );

        } else if ( n.x > n.y && n.x > n.z ) {

            uv0.set( v0.z - uvBbox.min.z, v0.y - uvBbox.min.y ).multiplyScalar( max );
            uv1.set( v1.z - uvBbox.min.z, v1.y - uvBbox.min.y ).multiplyScalar( max );
            uv2.set( v2.z - uvBbox.min.z, v2.y - uvBbox.min.y ).multiplyScalar( max );

        } else if ( n.z > n.y && n.z > n.x ) {

            uv0.set( v0.x - uvBbox.min.x, v0.y - uvBbox.min.y ).multiplyScalar( max );
            uv1.set( v1.x - uvBbox.min.x, v1.y - uvBbox.min.y ).multiplyScalar( max );
            uv2.set( v2.x - uvBbox.min.x, v2.y - uvBbox.min.y ).multiplyScalar( max );

        }

        return { uv0: uv0, uv1: uv1, uv2: uv2 } 
    };



    let i, id0, id1, id2, uvs;
    let v0 = new Vector3();
    let v1 = new Vector3();
    let v2 = new Vector3();

    new Vector3();
    new Vector3();
    new Vector3();

    const positionAttribute = geometry.getAttribute( 'position' );
    geometry.getAttribute( 'normal' );

    if ( geometry.index ) { // is it indexed buffer geometry

        for (i = 0; i < geometry.index.count; i+=3 ) {

            //console.log('is index')

            //n = i*3;
            id0 = geometry.index.getX( i + 0 );
            id1 = geometry.index.getX( i + 1 );
            id2 = geometry.index.getX( i + 2 );

            v0.fromBufferAttribute( positionAttribute, id0 );
            v1.fromBufferAttribute( positionAttribute, id1 );
            v2.fromBufferAttribute( positionAttribute, id2 );

            /*nn0.fromBufferAttribute( normalAttribute, id0 );
            nn1.fromBufferAttribute( normalAttribute, id1 );
            nn2.fromBufferAttribute( normalAttribute, id2 )*/



            if( type === 'sphere' ) uvs = makeSphereUVs( v0, v1, v2 );
            else uvs = makeCubeUVs( v0, v1, v2);

            coords[2 * id0] = uvs.uv0.x;
            coords[2 * id0 + 1] = uvs.uv0.y;

            coords[2 * id1] = uvs.uv1.x;
            coords[2 * id1 + 1] = uvs.uv1.y;

            coords[2 * id2] = uvs.uv2.x;
            coords[2 * id2 + 1] = uvs.uv2.y;
        }
    } else {

        for ( i = 0; i < positionAttribute.count; i += 3) {

            v0.fromBufferAttribute( positionAttribute, i + 0 );
            v1.fromBufferAttribute( positionAttribute, i + 1 );
            v2.fromBufferAttribute( positionAttribute, i + 2 );

            if( type === 'sphere' ) uvs = makeSphereUVs( v0, v1, v2 );
            else uvs = makeCubeUVs( v0, v1, v2 );

            let idx0 = i;//vi / 3;
            let idx1 = i+1;//idx0 + 1;
            let idx2 = i+2;//idx0 + 2;

            coords[2 * idx0] = uvs.uv0.x;
            coords[2 * idx0 + 1] = uvs.uv0.y;

            coords[2 * idx1] = uvs.uv1.x;
            coords[2 * idx1 + 1] = uvs.uv1.y;

            coords[2 * idx2] = uvs.uv2.x;
            coords[2 * idx2 + 1] = uvs.uv2.y;
        }

    }

    geometry.attributes.uv.array = new Float32Array( coords );
    geometry.attributes.uv.needsUpdate = true;

}

/**
 * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)
 */

const Visible = 0;
const Deleted = 1;

const _v1$1 = new Vector3();
const _line3 = new Line3();
const _plane = new Plane();
const _closestPoint = new Vector3();
const _triangle = new Triangle();

class ConvexHull {

	constructor() {

		this.tolerance = - 1;

		this.faces = []; // the generated faces of the convex hull
		this.newFaces = []; // this array holds the faces that are generated within a single iteration

		// the vertex lists work as follows:
		//
		// let 'a' and 'b' be 'Face' instances
		// let 'v' be points wrapped as instance of 'Vertex'
		//
		//     [v, v, ..., v, v, v, ...]
		//      ^             ^
		//      |             |
		//  a.outside     b.outside
		//
		this.assigned = new VertexList();
		this.unassigned = new VertexList();

		this.vertices = []; 	// vertices of the hull (internal representation of given geometry data)

	}

	setFromPoints( points ) {

		// The algorithm needs at least four points.

		if ( points.length >= 4 ) {

			this.makeEmpty();

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				this.vertices.push( new VertexNode( points[ i ] ) );

			}

			this.compute();

		}

		return this;

	}

	setFromObject( object ) {

		const points = [];

		object.updateMatrixWorld( true );

		object.traverse( function ( node ) {

			const geometry = node.geometry;

			if ( geometry !== undefined ) {

				const attribute = geometry.attributes.position;

				if ( attribute !== undefined ) {

					for ( let i = 0, l = attribute.count; i < l; i ++ ) {

						const point = new Vector3();

						point.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

						points.push( point );

					}

				}

			}

		} );

		return this.setFromPoints( points );

	}

	containsPoint( point ) {

		const faces = this.faces;

		for ( let i = 0, l = faces.length; i < l; i ++ ) {

			const face = faces[ i ];

			// compute signed distance and check on what half space the point lies

			if ( face.distanceToPoint( point ) > this.tolerance ) return false;

		}

		return true;

	}

	intersectRay( ray, target ) {

		// based on "Fast Ray-Convex Polyhedron Intersection" by Eric Haines, GRAPHICS GEMS II

		const faces = this.faces;

		let tNear = - Infinity;
		let tFar = Infinity;

		for ( let i = 0, l = faces.length; i < l; i ++ ) {

			const face = faces[ i ];

			// interpret faces as planes for the further computation

			const vN = face.distanceToPoint( ray.origin );
			const vD = face.normal.dot( ray.direction );

			// if the origin is on the positive side of a plane (so the plane can "see" the origin) and
			// the ray is turned away or parallel to the plane, there is no intersection

			if ( vN > 0 && vD >= 0 ) return null;

			// compute the distance from the ray’s origin to the intersection with the plane

			const t = ( vD !== 0 ) ? ( - vN / vD ) : 0;

			// only proceed if the distance is positive. a negative distance means the intersection point
			// lies "behind" the origin

			if ( t <= 0 ) continue;

			// now categorized plane as front-facing or back-facing

			if ( vD > 0 ) {

				// plane faces away from the ray, so this plane is a back-face

				tFar = Math.min( t, tFar );

			} else {

				// front-face

				tNear = Math.max( t, tNear );

			}

			if ( tNear > tFar ) {

				// if tNear ever is greater than tFar, the ray must miss the convex hull

				return null;

			}

		}

		// evaluate intersection point

		// always try tNear first since its the closer intersection point

		if ( tNear !== - Infinity ) {

			ray.at( tNear, target );

		} else {

			ray.at( tFar, target );

		}

		return target;

	}

	intersectsRay( ray ) {

		return this.intersectRay( ray, _v1$1 ) !== null;

	}

	makeEmpty() {

		this.faces = [];
		this.vertices = [];

		return this;

	}

	// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face

	addVertexToFace( vertex, face ) {

		vertex.face = face;

		if ( face.outside === null ) {

			this.assigned.append( vertex );

		} else {

			this.assigned.insertBefore( face.outside, vertex );

		}

		face.outside = vertex;

		return this;

	}

	// Removes a vertex from the 'assigned' list of vertices and from the given face

	removeVertexFromFace( vertex, face ) {

		if ( vertex === face.outside ) {

			// fix face.outside link

			if ( vertex.next !== null && vertex.next.face === face ) {

				// face has at least 2 outside vertices, move the 'outside' reference

				face.outside = vertex.next;

			} else {

				// vertex was the only outside vertex that face had

				face.outside = null;

			}

		}

		this.assigned.remove( vertex );

		return this;

	}

	// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list

	removeAllVerticesFromFace( face ) {

		if ( face.outside !== null ) {

			// reference to the first and last vertex of this face

			const start = face.outside;
			let end = face.outside;

			while ( end.next !== null && end.next.face === face ) {

				end = end.next;

			}

			this.assigned.removeSubList( start, end );

			// fix references

			start.prev = end.next = null;
			face.outside = null;

			return start;

		}

	}

	// Removes all the visible vertices that 'face' is able to see

	deleteFaceVertices( face, absorbingFace ) {

		const faceVertices = this.removeAllVerticesFromFace( face );

		if ( faceVertices !== undefined ) {

			if ( absorbingFace === undefined ) {

				// mark the vertices to be reassigned to some other face

				this.unassigned.appendChain( faceVertices );


			} else {

				// if there's an absorbing face try to assign as many vertices as possible to it

				let vertex = faceVertices;

				do {

					// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference
					// will be changed by upcoming method calls

					const nextVertex = vertex.next;

					const distance = absorbingFace.distanceToPoint( vertex.point );

					// check if 'vertex' is able to see 'absorbingFace'

					if ( distance > this.tolerance ) {

						this.addVertexToFace( vertex, absorbingFace );

					} else {

						this.unassigned.append( vertex );

					}

					// now assign next vertex

					vertex = nextVertex;

				} while ( vertex !== null );

			}

		}

		return this;

	}

	// Reassigns as many vertices as possible from the unassigned list to the new faces

	resolveUnassignedPoints( newFaces ) {

		if ( this.unassigned.isEmpty() === false ) {

			let vertex = this.unassigned.first();

			do {

				// buffer 'next' reference, see .deleteFaceVertices()

				const nextVertex = vertex.next;

				let maxDistance = this.tolerance;

				let maxFace = null;

				for ( let i = 0; i < newFaces.length; i ++ ) {

					const face = newFaces[ i ];

					if ( face.mark === Visible ) {

						const distance = face.distanceToPoint( vertex.point );

						if ( distance > maxDistance ) {

							maxDistance = distance;
							maxFace = face;

						}

						if ( maxDistance > 1000 * this.tolerance ) break;

					}

				}

				// 'maxFace' can be null e.g. if there are identical vertices

				if ( maxFace !== null ) {

					this.addVertexToFace( vertex, maxFace );

				}

				vertex = nextVertex;

			} while ( vertex !== null );

		}

		return this;

	}

	// Computes the extremes of a simplex which will be the initial hull

	computeExtremes() {

		const min = new Vector3();
		const max = new Vector3();

		const minVertices = [];
		const maxVertices = [];

		// initially assume that the first vertex is the min/max

		for ( let i = 0; i < 3; i ++ ) {

			minVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];

		}

		min.copy( this.vertices[ 0 ].point );
		max.copy( this.vertices[ 0 ].point );

		// compute the min/max vertex on all six directions

		for ( let i = 0, l = this.vertices.length; i < l; i ++ ) {

			const vertex = this.vertices[ i ];
			const point = vertex.point;

			// update the min coordinates

			for ( let j = 0; j < 3; j ++ ) {

				if ( point.getComponent( j ) < min.getComponent( j ) ) {

					min.setComponent( j, point.getComponent( j ) );
					minVertices[ j ] = vertex;

				}

			}

			// update the max coordinates

			for ( let j = 0; j < 3; j ++ ) {

				if ( point.getComponent( j ) > max.getComponent( j ) ) {

					max.setComponent( j, point.getComponent( j ) );
					maxVertices[ j ] = vertex;

				}

			}

		}

		// use min/max vectors to compute an optimal epsilon

		this.tolerance = 3 * Number.EPSILON * (
			Math.max( Math.abs( min.x ), Math.abs( max.x ) ) +
			Math.max( Math.abs( min.y ), Math.abs( max.y ) ) +
			Math.max( Math.abs( min.z ), Math.abs( max.z ) )
		);

		return { min: minVertices, max: maxVertices };

	}

	// Computes the initial simplex assigning to its faces all the points
	// that are candidates to form part of the hull

	computeInitialHull() {

		const vertices = this.vertices;
		const extremes = this.computeExtremes();
		const min = extremes.min;
		const max = extremes.max;

		// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation
		// (max.x - min.x)
		// (max.y - min.y)
		// (max.z - min.z)

		let maxDistance = 0;
		let index = 0;

		for ( let i = 0; i < 3; i ++ ) {

			const distance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );

			if ( distance > maxDistance ) {

				maxDistance = distance;
				index = i;

			}

		}

		const v0 = min[ index ];
		const v1 = max[ index ];
		let v2;
		let v3;

		// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'

		maxDistance = 0;
		_line3.set( v0.point, v1.point );

		for ( let i = 0, l = this.vertices.length; i < l; i ++ ) {

			const vertex = vertices[ i ];

			if ( vertex !== v0 && vertex !== v1 ) {

				_line3.closestPointToPoint( vertex.point, true, _closestPoint );

				const distance = _closestPoint.distanceToSquared( vertex.point );

				if ( distance > maxDistance ) {

					maxDistance = distance;
					v2 = vertex;

				}

			}

		}

		// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'

		maxDistance = - 1;
		_plane.setFromCoplanarPoints( v0.point, v1.point, v2.point );

		for ( let i = 0, l = this.vertices.length; i < l; i ++ ) {

			const vertex = vertices[ i ];

			if ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {

				const distance = Math.abs( _plane.distanceToPoint( vertex.point ) );

				if ( distance > maxDistance ) {

					maxDistance = distance;
					v3 = vertex;

				}

			}

		}

		const faces = [];

		if ( _plane.distanceToPoint( v3.point ) < 0 ) {

			// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron

			faces.push(
				Face.create( v0, v1, v2 ),
				Face.create( v3, v1, v0 ),
				Face.create( v3, v2, v1 ),
				Face.create( v3, v0, v2 )
			);

			// set the twin edge

			for ( let i = 0; i < 3; i ++ ) {

				const j = ( i + 1 ) % 3;

				// join face[ i ] i > 0, with the first face

				faces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );

				// join face[ i ] with face[ i + 1 ], 1 <= i <= 3

				faces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );

			}

		} else {

			// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron

			faces.push(
				Face.create( v0, v2, v1 ),
				Face.create( v3, v0, v1 ),
				Face.create( v3, v1, v2 ),
				Face.create( v3, v2, v0 )
			);

			// set the twin edge

			for ( let i = 0; i < 3; i ++ ) {

				const j = ( i + 1 ) % 3;

				// join face[ i ] i > 0, with the first face

				faces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );

				// join face[ i ] with face[ i + 1 ]

				faces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );

			}

		}

		// the initial hull is the tetrahedron

		for ( let i = 0; i < 4; i ++ ) {

			this.faces.push( faces[ i ] );

		}

		// initial assignment of vertices to the faces of the tetrahedron

		for ( let i = 0, l = vertices.length; i < l; i ++ ) {

			const vertex = vertices[ i ];

			if ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {

				maxDistance = this.tolerance;
				let maxFace = null;

				for ( let j = 0; j < 4; j ++ ) {

					const distance = this.faces[ j ].distanceToPoint( vertex.point );

					if ( distance > maxDistance ) {

						maxDistance = distance;
						maxFace = this.faces[ j ];

					}

				}

				if ( maxFace !== null ) {

					this.addVertexToFace( vertex, maxFace );

				}

			}

		}

		return this;

	}

	// Removes inactive faces

	reindexFaces() {

		const activeFaces = [];

		for ( let i = 0; i < this.faces.length; i ++ ) {

			const face = this.faces[ i ];

			if ( face.mark === Visible ) {

				activeFaces.push( face );

			}

		}

		this.faces = activeFaces;

		return this;

	}

	// Finds the next vertex to create faces with the current hull

	nextVertexToAdd() {

		// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'

		if ( this.assigned.isEmpty() === false ) {

			let eyeVertex, maxDistance = 0;

			// grap the first available face and start with the first visible vertex of that face

			const eyeFace = this.assigned.first().face;
			let vertex = eyeFace.outside;

			// now calculate the farthest vertex that face can see

			do {

				const distance = eyeFace.distanceToPoint( vertex.point );

				if ( distance > maxDistance ) {

					maxDistance = distance;
					eyeVertex = vertex;

				}

				vertex = vertex.next;

			} while ( vertex !== null && vertex.face === eyeFace );

			return eyeVertex;

		}

	}

	// Computes a chain of half edges in CCW order called the 'horizon'.
	// For an edge to be part of the horizon it must join a face that can see
	// 'eyePoint' and a face that cannot see 'eyePoint'.

	computeHorizon( eyePoint, crossEdge, face, horizon ) {

		// moves face's vertices to the 'unassigned' vertex list

		this.deleteFaceVertices( face );

		face.mark = Deleted;

		let edge;

		if ( crossEdge === null ) {

			edge = crossEdge = face.getEdge( 0 );

		} else {

			// start from the next edge since 'crossEdge' was already analyzed
			// (actually 'crossEdge.twin' was the edge who called this method recursively)

			edge = crossEdge.next;

		}

		do {

			const twinEdge = edge.twin;
			const oppositeFace = twinEdge.face;

			if ( oppositeFace.mark === Visible ) {

				if ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {

					// the opposite face can see the vertex, so proceed with next edge

					this.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );

				} else {

					// the opposite face can't see the vertex, so this edge is part of the horizon

					horizon.push( edge );

				}

			}

			edge = edge.next;

		} while ( edge !== crossEdge );

		return this;

	}

	// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order

	addAdjoiningFace( eyeVertex, horizonEdge ) {

		// all the half edges are created in ccw order thus the face is always pointing outside the hull

		const face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );

		this.faces.push( face );

		// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )

		face.getEdge( - 1 ).setTwin( horizonEdge.twin );

		return face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex


	}

	//  Adds 'horizon.length' faces to the hull, each face will be linked with the
	//  horizon opposite face and the face on the left/right

	addNewFaces( eyeVertex, horizon ) {

		this.newFaces = [];

		let firstSideEdge = null;
		let previousSideEdge = null;

		for ( let i = 0; i < horizon.length; i ++ ) {

			const horizonEdge = horizon[ i ];

			// returns the right side edge

			const sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );

			if ( firstSideEdge === null ) {

				firstSideEdge = sideEdge;

			} else {

				// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )

				sideEdge.next.setTwin( previousSideEdge );

			}

			this.newFaces.push( sideEdge.face );
			previousSideEdge = sideEdge;

		}

		// perform final join of new faces

		firstSideEdge.next.setTwin( previousSideEdge );

		return this;

	}

	// Adds a vertex to the hull

	addVertexToHull( eyeVertex ) {

		const horizon = [];

		this.unassigned.clear();

		// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list

		this.removeVertexFromFace( eyeVertex, eyeVertex.face );

		this.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );

		this.addNewFaces( eyeVertex, horizon );

		// reassign 'unassigned' vertices to the new faces

		this.resolveUnassignedPoints( this.newFaces );

		return	this;

	}

	cleanup() {

		this.assigned.clear();
		this.unassigned.clear();
		this.newFaces = [];

		return this;

	}

	compute() {

		let vertex;

		this.computeInitialHull();

		// add all available vertices gradually to the hull

		while ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {

			this.addVertexToHull( vertex );

		}

		this.reindexFaces();

		this.cleanup();

		return this;

	}

}

//

class Face {

	constructor() {

		this.normal = new Vector3();
		this.midpoint = new Vector3();
		this.area = 0;

		this.constant = 0; // signed distance from face to the origin
		this.outside = null; // reference to a vertex in a vertex list this face can see
		this.mark = Visible;
		this.edge = null;

	}

	static create( a, b, c ) {

		const face = new Face();

		const e0 = new HalfEdge( a, face );
		const e1 = new HalfEdge( b, face );
		const e2 = new HalfEdge( c, face );

		// join edges

		e0.next = e2.prev = e1;
		e1.next = e0.prev = e2;
		e2.next = e1.prev = e0;

		// main half edge reference

		face.edge = e0;

		return face.compute();

	}

	getEdge( i ) {

		let edge = this.edge;

		while ( i > 0 ) {

			edge = edge.next;
			i --;

		}

		while ( i < 0 ) {

			edge = edge.prev;
			i ++;

		}

		return edge;

	}

	compute() {

		const a = this.edge.tail();
		const b = this.edge.head();
		const c = this.edge.next.head();

		_triangle.set( a.point, b.point, c.point );

		_triangle.getNormal( this.normal );
		_triangle.getMidpoint( this.midpoint );
		this.area = _triangle.getArea();

		this.constant = this.normal.dot( this.midpoint );

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) - this.constant;

	}

}

// Entity for a Doubly-Connected Edge List (DCEL).

class HalfEdge {


	constructor( vertex, face ) {

		this.vertex = vertex;
		this.prev = null;
		this.next = null;
		this.twin = null;
		this.face = face;

	}

	head() {

		return this.vertex;

	}

	tail() {

		return this.prev ? this.prev.vertex : null;

	}

	length() {

		const head = this.head();
		const tail = this.tail();

		if ( tail !== null ) {

			return tail.point.distanceTo( head.point );

		}

		return - 1;

	}

	lengthSquared() {

		const head = this.head();
		const tail = this.tail();

		if ( tail !== null ) {

			return tail.point.distanceToSquared( head.point );

		}

		return - 1;

	}

	setTwin( edge ) {

		this.twin = edge;
		edge.twin = this;

		return this;

	}

}

// A vertex as a double linked list node.

class VertexNode {

	constructor( point ) {

		this.point = point;
		this.prev = null;
		this.next = null;
		this.face = null; // the face that is able to see this vertex

	}

}

// A double linked list that contains vertex nodes.

class VertexList {

	constructor() {

		this.head = null;
		this.tail = null;

	}

	first() {

		return this.head;

	}

	last() {

		return this.tail;

	}

	clear() {

		this.head = this.tail = null;

		return this;

	}

	// Inserts a vertex before the target vertex

	insertBefore( target, vertex ) {

		vertex.prev = target.prev;
		vertex.next = target;

		if ( vertex.prev === null ) {

			this.head = vertex;

		} else {

			vertex.prev.next = vertex;

		}

		target.prev = vertex;

		return this;

	}

	// Inserts a vertex after the target vertex

	insertAfter( target, vertex ) {

		vertex.prev = target;
		vertex.next = target.next;

		if ( vertex.next === null ) {

			this.tail = vertex;

		} else {

			vertex.next.prev = vertex;

		}

		target.next = vertex;

		return this;

	}

	// Appends a vertex to the end of the linked list

	append( vertex ) {

		if ( this.head === null ) {

			this.head = vertex;

		} else {

			this.tail.next = vertex;

		}

		vertex.prev = this.tail;
		vertex.next = null; // the tail has no subsequent vertex

		this.tail = vertex;

		return this;

	}

	// Appends a chain of vertices where 'vertex' is the head.

	appendChain( vertex ) {

		if ( this.head === null ) {

			this.head = vertex;

		} else {

			this.tail.next = vertex;

		}

		vertex.prev = this.tail;

		// ensure that the 'tail' reference points to the last vertex of the chain

		while ( vertex.next !== null ) {

			vertex = vertex.next;

		}

		this.tail = vertex;

		return this;

	}

	// Removes a vertex from the linked list

	remove( vertex ) {

		if ( vertex.prev === null ) {

			this.head = vertex.next;

		} else {

			vertex.prev.next = vertex.next;

		}

		if ( vertex.next === null ) {

			this.tail = vertex.prev;

		} else {

			vertex.next.prev = vertex.prev;

		}

		return this;

	}

	// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b

	removeSubList( a, b ) {

		if ( a.prev === null ) {

			this.head = b.next;

		} else {

			a.prev.next = b.next;

		}

		if ( b.next === null ) {

			this.tail = a.prev;

		} else {

			b.next.prev = a.prev;

		}

		return this;

	}

	isEmpty() {

		return this.head === null;

	}

}

class ConvexGeometry extends BufferGeometry {

	constructor( points = [] ) {

		super();

		// buffers

		const vertices = [];
		const normals = [];

		const convexHull = new ConvexHull().setFromPoints( points );

		// generate vertices and normals

		const faces = convexHull.faces;

		for ( let i = 0; i < faces.length; i ++ ) {

			const face = faces[ i ];
			let edge = face.edge;

			// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)

			do {

				const point = edge.head().point;

				vertices.push( point.x, point.y, point.z );
				normals.push( face.normal.x, face.normal.y, face.normal.z );

				edge = edge.next;

			} while ( edge !== face.edge );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

	}

}

// THREE BODY

class Body extends Item {

	constructor () {

		super();

		this.Utils = Utils;
		this.type = 'body';
		this.num = Num[this.type];
		this.full = false;
		this.extraConvex = false;
		this.needMatrix = root.engine ==='RAPIER' || root.engine ==='HAVOK';
		//this.tmpVolume = 0

	}

	setFull( full ){
		this.num = Num[ full ? 'bodyFull':'body' ];
		this.full = full;
	}

	step ( AR, N ) {

		const list = this.list;
		let i = list.length, b, n, a;
		
		while( i-- ){

			b = list[i];

			if( b === null ) continue

			n = N + ( i * this.num );

			// update only when physics actif
			if( !b.actif ){
				a = AR[n+0]+AR[n+1]+AR[n+2]+AR[n+3]+ AR[n+4]+AR[n+5]+AR[n+6]+AR[n+7];
				if( a === 0 ) continue
				else b.actif = true;
			}

		    // test is object sleep
			b.sleep = AR[n] > 0 ? false : true;

			// update default material
	        if( b.defMat ){

	        	if( b.isInstance ){
	        		b.instance.setColorAt( b.id, b.sleep ? Colors.sleep : Colors.body );
	        	} else {
	        		if ( !b.sleep && b.material.name === 'sleep' ) b.material = Mat.get('body');
			        if ( b.sleep && b.material.name === 'body' ) b.material = Mat.get('sleep');
	        	}
			    
			}

			if( b.sleep && !b.isKinematic ) continue 

			// update position / rotation / velocity

		    if( b.isInstance ){ 
		    	if( b.speedMat ) b.instance.setColorAt(b.id, [ Math.abs(AR[n+8])*0.5, Math.abs(AR[n+9])*0.5, Math.abs(AR[n+10])*0.5] );
		    	b.instance.setTransformAt( b.id, [AR[n+1],AR[n+2],AR[n+3]], [AR[n+4],AR[n+5],AR[n+6],AR[n+7]], b.noScale ? [1,1,1] : b.size );
		    	b.position = {x:AR[n+1], y:AR[n+2], z:AR[n+3]};
		    	///b.quaternion = {x:AR[n+4], y:AR[n+5], z:AR[n+6], w:AR[n+7]}
		    	b.quaternion = {_x:AR[n+4], _y:AR[n+5], _z:AR[n+6], _w:AR[n+7]};
		    	if( this.needMatrix ) b.matrixWorld.compose( b.position, b.quaternion, {x:1, y:1, z:1}); 
		    	if( this.full ){
		    		b.velocity = {x:AR[n+8], y:AR[n+9], z:AR[n+10]};
		    		b.angular = {x:AR[n+11], y:AR[n+12], z:AR[n+13]};
		    	}
		    }
		    else {
		    	b.position.fromArray( AR, n + 1 );
		        b.quaternion.fromArray( AR, n + 4 );
		        if( this.full ){
			        b.velocity.fromArray( AR, n + 8 );
			        b.angular.fromArray( AR, n + 11 );
			    }
		        if( !b.auto ) b.updateMatrix();
		    }
		}

	}

	///

	geometry ( o = {}, b = null, material = null ) {

		//console.log("geometry is add")

		//console.log( 'geometry', o, b, material)

		let g, i, n, s = o.size, gName='';
		let t = o.type;
		let noScale = false, unic = false;
		let seg = o.seg || 16;

		//if( o.instance && t!== 'capsule'&& !o.radius) s = o.instanceSize || [1,1,1]

		if( o.instance && t=== 'compound'){ 
			t = o.shapes[0].type;
			s = o.shapes[0].size;
			o.translate = o.shapes[0].pos;
		}

		if( t==='mesh' || t==='convex' ){
			if( o.shape ){
				if( o.shape.isMesh ) o.shape = o.shape.geometry;
			} else {
				if( o.mesh && !o.v ) o.shape = o.mesh.geometry;
			}	
		}

		if( o.radius ){
			if( !o.breakable ){
				if( t === 'box' ) t = 'ChamferBox';
				if( t === 'cylinder' ) t = 'ChamferCyl';
			}
		}

		if( o.geometry ){
			if( t === 'convex' ) o.shape = o.geometry;
			else t = 'direct';
		} 


	    if( root.engine === 'PHYSX' && ( o.type==='cylinder' || o.type==='cone' ) ){
			// convert geometry to convex if not in physics
	    	let geom = new CylinderGeometry( o.type === 'cone' ? 0 : o.size[ 0 ], o.size[ 0 ], o.size[ 1 ], seg, 1 );//24
	    	if( o.isWheel ) geom.rotateZ( -PI90 );
	    	o.v = MathTool.getVertex( geom );
	    	o.type = 'convex';

	    }

	    if( root.engine === 'HAVOK' && o.type==='cone' ){
	    	// convert geometry to convex if not in physics
	    	let geom = new CylinderGeometry( o.type === 'cone' ? 0 : o.size[ 0 ], o.size[ 0 ], o.size[ 1 ], seg, 1 );//24
	    	o.v = MathTool.getVertex( geom );
	    	o.type = 'convex';

	    }

	    if( o.type==='stair' ){
	    	o.type = 'box';
	    	t = 'box';
	    }

		switch( t ){

			case 'direct':

			    g = o.geometry.clone();
			    if( o.size ) g.scale( o.size[0], o.size[1], o.size[2] );

			    unic = true;
			    noScale = true;

			break;

			case 'convex':

			if( o.v ){ 

				if( o.nogeo ) g = new BufferGeometry();
				else {
					let vv = [];
					i = Math.floor( o.v.length/3 );
					while( i-- ){
						n = i*3;
						vv.push( new Vector3( o.v[n], o.v[n+1], o.v[n+2] ) );
					}
					g = new ConvexGeometry( vv );
					//o.v = math.getVertex( g )
					//o.index = math.getIndex( g )
					//console.log(o.v, o.index)
				}
				unic = true;
				noScale = true;
			}

			if( o.shape ){

				g = o.shape.clone();
				if( o.size ) g.scale( o.size[0], o.size[0], o.size[0] );
				if( o.shapeScale ) g.scale( o.shapeScale[0], o.shapeScale[1], o.shapeScale[2] );
				//o.v = g.attributes.position.array;
				o.v = MathTool.getVertex( g );
				o.index = MathTool.getIndex( g );

				unic = true;
				noScale = true;
			}

			if(!g.boundingBox) g.computeBoundingBox();
			let bx = g.boundingBox;
		    o.boxSize = [ -bx.min.x + bx.max.x, -bx.min.y + bx.max.y, -bx.min.z + bx.max.z ];

			//console.log(g)

			break;

			case 'mesh':

				g = o.shape.clone();
				if( o.size ) g.scale( o.size[0], o.size[0], o.size[0] );
				
				o.v = MathTool.getVertex( g, root.engine === 'OIMO' );
				o.index = root.engine === 'OIMO' ? null : MathTool.getIndex( g );
				
				unic = true;
				noScale = true;
			
			break;

			case 'highSphere':

			    gName = 'highSphere_' + s[ 0 ];

			    g = Geo.get( gName );
			    if(!g){
			    	g = new SphereBox( s[ 0 ] );
					g.name = gName;
			    } else {
					gName = '';
				}
			    noScale = true;
			    o.type = 'sphere';

			break;

			case 'capsule':

			    gName = 'capsule_' + s[ 0 ] +'_'+s[ 1 ] + '_' + seg; 

			    g = Geo.get( gName );
			    if(!g){
					g = new Capsule( s[ 0 ], s[ 1 ], seg );
					g.name = gName;
				} else {
					gName = '';
				}
				noScale = true;
			break;

			case 'ChamferBox':

			    gName = 'ChamferBox_' + s[ 0 ] +'_'+ s[ 1 ] +'_'+ s[ 2 ] + '_' + o.radius; 

			    //console.log(s, o.radius)
			    g = Geo.get( gName );
			    if(!g){
					g = new ChamferBox( s[ 0 ], s[ 1 ], s[ 2 ], o.radius );
					g.name = gName;
				} else {
					gName = '';
				}
				noScale = true;
			break;

			case 'ChamferCyl':

			    gName = 'ChamferCyl_' + s[ 0 ] +'_'+ s[ 1 ] +'_'+ s[ 2 ] + '_' + o.radius + '_' + seg;



			    g = Geo.get( gName );
			    if(!g){
					g = new ChamferCyl( s[ 0 ], s[ 0 ], s[ 1 ], o.radius, seg );
					g.name = gName;
				} else {
					gName = '';
				}
				noScale = true;
			break;

			default:
			    if( !o.breakable ) g = Geo.get(t); //geo[ t ];
			    else {
			    	g = Geo.get(t).clone();
			    	g.scale( s[0], s[1], s[2] );
			    	unic = true;
			    	noScale = true;
			    }
			break;

		}


		if( o.translate ) g.translate( o.translate[0], o.translate[1], o.translate[2]);


		// clear untranspherable variable for phy
    	if( o.shape ) delete o.shape;
    	if( o.geometry ) delete o.geometry;


    	if ( g.attributes.uv === undefined || o.autoUV ){
				//console.log(o.shape)
				createUV(g, 'box', 5.0, o.pos, o.quat );
		}


    	// reuse complex geometry
    	if( gName !== '' ) Geo.set( g );

    	if( o.isWheel ){
    		g = g.clone();
    		g.rotateZ( -PI90 );
    		unic = true;
    	}
    	
    	// unic geometry dispose on reset 
    	if( unic ) Geo.unic(g);

    	


    	if( b === null && material === null ){
    		g.noScale = noScale; 
    		return g
    	}

    	if( o.meshRemplace && o.debug ) material = Mat.get( 'debug3' );

    	//if( o.instance ) return

		let m = new Mesh( g, material );

		if( o.localRot ) o.localQuat = MathTool.quatFromEuler(o.localRot); //math.toQuatArray( o.localRot )
		if( o.localPos ) m.position.fromArray( o.localPos );
		if( o.localQuat ) m.quaternion.fromArray( o.localQuat );

    	if( !noScale ) m.scale.fromArray( o.size );
    	//if( unic ) m.unic = true

    	// disable raycast
    	if(o.ray !== undefined){
    		if( !o.ray ) m.raycast = () => {return};
    	}

    	// add or not add
    	if( !o.meshRemplace || o.debug ) b.add( m );

	}

	add ( o = {} ) {

		//this.tmpVolume = 0

		//console.log('add', o.type )

		let i, n, name;

		if( !o.instance ) name = this.setName( o );

		o.type = o.type === undefined ? 'box' : o.type;

		if( o.type === 'plane' && !o.visible ) o.visible = false;

		if( o.type === 'stair'){ 

			let v1 = new Vector3(0,0,o.size[2]);
			let v2 = new Vector3(0, o.size[1]*0.5,o.size[2]*0.5);
			let angle = v1.angleTo(v2);
			let dist = v1.distanceTo(v2);
			o.rot = [angle * todeg$1,0,0];
			o.size[1] *= o.div || 0.2;
			o.size[2] = dist*2;
		
		    let p1 = new Vector3(0,-o.size[1]*0.5,0);
		    p1.applyAxisAngle({x:1, y:0, z:0},angle);
			o.pos[1] += p1.y;
			o.pos[2] += p1.z;
		}

		// change default center of mass 
		if( o.massCenter && root.engine !== 'PHYSX'){
			if( o.type !== 'compound' ){
				//o.localPos = o.massCenter
				o.shapes = [{ type:o.type, pos:o.massCenter, size:o.size }];
				if( o.seg ) o.shapes[0].seg = o.seg;
				if( o.radius ) o.shapes[0].radius = o.radius;
				delete ( o.size );
				o.type = 'compound';
			} else {
				for ( i = 0; i < o.shapes.length; i ++ ) {
					n = o.shapes[ i ];
					if( n.pos ) n.pos = Utils.vecAdd( n.pos, o.massCenter );
					else n.pos = o.massCenter;
					Geo.unic(n);
				}
			}
		}

		//console.log('add', o.type, )

		// position
		o.pos = o.pos === undefined ? [ 0, 0, 0 ] : o.pos;

		// rotation is in degree or Quaternion
	    o.quat = o.quat === undefined ? [ 0, 0, 0, 1 ] : o.quat;
	    if( o.rot !== undefined ){ o.quat = MathTool.quatFromEuler(o.rot); delete o.rot; }
	    if( o.meshRot !== undefined ){ o.meshQuat = MathTool.quatFromEuler(o.meshRot); delete o.meshRot; }
	    //if( o.rot !== undefined ){ o.quat =  math.toQuatArray( o.rot ); delete o.rot; }
	    //if( o.meshRot !== undefined ){ o.meshQuat = math.toQuatArray( o.meshRot ); delete o.meshRot; }

	    //o.size = o.size == undefined ? [ 1, 1, 1 ] : math.correctSize( o.size );
	    o.size = MathTool.autoSize( o.size, o.type );
	    if( o.meshScale ) o.meshScale = MathTool.autoSize( o.meshScale );

	    let material, noMat = false;
	    //let defMat = false;

	    if( o.visible === false ) o.material = 'hide';

	    if ( o.material !== undefined ) {
	    	if ( o.material.constructor === String ) material = Mat.get( o.material );
	    	else material = o.material;
	    } else {
	    	noMat = true;
	    	//defMat = this.type === 'body'
	    	material = Mat.get( this.type );
	    	if( o.instance ) material = Mat.get( 'base' );
	    }

	    if( o.unicMat ) {
	    	material = material.clone();
	    	//root.tmpMat.push( material )
	    	Mat.addToTmp( material );
	    }

	    if( o.material ) delete o.material;


	    //let b = new Basic3D( o.instance )
	    let b = o.instance ? {} : new Basic3D();

	    if( o.mesh && !o.instance ){

	    	//if( o.isTerrain ) o.noClone = true
	    	if( o.mesh.type === 'terrain' ) o.noClone = true;

	    	let mm = o.noClone ? o.mesh : o.mesh.clone();

	    	mm.position.fromArray( o.meshPos || [0,0,0]);
	    	if( o.meshRot ) { o.meshQuat = MathTool.quatFromEuler(o.meshRot); delete o.meshRot; }
	    	//if( o.meshRot ) { o.meshQuat = math.toQuatArray( o.meshRot ); delete o.meshRot; }
	    	if( o.meshQuat ) mm.quaternion.fromArray( o.meshQuat );
	    	if( o.meshSize ) mm.scale.set(1,1,1).multiplyScalar(o.meshSize);
	    	if( o.meshScale ) mm.scale.fromArray( o.meshScale );
	    	
	    	if( !noMat ) mm.material = material;

	    	root.tmpMesh.push(mm);

	    	o.meshRemplace = true;
	    	b.add( mm );

	    }

	    switch( o.type ){

	    	case 'null': break;

	    	case 'compound':

	    	    for ( i = 0; i < o.shapes.length; i ++ ) {

					n = o.shapes[ i ];

					n.type = n.type === undefined ? 'box' : n.type;
					//n.size = n.size === undefined ? [ 1, 1, 1 ] : math.correctSize( n.size );
					n.size = MathTool.autoSize( n.size, n.type );

					if( n.pos ) n.localPos = n.pos;

					if( n.rot !== undefined ){ n.quat = MathTool.quatFromEuler(n.rot); delete n.rot; }
					//if( n.rot !== undefined ){ n.quat = math.toQuatArray( n.rot ); delete n.rot; }
					if( n.quat ) n.localQuat = n.quat;

					n.debug = o.debug || false;
					n.meshRemplace = o.meshRemplace || false;

					if( !o.instance ) this.geometry( n, b, material );
				}

	    	break;
	    	default:

			    if( !o.instance ) this.geometry( o, b, material );

			break;

	    }



	    
	    b.type = this.type;
	    b.size = o.size;
		b.shapetype = o.type;
		b.isKinematic = o.kinematic || false;

		// for buttton only
		if( o.button ) b.isButton = true;

	    // enable or disable raycast
	    b.isRay = true;//b.type === 'body' || b.isButton ? true : false
	    if( o.ray !== undefined ) b.isRay = o.ray; 
	    if( !o.instance ) b.setRaycast();
	    

		if( !noMat ) b.material = material;
		b.defMat = false;
		
		if( b.material && noMat ) b.defMat = b.material.name === 'body';


		//  for instancing
		if( o.instance ){ 

			b.isInstance = true;
			b.instance = root.instanceMesh[ o.instance ] || this.addInstance( o, material );
			b.instance.isRay = b.isRay;

			b.defMat = b.instance.material.name === 'base';
			
			b.id = b.instance.count;
			b.mass = o.mass || 0;
			
			b.name = b.instance.name + b.id;
			//if( o.name ) b.name = o.name
			o.name = b.name;
			b.noScale = b.instance.noScale;//false//o.type!=='box' || o.type!=='ChamferBox' || o.type!=='sphere';
			if(o.sizeByInstance) b.noScale = false;
			//if(o.type === 'sphere') b.noScale = false
		    //if( o.type === 'capsule' ) b.noScale = true
		    //if( o.type === 'box' ) b.noScale = true
			//if(o.radius) b.noScale = true

			let color = o.color;
			if( b.defMat ) color = o.sleep ? Colors.sleep : Colors.body;

			b.instance.add( o.pos, o.quat, b.noScale ? [1,1,1] : b.size, color );

			b.position = {x:o.pos[0], y:o.pos[1], z:o.pos[2]};
			b.quaternion = {_x:o.quat[0], _y:o.quat[1], _z:o.quat[2], _w:o.quat[3]};
		    b.velocity = {x:0, y:0, z:0};
		    b.angular = {x:0, y:0, z:0};
		    if( this.needMatrix ) b.matrixWorld = new Matrix4();



			// for convex
			if(b.instance.v) o.v = b.instance.v;
			if(b.instance.index) o.index = b.instance.index;
		    o.type = b.instance.type;

		    //console.log(o.v)

			/*if( this.extraConvex && ( o.type==='cylinder' || o.type==='cone') ){
		    	o.v = b.instance.v;
		    	o.type = 'convex';
		    }*/


			//console.log( b )

		} else {

			b.name = name;

			if( o.renderOrder ) b.renderOrder = o.renderOrder;
			if( o.visible === undefined ) o.visible = true;
			if( o.shadow === undefined ) o.shadow = o.visible;

			b.visible = o.visible !== undefined ? o.visible : true;
		    b.receiveShadow = o.shadow;
		    b.castShadow = o.shadow;

		    // apply option
			this.set( o, b );

		}

	    if( o.instance ) delete o.instance;
	    if( o.mesh ) delete o.mesh;


    	if( o.breakable ){

    		root.motor.addBreaker();
			let child = b.children[0];
			b.remove(child);
			b = child;
			b.name = name;
			b.type = this.type;
			b.density = o.density;
			b.breakable = true;
			b.breakOption = o.breakOption !== undefined ? o.breakOption : [ 250, 1, 2, 1 ];
			//b.userData.mass = o.mass;
		}

		// for skeleton mesh

		/*if( o.bone ){

			b.userData.decal = o.decal;
            b.userData.decalinv = o.decalinv;
            b.userData.bone = o.bone;
		    

		    delete o.bone
		    delete o.decal
		    delete o.decalinv
		}*/

		//o.volume = this.tmpVolume


		



		// add to world
		this.addToWorld( b, o.id );

		if( o.onlyMakeMesh ) return b

		if(o.phySize) o.size = o.phySize;
		if(o.phyPos) o.pos = o.phyPos;

		if(o.parent) delete o.parent;

		// add to physic worker 
		root.post( { m:'add', o:o } );

		//console.log(b)

		return b

	}

	set ( o = {}, b = null ) {

		if( b === null ) b = this.byName( o.name );
		if( b === null ) return

		/*if(b.isInstance){

			b.instance.setTransformAt( b.id, o.pos, o.quat, b.noScale ? [1,1,1] : b.size )
		    b.position = {x:o.pos[0], y:o.pos[1], z:o.pos[2]}

		}else{*/
			if( o.pos ) b.position.fromArray( o.pos );
		    if( o.quat ) b.quaternion.fromArray( o.quat );

		    b.auto = o.auto || false;

		    if( !b.auto ) {
		    	b.matrixAutoUpdate = false;
			    b.updateMatrix();
			} else {
				b.matrixAutoUpdate = true;
			}
		//}

		

	}

	addInstance ( o, material ) {

		//console.log(o)
		if( o.sizeByInstance ) o.size = [1,1,1];
		let g = this.geometry( o );

	//console.log(g)

		if( o.mesh ) {
			g = o.mesh.isObject3D ? o.mesh.geometry.clone() : o.mesh.clone();
			if( o.meshScale ) g.scale( o.meshScale[0], o.meshScale[1], o.meshScale[2] );
			g.noScale = true;
		}/* else {
			g = this.geometry( o )
		}*/

		let bb = new Instance( g, material, 0 );

		bb.type = o.type;
		bb.noScale = g.noScale;

		//console.log(o)
		if( bb.type === 'convex' ) bb.v = o.v;
		if( o.index ) bb.index = o.index;
		

		//if( bb.type==='convex' ) bb.v = MathTool.getVertex( bb.geometry )

    	//bb.matrixAutoUpdate = false
    	//bb.instanceMatrix.setUsage( DynamicDrawUsage )
    	bb.receiveShadow = o.shadow !== undefined ? o.shadow : true;
    	bb.castShadow = o.shadow !== undefined ? o.shadow : true;

    	bb.name = o.instance;
		root.scene.add( bb );
		root.instanceMesh[ o.instance ] = bb;


		//console.log(bb.name+" is add")

    	return bb

	}

}

class Joint extends Item {

	constructor () {

		super();

		this.Utils = Utils;

		this.type = 'joint';

		this.v1 = new Vector3();
		this.v2 = new Vector3();

	}

	step ( AR, N ) {

		let i = this.list.length, j, n;
		
		while( i-- ){

			j = this.list[i];

			n = N + ( i * Num.joint );

			if( Num.joint === 16 ) j.updateFromPhy( AR, n );
			else j.update();

		}

	}

	///

	add ( o = {} ) {

		let name = this.setName( o );

		let body1 = null;
		let body2 = null;
		let isString;

		if( o.b1 ) {
			isString = typeof o.b1 === 'string';
			body1 = isString ? Utils.byName( o.b1 ) : o.b1;
			if(!isString) o.b1 = o.b1.name;
		}

		if( o.b2 ) {
			isString = typeof o.b2 === 'string';
			body2 = isString ? Utils.byName( o.b2 ) : o.b2;
			if(!isString) o.b2 = o.b2.name;
		}

		// world to local

		if ( o.worldPos ) o.worldAnchor = o.worldPos;
		if ( o.worldAnchor ){

			this.v1.fromArray( o.worldAnchor ); 
			this.v2.fromArray( o.worldAnchor );

			//console.log(body1,body2)

			o.pos1 = body1 ? Utils.toLocal( this.v1, body1 ).toArray() : o.worldAnchor;
			o.pos2 = body2 ? Utils.toLocal( this.v2, body2 ).toArray() : o.worldAnchor;

			delete o.worldAnchor;

		}

		if ( o.worldAxis ){

			this.v1.fromArray( o.worldAxis ); 
			this.v2.fromArray( o.worldAxis );

			o.axis1 = body1 ? Utils.toLocal( this.v1, body1, true ).toArray():o.worldAxis;
			o.axis2 = body2 ? Utils.toLocal( this.v2, body2, true ).toArray():o.worldAxis;

			//o.quat1 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis1).normalize() ).toArray();
		    //o.quat2 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis2).normalize() ).toArray();

			//console.log(o.worldAxis, o.axis1, o.axis2)

			delete o.worldAxis;

		}

		if ( o.worldQuat ){

			o.quat1 = Utils.quatLocal(o.worldQuat, body1);
			o.quat2 = Utils.quatLocal(o.worldQuat, body2);

			if( root.engine === 'OIMO' || root.engine === 'HAVOK' ){

				//this.v1.fromArray( math.quadToAxisArray( o.worldQuat ) ).normalize()
				//this.v2.fromArray( math.quadToAxisArray( o.worldQuat ) ).normalize()

				//o.axis1 = Utils.axisLocal( math.quadToAxisArray( o.worldQuat ), body1)//this.v1.fromArray( math.quadToAxisArray( o.quat1 ) ).normalize().toArray()
				//o.axis2 = Utils.axisLocal( math.quadToAxisArray( o.worldQuat ), body2)//this.v2.fromArray( math.quadToAxisArray( o.quat2 ) ).normalize().toArray()

				o.axis1 = Utils.axisLocal( MathTool.quatToAxis( o.worldQuat ), body1);
				o.axis2 = Utils.axisLocal( MathTool.quatToAxis( o.worldQuat ), body2);

				//o.axis1 = body1 ? Utils.toLocal( this.v1, body1, true ).toArray():[1,0,0]
				//o.axis2 = body2 ? Utils.toLocal( this.v2, body2, true ).toArray():[1,0,0]

			}
			/*this.v1.fromArray( o.worldAxis ) 
			this.v2.fromArray( o.worldAxis )

			o.axis1 = body1 ? Utils.toLocal( this.v1, body1, true ).normalize().toArray():o.worldAxis
			o.axis2 = body2 ? Utils.toLocal( this.v2, body2, true ).normalize().toArray():o.worldAxis
*/
			//o.quat1 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis1).normalize() ).toArray();
		    //o.quat2 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis2).normalize() ).toArray();

			//console.log(o.worldQuat, o.quat1, o.quat2)

			delete o.worldQuat;

		}

		//if( !o.axis1 ) o.axis1 = [0,0,1]
		//if( !o.axis2 ) o.axis2 = [0,0,1]

		if( !o.axis1 ) o.axis1 = [1,0,0];
		if( !o.axis2 ) o.axis2 = [1,0,0];

		if( !o.pos1 ) o.pos1 = [0,0,0];
		if( !o.pos2 ) o.pos2 = [0,0,0];

		/*if( o.b2 ) body2 = typeof o.b2 !== 'string' ? o.b2 : Utils.byName(o.b2)
		if( o.b1 && typeof o.b1 !== 'string') o.b1 = o.b1.name;
		if( o.b2 && typeof o.b2 !== 'string') o.b2 = o.b2.name;*/

		if( o.rot1 !== undefined ){ o.quat1 = MathTool.quatFromEuler( o.rot1 ); delete ( o.rot1 ); }
		if( o.rot2 !== undefined ){ o.quat2 = MathTool.quatFromEuler( o.rot2 ); delete ( o.rot2 ); }

		if( !o.quat1 ) o.quat1 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis1).normalize() ).toArray();
		if( !o.quat2 ) o.quat2 = new Quaternion().setFromUnitVectors( new Vector3(1, 0, 0), new Vector3().fromArray(o.axis2).normalize() ).toArray();

		if( o.drivePosition) if( o.drivePosition.rot !== undefined ){ o.drivePosition.quat = MathTool.quatFromEuler( o.drivePosition.rot ); delete ( o.drivePosition.rot ); }

		let j = new ExtraJoint( Geo.get('joint'), o );
		j.name = name;

		j.visible = root.jointVisible || false; // joint is visible after first update

		if(!o.visible) o.visible = j.visible;
		//j.isVisible = o.visible !== undefined ? o.visible : true;
		j.visible = o.visible !== undefined ? o.visible : true;
		j.body1 = body1;
		j.body2 = body2;

		// apply option
		this.set( o, j );

		// add to world
		this.addToWorld( j, o.id );

		// add to worker 
		root.post( { m:'add', o:o } );

		return j

	}

	set ( o = {}, j = null ) {

		if( j === null ) j = this.byName( o.name );
		if( j === null ) return

		if( o.visible !== undefined ) j.visible = o.visible;

	}

}





class ExtraJoint extends Basic3D {

	constructor( g, o ) {

	    super();

	    let material = Mat.get('line');

	    this.type = 'joint';
	    this.mode = 'revolute';
	    this.isJoint = true;

	    this.mtx = new Matrix4();
	    this.size = o.helperSize || 0.1;
	    g = g.clone(); 
	    g.scale( this.size, this.size, this.size);
	    this.m1 = new LineSegments( g, material );
	    
	    this.add(this.m1);
	    
	    this.m1.matrixAutoUpdate = false;

	    this.m2 = new LineSegments( g, material );
	    //this.m2.scale.set( this.size, this.size, this.size)
	    this.add( this.m2 );

	    this.m2.matrixAutoUpdate = false;

	    this.m2.updateMatrix();
	    this.m1.updateMatrix();

	    this.body1 = null;
	    this.body2 = null;

	    this.mat1 = new Matrix4();
	    this.mat2 = new Matrix4();
	    this.end = new Vector3();

	    // experimental rotation ?
	    //Utils.refAxis( this.mat1, o.axis1 )
	    //Utils.refAxis( this.mat2, o.axis2 )

	    let qq = new Quaternion();
	    if(o.quat1) this.mat1.makeRotationFromQuaternion(qq.fromArray(o.quat1));
	    if(o.quat2) this.mat2.makeRotationFromQuaternion(qq.fromArray(o.quat2));

	    this.mat1.setPosition( o.pos1[0], o.pos1[1], o.pos1[2] );
	    this.mat2.setPosition( o.pos2[0], o.pos2[1], o.pos2[2] );
	    
	    
	    const positions = [ 0, 0, 0, 0, 0, 0 ];
	    const colors = [ 1, 0, 0, 1, 0, 0 ];
	    const gline = new BufferGeometry();
	    gline.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	    gline.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	    gline.computeBoundingSphere();


	    this.m3 = new LineSegments( gline, material );
	    this.add( this.m3 );
	    this.m3.matrixAutoUpdate = false;

	    this.pp = this.m3.geometry.attributes.position;

	}

	update () {

		if( !this.visible ) return

		if( this.body1 ){
			this.matrix.copy( this.body1.matrixWorld ).multiply( this.mat1 );
		} else {
			this.matrix.copy( this.mat1 );
		}

		if( this.body2 ){
			this.m2.matrix.copy( this.body2.matrixWorld ).multiply( this.mat2 );
		} else {
			this.m2.matrix.copy( this.mat2 );
		}

		this.m2.matrix.premultiply(this.matrix.clone().invert());
		this.end.setFromMatrixPosition( this.m2.matrix );


		//m.matrix = b.matrixWorld;
        //m.matrixAutoUpdate = false;

		//this.position.fromArray( r, n );
		//this.quaternion.fromArray( r, n + 3 );

		//this.updateMatrix();

		//this.m2.position.fromArray( r, n+7 );
		//this.m2.quaternion.fromArray( r, n+10 );
		//this.m2.matrix.compose( this.m2.position, this.m2.quaternion, {x:1,y:1,z:1} );

		//this.mtx.copy( this.matrix ).invert().multiply( this.m2.matrix );
		//this.mtx.decompose( this.m2.position, this.m2.quaternion, {x:1,y:1,z:1} );
		//this.m2.updateMatrix();

		//const position = this.m3.geometry.attributes.position;
		//position.setXYZ(1, this.m2.position.x, this.m2.position.y, this.m2.position.z)

		this.pp.setXYZ(1, this.end.x, this.end.y, this.end.z);
		this.pp.needsUpdate = true;

		if( !this.visible ) this.visible = true;

	}

	updateFromPhy ( r, n = 0 ) {

		//if( !this.isVisible ) return
		if( !this.visible ) return


		//m.matrix = b.matrixWorld;
        //m.matrixAutoUpdate = false;

		this.position.fromArray( r, n );
		this.quaternion.fromArray( r, n + 3 );

		this.updateMatrix();

		this.m2.position.fromArray( r, n+7 );
		this.m2.quaternion.fromArray( r, n+10 );
		this.m2.matrix.compose( this.m2.position, this.m2.quaternion, {x:1,y:1,z:1} );

		this.mtx.copy( this.matrix ).invert().multiply( this.m2.matrix );
		this.mtx.decompose( this.m2.position, this.m2.quaternion, {x:1,y:1,z:1} );
		this.m2.updateMatrix();


		this.pp.setXYZ(1, this.m2.position.x, this.m2.position.y, this.m2.position.z);
		this.pp.needsUpdate = true;

		if( !this.visible ) this.visible = true;

	}

	dispose (){

		this.m1.geometry.dispose();
		this.m2.geometry.dispose();
		this.m3.geometry.dispose();
		this.children = [];

	}

}

class Contact extends Item {

	constructor () {

		super();

		this.Utils = Utils;
		this.type = 'contact';

	}

	step ( AR, N ) {

		let i = this.list.length, c, n;
		
		while( i-- ){

			c = this.list[i];

			n = N + ( i * Num.contact );

			//c.update( AR.slice( n, n+8 ) )
			c.update( AR, n );

		}

	}

	add ( o = {} ) {

		this.setName( o );

		let c = new Pair( o );

		if( o.callback ) delete ( o.callback );

		// add to world
		this.addToWorld( c, o.id );

		// add to worker 
		root.post( { m:'add', o:o } );

		return c;

	}


}


class Pair {

	constructor ( o = {} ) {

		this.type = 'contact';

		this.name = o.name;
		this.callback = o.callback || function(){};

		this.b1 = o.b1 || null;
		this.b2 = o.b2 || null;
		this.ignore = o.ignore || [];

		this.always = o.always !== undefined ? o.always : true;
		this.simple = o.simple || false;

		this.data = {

			hit:false,
			point: [0,0,0],
			normal: [0,0,0],
			//object: null,
		};

	}

	update ( r, n = 0 ) {

		this.data.hit = r[n] > 0 ? true : false;

		if( !this.simple ){

			this.data.point = [ r[n+1], r[n+2], r[n+3] ];
			this.data.normal = [ r[n+4], r[n+5], r[n+6] ];

		}
		
		if( this.data.hit || this.always ) this.callback( this.data );

	}


}

// THREE VEHICLE

class Vehicle extends Item {

	constructor () {

		super();

		this.Utils = Utils;
		this.type = 'vehicle';
		this.num = Num[this.type];

	}

	step ( AR, N ) {

		let i = this.list.length, n, s;

		while( i-- ){

			s = this.list[i];
			n = N + ( i * this.num );
			s.step( AR, n );

		}

	}

	add ( o = {} ) {

		this.setName( o );
        const car = new Car( o );

        // add to world
		this.addToWorld( car, o.id );

        // add to physics
        root.post({ m:'add', o:car.o });

        return car

	}

	set ( o = {}, b = null ) {

		if( b === null ) b = this.byName( o.name );
		if( b === null ) return

	}

}



// CAR

class Car extends Basic3D {//extends Object3D {

	constructor( o ) {

		super();

		// extra function // ex car selection
		if(o.extra){
			this.extra = o.extra;
			delete o.extra;
		}

		this.type = 'vehicle';
		this.name = o.name || 'car';
		this.isRay = o.ray || false;
		//this.withBody = false;
		this.actif = false;
		//this.position = new THREE.Vector3();
		this.steering = 0;
		this.suspension = [];
		this.rolling = [];
		this.init( o );

	}

	drive () {

	}

	raycast(){
		return
	}

	init ( o ) {

		this.mass = o.mass || 2000;

		this.model = null;

		//this.decal = o.bodyDecalY || 0;
		//this.circum = (Math.PI * 2 * o.radius);// in metter

        // CHASSIS
		this.size = o.size || [0.85*2, 0.5*2, 2.5*2];
		this.massCenter = o.massCenter || [0, 0.55, 1.594];
		this.chassisPos = o.chassisPos || [0, 0.83, 0];

		this.maxSteering = o.maxSteering || 24;
		this.incSteering = o.incSteering || 2;

		this.s_travel = o.s_travel || 0.4;
		this.s_ratio = 1 / ( this.s_travel * 0.5 );
		this.decaly = root.engine === 'PHYSX' ? this.s_travel * 0.5 : 0;


		//this.diff = math.vecSub( this.chassisPos, this.massCenter )
		//this.diff[2] = 0

		// WHEELS
		this.numWheel = o.numWheel || 4;
		this.radius = o.radius || 0.35;
		this.radiusBack = o.radiusBack || this.radius;
		this.deep = o.deep || 0.3;
		this.deepBack = o.deepBack || this.deep;

		let byAxe = this.numWheel < 4 ? 1 : 2;

		if(!o.wPos) o.wPos = [0.8, 0.1, 1.4];

		if( o.wPos ){

			this.wPos = o.wPos;

			var p, wp = o.wPos, axe, pp = [], s=1, back=0, y, x, z, pzz;
			wp.length === 3 ? true : false;
			wp.length === 4 ? true : false;

			for( let i=0; i < this.numWheel; i++ ){

				s = i%2 === 0 ? -1 : 1;
				axe = Math.floor(i * 0.5);
				back = i >= byAxe ? true: false;
				
				y = wp[ 1 ];
				if( y===0 ) y = back ? this.radiusBack : this.radius;

				x = wp[ 0 ];
				//if( x === 0 ) x = (back ? this.deepBack : this.deep)*0.5
				if( x instanceof Array ) x = wp[0][axe];

				z = back ? -wp[2] : wp[2];
			    if( wp[2] instanceof Array ) z = wp[2][axe];

			    	


				p = [ x * s, y, z ];

				pp.push( p );

			}

			//console.log(this.name, pp)

			this.wheelsPosition = pp;
			delete o.wPos;

		}

		if( o.wheelsPosition ) this.wheelsPosition = o.wheelsPosition;

		//console.log(this.wheelsPosition)

		const scale = o.meshScale || 1;


		const chassisShapes = [];// { type:'convex', shape:bodyShape, pos:[0,0,0], flag:8|2|1 } ];//, isExclusive:true

		//if( o.chassisShape ) chassisShapes.push( { type:'convex', shape:o.chassisShape, pos:[0,0,0], flag:8|2|1 } );
		//else chassisShapes.push( { type:'box', size:this.size, pos:[0,0,0], flag:8|2|1 } );

		if( o.chassisShape ) chassisShapes.push( { type:'convex', shape:o.chassisShape, size:[scale], pos:this.chassisPos, filter:[1, -1, 0, 0], isExclusive:true, ray:this.isRay  } );
		else chassisShapes.push( { type:'box', size:this.size, pos:this.chassisPos } ); 

		for( let i=0; i < this.numWheel; i++ ){
	    	if( i < byAxe ) chassisShapes.push({ type:'cylinder', size:[ this.radius, this.deep ], isWheel:true, radius:o.rad || 0.05 , shadow:false, ray:false });
	    	else chassisShapes.push({ type:'cylinder', size:[ this.radiusBack, this.deepBack ], isWheel:true, radius:o.rad || 0.05 , shadow:false, ray:false  });
	    	
	    }

	    /*for( var i=0; i < o.numWheel; i++ ){

	    	if( this.radiusBack !== this.radius ){
	    		if(i<2) chassisShapes.push( { type:'convex', shape:wheelShape, pos:[0,0,0] } );
	    		else chassisShapes.push(  { type:'convex', shape:wheelShapeBack, pos:[0,0,0] } );
	    	} else {
	    		chassisShapes.push(  { type:'convex', shape:wheelShape, pos:[0,0,0] } );
	    	}

	    }*/

	    var material = Mat.get( o.debug ? 'debug' : (o.chassisMesh === undefined ? 'body' : 'hide'));
	    //if( o.body === undefined ) material = 'move';

	    let n;

	    for ( let i = 0; i < chassisShapes.length; i ++ ) {
	    	n = chassisShapes[i];
	    	if( n.pos ) n.localPos = n.pos;
	    	n.size = MathTool.autoSize( n.size, n.type );
	    	root.items.body.geometry( n, this, material );
	    }

	    //if( o.chassisShape ) console.log(  )


		let m;

		if(o.chassisMesh){
			m = o.noClone ? o.chassisMesh : o.chassisMesh.clone();
			m.position.set( 0, 0, 0 );
			Utils.noRay( m );
			m.scale.set( scale, scale, scale );
			this.children[0].add( m );
			this.model = m;
			delete o.chassisMesh;

			//this.chassis.children[0].castShadow = false;
			//this.chassis.children[0].receiveShadow = false;
		}


		//let back = false, 

		// wheel model
		if( o.wheelMesh ){
			
			
			for( let i = 1; i<this.numWheel+1; i++ ) {
				back = i >= byAxe+1;
				if( o.wheelMeshBack ) m = back ? o.wheelMeshBack.clone() : o.wheelMesh.clone();
				else m = o.wheelMesh.clone();
				Utils.noRay( m );
				m.position.set( 0, 0, 0 );
				if(i==2 || i ==4) m.scale.set( -scale, scale, scale );
				else m.scale.set( scale, scale, scale );
				this.children[i].add( m );

			    //this.chassis.children[i].castShadow = false;
			    //this.chassis.children[i].receiveShadow = false;
			}
			delete o.wheelMesh;
		}

		

		// suspension model
		if( o.suspensionMesh ){

			this.suspensionMesh = [];

			for( let i = 1; i<this.numWheel+1; i++ ) {

				m = o.suspensionMesh.clone();
				Utils.noRay( m );
				m.position.set( 0, 0, 0 );
				m.position.fromArray(this.wheelsPosition[i-1]);
				m.position.x = 0;
				if(i==2 || i ==4) m.scale.set( scale, scale, scale );
				else m.scale.set( -scale, scale, scale );
				this.children[0].add( m );
			    this.suspensionMesh.push( m );

			}
			delete o.suspensionMesh;

		}

		// suspension model
		if( o.brakeMesh ){

			this.brake = [];

			for( let i = 1; i<this.numWheel+1; i++ ) {
				back = i > 2;
				if( o.brakeMeshBack ) m = back ? o.brakeMeshBack.clone() : o.brakeMesh.clone();
				else m = o.brakeMesh.clone();
				Utils.noRay( m );
				m.position.set( 0, 0, 0 );
				m.position.fromArray(this.wheelsPosition[i-1]);
				if( o.brakeMeshBack ) pzz = scale;
				else pzz = back ? scale : -scale;
				if(i==2 || i ==4) m.scale.set( -scale, scale, pzz );
				else m.scale.set( scale, scale, pzz );
				this.children[0].add( m );
			    this.brake.push( m );

			}
			delete o.brakeMesh;

		}

		o.mass = this.mass;

		o.size = o.chassisShape ? chassisShapes[0].boxSize : this.size;
		o.numWheel = this.numWheel;
		o.wheelsPosition = this.wheelsPosition;
		o.radius = this.radius;
		o.radiusBack = this.radiusBack;
		o.deep = this.deep;
		o.deepBack = this.deepBack;

		o.chassisShape = chassisShapes[0];

		o.maxSteering = this.maxSteering;
		o.incSteering = this.incSteering;
		o.s_travel = this.s_travel;

		o.massCenter = this.massCenter;
		o.chassisPos = this.chassisPos;

		this.o = o;

	}

	respawn ( o ) {

		//{ pos:[0,0,0], rot:[0,0,0], keepVelocity:false }

		o = o || {};
		o.respawn = true;
		o.name = this.name;

		if( o.keepRotation ) o.quat = this.quaternion.toArray();


		//root.view.up( o );
		root.motor.change( o );

	}

	move(){

		/*phy.update({ 
		    name:this.name,
		    key: key
		});*/
	}

	dispose (){

		/*if(this.withBody){
			root.content.remove( this.body );
		}*/

		//root.remove( this.name + '_chassis' );
	}

	step ( AR, n ) {

		if( !this.actif ){
			let a = AR[n+0]+AR[n+1]+AR[n+2]+AR[n+3]+ AR[n+4]+AR[n+5]+AR[n+6]+AR[n+7];
			if( a===0 ) return;
			else this.actif = true;
		}

		

		this.position.fromArray( AR, n + 1 );
		this.quaternion.fromArray( AR, n + 4 );
		this.updateMatrix();

		let num = this.numWheel+1;
		let mesh;
		let s1 = 0, s2 = 0;
		let sp = [];
		let k = 0;

		for( let i = 0; i<num; i++ ){

			k = (i*8) + n;

			if(i===0) ( ( AR[ k ] ) / this.circum );
			if(i===1) s1 = AR[ k ];
			if(i===2) s2 = AR[ k ]; 
			
			mesh = this.children[i];
			

			if( mesh && i>0 ){

				//sp[i-1] = this.wheelsPosition[i-1][1] - AR[k+2]
				sp[i-1] = (this.wheelsPosition[i-1][1] - this.decaly ) - AR[k+2];

				// local
				
				mesh.position.fromArray( AR, k + 1 );
				//mesh.position.y += this.massCenter[1]
				mesh.quaternion.fromArray( AR, k + 4 );

				this.rolling[i-1] = mesh.rotation.x;

				if(this.brake){
					this.brake[i-1].position.copy( mesh.position );
					if(i==1 || i==2) this.brake[i-1].rotation.y = AR[k];
				}

			}

		}

		
		k = 4;
		while(k--){

			this.suspension[k] = MathTool.clamp( sp[k]*this.s_ratio, -1, 1 );
			
			if(this.suspensionMesh ){
				if ( this.suspension[k] > 0 ) {
					Utils.morph( this.suspensionMesh[k].children[0], 'low', this.suspension[k] );
					Utils.morph( this.suspensionMesh[k].children[0], 'top', 0 );
				} else {
					Utils.morph( this.suspensionMesh[k].children[0], 'low', 0 );
					Utils.morph( this.suspensionMesh[k].children[0], 'top', -this.suspension[k] );
				}
			}

		} 

		this.steering = Math.round(((s1+s2)*0.5)*todeg$1) / this.maxSteering;
		
		//console.log(this.steering)
		//console.log(acc)




	}
}

/**
 * The KHR_mesh_quantization extension allows these extra attribute component types
 *
 * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes
 */
const KHR_mesh_quantization_ExtraAttrTypes = {
	POSITION: [
		'byte',
		'byte normalized',
		'unsigned byte',
		'unsigned byte normalized',
		'short',
		'short normalized',
		'unsigned short',
		'unsigned short normalized',
	],
	NORMAL: [
		'byte normalized',
		'short normalized',
	],
	TANGENT: [
		'byte normalized',
		'short normalized',
	],
	TEXCOORD: [
		'byte',
		'byte normalized',
		'unsigned byte',
		'short',
		'short normalized',
		'unsigned short',
	],
};


class GLTFExporter {

	constructor() {

		this.pluginCallbacks = [];

		this.register( function ( writer ) {

			return new GLTFLightExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsUnlitExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsTransmissionExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsVolumeExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsIorExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsSpecularExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsClearcoatExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsIridescenceExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsSheenExtension( writer );

		} );

		this.register( function ( writer ) {

			return new GLTFMaterialsEmissiveStrengthExtension( writer );

		} );

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	/**
	 * Parse scenes and generate GLTF output
	 * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
	 * @param  {Function} onDone  Callback on completed
	 * @param  {Function} onError  Callback on errors
	 * @param  {Object} options options
	 */
	parse( input, onDone, onError, options ) {

		const writer = new GLTFWriter();
		const plugins = [];

		for ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {

			plugins.push( this.pluginCallbacks[ i ]( writer ) );

		}

		writer.setPlugins( plugins );
		writer.write( input, onDone, options ).catch( onError );

	}

	parseAsync( input, options ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( input, resolve, reject, options );

		} );

	}

}

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const WEBGL_CONSTANTS = {
	POINTS: 0x0000,
	LINES: 0x0001,
	LINE_LOOP: 0x0002,
	LINE_STRIP: 0x0003,
	TRIANGLES: 0x0004,
	TRIANGLE_STRIP: 0x0005,
	TRIANGLE_FAN: 0x0006,

	BYTE: 0x1400,
	UNSIGNED_BYTE: 0x1401,
	SHORT: 0x1402,
	UNSIGNED_SHORT: 0x1403,
	INT: 0x1404,
	UNSIGNED_INT: 0x1405,
	FLOAT: 0x1406,

	ARRAY_BUFFER: 0x8892,
	ELEMENT_ARRAY_BUFFER: 0x8893,

	NEAREST: 0x2600,
	LINEAR: 0x2601,
	NEAREST_MIPMAP_NEAREST: 0x2700,
	LINEAR_MIPMAP_NEAREST: 0x2701,
	NEAREST_MIPMAP_LINEAR: 0x2702,
	LINEAR_MIPMAP_LINEAR: 0x2703,

	CLAMP_TO_EDGE: 33071,
	MIRRORED_REPEAT: 33648,
	REPEAT: 10497
};

const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';

const THREE_TO_WEBGL = {};

THREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;

THREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;

const PATH_PROPERTIES = {
	scale: 'scale',
	position: 'translation',
	quaternion: 'rotation',
	morphTargetInfluences: 'weights'
};

const DEFAULT_SPECULAR_COLOR = new Color();

// GLB constants
// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

const GLB_HEADER_BYTES = 12;
const GLB_HEADER_MAGIC = 0x46546C67;
const GLB_VERSION = 2;

const GLB_CHUNK_PREFIX_BYTES = 8;
const GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
const GLB_CHUNK_TYPE_BIN = 0x004E4942;

//------------------------------------------------------------------------------
// Utility functions
//------------------------------------------------------------------------------

/**
 * Compare two arrays
 * @param  {Array} array1 Array 1 to compare
 * @param  {Array} array2 Array 2 to compare
 * @return {Boolean}        Returns true if both arrays are equal
 */
function equalArray( array1, array2 ) {

	return ( array1.length === array2.length ) && array1.every( function ( element, index ) {

		return element === array2[ index ];

	} );

}

/**
 * Converts a string to an ArrayBuffer.
 * @param  {string} text
 * @return {ArrayBuffer}
 */
function stringToArrayBuffer( text ) {

	return new TextEncoder().encode( text ).buffer;

}

/**
 * Is identity matrix
 *
 * @param {Matrix4} matrix
 * @returns {Boolean} Returns true, if parameter is identity matrix
 */
function isIdentityMatrix( matrix ) {

	return equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );

}

/**
 * Get the min and max vectors from the given attribute
 * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count
 * @param  {Integer} start
 * @param  {Integer} count
 * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)
 */
function getMinMax( attribute, start, count ) {

	const output = {

		min: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),
		max: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )

	};

	for ( let i = start; i < start + count; i ++ ) {

		for ( let a = 0; a < attribute.itemSize; a ++ ) {

			let value;

			if ( attribute.itemSize > 4 ) {

				 // no support for interleaved data for itemSize > 4

				value = attribute.array[ i * attribute.itemSize + a ];

			} else {

				if ( a === 0 ) value = attribute.getX( i );
				else if ( a === 1 ) value = attribute.getY( i );
				else if ( a === 2 ) value = attribute.getZ( i );
				else if ( a === 3 ) value = attribute.getW( i );

				if ( attribute.normalized === true ) {

					value = MathUtils.normalize( value, attribute.array );

				}

			}

			output.min[ a ] = Math.min( output.min[ a ], value );
			output.max[ a ] = Math.max( output.max[ a ], value );

		}

	}

	return output;

}

/**
 * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
 * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
 *
 * @param {Integer} bufferSize The size the original buffer.
 * @returns {Integer} new buffer size with required padding.
 *
 */
function getPaddedBufferSize( bufferSize ) {

	return Math.ceil( bufferSize / 4 ) * 4;

}

/**
 * Returns a buffer aligned to 4-byte boundary.
 *
 * @param {ArrayBuffer} arrayBuffer Buffer to pad
 * @param {Integer} paddingByte (Optional)
 * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
 */
function getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {

	const paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );

	if ( paddedLength !== arrayBuffer.byteLength ) {

		const array = new Uint8Array( paddedLength );
		array.set( new Uint8Array( arrayBuffer ) );

		if ( paddingByte !== 0 ) {

			for ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {

				array[ i ] = paddingByte;

			}

		}

		return array.buffer;

	}

	return arrayBuffer;

}

function getCanvas() {

	if ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {

		return new OffscreenCanvas( 1, 1 );

	}

	return document.createElement( 'canvas' );

}

function getToBlobPromise( canvas, mimeType ) {

	if ( canvas.toBlob !== undefined ) {

		return new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );

	}

	let quality;

	// Blink's implementation of convertToBlob seems to default to a quality level of 100%
	// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.
	if ( mimeType === 'image/jpeg' ) {

		quality = 0.92;

	} else if ( mimeType === 'image/webp' ) {

		quality = 0.8;

	}

	return canvas.convertToBlob( {

		type: mimeType,
		quality: quality

	} );

}

/**
 * Writer
 */
class GLTFWriter {

	constructor() {

		this.plugins = [];

		this.options = {};
		this.pending = [];
		this.buffers = [];

		this.byteOffset = 0;
		this.buffers = [];
		this.nodeMap = new Map();
		this.skins = [];

		this.extensionsUsed = {};
		this.extensionsRequired = {};

		this.uids = new Map();
		this.uid = 0;

		this.json = {
			asset: {
				version: '2.0',
				generator: 'THREE.GLTFExporter'
			}
		};

		this.cache = {
			meshes: new Map(),
			attributes: new Map(),
			attributesNormalized: new Map(),
			materials: new Map(),
			textures: new Map(),
			images: new Map()
		};

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	/**
	 * Parse scenes and generate GLTF output
	 * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
	 * @param  {Function} onDone  Callback on completed
	 * @param  {Object} options options
	 */
	async write( input, onDone, options = {} ) {

		this.options = Object.assign( {
			// default options
			binary: false,
			trs: false,
			onlyVisible: true,
			maxTextureSize: Infinity,
			animations: [],
			includeCustomExtensions: false
		}, options );

		if ( this.options.animations.length > 0 ) {

			// Only TRS properties, and not matrices, may be targeted by animation.
			this.options.trs = true;

		}

		this.processInput( input );

		await Promise.all( this.pending );

		const writer = this;
		const buffers = writer.buffers;
		const json = writer.json;
		options = writer.options;

		const extensionsUsed = writer.extensionsUsed;
		const extensionsRequired = writer.extensionsRequired;

		// Merge buffers.
		const blob = new Blob( buffers, { type: 'application/octet-stream' } );

		// Declare extensions.
		const extensionsUsedList = Object.keys( extensionsUsed );
		const extensionsRequiredList = Object.keys( extensionsRequired );

		if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;
		if ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;

		// Update bytelength of the single buffer.
		if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

		if ( options.binary === true ) {

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

			const reader = new FileReader();
			reader.readAsArrayBuffer( blob );
			reader.onloadend = function () {

				// Binary chunk.
				const binaryChunk = getPaddedArrayBuffer( reader.result );
				const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
				binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );
				binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );

				// JSON chunk.
				const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );
				const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
				jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );
				jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );

				// GLB header.
				const header = new ArrayBuffer( GLB_HEADER_BYTES );
				const headerView = new DataView( header );
				headerView.setUint32( 0, GLB_HEADER_MAGIC, true );
				headerView.setUint32( 4, GLB_VERSION, true );
				const totalByteLength = GLB_HEADER_BYTES
					+ jsonChunkPrefix.byteLength + jsonChunk.byteLength
					+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;
				headerView.setUint32( 8, totalByteLength, true );

				const glbBlob = new Blob( [
					header,
					jsonChunkPrefix,
					jsonChunk,
					binaryChunkPrefix,
					binaryChunk
				], { type: 'application/octet-stream' } );

				const glbReader = new FileReader();
				glbReader.readAsArrayBuffer( glbBlob );
				glbReader.onloadend = function () {

					onDone( glbReader.result );

				};

			};

		} else {

			if ( json.buffers && json.buffers.length > 0 ) {

				const reader = new FileReader();
				reader.readAsDataURL( blob );
				reader.onloadend = function () {

					const base64data = reader.result;
					json.buffers[ 0 ].uri = base64data;
					onDone( json );

				};

			} else {

				onDone( json );

			}

		}


	}

	/**
	 * Serializes a userData.
	 *
	 * @param {THREE.Object3D|THREE.Material} object
	 * @param {Object} objectDef
	 */
	serializeUserData( object, objectDef ) {

		if ( Object.keys( object.userData ).length === 0 ) return;

		const options = this.options;
		const extensionsUsed = this.extensionsUsed;

		try {

			const json = JSON.parse( JSON.stringify( object.userData ) );

			if ( options.includeCustomExtensions && json.gltfExtensions ) {

				if ( objectDef.extensions === undefined ) objectDef.extensions = {};

				for ( const extensionName in json.gltfExtensions ) {

					objectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];
					extensionsUsed[ extensionName ] = true;

				}

				delete json.gltfExtensions;

			}

			if ( Object.keys( json ).length > 0 ) objectDef.extras = json;

		} catch ( error ) {

			console.warn( 'THREE.GLTFExporter: userData of \'' + object.name + '\' ' +
				'won\'t be serialized because of JSON.stringify error - ' + error.message );

		}

	}

	/**
	 * Returns ids for buffer attributes.
	 * @param  {Object} object
	 * @return {Integer}
	 */
	getUID( attribute, isRelativeCopy = false ) {

		if ( this.uids.has( attribute ) === false ) {

			const uids = new Map();

			uids.set( true, this.uid ++ );
			uids.set( false, this.uid ++ );

			this.uids.set( attribute, uids );

		}

		const uids = this.uids.get( attribute );

		return uids.get( isRelativeCopy );

	}

	/**
	 * Checks if normal attribute values are normalized.
	 *
	 * @param {BufferAttribute} normal
	 * @returns {Boolean}
	 */
	isNormalizedNormalAttribute( normal ) {

		const cache = this.cache;

		if ( cache.attributesNormalized.has( normal ) ) return false;

		const v = new Vector3();

		for ( let i = 0, il = normal.count; i < il; i ++ ) {

			// 0.0005 is from glTF-validator
			if ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;

		}

		return true;

	}

	/**
	 * Creates normalized normal buffer attribute.
	 *
	 * @param {BufferAttribute} normal
	 * @returns {BufferAttribute}
	 *
	 */
	createNormalizedNormalAttribute( normal ) {

		const cache = this.cache;

		if ( cache.attributesNormalized.has( normal ) )	return cache.attributesNormalized.get( normal );

		const attribute = normal.clone();
		const v = new Vector3();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			v.fromBufferAttribute( attribute, i );

			if ( v.x === 0 && v.y === 0 && v.z === 0 ) {

				// if values can't be normalized set (1, 0, 0)
				v.setX( 1.0 );

			} else {

				v.normalize();

			}

			attribute.setXYZ( i, v.x, v.y, v.z );

		}

		cache.attributesNormalized.set( normal, attribute );

		return attribute;

	}

	/**
	 * Applies a texture transform, if present, to the map definition. Requires
	 * the KHR_texture_transform extension.
	 *
	 * @param {Object} mapDef
	 * @param {THREE.Texture} texture
	 */
	applyTextureTransform( mapDef, texture ) {

		let didTransform = false;
		const transformDef = {};

		if ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {

			transformDef.offset = texture.offset.toArray();
			didTransform = true;

		}

		if ( texture.rotation !== 0 ) {

			transformDef.rotation = texture.rotation;
			didTransform = true;

		}

		if ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {

			transformDef.scale = texture.repeat.toArray();
			didTransform = true;

		}

		if ( didTransform ) {

			mapDef.extensions = mapDef.extensions || {};
			mapDef.extensions[ 'KHR_texture_transform' ] = transformDef;
			this.extensionsUsed[ 'KHR_texture_transform' ] = true;

		}

	}

	buildMetalRoughTexture( metalnessMap, roughnessMap ) {

		if ( metalnessMap === roughnessMap ) return metalnessMap;

		function getEncodingConversion( map ) {

			if ( map.encoding === sRGBEncoding ) {

				return function SRGBToLinear( c ) {

					return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

				};

			}

			return function LinearToLinear( c ) {

				return c;

			};

		}

		console.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );

		const metalness = metalnessMap ? metalnessMap.image : null;
		const roughness = roughnessMap ? roughnessMap.image : null;

		const width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );
		const height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );

		const canvas = getCanvas();
		canvas.width = width;
		canvas.height = height;

		const context = canvas.getContext( '2d' );
		context.fillStyle = '#00ffff';
		context.fillRect( 0, 0, width, height );

		const composite = context.getImageData( 0, 0, width, height );

		if ( metalness ) {

			context.drawImage( metalness, 0, 0, width, height );

			const convert = getEncodingConversion( metalnessMap );
			const data = context.getImageData( 0, 0, width, height ).data;

			for ( let i = 2; i < data.length; i += 4 ) {

				composite.data[ i ] = convert( data[ i ] / 256 ) * 256;

			}

		}

		if ( roughness ) {

			context.drawImage( roughness, 0, 0, width, height );

			const convert = getEncodingConversion( roughnessMap );
			const data = context.getImageData( 0, 0, width, height ).data;

			for ( let i = 1; i < data.length; i += 4 ) {

				composite.data[ i ] = convert( data[ i ] / 256 ) * 256;

			}

		}

		context.putImageData( composite, 0, 0 );

		//

		const reference = metalnessMap || roughnessMap;

		const texture = reference.clone();

		texture.source = new Source( canvas );
		texture.encoding = LinearEncoding;

		return texture;

	}

	/**
	 * Process a buffer to append to the default one.
	 * @param  {ArrayBuffer} buffer
	 * @return {Integer}
	 */
	processBuffer( buffer ) {

		const json = this.json;
		const buffers = this.buffers;

		if ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];

		// All buffers are merged before export.
		buffers.push( buffer );

		return 0;

	}

	/**
	 * Process and generate a BufferView
	 * @param  {BufferAttribute} attribute
	 * @param  {number} componentType
	 * @param  {number} start
	 * @param  {number} count
	 * @param  {number} target (Optional) Target usage of the BufferView
	 * @return {Object}
	 */
	processBufferView( attribute, componentType, start, count, target ) {

		const json = this.json;

		if ( ! json.bufferViews ) json.bufferViews = [];

		// Create a new dataview and dump the attribute's array into it

		let componentSize;

		switch ( componentType ) {

			case WEBGL_CONSTANTS.BYTE:
			case WEBGL_CONSTANTS.UNSIGNED_BYTE:

				componentSize = 1;

				break;

			case WEBGL_CONSTANTS.SHORT:
			case WEBGL_CONSTANTS.UNSIGNED_SHORT:

				componentSize = 2;

				break;

			default:

				componentSize = 4;

		}

		const byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );
		const dataView = new DataView( new ArrayBuffer( byteLength ) );
		let offset = 0;

		for ( let i = start; i < start + count; i ++ ) {

			for ( let a = 0; a < attribute.itemSize; a ++ ) {

				let value;

				if ( attribute.itemSize > 4 ) {

					 // no support for interleaved data for itemSize > 4

					value = attribute.array[ i * attribute.itemSize + a ];

				} else {

					if ( a === 0 ) value = attribute.getX( i );
					else if ( a === 1 ) value = attribute.getY( i );
					else if ( a === 2 ) value = attribute.getZ( i );
					else if ( a === 3 ) value = attribute.getW( i );

					if ( attribute.normalized === true ) {

						value = MathUtils.normalize( value, attribute.array );

					}

				}

				if ( componentType === WEBGL_CONSTANTS.FLOAT ) {

					dataView.setFloat32( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.INT ) {

					dataView.setInt32( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {

					dataView.setUint32( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {

					dataView.setInt16( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

					dataView.setUint16( offset, value, true );

				} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {

					dataView.setInt8( offset, value );

				} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

					dataView.setUint8( offset, value );

				}

				offset += componentSize;

			}

		}

		const bufferViewDef = {

			buffer: this.processBuffer( dataView.buffer ),
			byteOffset: this.byteOffset,
			byteLength: byteLength

		};

		if ( target !== undefined ) bufferViewDef.target = target;

		if ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {

			// Only define byteStride for vertex attributes.
			bufferViewDef.byteStride = attribute.itemSize * componentSize;

		}

		this.byteOffset += byteLength;

		json.bufferViews.push( bufferViewDef );

		// @TODO Merge bufferViews where possible.
		const output = {

			id: json.bufferViews.length - 1,
			byteLength: 0

		};

		return output;

	}

	/**
	 * Process and generate a BufferView from an image Blob.
	 * @param {Blob} blob
	 * @return {Promise<Integer>}
	 */
	processBufferViewImage( blob ) {

		const writer = this;
		const json = writer.json;

		if ( ! json.bufferViews ) json.bufferViews = [];

		return new Promise( function ( resolve ) {

			const reader = new FileReader();
			reader.readAsArrayBuffer( blob );
			reader.onloadend = function () {

				const buffer = getPaddedArrayBuffer( reader.result );

				const bufferViewDef = {
					buffer: writer.processBuffer( buffer ),
					byteOffset: writer.byteOffset,
					byteLength: buffer.byteLength
				};

				writer.byteOffset += buffer.byteLength;
				resolve( json.bufferViews.push( bufferViewDef ) - 1 );

			};

		} );

	}

	/**
	 * Process attribute to generate an accessor
	 * @param  {BufferAttribute} attribute Attribute to process
	 * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
	 * @param  {Integer} start (Optional)
	 * @param  {Integer} count (Optional)
	 * @return {Integer|null} Index of the processed accessor on the "accessors" array
	 */
	processAccessor( attribute, geometry, start, count ) {

		const json = this.json;

		const types = {

			1: 'SCALAR',
			2: 'VEC2',
			3: 'VEC3',
			4: 'VEC4',
			9: 'MAT3',
			16: 'MAT4'

		};

		let componentType;

		// Detect the component type of the attribute array
		if ( attribute.array.constructor === Float32Array ) {

			componentType = WEBGL_CONSTANTS.FLOAT;

		} else if ( attribute.array.constructor === Int32Array ) {

			componentType = WEBGL_CONSTANTS.INT;

		} else if ( attribute.array.constructor === Uint32Array ) {

			componentType = WEBGL_CONSTANTS.UNSIGNED_INT;

		} else if ( attribute.array.constructor === Int16Array ) {

			componentType = WEBGL_CONSTANTS.SHORT;

		} else if ( attribute.array.constructor === Uint16Array ) {

			componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;

		} else if ( attribute.array.constructor === Int8Array ) {

			componentType = WEBGL_CONSTANTS.BYTE;

		} else if ( attribute.array.constructor === Uint8Array ) {

			componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;

		} else {

			throw new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );

		}

		if ( start === undefined ) start = 0;
		if ( count === undefined ) count = attribute.count;

		// Skip creating an accessor if the attribute doesn't have data to export
		if ( count === 0 ) return null;

		const minMax = getMinMax( attribute, start, count );
		let bufferViewTarget;

		// If geometry isn't provided, don't infer the target usage of the bufferView. For
		// animation samplers, target must not be set.
		if ( geometry !== undefined ) {

			bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;

		}

		const bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );

		const accessorDef = {

			bufferView: bufferView.id,
			byteOffset: bufferView.byteOffset,
			componentType: componentType,
			count: count,
			max: minMax.max,
			min: minMax.min,
			type: types[ attribute.itemSize ]

		};

		if ( attribute.normalized === true ) accessorDef.normalized = true;
		if ( ! json.accessors ) json.accessors = [];

		return json.accessors.push( accessorDef ) - 1;

	}

	/**
	 * Process image
	 * @param  {Image} image to process
	 * @param  {Integer} format of the image (RGBAFormat)
	 * @param  {Boolean} flipY before writing out the image
	 * @param  {String} mimeType export format
	 * @return {Integer}     Index of the processed texture in the "images" array
	 */
	processImage( image, format, flipY, mimeType = 'image/png' ) {

		if ( image !== null ) {

			const writer = this;
			const cache = writer.cache;
			const json = writer.json;
			const options = writer.options;
			const pending = writer.pending;

			if ( ! cache.images.has( image ) ) cache.images.set( image, {} );

			const cachedImages = cache.images.get( image );

			const key = mimeType + ':flipY/' + flipY.toString();

			if ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];

			if ( ! json.images ) json.images = [];

			const imageDef = { mimeType: mimeType };

			const canvas = getCanvas();

			canvas.width = Math.min( image.width, options.maxTextureSize );
			canvas.height = Math.min( image.height, options.maxTextureSize );

			const ctx = canvas.getContext( '2d' );

			if ( flipY === true ) {

				ctx.translate( 0, canvas.height );
				ctx.scale( 1, - 1 );

			}

			if ( image.data !== undefined ) { // THREE.DataTexture

				if ( format !== RGBAFormat ) {

					console.error( 'GLTFExporter: Only RGBAFormat is supported.' );

				}

				if ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {

					console.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );

				}

				const data = new Uint8ClampedArray( image.height * image.width * 4 );

				for ( let i = 0; i < data.length; i += 4 ) {

					data[ i + 0 ] = image.data[ i + 0 ];
					data[ i + 1 ] = image.data[ i + 1 ];
					data[ i + 2 ] = image.data[ i + 2 ];
					data[ i + 3 ] = image.data[ i + 3 ];

				}

				ctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );

			} else {

				ctx.drawImage( image, 0, 0, canvas.width, canvas.height );

			}

			if ( options.binary === true ) {

				pending.push(

					getToBlobPromise( canvas, mimeType )
						.then( blob => writer.processBufferViewImage( blob ) )
						.then( bufferViewIndex => {

							imageDef.bufferView = bufferViewIndex;

						} )

				);

			} else {

				if ( canvas.toDataURL !== undefined ) {

					imageDef.uri = canvas.toDataURL( mimeType );

				} else {

					pending.push(

						getToBlobPromise( canvas, mimeType )
							.then( blob => new FileReader().readAsDataURL( blob ) )
							.then( dataURL => {

								imageDef.uri = dataURL;

							} )

					);

				}

			}

			const index = json.images.push( imageDef ) - 1;
			cachedImages[ key ] = index;
			return index;

		} else {

			throw new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );

		}

	}

	/**
	 * Process sampler
	 * @param  {Texture} map Texture to process
	 * @return {Integer}     Index of the processed texture in the "samplers" array
	 */
	processSampler( map ) {

		const json = this.json;

		if ( ! json.samplers ) json.samplers = [];

		const samplerDef = {
			magFilter: THREE_TO_WEBGL[ map.magFilter ],
			minFilter: THREE_TO_WEBGL[ map.minFilter ],
			wrapS: THREE_TO_WEBGL[ map.wrapS ],
			wrapT: THREE_TO_WEBGL[ map.wrapT ]
		};

		return json.samplers.push( samplerDef ) - 1;

	}

	/**
	 * Process texture
	 * @param  {Texture} map Map to process
	 * @return {Integer} Index of the processed texture in the "textures" array
	 */
	processTexture( map ) {

		const cache = this.cache;
		const json = this.json;

		if ( cache.textures.has( map ) ) return cache.textures.get( map );

		if ( ! json.textures ) json.textures = [];

		let mimeType = map.userData.mimeType;

		if ( mimeType === 'image/webp' ) mimeType = 'image/png';

		const textureDef = {
			sampler: this.processSampler( map ),
			source: this.processImage( map.image, map.format, map.flipY, mimeType )
		};

		if ( map.name ) textureDef.name = map.name;

		this._invokeAll( function ( ext ) {

			ext.writeTexture && ext.writeTexture( map, textureDef );

		} );

		const index = json.textures.push( textureDef ) - 1;
		cache.textures.set( map, index );
		return index;

	}

	/**
	 * Process material
	 * @param  {THREE.Material} material Material to process
	 * @return {Integer|null} Index of the processed material in the "materials" array
	 */
	processMaterial( material ) {

		const cache = this.cache;
		const json = this.json;

		if ( cache.materials.has( material ) ) return cache.materials.get( material );

		if ( material.isShaderMaterial ) {

			console.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );
			return null;

		}

		if ( ! json.materials ) json.materials = [];

		// @QUESTION Should we avoid including any attribute that has the default value?
		const materialDef = {	pbrMetallicRoughness: {} };

		if ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {

			console.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );

		}

		// pbrMetallicRoughness.baseColorFactor
		const color = material.color.toArray().concat( [ material.opacity ] );

		if ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {

			materialDef.pbrMetallicRoughness.baseColorFactor = color;

		}

		if ( material.isMeshStandardMaterial ) {

			materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
			materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;

		} else {

			materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
			materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;

		}

		// pbrMetallicRoughness.metallicRoughnessTexture
		if ( material.metalnessMap || material.roughnessMap ) {

			const metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );

			const metalRoughMapDef = { index: this.processTexture( metalRoughTexture ) };
			this.applyTextureTransform( metalRoughMapDef, metalRoughTexture );
			materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;

		}

		// pbrMetallicRoughness.baseColorTexture
		if ( material.map ) {

			const baseColorMapDef = { index: this.processTexture( material.map ) };
			this.applyTextureTransform( baseColorMapDef, material.map );
			materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;

		}

		if ( material.emissive ) {

			const emissive = material.emissive;
			const maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );

			if ( maxEmissiveComponent > 0 ) {

				materialDef.emissiveFactor = material.emissive.toArray();

			}

			// emissiveTexture
			if ( material.emissiveMap ) {

				const emissiveMapDef = { index: this.processTexture( material.emissiveMap ) };
				this.applyTextureTransform( emissiveMapDef, material.emissiveMap );
				materialDef.emissiveTexture = emissiveMapDef;

			}

		}

		// normalTexture
		if ( material.normalMap ) {

			const normalMapDef = { index: this.processTexture( material.normalMap ) };

			if ( material.normalScale && material.normalScale.x !== 1 ) {

				// glTF normal scale is univariate. Ignore `y`, which may be flipped.
				// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
				normalMapDef.scale = material.normalScale.x;

			}

			this.applyTextureTransform( normalMapDef, material.normalMap );
			materialDef.normalTexture = normalMapDef;

		}

		// occlusionTexture
		if ( material.aoMap ) {

			const occlusionMapDef = {
				index: this.processTexture( material.aoMap ),
				texCoord: 1
			};

			if ( material.aoMapIntensity !== 1.0 ) {

				occlusionMapDef.strength = material.aoMapIntensity;

			}

			this.applyTextureTransform( occlusionMapDef, material.aoMap );
			materialDef.occlusionTexture = occlusionMapDef;

		}

		// alphaMode
		if ( material.transparent ) {

			materialDef.alphaMode = 'BLEND';

		} else {

			if ( material.alphaTest > 0.0 ) {

				materialDef.alphaMode = 'MASK';
				materialDef.alphaCutoff = material.alphaTest;

			}

		}

		// doubleSided
		if ( material.side === DoubleSide ) materialDef.doubleSided = true;
		if ( material.name !== '' ) materialDef.name = material.name;

		this.serializeUserData( material, materialDef );

		this._invokeAll( function ( ext ) {

			ext.writeMaterial && ext.writeMaterial( material, materialDef );

		} );

		const index = json.materials.push( materialDef ) - 1;
		cache.materials.set( material, index );
		return index;

	}

	/**
	 * Process mesh
	 * @param  {THREE.Mesh} mesh Mesh to process
	 * @return {Integer|null} Index of the processed mesh in the "meshes" array
	 */
	processMesh( mesh ) {

		const cache = this.cache;
		const json = this.json;

		const meshCacheKeyParts = [ mesh.geometry.uuid ];

		if ( Array.isArray( mesh.material ) ) {

			for ( let i = 0, l = mesh.material.length; i < l; i ++ ) {

				meshCacheKeyParts.push( mesh.material[ i ].uuid	);

			}

		} else {

			meshCacheKeyParts.push( mesh.material.uuid );

		}

		const meshCacheKey = meshCacheKeyParts.join( ':' );

		if ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );

		const geometry = mesh.geometry;

		let mode;

		// Use the correct mode
		if ( mesh.isLineSegments ) {

			mode = WEBGL_CONSTANTS.LINES;

		} else if ( mesh.isLineLoop ) {

			mode = WEBGL_CONSTANTS.LINE_LOOP;

		} else if ( mesh.isLine ) {

			mode = WEBGL_CONSTANTS.LINE_STRIP;

		} else if ( mesh.isPoints ) {

			mode = WEBGL_CONSTANTS.POINTS;

		} else {

			mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;

		}

		const meshDef = {};
		const attributes = {};
		const primitives = [];
		const targets = [];

		// Conversion between attributes names in threejs and gltf spec
		const nameConversion = {
			uv: 'TEXCOORD_0',
			uv2: 'TEXCOORD_1',
			color: 'COLOR_0',
			skinWeight: 'WEIGHTS_0',
			skinIndex: 'JOINTS_0'
		};

		const originalNormal = geometry.getAttribute( 'normal' );

		if ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {

			console.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );

			geometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );

		}

		// @QUESTION Detect if .vertexColors = true?
		// For every attribute create an accessor
		let modifiedAttribute = null;

		for ( let attributeName in geometry.attributes ) {

			// Ignore morph target attributes, which are exported later.
			if ( attributeName.slice( 0, 5 ) === 'morph' ) continue;

			const attribute = geometry.attributes[ attributeName ];
			attributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();

			// Prefix all geometry attributes except the ones specifically
			// listed in the spec; non-spec attributes are considered custom.
			const validVertexAttributes =
					/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;

			if ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;

			if ( cache.attributes.has( this.getUID( attribute ) ) ) {

				attributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );
				continue;

			}

			// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.
			modifiedAttribute = null;
			const array = attribute.array;

			if ( attributeName === 'JOINTS_0' &&
				! ( array instanceof Uint16Array ) &&
				! ( array instanceof Uint8Array ) ) {

				console.warn( 'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.' );
				modifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );

			}

			const accessor = this.processAccessor( modifiedAttribute || attribute, geometry );

			if ( accessor !== null ) {

				if ( ! attributeName.startsWith( '_' ) ) {

					this.detectMeshQuantization( attributeName, attribute );

				}

				attributes[ attributeName ] = accessor;
				cache.attributes.set( this.getUID( attribute ), accessor );

			}

		}

		if ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );

		// Skip if no exportable attributes found
		if ( Object.keys( attributes ).length === 0 ) return null;

		// Morph targets
		if ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {

			const weights = [];
			const targetNames = [];
			const reverseDictionary = {};

			if ( mesh.morphTargetDictionary !== undefined ) {

				for ( const key in mesh.morphTargetDictionary ) {

					reverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;

				}

			}

			for ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {

				const target = {};
				let warned = false;

				for ( const attributeName in geometry.morphAttributes ) {

					// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.
					// Three.js doesn't support TANGENT yet.

					if ( attributeName !== 'position' && attributeName !== 'normal' ) {

						if ( ! warned ) {

							console.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );
							warned = true;

						}

						continue;

					}

					const attribute = geometry.morphAttributes[ attributeName ][ i ];
					const gltfAttributeName = attributeName.toUpperCase();

					// Three.js morph attribute has absolute values while the one of glTF has relative values.
					//
					// glTF 2.0 Specification:
					// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

					const baseAttribute = geometry.attributes[ attributeName ];

					if ( cache.attributes.has( this.getUID( attribute, true ) ) ) {

						target[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );
						continue;

					}

					// Clones attribute not to override
					const relativeAttribute = attribute.clone();

					if ( ! geometry.morphTargetsRelative ) {

						for ( let j = 0, jl = attribute.count; j < jl; j ++ ) {

							for ( let a = 0; a < attribute.itemSize; a ++ ) {

								if ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );
								if ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );
								if ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );
								if ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );

							}

						}

					}

					target[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );
					cache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );

				}

				targets.push( target );

				weights.push( mesh.morphTargetInfluences[ i ] );

				if ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );

			}

			meshDef.weights = weights;

			if ( targetNames.length > 0 ) {

				meshDef.extras = {};
				meshDef.extras.targetNames = targetNames;

			}

		}

		const isMultiMaterial = Array.isArray( mesh.material );

		if ( isMultiMaterial && geometry.groups.length === 0 ) return null;

		const materials = isMultiMaterial ? mesh.material : [ mesh.material ];
		const groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];

		for ( let i = 0, il = groups.length; i < il; i ++ ) {

			const primitive = {
				mode: mode,
				attributes: attributes,
			};

			this.serializeUserData( geometry, primitive );

			if ( targets.length > 0 ) primitive.targets = targets;

			if ( geometry.index !== null ) {

				let cacheKey = this.getUID( geometry.index );

				if ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {

					cacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;

				}

				if ( cache.attributes.has( cacheKey ) ) {

					primitive.indices = cache.attributes.get( cacheKey );

				} else {

					primitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );
					cache.attributes.set( cacheKey, primitive.indices );

				}

				if ( primitive.indices === null ) delete primitive.indices;

			}

			const material = this.processMaterial( materials[ groups[ i ].materialIndex ] );

			if ( material !== null ) primitive.material = material;

			primitives.push( primitive );

		}

		meshDef.primitives = primitives;

		if ( ! json.meshes ) json.meshes = [];

		this._invokeAll( function ( ext ) {

			ext.writeMesh && ext.writeMesh( mesh, meshDef );

		} );

		const index = json.meshes.push( meshDef ) - 1;
		cache.meshes.set( meshCacheKey, index );
		return index;

	}

	/**
	 * If a vertex attribute with a
	 * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
	 * is used, it is checked whether it is a valid data type according to the
	 * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
	 * extension.
	 * In this case the extension is automatically added to the list of used extensions.
	 *
	 * @param {string} attributeName
	 * @param {THREE.BufferAttribute} attribute
	 */
	detectMeshQuantization( attributeName, attribute ) {

		if ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;

		let attrType = undefined;

		switch ( attribute.array.constructor ) {

			case Int8Array:

				attrType = 'byte';

				break;

			case Uint8Array:

				attrType = 'unsigned byte';

				break;

			case Int16Array:

				attrType = 'short';

				break;

			case Uint16Array:

				attrType = 'unsigned short';

				break;

			default:

				return;

		}

		if ( attribute.normalized ) attrType += ' normalized';

		const attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];

		if ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {

			this.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;
			this.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;

		}

	}

	/**
	 * Process camera
	 * @param  {THREE.Camera} camera Camera to process
	 * @return {Integer}      Index of the processed mesh in the "camera" array
	 */
	processCamera( camera ) {

		const json = this.json;

		if ( ! json.cameras ) json.cameras = [];

		const isOrtho = camera.isOrthographicCamera;

		const cameraDef = {
			type: isOrtho ? 'orthographic' : 'perspective'
		};

		if ( isOrtho ) {

			cameraDef.orthographic = {
				xmag: camera.right * 2,
				ymag: camera.top * 2,
				zfar: camera.far <= 0 ? 0.001 : camera.far,
				znear: camera.near < 0 ? 0 : camera.near
			};

		} else {

			cameraDef.perspective = {
				aspectRatio: camera.aspect,
				yfov: MathUtils.degToRad( camera.fov ),
				zfar: camera.far <= 0 ? 0.001 : camera.far,
				znear: camera.near < 0 ? 0 : camera.near
			};

		}

		// Question: Is saving "type" as name intentional?
		if ( camera.name !== '' ) cameraDef.name = camera.type;

		return json.cameras.push( cameraDef ) - 1;

	}

	/**
	 * Creates glTF animation entry from AnimationClip object.
	 *
	 * Status:
	 * - Only properties listed in PATH_PROPERTIES may be animated.
	 *
	 * @param {THREE.AnimationClip} clip
	 * @param {THREE.Object3D} root
	 * @return {number|null}
	 */
	processAnimation( clip, root ) {

		const json = this.json;
		const nodeMap = this.nodeMap;

		if ( ! json.animations ) json.animations = [];

		clip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );

		const tracks = clip.tracks;
		const channels = [];
		const samplers = [];

		for ( let i = 0; i < tracks.length; ++ i ) {

			const track = tracks[ i ];
			const trackBinding = PropertyBinding.parseTrackName( track.name );
			let trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );
			const trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];

			if ( trackBinding.objectName === 'bones' ) {

				if ( trackNode.isSkinnedMesh === true ) {

					trackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );

				} else {

					trackNode = undefined;

				}

			}

			if ( ! trackNode || ! trackProperty ) {

				console.warn( 'THREE.GLTFExporter: Could not export animation track "%s".', track.name );
				return null;

			}

			const inputItemSize = 1;
			let outputItemSize = track.values.length / track.times.length;

			if ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {

				outputItemSize /= trackNode.morphTargetInfluences.length;

			}

			let interpolation;

			// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE

			// Detecting glTF cubic spline interpolant by checking factory method's special property
			// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return
			// valid value from .getInterpolation().
			if ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {

				interpolation = 'CUBICSPLINE';

				// itemSize of CUBICSPLINE keyframe is 9
				// (VEC3 * 3: inTangent, splineVertex, and outTangent)
				// but needs to be stored as VEC3 so dividing by 3 here.
				outputItemSize /= 3;

			} else if ( track.getInterpolation() === InterpolateDiscrete ) {

				interpolation = 'STEP';

			} else {

				interpolation = 'LINEAR';

			}

			samplers.push( {
				input: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),
				output: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),
				interpolation: interpolation
			} );

			channels.push( {
				sampler: samplers.length - 1,
				target: {
					node: nodeMap.get( trackNode ),
					path: trackProperty
				}
			} );

		}

		json.animations.push( {
			name: clip.name || 'clip_' + json.animations.length,
			samplers: samplers,
			channels: channels
		} );

		return json.animations.length - 1;

	}

	/**
	 * @param {THREE.Object3D} object
	 * @return {number|null}
	 */
	 processSkin( object ) {

		const json = this.json;
		const nodeMap = this.nodeMap;

		const node = json.nodes[ nodeMap.get( object ) ];

		const skeleton = object.skeleton;

		if ( skeleton === undefined ) return null;

		const rootJoint = object.skeleton.bones[ 0 ];

		if ( rootJoint === undefined ) return null;

		const joints = [];
		const inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );
		const temporaryBoneInverse = new Matrix4();

		for ( let i = 0; i < skeleton.bones.length; ++ i ) {

			joints.push( nodeMap.get( skeleton.bones[ i ] ) );
			temporaryBoneInverse.copy( skeleton.boneInverses[ i ] );
			temporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );

		}

		if ( json.skins === undefined ) json.skins = [];

		json.skins.push( {
			inverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),
			joints: joints,
			skeleton: nodeMap.get( rootJoint )
		} );

		const skinIndex = node.skin = json.skins.length - 1;

		return skinIndex;

	}

	/**
	 * Process Object3D node
	 * @param  {THREE.Object3D} node Object3D to processNode
	 * @return {Integer} Index of the node in the nodes list
	 */
	processNode( object ) {

		const json = this.json;
		const options = this.options;
		const nodeMap = this.nodeMap;

		if ( ! json.nodes ) json.nodes = [];

		const nodeDef = {};

		if ( options.trs ) {

			const rotation = object.quaternion.toArray();
			const position = object.position.toArray();
			const scale = object.scale.toArray();

			if ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {

				nodeDef.rotation = rotation;

			}

			if ( ! equalArray( position, [ 0, 0, 0 ] ) ) {

				nodeDef.translation = position;

			}

			if ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {

				nodeDef.scale = scale;

			}

		} else {

			if ( object.matrixAutoUpdate ) {

				object.updateMatrix();

			}

			if ( isIdentityMatrix( object.matrix ) === false ) {

				nodeDef.matrix = object.matrix.elements;

			}

		}

		// We don't export empty strings name because it represents no-name in Three.js.
		if ( object.name !== '' ) nodeDef.name = String( object.name );

		this.serializeUserData( object, nodeDef );

		if ( object.isMesh || object.isLine || object.isPoints ) {

			const meshIndex = this.processMesh( object );

			if ( meshIndex !== null ) nodeDef.mesh = meshIndex;

		} else if ( object.isCamera ) {

			nodeDef.camera = this.processCamera( object );

		}

		if ( object.isSkinnedMesh ) this.skins.push( object );

		if ( object.children.length > 0 ) {

			const children = [];

			for ( let i = 0, l = object.children.length; i < l; i ++ ) {

				const child = object.children[ i ];

				if ( child.visible || options.onlyVisible === false ) {

					const nodeIndex = this.processNode( child );

					if ( nodeIndex !== null ) children.push( nodeIndex );

				}

			}

			if ( children.length > 0 ) nodeDef.children = children;

		}

		this._invokeAll( function ( ext ) {

			ext.writeNode && ext.writeNode( object, nodeDef );

		} );

		const nodeIndex = json.nodes.push( nodeDef ) - 1;
		nodeMap.set( object, nodeIndex );
		return nodeIndex;

	}

	/**
	 * Process Scene
	 * @param  {Scene} node Scene to process
	 */
	processScene( scene ) {

		const json = this.json;
		const options = this.options;

		if ( ! json.scenes ) {

			json.scenes = [];
			json.scene = 0;

		}

		const sceneDef = {};

		if ( scene.name !== '' ) sceneDef.name = scene.name;

		json.scenes.push( sceneDef );

		const nodes = [];

		for ( let i = 0, l = scene.children.length; i < l; i ++ ) {

			const child = scene.children[ i ];

			if ( child.visible || options.onlyVisible === false ) {

				const nodeIndex = this.processNode( child );

				if ( nodeIndex !== null ) nodes.push( nodeIndex );

			}

		}

		if ( nodes.length > 0 ) sceneDef.nodes = nodes;

		this.serializeUserData( scene, sceneDef );

	}

	/**
	 * Creates a Scene to hold a list of objects and parse it
	 * @param  {Array} objects List of objects to process
	 */
	processObjects( objects ) {

		const scene = new Scene();
		scene.name = 'AuxScene';

		for ( let i = 0; i < objects.length; i ++ ) {

			// We push directly to children instead of calling `add` to prevent
			// modify the .parent and break its original scene and hierarchy
			scene.children.push( objects[ i ] );

		}

		this.processScene( scene );

	}

	/**
	 * @param {THREE.Object3D|Array<THREE.Object3D>} input
	 */
	processInput( input ) {

		const options = this.options;

		input = input instanceof Array ? input : [ input ];

		this._invokeAll( function ( ext ) {

			ext.beforeParse && ext.beforeParse( input );

		} );

		const objectsWithoutScene = [];

		for ( let i = 0; i < input.length; i ++ ) {

			if ( input[ i ] instanceof Scene ) {

				this.processScene( input[ i ] );

			} else {

				objectsWithoutScene.push( input[ i ] );

			}

		}

		if ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );

		for ( let i = 0; i < this.skins.length; ++ i ) {

			this.processSkin( this.skins[ i ] );

		}

		for ( let i = 0; i < options.animations.length; ++ i ) {

			this.processAnimation( options.animations[ i ], input[ 0 ] );

		}

		this._invokeAll( function ( ext ) {

			ext.afterParse && ext.afterParse( input );

		} );

	}

	_invokeAll( func ) {

		for ( let i = 0, il = this.plugins.length; i < il; i ++ ) {

			func( this.plugins[ i ] );

		}

	}

}

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_lights_punctual';

	}

	writeNode( light, nodeDef ) {

		if ( ! light.isLight ) return;

		if ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {

			console.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );
			return;

		}

		const writer = this.writer;
		const json = writer.json;
		const extensionsUsed = writer.extensionsUsed;

		const lightDef = {};

		if ( light.name ) lightDef.name = light.name;

		lightDef.color = light.color.toArray();

		lightDef.intensity = light.intensity;

		if ( light.isDirectionalLight ) {

			lightDef.type = 'directional';

		} else if ( light.isPointLight ) {

			lightDef.type = 'point';

			if ( light.distance > 0 ) lightDef.range = light.distance;

		} else if ( light.isSpotLight ) {

			lightDef.type = 'spot';

			if ( light.distance > 0 ) lightDef.range = light.distance;

			lightDef.spot = {};
			lightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;
			lightDef.spot.outerConeAngle = light.angle;

		}

		if ( light.decay !== undefined && light.decay !== 2 ) {

			console.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '
				+ 'and expects light.decay=2.' );

		}

		if ( light.target
				&& ( light.target.parent !== light
				|| light.target.position.x !== 0
				|| light.target.position.y !== 0
				|| light.target.position.z !== - 1 ) ) {

			console.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '
				+ 'make light.target a child of the light with position 0,0,-1.' );

		}

		if ( ! extensionsUsed[ this.name ] ) {

			json.extensions = json.extensions || {};
			json.extensions[ this.name ] = { lights: [] };
			extensionsUsed[ this.name ] = true;

		}

		const lights = json.extensions[ this.name ].lights;
		lights.push( lightDef );

		nodeDef.extensions = nodeDef.extensions || {};
		nodeDef.extensions[ this.name ] = { light: lights.length - 1 };

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_unlit';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshBasicMaterial ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = {};

		extensionsUsed[ this.name ] = true;

		materialDef.pbrMetallicRoughness.metallicFactor = 0.0;
		materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_clearcoat';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.clearcoatFactor = material.clearcoat;

		if ( material.clearcoatMap ) {

			const clearcoatMapDef = { index: writer.processTexture( material.clearcoatMap ) };
			writer.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );
			extensionDef.clearcoatTexture = clearcoatMapDef;

		}

		extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;

		if ( material.clearcoatRoughnessMap ) {

			const clearcoatRoughnessMapDef = { index: writer.processTexture( material.clearcoatRoughnessMap ) };
			writer.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );
			extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;

		}

		if ( material.clearcoatNormalMap ) {

			const clearcoatNormalMapDef = { index: writer.processTexture( material.clearcoatNormalMap ) };
			writer.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );
			extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;

		}

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;


	}

}

/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */
class GLTFMaterialsIridescenceExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_iridescence';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.iridescenceFactor = material.iridescence;

		if ( material.iridescenceMap ) {

			const iridescenceMapDef = { index: writer.processTexture( material.iridescenceMap ) };
			writer.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );
			extensionDef.iridescenceTexture = iridescenceMapDef;

		}

		extensionDef.iridescenceIor = material.iridescenceIOR;
		extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];
		extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];

		if ( material.iridescenceThicknessMap ) {

			const iridescenceThicknessMapDef = { index: writer.processTexture( material.iridescenceThicknessMap ) };
			writer.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );
			extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;

		}

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 */
class GLTFMaterialsTransmissionExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_transmission';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.transmissionFactor = material.transmission;

		if ( material.transmissionMap ) {

			const transmissionMapDef = { index: writer.processTexture( material.transmissionMap ) };
			writer.applyTextureTransform( transmissionMapDef, material.transmissionMap );
			extensionDef.transmissionTexture = transmissionMapDef;

		}

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_volume';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.thicknessFactor = material.thickness;

		if ( material.thicknessMap ) {

			const thicknessMapDef = { index: writer.processTexture( material.thicknessMap ) };
			writer.applyTextureTransform( thicknessMapDef, material.thicknessMap );
			extensionDef.thicknessTexture = thicknessMapDef;

		}

		extensionDef.attenuationDistance = material.attenuationDistance;
		extensionDef.attenuationColor = material.attenuationColor.toArray();

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_ior';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.ior = material.ior;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_specular';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&
		       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&
		     ! material.specularIntensityMap && ! material.specularColorTexture ) ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		if ( material.specularIntensityMap ) {

			const specularIntensityMapDef = { index: writer.processTexture( material.specularIntensityMap ) };
			writer.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );
			extensionDef.specularTexture = specularIntensityMapDef;

		}

		if ( material.specularColorMap ) {

			const specularColorMapDef = { index: writer.processTexture( material.specularColorMap ) };
			writer.applyTextureTransform( specularColorMapDef, material.specularColorMap );
			extensionDef.specularColorTexture = specularColorMapDef;

		}

		extensionDef.specularFactor = material.specularIntensity;
		extensionDef.specularColorFactor = material.specularColor.toArray();

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_sheen';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		if ( material.sheenRoughnessMap ) {

			const sheenRoughnessMapDef = { index: writer.processTexture( material.sheenRoughnessMap ) };
			writer.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );
			extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;

		}

		if ( material.sheenColorMap ) {

			const sheenColorMapDef = { index: writer.processTexture( material.sheenColorMap ) };
			writer.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );
			extensionDef.sheenColorTexture = sheenColorMapDef;

		}

		extensionDef.sheenRoughnessFactor = material.sheenRoughness;
		extensionDef.sheenColorFactor = material.sheenColor.toArray();

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */
class GLTFMaterialsEmissiveStrengthExtension {

	constructor( writer ) {

		this.writer = writer;
		this.name = 'KHR_materials_emissive_strength';

	}

	writeMaterial( material, materialDef ) {

		if ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;

		const writer = this.writer;
		const extensionsUsed = writer.extensionsUsed;

		const extensionDef = {};

		extensionDef.emissiveStrength = material.emissiveIntensity;

		materialDef.extensions = materialDef.extensions || {};
		materialDef.extensions[ this.name ] = extensionDef;

		extensionsUsed[ this.name ] = true;

	}

}

/**
 * Static utility functions
 */
GLTFExporter.Utils = {

	insertKeyframe: function ( track, time ) {

		const tolerance = 0.001; // 1ms
		const valueSize = track.getValueSize();

		const times = new track.TimeBufferType( track.times.length + 1 );
		const values = new track.ValueBufferType( track.values.length + valueSize );
		const interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );

		let index;

		if ( track.times.length === 0 ) {

			times[ 0 ] = time;

			for ( let i = 0; i < valueSize; i ++ ) {

				values[ i ] = 0;

			}

			index = 0;

		} else if ( time < track.times[ 0 ] ) {

			if ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;

			times[ 0 ] = time;
			times.set( track.times, 1 );

			values.set( interpolant.evaluate( time ), 0 );
			values.set( track.values, valueSize );

			index = 0;

		} else if ( time > track.times[ track.times.length - 1 ] ) {

			if ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {

				return track.times.length - 1;

			}

			times[ times.length - 1 ] = time;
			times.set( track.times, 0 );

			values.set( track.values, 0 );
			values.set( interpolant.evaluate( time ), track.values.length );

			index = times.length - 1;

		} else {

			for ( let i = 0; i < track.times.length; i ++ ) {

				if ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;

				if ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {

					times.set( track.times.slice( 0, i + 1 ), 0 );
					times[ i + 1 ] = time;
					times.set( track.times.slice( i + 1 ), i + 2 );

					values.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );
					values.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );
					values.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );

					index = i + 1;

					break;

				}

			}

		}

		track.times = times;
		track.values = values;

		return index;

	},

	mergeMorphTargetTracks: function ( clip, root ) {

		const tracks = [];
		const mergedTracks = {};
		const sourceTracks = clip.tracks;

		for ( let i = 0; i < sourceTracks.length; ++ i ) {

			let sourceTrack = sourceTracks[ i ];
			const sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );
			const sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );

			if ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {

				// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.
				tracks.push( sourceTrack );
				continue;

			}

			if ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete
				&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {

				if ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

					// This should never happen, because glTF morph target animations
					// affect all targets already.
					throw new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );

				}

				console.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );

				sourceTrack = sourceTrack.clone();
				sourceTrack.setInterpolation( InterpolateLinear );

			}

			const targetCount = sourceTrackNode.morphTargetInfluences.length;
			const targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];

			if ( targetIndex === undefined ) {

				throw new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );

			}

			let mergedTrack;

			// If this is the first time we've seen this object, create a new
			// track to store merged keyframe data for each morph target.
			if ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {

				mergedTrack = sourceTrack.clone();

				const values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );

				for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

					values[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];

				}

				// We need to take into consideration the intended target node
				// of our original un-merged morphTarget animation.
				mergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';
				mergedTrack.values = values;

				mergedTracks[ sourceTrackNode.uuid ] = mergedTrack;
				tracks.push( mergedTrack );

				continue;

			}

			const sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );

			mergedTrack = mergedTracks[ sourceTrackNode.uuid ];

			// For every existing keyframe of the merged track, write a (possibly
			// interpolated) value from the source track.
			for ( let j = 0; j < mergedTrack.times.length; j ++ ) {

				mergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );

			}

			// For every existing keyframe of the source track, write a (possibly
			// new) keyframe to the merged track. Values from the previous loop may
			// be written again, but keyframes are de-duplicated.
			for ( let j = 0; j < sourceTrack.times.length; j ++ ) {

				const keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );
				mergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];

			}

		}

		clip.tracks = tracks;

		return clip;

	}

};

function clone( source ) {

	const sourceLookup = new Map();
	const cloneLookup = new Map();

	const clone = source.clone();

	parallelTraverse( source, clone, function ( sourceNode, clonedNode ) {

		sourceLookup.set( clonedNode, sourceNode );
		cloneLookup.set( sourceNode, clonedNode );

	} );

	clone.traverse( function ( node ) {

		if ( ! node.isSkinnedMesh ) return;

		const clonedMesh = node;
		const sourceMesh = sourceLookup.get( node );
		const sourceBones = sourceMesh.skeleton.bones;

		clonedMesh.skeleton = sourceMesh.skeleton.clone();
		clonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );

		clonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {

			return cloneLookup.get( bone );

		} );

		clonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );

	} );

	return clone;

}

function parallelTraverse( a, b, callback ) {

	callback( a, b );

	for ( let i = 0; i < a.children.length; i ++ ) {

		parallelTraverse( a.children[ i ], b.children[ i ], callback );

	}

}

class Tension {

	constructor( origin, target ) {


		this.target = target || origin;

		this.baseGeometry = origin.geometry;
		this.geometry = this.target.geometry;

		this.V = [ new Vector3(), new Vector3(), new Vector3() ];
		this.X = [ new Vector4(), new Vector4(), new Matrix4() ];
		this.M = [ new Vector3(), new Vector3(), new Vector3() ];

		this.isMorph = this.target.morphTargetInfluences ? true : false;
		this.isSkin = this.target.isSkinnedMesh ? true : false;

		this.init();

	}

	init(){

		if( this.geometry.attributes.position.count !== this.baseGeometry.attributes.position.count ){
			console.log('object not have same number of vertices !!');
			return
		}

		this.length = this.baseGeometry.attributes.position.count;
		this.indexLength = this.baseGeometry.index.count / 3 ;

		//console.log( this.length, this.indexLength )
		

		this.originEdges = new Array(this.length).fill(0);
		this.targetEdges = new Array(this.length).fill(0);

		if( this.isSkin || this.isMorph) this.back = new Array( this.length * 3 ).fill(0);
		this.num = new Array( this.length ).fill(0);

		this.getEdge( this.baseGeometry, this.originEdges );
		this.addColor();

		setTimeout( this.start.bind(this), 100 );

	}

	start(){
		this.ready = true;
		this.update();
	}

	addColor(){

		const g = this.geometry;
		//if( g.attributes.color ) return;
		let lng = g.attributes.position.array.length;
		g.setAttribute( 'color', new Float32BufferAttribute( new Array(lng).fill(0), 3 ) );

	}

	resetEdge( edges )
	{
		let j = edges.length;
		while(j--) edges[j] = 0;
	}

	getEdge( g, edges, isSkin = false, isMorph = false ) 
	{
		let positions = g.attributes.position.array;
		const indices = g.index.array;
		let vA = this.V[0], vB = this.V[1], vC = this.V[2];
		let j, i=0, a, b, c, ab, ac, bc;

		if( isMorph ) positions = this.getMorph();
		if( isSkin ) positions = this.getSkinned( positions );
		if( isSkin || isMorph ) this.resetEdge( edges );
		
		j = this.indexLength;

		while( j-- )
		{
		    a = indices[i];
		    b = indices[i+1];
		    c = indices[i+2];
		    vA.fromArray( positions, a * 3 );
		    vB.fromArray( positions, b * 3 );
		    vC.fromArray( positions, c * 3 );

		    ab = vA.distanceTo(vB);
		    ac = vA.distanceTo(vC);
		    bc = vB.distanceTo(vC);
	    
		    
		    edges[a] += (ab + ac)*0.5;
			edges[b] += (ab + bc)*0.5;
			edges[c] += (ac + bc)*0.5;
			
			/*
			edges[a] += (ab + ac);
			edges[b] += (ab + bc);
			edges[c] += (ac + bc);

			num[a] += 2;
			num[b] += 2;
			num[c] += 2;
			*/

			i+=3;
		}

		//j = this.length;
		//while( j-- ){ edges[j] /= num[j]; }
	}

	isZero(v){

		if(v.x===0 && v.y===0 && v.z ===0 ) return true
		return false

	}

	getMorph()
	{
		const morphInfluences = this.target.morphTargetInfluences;
		const morphRef = this.geometry.morphAttributes.position;
		const morphsMax = morphInfluences.length;
		const position = this.geometry.attributes.position.array;
		let lng = this.geometry.attributes.position.count, id, i, j;
		let vertex = this.M[0];
		let base = this.M[1];
		let temp = this.M[2];
		let relative = this.geometry.morphTargetsRelative;
		let data;

		 // the following code section is normally implemented in the vertex shader

		i = lng;
	    while(i--)
	    {
			id = i*3;
			base.fromArray( position, id );
			vertex.set( 0,0,0 );
			j = morphsMax;
			while(j--){

				if ( morphInfluences[ j ] != 0.0 ){
					data =  morphRef[j].data ? morphRef[j].data.array : morphRef[j].array;
					if( relative ) vertex.addScaledVector( temp.fromArray( data, id ), morphInfluences[ j ] );
					else vertex.addScaledVector( temp.fromArray( data, id ).sub(base), morphInfluences[ j ] );
				}

			}
			base.add( vertex );
			base.toArray( this.back, id );
		}
		return this.back

	}

	getSkinned( position )
	{

		const skeleton = this.target.skeleton;
	    skeleton.boneMatrices;
	    const geometry = this.geometry;
	    //const position = geometry.attributes.position.array;
	    const skinIndex = geometry.attributes.skinIndex.array;
	    const skinWeigth = geometry.attributes.skinWeight.array;

	    const bindMatrix = this.target.bindMatrix;
	    const bindMatrixInverse = this.target.bindMatrixInverse;

	    let vertex = this.V[0];
	    let skin = this.V[1];
	    let temp = this.V[2];
	    let skinIndices = this.X[0];
	    let skinWeights = this.X[1];
	    let boneMatrix = this.X[2];

	    let lng = geometry.attributes.position.count;
	    let i, j, boneIndex, weight, id;

	    // the following code section is normally implemented in the vertex shader
	    i = lng;
	    while(i--)
	    {
			id = i*3;
            skinIndices.fromArray( skinIndex, i*4 );
            skinWeights.fromArray( skinWeigth, i*4 );
            vertex.fromArray( position, id ).applyMatrix4( bindMatrix ); // transform to bind space
            skin.set( 0, 0, 0 );
            j = 4;
            while(j--)
            {
                weight = skinWeights.getComponent( j );
                if ( weight > 0 ) {
                	boneIndex = skinIndices.getComponent( j );
	                boneMatrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );
	                // weighted vertex transformation
	                skin.addScaledVector( temp.copy( vertex ).applyMatrix4( boneMatrix ), weight );
	            }

            }

            skin.applyMatrix4( bindMatrixInverse ); // back to local space
            skin.toArray( this.back, id );
        }
        return this.back
	}

	update() 
	{

		if(!this.ready) return

		this.getEdge( this.geometry, this.targetEdges, this.isSkin, this.isMorph );
		const color = this.geometry.attributes.color.array;
		let o, delta, n, i = this.length;

		while( i-- )
		{
			o = this.originEdges[i];
			delta = ( ( o - this.targetEdges[i] ) / o ) + 0.5;
			n = i*3;
			color[n] = delta > 0.5 ? (delta-0.5)*2 : 0;
			color[n+1] = 0;
			color[n+2] = delta < 0.5 ? (1-(delta*2)) : 0;
		}
		this.geometry.attributes.color.needsUpdate = true;
	}

}

class ExoSkeleton extends Object3D {

    constructor( object, skeleton ) {

        super();

        this.isReady = false;

        this.skeleton = skeleton;

        this.bones = this.skeleton.bones;//getBoneList( object );
        this.root = object;

        this.box = new BoxGeometry();

        //console.log(this.bones)

        //this.avatar = avatar;
        //this.nodes = [];
        this.mtxr = new Matrix4();
        this.mtx0 = new Matrix4();
        this.mtx1 = new Matrix4();

        this.mtx = new Matrix4();
        this.mtx2 = new Matrix4();

        this.p = new Vector3();
        this.s = new Vector3();
        this.q = new Quaternion();
        this.e = new Euler();

        this.mat = new MeshBasicMaterial({ color:0xCCCC80, wireframe:true, toneMapped:false });//root.mat.skinCollider;

        this.init();

        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;

    }

    updateMatrixWorld ( force ) {

        if( !this.isReady ) return;

        //THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

        let nodes = this.children;
        let i = nodes.length, node, bone;

        this.mtxr.copy( this.root.matrixWorld ).invert();

        //console.log('up', i)

        while( i-- ){

            node = nodes[i];
            bone = node.userData.bone;

            //this.mtx1.fromArray( this.skeleton.boneMatrices, bone.idx )

            this.mtx0.multiplyMatrices(this.mtxr, bone.matrixWorld );
            //this.mtx0.scale( bone.scalling );

            this.mtx.multiplyMatrices( this.mtx0, node.userData.decal );
            //this.mtx.multiplyMatrices( this.mtx1, this.mtx );


            this.mtx.decompose( this.p, this.q, this.s );


            node.position.copy( this.p );
            node.quaternion.copy( this.q );

            node.updateMatrix();

        }

        super.updateMatrixWorld( force );

    }

    init () {

        this.mtxr.copy( this.root.matrixWorld ).invert();

        // get character bones
        const bones = this.bones; //object.skeleton.bones;
        //let nodes = [];

        let p1 = new Vector3();
        let p2 = new Vector3();

        let i, lng = bones.length, name, n, bone, parent;
        let size, dist, type, translate, rot, fx;

        for( i = 0; i < lng; i++ ){

            type = null;
            bone = bones[i];
            name = bone.name;
            parent = bone.parent;

            //bone.updateMatrix()


            if( parent ) {

                //parent.updateMatrix()

                n = parent.name;

                p1.setFromMatrixPosition( parent.matrixWorld );
                p2.setFromMatrixPosition( bone.matrixWorld );

                //p1.setFromMatrixPosition( this.mtx.multiplyMatrices(this.mtxr, parent.matrixWorld ) ) //parent.matrixWorld );
                //p2.setFromMatrixPosition( this.mtx.multiplyMatrices(this.mtxr, bone.matrixWorld ) ) //bone.matrixWorld );
                dist = p1.distanceTo( p2 );

                //console.log(n, dist)

                translate = [ 0, 0, dist * 0.5 ];
                size = [ dist, 1, 1 ];
                rot = [0,0,0];

                fx = '_C';

                if( n==='head' && name === 'End_head' ){ type = 'box'; size = [ 0.16, 0.2, dist ]; translate = [ 0, 0.025, -dist * 0.5 ]; }
                if( n==='chest' && name==='neck' ){ type = 'box'; size = [  0.30, 0.28, dist ]; translate = [ 0, 0, -dist * 0.5 ]; }
                if( n==='abdomen' ){ type = 'box'; size = [ 0.28, 0.24,  dist+0.14 ]; rot[2] = 0; translate = [ 0, 0, -dist * 0.5 ];translate[2] += 0.07;}

                 // legs
                if( n==='rThigh' ){ type = 'box'; size = [  0.15, 0.15, dist ];  }
                if( n==='lThigh' ){ type = 'box'; size = [  0.15, 0.15 , dist];  }
                if( n==='rShin' ){ type = 'box'; size = [  0.12, 0.12, dist+ 0.1, ]; translate[2] += 0.05; }
                if( n==='lShin' ){ type = 'box'; size = [  0.12, 0.12, dist+ 0.1, ]; translate[2] += 0.05; }

                // arm
                if( n==='rShldr'  ){ type = 'box'; size = [   dist+ 0.06, 0.12, 0.12  ]; translate[0] = -translate[2]+0.03; translate[2]=0; }
                if( n==='lShldr'  ){ type = 'box'; size = [  dist+ 0.06,0.12,   0.12, ];  translate[0] = translate[2]-0.03; translate[2]=0; }
                if( n==='rForeArm' ){ type = 'box'; size = [  dist + 0.1,0.1,  0.1 ];  translate[0] = -translate[2]-0.05; translate[2]=0; }
                if( n==='lForeArm' ){ type = 'box'; size = [  dist + 0.1,0.1,  0.1]; translate[0] = translate[2]+0.05; translate[2]=0; }

                if( type !== null ) this.addMesh( parent, type, size, translate, rot, fx );

            }
        }

        this.isReady = true;

    }

    addMesh ( parent, type, size, translate, rot, fx ) {

        // translation
        //this.mtx.makeTranslation( translate[0], translate[1], translate[2] );
        this.mtx.makeTranslation( translate[0], translate[1], translate[2] );
        // rotation
        //this.mtx2.makeRotationFromEuler( this.e.set( rot[0]*math.torad, rot[1]*math.torad, rot[2]*math.torad ) );
        //this.mtx.multiply( this.mtx2 );

       //let box = new BoxGeometry( size[0], size[1], size[2])


        var mesh = new Mesh( this.box, this.mat );
        mesh.scale.fromArray(size);

        //mesh.name = fx;
        mesh.userData.decal = this.mtx.clone();
        mesh.userData.bone = parent;
        mesh.userData.size = size;


        this.add( mesh );

        //mesh.userData.avatar = this.avatar;

    }

    dispose () {
        this.children = [];
        this.box.dispose();
        this.mat.dispose();
        this.isReady = false;
    }

}

/*
function getBoneList( object ) {

    const boneList = [];

    if ( object.isBone === true ) {

        boneList.push( object );

    }

    for ( let i = 0; i < object.children.length; i ++ ) {

        boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

    }

    return boneList;

}*/

const setting$4 = {

    mixRatio:0.0,
    threshold:0.1,
    normal:0.25,
    hair:0xa43412,
    bow:0x100402,
    sheen:2,//2.25,
    sheenRoughness:1.0,//1.0,
    metalness:0.6,
    roughness:0.4,
    wireframe:false,
    vertexColors:false,
    alphaTest:0.3,
    h_metal:0.4,
    h_rough:0.6,
    clearcoat:1.0,
    
};

const Human = {

	isBreath:false,
	isEyeMove:true,
	haveMorph:true,
    

    skeletonRef:'body',
	fullMorph: ['MUSCLE', 'LOW', 'BIG', 'MONSTER'],

	haveQuality: true,
	textureRef:'avatar_c',
	texturePath: 'assets/textures/avatar_',
	textures: [
        'avatar_c.jpg', 'avatar_n.jpg', 'avatar_m.jpg', 'avatar_r.jpg', 'avatar_u.jpg',
        'mouth_c.jpg', 'mouth_a.jpg', 'mouth_n.jpg', 
        'eye_c.jpg', 'eye_n.jpg', 'hair.jpg', 'hair_a.jpg',
        'eyelash_c.jpg', 'eyelash_a.jpg', 'eyelash_n.jpg',
        'hair_man.jpg', 'hair_man_a.jpg', //'avatar_ao.jpg',
    ],

    modelPath: 'assets/models/avatar/',
    forceModel: null,

    setting:setting$4,

    materialRef:'skin',
    materials:{
        skin:{
            type:'Physical',
            map: 'avatar_c', 
            normalMap:'avatar_n',
            roughness:1,
            metalness:1,
            metalnessMap:'avatar_m',
            roughnessMap:'avatar_r',
            normalScale: new Vector2( setting$4.normal, -setting$4.normal),
            
            sheen:setting$4.sheen,
            sheenRoughness:setting$4.sheenRoughness,
            sheenColor:0xffffff,
            sheenColorMap:'avatar_u',
            iridescence:0.5,

            /*aoMap:'avatar_ao',
            aoMapIntensity:1,*/


            //envMapIntensity:1,
            
        },
    	mouth:{
            type:'Standard',
    		map:'mouth_c',
            roughness:0.6,
            metalness:0.6,
            alphaMap:'mouth_a',
            alphaTest:0.5,
            normalMap:'mouth_n'
    	},
    	sub_eye:{
            type:'Physical',
            roughness:0,//0.568,
            metalness:1,
            ior:1.376,
            opacity:1,
            blending:AdditiveBlending,
            clearcoat:1,
            transparent:true,
            envMapIntensity:0,
            //wireframe:true
        },
        eye:{
            type:'Physical',
        	map:'eye_c',
            roughness:0.7,
            metalness:0.15,
            normalMap:'eye_n',
            normalScale:new Vector2( 2, -2),
            clearcoat:0.25,
            //clearcoatRoughness:0.5,
        },
        hair:{
            type:'Standard',
        	map:'hair',
            color:setting$4.hair,
            roughness:setting$4.h_rough,
            metalness:setting$4.h_metal,
            alphaMap:'hair_a',
            alphaTest:setting$4.alphaTest,
            side: DoubleSide,
            opacity:1.0,
            transparent:true,
            blending:CustomBlending,
            blendDst:ZeroFactor,
            blendDstAlpha:SrcAlphaFactor,
            alphaToCoverage:true,
        },
        hair_man:{
            type:'Standard',
        	map:'hair_man',
            color:setting$4.hair,
            roughness:setting$4.h_rough,
            metalness:setting$4.h_metal,
            alphaMap:'hair_man_a',
            alphaTest:setting$4.alphaTest,
            side: DoubleSide,
            opacity:1.0,
            transparent:true,
            blending:CustomBlending,
            blendDst:ZeroFactor,
            blendDstAlpha:SrcAlphaFactor,
            alphaToCoverage:true,
        },
        eyelash:{
            type:'Standard',
        	color:setting$4.hair,
            map:'eyelash_c',
            roughness:setting$4.h_rough,
            metalness:setting$4.h_metal,
            alphaMap:'eyelash_a',
            alphaTest:setting$4.alphaTest,
            transparent:true,
            side: DoubleSide,
            alphaToCoverage:true,
            polygonOffset: true,                
            polygonOffsetFactor: - 4,
            //normalMap:'eyelash_n',
            //normalScale:new Vector2( 1, -1)
        },
        tear:{
            type:'Physical',
        	map:'eyelash_c',
            roughness:0.5,
            metalness:0.5,
            alphaMap:'eyelash_a',
            transparent:true,
            alphaToCoverage:true,
            opacity:1,
        },
        low:{
            type:'Basic',
        	color:0x000000,
            wireframe: true,
        }

    },

    changeMaterial:( sx ) => {

        if( !Pool.getMaterial( 'skin' ) ) return

        const s = Human.setting;

        if(sx){
            for(let v in sx){
                if(s[v]!== undefined) s[v] = sx[v];
            }
        }
        
        /*
         m = Pool.getMaterial( 'skin' );
        
        //m.roughness = s.roughness;
        //m.metalness = s.metalness;
        m.wireframe = s.wireframe;
        m.vertexColors = s.vertexColors;
        m.normalScale.set( s.normal, -s.normal )
        m.sheen = s.sheen;
        m.sheenRoughness = s.sheenRoughness;
        */

       /* let c = s.hair;
        m = Pool.getMaterial( 'hair' )
        m.color.setHex( c )
        m.alphaTest = s.alphaTest
        m.metalness = s.h_metal
        m.roughness = s.h_rough
        m = Pool.getMaterial( 'hair_man' )
        m.color.setHex( c )
        m.alphaTest = s.alphaTest
        m.metalness = s.h_metal
        m.roughness = s.h_rough
        m = Pool.getMaterial( 'eyelash' )
        m.color.setHex( c )
        m.alphaTest = s.alphaTest
        m.metalness = s.h_metal
        m.roughness = s.h_rough*/

        //if( s.vertexColors && m.map !== null ){ m.map = null; this.tensionActive = true; m.sheen = 0;}
        ///if( !s.vertexColors && m.map === null ){ m.map = this.skin; this.tensionActive = false; }

    },

    

    applyMaterial:( root, model ) => {

        // apply Material

        const def = Pool.getMaterial( 'skin' );

        root.traverse( ( node ) => {

            if ( node.isMesh ){
                switch( node.name ){
                    case 'body':

                    //Pool.addUv2( node )
                    node.material = def;
                    node.receiveShadow = true;
                    node.castShadow = true;
                    break;
                    case 'body_low': 
                        node.material = def;
                        node.receiveShadow = false;
                        node.castShadow = false;
                        node.visible = false;
                    break;
                    case 'Head': 
                    //Pool.addUv2( node )
                    node.material = def;
                    node.receiveShadow = true;
                    node.castShadow = true;
                    break;
                    case 'mouth':
                    node.material = Pool.getMaterial( 'mouth' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    break;
                    case 'eyelash':  case 'eyebrow':
                    node.material = Pool.getMaterial( 'eyelash' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    break;
                    case 'tear': 
                    node.material = Pool.getMaterial( 'tear' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    break;
                    case 'eye_l':case 'eye_r':
                    node.material = Pool.getMaterial( 'eye' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    break;
                    case 'eye_l_s':case 'eye_r_s':
                    node.material = Pool.getMaterial( 'sub_eye' ) || def;
                    node.receiveShadow = false;
                    node.castShadow = false;
                    //node.visible = false
                    break;
                    case 'hair': 
                    node.material = Pool.getMaterial( 'hair' ) || def;
                    node.receiveShadow = true;
                    node.castShadow = true;
                    node.matrixWorldAutoUpdate = false;
                    break;
                    case 'hair_man': 
                    node.material = Pool.getMaterial( 'hair_man' ) || def;
                    node.receiveShadow = true;
                    node.castShadow = true;

                    node.matrixWorldAutoUpdate = false;
                    break;
                }
            }

        });

    },





};

const setting$3 = {

    metalness:0.6,
    roughness:0.4,
    clearcoat:1.0,
    wireframe:false,
    
};

const Eva = {

    decalY:0.02,

	isBreath:false,
	isEyeMove:false,
	haveMorph:false,

	skeletonRef:'eva_SKIN',

	fullMorph: [],

	haveQuality: false,
	skinRef:'eva_00',
	texturePath: 'assets/textures/eva/',
	textures: ['eva00_c.jpg', 'eva01_c.jpg', 'eva02_c.jpg', 'eva_l.jpg'],

    modelPath: 'assets/models/',
    forceModel:'eva',

    setting:setting$3,

    materialRef:'eva00',
    materials:{
        eva00:{
            type:'Physical',
            map: 'eva00_c', 
            emissiveMap:'eva_l',
            emissive:0xffffff,
            roughness:setting$3.roughness,
            metalness:setting$3.metalness,
            wireframe:setting$3.wireframe,
            clearcoat:setting$3.clearcoat,
            iridescence:0.5,
        },
        eva01:{
            type:'Physical',
            map: 'eva01_c',
            emissiveMap:'eva_l',
            emissive:0xffffff,
            roughness:setting$3.roughness,
            metalness:setting$3.metalness,
            wireframe:setting$3.wireframe,
            clearcoat:setting$3.clearcoat,
            iridescence:0.5,
        },
        eva02:{
            type:'Physical',
            map: 'eva02_c', 
            emissiveMap:'eva_l',
            emissive:0xffffff,
            roughness:setting$3.roughness,
            metalness:setting$3.metalness,
            wireframe:setting$3.wireframe,
            clearcoat:setting$3.clearcoat,
            iridescence:0.5,
        }
    },

    changeMaterial:( Setting ) => {

        const s = Eva.setting;

        if(Setting){
            for(let o in Setting){
                if( s[o] !== undefined) s[o] = Setting[o];
            }
        }
        
        let m = Pool.getMaterial( 'eva00' );
        m.roughness = s.roughness;
        m.metalness = s.metalness;
        m.wireframe = s.wireframe;
        m.clearcoat = s.clearcoat;
        m = Pool.getMaterial( 'eva01' );
        m.roughness = s.roughness;
        m.metalness = s.metalness;
        m.wireframe = s.wireframe;
        m.clearcoat = s.clearcoat;
        m = Pool.getMaterial( 'eva02' );
        m.roughness = s.roughness;
        m.metalness = s.metalness;
        m.wireframe = s.wireframe;
        m.clearcoat = s.clearcoat;

    },

    applyMaterial:( root, model ) => {

    	const def = Pool.getMaterial( model );

        root.traverse( ( node ) => {

            if ( node.isMesh ){
            	
            	node.material = def;
                node.receiveShadow = true;
                node.castShadow = true;

                switch( node.name ){

                    case 'eva_2_head':case 'eva_2_mach': 
                    node.visible = model === 'eva02' ? true : false;
                    break;

                    case 'eva_L_COLLAR':case 'eva_R_COLLAR': 
                    node.visible = model === 'eva00' ? false : true;
                    break;

                    case 'eva_HEAD': case 'eva_MACHOIR': 
                    node.visible = model === 'eva01' ? true : false;
                    break;

                    case 'eva_0_R_COLLAR':case 'eva_0_L_COLLAR':case 'eva_0_head': case 'eva_0_head2':
                    node.visible = model === 'eva00' ? true : false;
                    break;

                    case 'eva_0_CHEST2':
                    node.visible = model === 'eva01' ? false : true;
                    break;
                }
            }

        });

    }




};

const setting$2 = {

    metalness:0.2,
    roughness:0.8,
    wireframe:false,
    
};

const Lee = {

    decalY:-0.06,

	isBreath:false,
	isEyeMove:false,
	haveMorph:false,

	skeletonRef:'leeSkin',

	fullMorph: [],

	haveQuality: false,
	//skinRef:'leeSkin',
	texturePath: 'assets/textures/',
	textures: ['lee_c.jpg', 'lee_ao.jpg'],

    modelPath: 'assets/models/',
    forceModel:'lee',

    setting:setting$2,

    materialRef:'lee_material',
    materials:{
        lee_material:{
            type:'Physical',
            map: 'lee_c', 

            roughness:0.3,
            metalness:0.08,
            //aoMap: 'lee_ao',
            wireframe:setting$2.wireframe,
            sheen:2.2,
            //emissive:0xFFFFFF,
            //emissiveMap:'lee_c',
            sheenColorMap:'lee_c',
            sheenColor:0xFFFFFF,
            sheenRoughness:0.4,
            envMapIntensity:1,
            //aoMapIntensity:0.5,
            //emissiveIntensity:0.25,

        },
    },

    changeMaterial:( Setting ) => {

        const s = Lee.setting;

        if(Setting){
            for(let o in Setting){
                if( s[o] !== undefined) s[o] = Setting[o];
            }
        }
        
        let m = Pool.getMaterial( 'lee_material' );
        m.roughness = s.roughness;
        m.metalness = s.metalness;
        m.wireframe = s.wireframe;

    },

    applyMaterial:( root, model ) => {

    	const def = Pool.getMaterial( 'lee_material' );

        root.traverse( ( node ) => {

            if ( node.isMesh ){
            	
            	node.material = def;
                node.receiveShadow = true;
                node.castShadow = true;

            }

        });

    },

    adjustment:() => {

        return [
            //{name:'lShldr', values:[0,-70,0]},
            {name:'lHand', values:[-60,0,0]},
            //{name:'rShldr', values:[0,70,0]},
            {name:'rHand', values:[-60,0,0]}
        ]

    }




};

/** __
*    _)_|_|_
*   __) |_| | 2023
*  @author lo.th / https://github.com/lo-th
* 
*  AVATAR
*/

const FrameTime = 30;
const TimeFrame = 1/30;
const torad = Math.PI / 180;
const todeg = 180 / Math.PI;
const V = new Vector3();

class Avatar extends Group$1 {

	constructor( o = {} ) {

        super();

        this.rootPath = o.path || './';
        this.lzmaPath = this.rootPath + 'src/libs/lzma_worker.js';
        Pool.dracoPath =  this.rootPath + 'src/libs/draco/';

        this.callback = o.callback || function (){};

        this.matrixAutoUpdate = false;
        this.isPause = true;

        this.textureQuality = o.quality || 1;

        this.model = o.type || 'man';
        this.startAnimation = o.anim || 'idle';

        

        this.ref = null;

        switch( this.model ){
            case 'lee': this.ref = Lee; break;
            case 'man': case 'woman': this.ref = Human; break;
            case 'eva00': case 'eva01': case 'eva02': this.ref = Eva; break;
        }


        this.compact = o.compact !== undefined ? o.compact : true;
        this.haveMorph = o.morph !== undefined ? o.morph : false;
        this.fullMaterial = o.material !== undefined ? o.material : true;

        this.size = o.size || 1;

        this.fullMorph = this.ref.fullMorph;
        

        this.skeleton = null;
        //this.root = null;
        this.mixer = null;
        this.mesh = {};
        this.bones = {};
        this.done = false;
        this.isClone = false;
        
        this.isBreath = this.ref.isBreath || false;
        this.isEyeMove = this.ref.isEyeMove || false;

        this.decalY = this.ref.decalY || 0;

        this.tensionTest = false;
        this.tensionActive = false;

        this.fixToe = false;
        this.clipsToesFix = [];

        this.n = Math.round(Math.random()*1000);

        this.actions = new Map();
        this.current = null;
        this.old = null;

        this.breath = 0;
        this.breathSide = -1;

        this.q = new Quaternion().setFromAxisAngle( {x:0, y:1, z:0}, Math.PI*0.5 );
        this.headBoneLook = new Vector3();
        this.eyeTarget = new Group$1();//new AxesHelper(0.01)//
        this.eyeTarget.position.set(0, 1, 0);

        this.tmpMtx = new Matrix4();
        this.tmpQ = new Quaternion();

        this.setting = {

            mixRatio:0.,
            threshold:0.1,
            normal:0.2,
            hair:0xa43412,

            bow:0x100402,

            sheen:2.25,
            sheenRoughness:1.0,

            metalness:1,
            roughness:0.5,
            wireframe:false,
            vertexColors:false,

            alphaTest:0.3,
            h_metal:0.4,
            h_rough:0.6,
            
        };

        //this.initMaterial();

        this.root = Pool.get( this.ref.forceModel ? this.ref.forceModel : this.model, 'O' );

        if( this.root ){
            this.isClone = true;
            this.tensionTest = false;
            this.root = clone( this.root );
            this.init();

        } else {
            if( this.fullMaterial ) this.load();
            else this.loadModels();
        }

    }

    load(){

        this.skin = Pool.getTexture(this.ref.textureRef);
        if( !this.skin ){

            const path = this.rootPath + this.ref.texturePath + (this.ref.haveQuality ? this.textureQuality + 'k/' : '');
            Pool.load( this.ref.textures, this.loadModels.bind(this), path, 'loading images...' );

        } else {

            this.loadModels();

        }

    }

    loadModels(){

        const model = this.ref.forceModel ? this.ref.forceModel : this.model;
        
        const asset = [model+'.glb'];
        const path = this.rootPath + this.ref.modelPath;
        if( this.ref.haveMorph && this.haveMorph ) asset.push( model+'_morph.glb' );
        Pool.load( asset, this.init.bind(this), path, 'loading models...' );

    }

    update( delta ){

        if( !this.done ) return;
        if ( this.mixer ){

            this.mixer.update( delta );

            // blink
            const n = this.n;
            if( n<=20) this.eyeControl((n*0.05));
            if( n>10 && n<=40 ) this.eyeControl(1-((n-20)*0.05));
            this.n ++;
            if( this.n===1000 ) this.n = 0;

            if( !this.isClone ){ 
                this.look( delta*10 );
                this.breathing();
                this.autoToes();
            }

            if( this.tensionActive ){ 
                this.tension1.update();
                this.tension2.update();
            }

            /*if( this.ref.adjustment && !this.isClone ) {
                let dt = this.ref.adjustment()
                let m = dt.length, l
                while(m--){
                    l = dt[m]
                    this.setRot2( l.name, l.x, l.y, l.z )
                }
            }*/

            if( window.gui && this.current ){ 
                window.gui.updateTimeBarre( Math.round( this.current.time * FrameTime ), this.current.frameMax );
            }
        }

    }

    look( delta ){

        if(!this.isEyeMove) return
        if(this.isPause) return

        const v = window.mouse || {x:0, y:0};

        if(delta>1) delta = 1;

        this.headBoneLook.lerp({ x:-(v.y*20)*torad, y:0, z:-(v.x*20)*torad }, delta );
        this.eyeTarget.position.lerp({ x:v.x*0.5, y:1, z:-v.y*0.25 }, delta );

        let e = this.headBoneLook;
        this.tmpQ.setFromEuler( { _x:e.x, _y:e.y, _z:e.z, _order:'XYZ' }, false );
        this.bones.head.quaternion.multiply(this.tmpQ);

        let ER = this.bones.ER;
        let EL = this.bones.EL;
        let up = {x:0, y:0, z:1};

        this.tmpMtx.lookAt( EL.position, this.eyeTarget.position.clone().add({x:0.03, y:0, z:-0.074}), up );
        EL.quaternion.setFromRotationMatrix( this.tmpMtx ).multiply(this.q);

        this.tmpMtx.lookAt( ER.position, this.eyeTarget.position.clone().add({x:-0.03, y:0, z:-0.074}), up );
        ER.quaternion.setFromRotationMatrix( this.tmpMtx ).multiply(this.q);

    }

    breathing(){

        if( !this.bones ) return;
        if( !this.isBreath ) return;
        if( !this.skeleton.setScalling ) return;

        let a = this.breath*0.01;

        if(this.breathSide > 0){
            this.skeleton.setScalling( this.bones.chest, this.lerp (1,1.02, a), this.lerp (1,1.04, a), 1 );
            this.skeleton.setScalling( this.bones.abdomen, 1, this.lerp (1,0.92, a), 1 );
        }else {
            this.skeleton.setScalling( this.bones.chest, this.lerp (1.02,1, a), this.lerp (1.04,1, a), 1 );
            this.skeleton.setScalling( this.bones.abdomen, 1, this.lerp (0.92,1, a), 1 );
        }


        // !! just for testing 
        //this.skeleton.setScalling( this.bones.lShldr, 1.3, 2, 2 )
        //this.skeleton.setScalling( this.bones.lForeArm, 1.3, 2, 2 )

        this.breath ++;
        if( this.breath === 100 ){ this.breath = 0; this.breathSide = this.breathSide > 0 ? -1:1; }

    }

    setPosition( x, y, z ){

        this.position.set( x, y, z );
        this.updateMatrix();

    }

    setRotation( x, y, z, a ){

        let r  = this.lerp( this.rotation.y, y, a);
        this.rotation.set( x, r, z );
        this.updateMatrix();

    }

    lerp( x, y, t ) { return ( 1 - t ) * x + t * y }

    onReady(){}

    initMaterial(){

        if( Pool.getMaterial( this.ref.materialRef ) ) return

        if( !this.fullMaterial ){
            Pool.set( this.ref.materialRef, new MeshStandardMaterial() );
            return
        }

        let m, type, data;

        for( const name in this.ref.materials ){

            data = {...this.ref.materials[name]};
            type = data.type;
            delete data.type;
            for( const t in data ){

                if(t!=='envMapIntensity')if(t==='map' || t.search('Map')!==-1 ) data[t] = Pool.getTexture(data[t]);
            }
            if(type==='Basic') m = new MeshBasicMaterial( data );
            else if(type==='Standard') m = new MeshStandardMaterial( data );
            else if(type==='Physical') m = new MeshPhysicalMaterial( data );
            m.name = name;

            //console.log(m)
            //Shader.add( m )
            Pool.set( name, m );
        }

        this.setting = this.ref.setting;

    }


    setMaterial(s){

        this.ref.changeMaterial(s);

    }

    getMaterial( name ){
        return Pool.getMaterial( name )
    }

    init(){

        this.initMaterial();

        if( !this.isClone ) {
            this.root = Pool.get( this.ref.forceModel ? this.ref.forceModel : this.model, 'O' ); 
            this.ref.applyMaterial( this.root, this.model );
        }

        if( this.ref.forceModel && this.isClone ) this.ref.applyMaterial( this.root, this.model );

        // get data
        this.root.traverse( function ( node ) {
            if ( node.isMesh ){

                if( node.name === this.ref.skeletonRef ){
                    node.matrixAutoUpdate = false;
                    this.skeleton = node.skeleton;
                    if( this.skeleton.resetScalling ) this.skeleton.resetScalling();

                    //console.log( node.geometry.boundingSphere, node.geometry.boundingBox, node.frustumCulled )
                    //node.geometry.boundingSphere.radius = 0.1;
                }
                node.raycast = function(){ return };
                this.mesh[node.name] = node;
            }
            if ( node.isBone ){
                this.bones[node.name] = node;
                //if(node.name==='rShldr' ) node.rotation.x = 80 * torad
               // console.log(node.name, node.rotation.x*todeg, node.rotation.y*todeg, node.rotation.z*todeg)
            }
        }.bind(this));

        if( this.ref.isEyeMove ){
            this.bones.neck.add( this.eyeTarget );
        }
    
        //if( !this.isClone ){
        // for extra skin
        for( let m in this.mesh ){
            if( this.mesh[m].isSkinnedMesh && m !== this.ref.skeletonRef ){
                this.mesh[m].skeleton.dispose();
                this.mesh[m].skeleton = this.skeleton;
            }
        }

        if( !this.isClone ){
            // add morph 
            if( this.haveMorph ) Pool.applyMorph( this.model+'_morph', this.mesh, true, false );
            Pool.set( this.model, this.root, 'O' );
            
        }

        if( this.size !== 1 ) this.root.scale.set(1,1,1).multiplyScalar(this.size);

        //if( this.tensionTest ) this.addTensionMap()



        // animation
        this.mixer = new AnimationMixer( this );

        

        if( Pool.clip.length === 0 ){ 
            // load animation include in json or the compacted version
            if( this.compact ) this.loadCompactAnimation(this.rootPath +'assets/animation/animations.bin');
            else this.loadAnimationJson(this.rootPath +'assets/animation/animations.json', this.start.bind(this) );

        } else {
            let i = Pool.clip.length;
            while(i--) this.addAction( Pool.clip[i] );
            this.start();
        }

        
             
    }

    addTensionMap(){

        this.tension1 = new Tension( this.mesh.body );
        this.tension2 = new Tension( this.mesh.Head );
    }

    setBounding( r ){

        for( let m in this.mesh ){
            if(this.mesh[m].isMesh ){
                this.mesh[m].geometry.boundingSphere.radius = r;
            }
        }

    }

    /*setBoneScale( v ){

        const ingnor = [ 'head', 'lToes', 'rToes', 'rCollar', 'lCollar', 'rBreast', 'lBreast', 'neck'];
        const center = ['hip', 'abdomen', 'chest'];
        const legs = ['lThigh', 'rThigh', 'lShin', 'rShin'];
        const b = this.bones

        for( let n in b ){
            if(ingnor.indexOf(n) === -1) {
                if(center.indexOf(n) !== -1) b[n].scalling.z = v
                else if(legs.indexOf(n) !== -1) b[n].scalling.z = v
                else if( n === 'root' ) b[n].scalling.y = v
                else if( n === 'rFoot' || n === 'lFoot') b[n].scalling.y = v
                else b[n].scalling.x = v
            } 
        }

        this.setBounding(v)
    }*/


    eyeControl( v ){

        this.setMorph('EyeBlink', v);
    
    }

    setMorph( name, v ){

        if( !this.haveMorph ) return
        this.morpher( 'eyelash', name, v);
        this.morpher( 'eyebrow', name, v);
        this.morpher( 'tear', name, v);
        this.morpher( 'mouth', name, v);
        this.morpher( 'body', name, v);
        this.morpher( 'Head', name, v);
        this.morpher( 'body_low', name, v);
    }

    morpher( obj, name, value ){

        if(!this.mesh[obj]) return
        if(!this.mesh[obj].morphTargetInfluences) return
        if(this.mesh[obj].morphTargetDictionary[name] === undefined ) return
        this.mesh[obj].morphTargetInfluences[ this.mesh[obj].morphTargetDictionary[name] ] = value;
    }

    lerp( x, y, t ) { return ( 1 - t ) * x + t * y; }

    clone( o ){

        return new this.constructor( {type:o.type}, this );
    
    }

    dispose(){

        if( this.exoskel ) this.addExo();
        if( this.helper ) this.addHelper();

        this.stop();
        //if( this.skeleton.resetScalling ) this.skeleton.resetScalling()
        this.mixer.uncacheRoot( this );

        //if(this.skeleton.boneTexture)this.skeleton.boneTexture.dispose();
        this.remove( this.root );

        this.skeleton.dispose();
        this.parent.remove(this);
        

        //console.log('hero remove')
        if(!this.isClone);
    }

    start(){



        //console.log('start', this.model)
        if( this.done ) return

        //this.updateMatrix()

        this.done = true;
 
        this.add( this.root );

        this.onReady();
        this.playAll();
        
        this.play( this.startAnimation );


        if( this.ref.adjustment ){
            this.makePoseTrack('adjustment', this.ref.adjustment() );
        }


        setTimeout( this.callback, 10 ); 


        //this.callback()
    }

    addHelper(){

        if( this.helper ){
            this.helper.dispose();
            this.remove( this.helper );
            this.helper = null;
        } else {
            this.helper = new SkeletonHelper( this.root );
            this.helper.raycast = function (){};
            this.helper.matrix = this.root.matrix;
            this.add( this.helper );
        }
    }

    addExo()
    {
        if( this.exoskel ){
            this.exoskel.dispose();
            this.remove( this.exoskel );
            this.exoskel = null;
        } else {
            this.exoskel = new ExoSkeleton( this.root, this.skeleton );
            this.exoskel.matrix = this.root.matrix;
            this.add( this.exoskel );

        }
        return this.exoskel
    }

    attachToBone( m, b ){

        m.matrix = b.matrixWorld;
        m.matrixAutoUpdate = false;
    }

    loadAnimationJson( url, callback ){

        const request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.onreadystatechange = function() {
            if ( request.readyState === 4 ) {
                if ( request.status === 200 || request.status === 0 ) {
                    let data = JSON.parse( request.responseText );
                    this.urls = [];
                    for( let g in data ){
                        if( g === 'main' ) this.urls.push( ...data[g] );
                        else this.urls.push( ...data[g].map( x => g+'/'+x ) );
                    }
                    this.endCallback = callback || function(){}; 
                    this.loadOne();
                }
            }
        }.bind(this);
        request.send();

    }

    loadOne(){

        let name = this.urls[0];
        this.loadAnimationFbx( this.rootPath + 'assets/animation/fbx/'+name+'.fbx', this.next.bind(this) );

    }

    next(){

        this.urls.shift();
        if( this.urls.length === 0 ) this.endCallback();
        else this.loadOne();

    }

    loadCompactAnimation( url = './assets/models/animations.bin' ){

        if(!this.lzma) this.lzma = new LZMA(this.lzmaPath);

        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';

        const glb = { animations : [] };
        const self = this;

        request.onload = function() {
            self.lzma.decompress( new Uint8Array( request.response ), function (result) {
                const data = JSON.parse(result);
                
                for(let c in data) glb.animations.push( AnimationClip.parse( data[c] ) ); 
                //console.log( glb )
                self.applydAnimation( glb );
                self.start();
            });
        };
        request.send();

    }

    loadAnimationGlb( url, callback ){

        let name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        Pool.loaderGLTF().load( url, function ( glb ) {
            this.applydAnimation( glb, name );
            if( callback ) callback();
        }.bind(this), null, callback );
    }

    directGlb( data, name ){

        Pool.loaderGLTF().parse( data, '', function ( glb ) {
            this.stop();
            this.applydAnimation( glb, name );
        }.bind(this));
    }

    loadAnimationFbx( url, callback ){

        //if( !this.loaderFbx ) this.loaderFbx = new FBXLoader();
        let name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        Pool.loaderFBX().load( url, function ( node ) {
            this.convertFbx( name, node.animations[ 0 ] );
            if( callback ) callback();
        }.bind(this), null, callback );
    }

    directFbx( data, name ){

        //if( !this.loaderFbx ) this.loaderFbx = new FBXLoader();
        try {
            let node = Pool.loaderFBX().parse( data, '' );
            this.convertFbx( name, node.animations[ 0 ], true );
        } catch ( e ) {
            console.error( 'bug', e );
        }
    }

    applydAnimation( glb, name ){

        let i = glb.animations.length, autoplay = false;
        if( i === 1 ){
            if( name ) glb.animations[0].name = name;
            autoplay = true;
        } 
        while(i--){ 
            this.addClip( glb.animations[i] );
            this.addAction( glb.animations[i], autoplay );
        }

    }

    addClip( clip, additive = false ){

        // Make the clip additive and remove the reference frame
        if( additive ){ 
            AnimationUtils.makeClipAdditive( clip );
            //clip = AnimationUtils.subclip( clip, clip.name, 2, 3, 30 );
        }

        ///console.log(clip)

        let i = Pool.clip.length, removeId = -1;
        while(i--){ if( Pool.clip[i].name === clip.name ) removeId = i; }
        if( removeId !== -1 ) Pool.clip.slice( removeId, 1 );


        //clip.optimize();
        Pool.clip.push( clip );
    }

    addAction( clip, play ){

        const action = this.mixer.clipAction( clip );
        action.frameMax = Math.round( clip.duration * FrameTime );
        action.play();
        action.enabled = true;//false;
        if(clip.name.search('idle')!==-1) action.enabled = true;
        //action.setEffectiveWeight( 0 );
        if( clip.name === 'Jumping Up' ) action.loop = LoopPingPong;
        //action.play()
        this.actions.set( clip.name, action );

        if(clip.name.search('walk')!==-1) this.clipsToesFix.push(clip.name);
        if(clip.name.search('run')!==-1) this.clipsToesFix.push(clip.name);
        if(clip.name.search('strafe')!==-1) this.clipsToesFix.push(clip.name);
        if(clip.name.search('jog')!==-1) this.clipsToesFix.push(clip.name);
        if(clip.name.search('RUN')!==-1) this.clipsToesFix.push(clip.name);

        //console.log(clip)

        if( window.gui ) window.gui.getAnimation();

       // if( play ) this.play( clip.name )

             
    }


    /// EXPORT

    getAnimation( toJson = false, fromPool = false ){

        let anim = [], n = 0;
        if(fromPool){
            let i = Pool.clip.length;
            while(i--){

                if( toJson ) anim[n] = Pool.clip[n].toJSON();
                else anim[n] = Pool.clip[n];
                // delete animations[n].uuid
                n++;
            }
        } else {
            this.actions.forEach( function ( action, key ) {
                if( toJson ) anim[n] = action._clip.toJSON();
                else anim[n] = action._clip;
                //delete data[n].uuid
                n++;
            });
        }

        return anim

    }

    exportAnimationLzma( callback ){

        if(!this.lzma) this.lzma = new LZMA(this.lzmaPath);

        const data = this.getAnimation( true );

        this.lzma.compress( JSON.stringify(data), 2, function(result) {

            if( callback ) callback( {name:'animations', data:new Uint8Array(result), type:'bin'}  );
            else {
                let link = document.createElement("a");
                link.style.display = "none";
                document.body.appendChild(link);
                link.href = URL.createObjectURL( new Blob( [new Uint8Array(result)], {type: "application/octet-stream"} ) );
                link.download = 'animations.bin';
                link.click();
            }
        });
    }

    exportGLB( callback ){

        if( !this.exporter ) this.exporter = new GLTFExporter();
        
        const animations = this.getAnimation();

        this.exporter.parse( this.root, function( gltf ){

            if( callback ) callback( {name:'model', data:gltf, type:'glb'}  );
            else {
                let link = document.createElement("a");
                link.style.display = "none";
                document.body.appendChild(link);
                link.href = URL.createObjectURL( new Blob([gltf], { type: "application/octet-stream" }) );
                link.download = 'model.glb';
                link.click();
            }

            //self.loader.parse( JSON.stringify(glb, null, 2), '', function (r){ console.log(r) } )

        }, null, { animations:animations, binary: true, onlyVisible: true } );

    }

    armAngle(){

    }

    autoToes(){

        if(!this.fixToe) return
        let r = this.getRot('rFoot');
        let l = this.getRot('lFoot');
        let v = this.getWorldPos('hip');
        let v0 = this.getWorldPos('rToes');
        let v1 = this.getWorldPos('lToes');
        if(r[0]>0 && (v0.z-v.z)<0) this.setRot('rToes', -r[0]*1.5, 0,0 );
        else if( r[0] !== 0 ) this.setRot('rToes', 0,0,0 );
        if(l[0]>0 && (v1.z-v.z)<0) this.setRot('lToes', -l[0]*1.5, 0,0 );
        else if( l[0] !== 0 ) this.setRot('lToes', 0,0,0 );
    }

    resetToes(){

        if(!this.fixToe) return
        this.fixToe = false;
        this.setRot('rToes', 0,0,0 );
        this.setRot('lToes', 0,0,0 );
    }

    convertFbx( name, anim, autoplay ) {

        const torad = Math.PI / 180;
        let p = new Vector3();
        let q = new Quaternion();
        let RX = new Quaternion().setFromAxisAngle({x:1, y:0, z:0}, 90 * torad );

        const baseTracks = anim.tracks;
        const tracks = [];

        let i = baseTracks.length, j, n, t, b, k = 0;

        while(i--){
            t = baseTracks[k];
            b = t.name.substring(0, t.name.lastIndexOf('.') );

            if( t.name === 'hip.position' ){
                let rp = [];
                j = t.values.length / 3;
                while(j--){
                    n = j * 3;
                    p.set( t.values[n], t.values[n+1], 0).multiplyScalar(0.01);
                    p.toArray( rp, n );
                }
                tracks.push( new VectorKeyframeTrack( t.name, t.times, rp ) );

            } else {
                let rq = [];
                j = t.values.length / 4; 
                while(j--){
                    n = j * 4;
                    if( b==='hip') q.set(t.values[n], t.values[n+1], t.values[n+2], t.values[n+3]).multiply( RX );
                    else q.set(t.values[n], t.values[n+2], -t.values[n+1], t.values[n+3]);
                    q.toArray( rq, n );
                }
                tracks.push( new QuaternionKeyframeTrack( t.name, t.times, rq ) );
            }
            k++;
        }

        let clip = new AnimationClip( name, -1, tracks );
        clip.duration = anim.duration;



        this.stop();
        this.addClip( clip );
        this.addAction( clip, autoplay );

    }

    makePoseTrack( name, data ){

        const torad = Math.PI / 180;
        //let lockPosition = true;
        //let p = new Vector3();
        let q = new Quaternion();
        //let RX = new Quaternion().setFromAxisAngle({x:1, y:0, z:0}, 90 * torad );

        const baseTracks = data;// anim.tracks;
        const tracks = [];

        let i = baseTracks.length, j, n, n2, t, k = 0;

        let numFrame = 3;//3

   

        while(i--){
            t = baseTracks[i];

            /*if( t.name === 'hip.position' ){
                let rp = []
                j = t.values.length / 3;
                while(j--){
                    n = j * 3;
                    if( lockPosition ) p.set( t.values[n], t.values[n+1], 0).multiplyScalar(0.01);
                    else p.set( t.values[n], t.values[n+1], t.values[n+2]).multiplyScalar(0.01);
                    p.toArray( rp, n );
                }
                tracks.push( new VectorKeyframeTrack( t.name, t.times, rp ) );

            } else {*/
                let rq = [];
                let tt = [];
                k = 0;
                j = numFrame;//t.values.length / 3 
                while(j--){
                    n = 0;//j * 3
                    n2 = k * 4;

                    tt.push( k * 0.03333333507180214 );
                    //if( b==='hip') q.set(t.values[n], t.values[n+1], t.values[n+2], t.values[n+3]).multiply( RX );
                    //else q.set(t.values[n], t.values[n+2], -t.values[n+1], t.values[n+3]);
                    q.setFromEuler( {_x:t.values[n]*torad, _y:t.values[n+1]*torad, _z:t.values[n+2]*torad, _order:'XYZ'});
                    q.toArray( rq, n2 );
                    k++;
                }
                tracks.push( new QuaternionKeyframeTrack( t.name+'.quaternion', tt, rq ) );
            //}
            
        }



        let clip = new AnimationClip( name, -1, tracks );
        clip.duration = numFrame * 0.03333333507180214;//anim.duration;

        // additive not work???
        //clip = AnimationUtils.makeClipAdditive( clip, 0, this.getAction( 'idle' ).clip, 30 )
        //clip = THREE.AnimationUtils.subclip( clip, clip.name, 2, 3, 30 );

        //console.log(clip)

        const action = this.mixer.clipAction( clip );
        //action.frameMax = numFrame;
        action.enabled = true;
        //action.time = 0;
        action.setEffectiveTimeScale( 1 );
        //action.setEffectiveWeight( 1 );
        action.play();

        //console.log(action)
        //action.paused = true;
        //this.actions.set( clip.name, action );

        //this.stop();
        //this.addClip( clip, true );
        //this.addAction( clip, autoplay );

    }


    //---------------------
    //
    //  ANIMATION CONTROL
    //
    //---------------------

    prepareCrossFade( startAction, endAction, duration )  {
        //singleStepMode = false;

        this.isPause = false;
        this.unPause();
        // If the current action is 'idle' (duration 4 sec), execute the crossfade immediately;
        // else wait until the current action has finished its current loop

        if ( endAction._clip.name !== 'idle' ) {
            this.executeCrossFade( startAction, endAction, duration );
        } else {
            this.synchronizeCrossFade( startAction, endAction, duration );
        }

    }

    synchronizeCrossFade( startAction, endAction, duration ) {

        this.mixer.addEventListener( 'loop', onLoopFinished );
        const self = this;
        function onLoopFinished( event ) {
            if ( event.action === startAction ) {
                self.mixer.removeEventListener( 'loop', onLoopFinished );
                self.executeCrossFade( startAction, endAction, duration );
            }
        }

    }

    executeCrossFade( startAction, endAction, duration, warping = true ) {
        // Not only the start action, but also the end action must get a weight of 1 before fading
        // (concerning the start action this is already guaranteed in this place)
        this.setWeight( endAction, 1 );
        endAction.time = 0;
        // Crossfade with warping - you can also try without warping by setting the third parameter to false
        startAction.crossFadeTo( endAction, duration, true );
    }

    pause(){
        this.actions.forEach( function ( action ) { action.paused = true; });
        this.isPause = true;
    }

    unPause(){
        this.actions.forEach( function ( action ) { action.paused = false; });
        this.isPause = false;
    }

    playAll(){
        this.actions.forEach( function ( action ) { action.play(); });
    }

    setTimescale( timescale ) {

        this.actions.forEach( function ( action ) { action.setEffectiveTimeScale( timescale ); });

    }

    syncro( name ) {

        let action = this.getAction( name );
        if ( !action ) return;
        let time = action.time;
        this.actions.forEach( function ( action ) { action.time = time; });

    }

    /*setTimescale( action, timescale ) {

        action.enabled = true;
        action.setEffectiveTimeScale( timescale );

    }*/

    setWeight( action, weight ) {

        //if( typeof action === 'string' ) action = this.getAction( action );
        //if ( !action ) return;

        action.enabled = true;
        if(weight<0) weight = 0;
        if(weight>1) weight = 1;
        //let old = action.getEffectiveWeight()
        //if(old===0 && weight!== 0) action.time = 0;
        //action.setEffectiveTimeScale( weight );
        action.setEffectiveWeight( weight );

    }


    getAnimInfo( name ){

        let action = this.getAction( name );
        if ( !action ) return;
        return {
            name: name,
            time: action.time,
            frame: Math.round( action.time * FrameTime ),
            frameMax: action.frameMax,
            timeScale: action.timeScale,
        }

        //if( ui ) ui.updateTimeBarre( anim.frame, anim.frameTime, anim.frameMax );

    }

    getAction( name ) {
        //if ( !this.actions.has( name ) ) return;
        return this.actions.get( name );
    }

    play( name, fade = 0.5 ) {

        let action = this.getAction( name );
        if ( !action ) return false;

        if(!this.current){
            this.stop();
            this.current = action;
            //action.play();
            action.setEffectiveWeight( 1 );
            //console.log(name)
        } else {

            if( this.current !== action ){

                this.old = this.current;
                this.current = action;

                let isIdle = this.current.getClip().name !== 'idle';

                
                /*this.current.play();

                if( this.clipsToesFix.indexOf(name) !== -1 ) this.fixToe = true;
                else this.resetToes(); 

                this.executeCrossFade( this.old, this.current, fade );*/

                


                //this.old.fadeOut( fade );

                const ratio = this.current.getClip().duration / this.old.getClip().duration;
                
                //else {
                    //this.current.paused = false
                    //this.current.time = 0

                    this.current.reset();
                    if ( !isIdle ) this.current.time = this.old.time * ratio;
                    this.current.setEffectiveTimeScale( 1 );
                    this.current.setEffectiveWeight( 1 );
                //}

                
                this.current.crossFadeFrom( this.old, fade, !isIdle );
                this.current.play();


                //console.log( action )

                //this.prepareCrossFade(this.old, this.current, fade)

                /*this.setWeight( this.current, 1 );
                //this.current.time = 0;

                this.old.fadeOut(fade)
                //this.current.reset()
                this.current.fadeIn(fade)
                this.current.play()*/

                //this.current.fadeIn( fade );
                //this.old.fadeOut( fade );

                //this.setWeight( this.current, 1 );

                //this.old.crossFadeFrom( this.current, fade, true );

                /*if ( this.current._clip.name === 'idle' ) {
                    this.old.fadeOut(fade)
                    this.current.reset()
                    this.current.fadeIn(fade)
                    console.log('idle')
                }*/


                

               // this.stop()
               //this.current = action;
               //

            }
        } 

        this.isPause = false;

        return true;
    }

    playFrame ( name, frame, weight = 1 ) {

        let action = this.getAction( name );
        if ( !action ) return;

        action.time = frame * TimeFrame;
        action.setEffectiveWeight( weight );
        action.play();
        action.paused = true;
        this.isPause = true;

    }

    playOne ( frame, weight = 1 ) {

        if ( !this.current ) return;

        this.current.time = frame * TimeFrame;
        this.current.setEffectiveWeight( weight );
        this.current.play();
        this.current.paused = true;
        this.isPause = true;

    }

    stop(){

        this.actions.forEach( function ( action ) { action.setEffectiveWeight( 0 ); });
        //this.mixer.stopAllAction()
    }



    // bone control

    setRot( name, x, y, z ){

        let n = this.bones[name];
        if(!n) return
        n.rotation.set( x*torad, y*torad, z*torad, 'XYZ' );
        n.updateMatrix();
    }

    setRot2( name, x, y, z ){

        let n = this.bones[name];
        if(!n) return
        //let q1 = n.quaternion
        let q2 = new Quaternion().setFromEuler( {_x:x*todeg, _y:y*todeg, _z:z*todeg, _order:'XYZ'}).invert();
     
        n.quaternion.premultiply(q2);
       // n.rotation.set( x*torad, y*torad, z*torad, 'XYZ' );
        n.updateMatrix();
    }

    getRot( name ){

        let n = this.bones[name];
        if(!n) return
        let r = n.rotation.toArray();
        return [ Math.round(r[0]*todeg), Math.round(r[1]*todeg), Math.round(r[2]*todeg) ];
    }

    getWorldPos( name ){

        let n = this.bones[name];
        if(!n) return
        V.set(0,0,0);
        n.localToWorld(V);
        return { x:V.x, y:V.y, z:V.z };
    }


    //---------------------
    //  HIDE PART OF BODY
    //---------------------

    bodyMask( o = {arm:true, leg:true, foot:true, chest:true } ){

        let s = 0.25;
        if(!this.canvas) {
            this.canvas = document.createElement( 'canvas' );
            this.canvas.width = this.canvas.height = 1024*s;
        }

        const ctx = this.canvas.getContext( '2d' ); 
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, 1024*s, 1024*s);
        ctx.fillStyle = 'black';
        if(o.arm) ctx.fillRect( 784*s, 448*s, 236*s, 186*s );
        if(o.leg) ctx.fillRect( 512*s, 734*s, 287*s, 290*s );
        if(o.foot) ctx.fillRect( 817*s, 822*s, 206*s, 200*s );
        if(o.chest){ 
            ctx.fillRect( 480*s, 576*s, 300*s, 160*s );
            ctx.fillRect( 553*s, 466*s, 228*s, 110*s );
            ctx.fillRect( 533*s, 531*s, 20*s, 45*s );
        }

        let img = new Image();
        img.src = this.canvas.toDataURL();

        if(this.mask) this.mask.dispose();
        //this.mask = new CanvasTexture( this.canvas );

        this.mask = new Texture( img );
        this.mask.flipY = false;
        this.mask.needsUpdate = true;
        const m = Pool.getMaterial( 'skin' );
        m.alphaTest = 0.9;
        m.alphaMap = this.mask;
        //m.needsUpdate = true;
    }


    //---------------------
    //   TOOLS
    //---------------------

    zeroColor(g){

        if( g.isMesh ) g = g.geometry;
        let lng = g.attributes.position.array.length;
        g.setAttribute( 'color', new Float32BufferAttribute( new Array(lng).fill(0), 3 ) );

    }

    /*uv2( g, uv2 = true, tangent = true ) {

        if( g.isMesh ) g = g.geometry;
        g.setAttribute( 'uv2', g.attributes.uv );

    }*/

}

class CapsuleHelper extends Object3D {

	constructor( r, h, useDir, material ) {

		super();

		//this.light = light;

		//this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		//this.color = color;

		this.type = 'SpotLightHelper';

		const geometry = new BufferGeometry();

		let py = (h*0.5)-r;
		let side = 32;
		let dir = r*0.2;

		const positions = [
		    r, py, 0 ,   r, -py, 0,
		    -r, py, 0 ,   -r, -py, 0,
		    0, py, r-dir ,   0, py, r+dir,
		];

		for ( let i = 0, j = 1; i < side; i ++, j ++ ) {

			const p1 = ( i / side ) * Math.PI * 2;
			const p2 = ( j / side ) * Math.PI * 2;

			positions.push(
				r*Math.cos( p1 ), py, r*Math.sin( p1 ),
				r*Math.cos( p2 ), py, r*Math.sin( p2 ),

				r*Math.cos( p1 ), -py, r*Math.sin( p1 ),
				r*Math.cos( p2 ), -py, r*Math.sin( p2 ),
			);

		}

		for ( let i = 0, j = 1; i < side; i ++, j ++ ) {

			const p1 = ( i / side ) * Math.PI * 2;
			const p2 = ( j / side ) * Math.PI * 2;

			let s = j <= side*0.5 ? 1 : -1; 

			positions.push(
				r*Math.cos( p1 ), py*s + r*Math.sin( p1 ),0,
				r*Math.cos( p2 ), py*s + r*Math.sin( p2 ),0,
			);

		}

		let colors = [];
		let cc = positions.length/3;
		while(cc--){
			colors.push(0,1,0);
		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		//const material = new LineBasicMaterial( { color:0x00ff00, fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.cone.raycast = function(){return};
		this.add( this.cone );

		if(!useDir) return

		const geometry2 = new BufferGeometry();

		const positions2 = [
		    dir*0.5, -py, r-dir ,   dir*0.5, -py, r+dir,
		    -dir*0.5, -py, r-dir ,   -dir*0.5, -py, r+dir,
		    dir*0.5, -py, r-dir,  -dir*0.5, -py, r-dir,

		    -dir*0.5, -py, r+dir , -dir, -py, r+dir ,
		    dir*0.5, -py, r+dir , dir, -py, r+dir ,

		    -dir, -py, r+dir , 0, -py, r+dir*2 ,
		    dir, -py, r+dir , 0, -py, r+dir*2 ,
		];

		colors = [];
		cc = positions2.length/3;
		while(cc--){
			colors.push(1,0,0);
		}

		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		//const material2 = new LineBasicMaterial( { color:0xFF0000, fog: false, toneMapped: false } );

		this.direction = new LineSegments( geometry2, material );
		this.direction.raycast = function(){return};
		this.add( this.direction );

	}

	setDirection(r) {

		if(!this.direction) return
		this.direction.rotation.y = r;

	}

	dispose() {

		this.cone.geometry.dispose();
		//this.cone.material.dispose();

		if(this.direction){
			this.direction.geometry.dispose();
			//this.direction.material.dispose();
		}

	}

	raycast(){
		return 
	}

	update() {

		/*this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector );*/

		/*if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}*/

	}

}

const _endMatrix = /*@__PURE__*/ new Matrix4();
const _p = /*@__PURE__*/ new Vector3();
const _q = /*@__PURE__*/ new Quaternion();
const _s = /*@__PURE__*/ new Vector3();

class SkeletonBody extends Object3D {

	constructor ( character ) {

		super();

		this.prefix = character.name || 'yoo_';

        this.mode = 'follow';

        this.withFinger = false;

        this.nodes = [];
		this.bones = character.model.skeleton.bones;
		this.model = character.model.root;
        this.posRef = {};
        this.quatRef = {};

        this.useSolver = false; 
        if( root.engine!=='PHYSX' ) this.useSolver = false;

        this.nameList = [];
        this.jointList = [];

        this.breast = false;

        this.ready = false;

		this.init();

	}

    setMode( mode ){

        if( mode === this.mode ) return

        this.mode = mode;
        const data = [];

        let kinematic = this.mode === 'follow';

        let i = this.nodes.length, node;

        while( i-- ){

            node = this.nodes[i];

            data.push( { name : node.name, kinematic:kinematic } );
            node.kinematic = kinematic;
            node.bone.isPhysics = !kinematic;
            
        }

        root.motor.change( data );

    }

    freeBone( node ){

        if(!node.kinematic) return
        node.cc++;
        if(node.cc=== 20 ){
            node.cc = 0;
            node.kinematic = false;
            node.bone.isPhysics = true;
            root.motor.change( { name : node.name, kinematic:false } );
        }
        
    }

    isVisible( v ){

        //let i = this.nodes.length, node
        //while( i-- ) Utils.byName( this.nodes[i].name ).visible = v

        let i = this.nameList.length;
        while( i-- ) Utils.byName( this.nameList[i] ).visible = v;

        let data = [];
        i = this.jointList.length;
        while( i-- ) data.push( { name:this.jointList[i], visible:v } );
        root.motor.change( data );

    }


	init(){

        if( this.useSolver ) this.solver = root.motor.add({ 
            type:'solver', name:this.prefix+'_solver', iteration:32,
            fix:true, needData:true
        });

		const data = [];

        // get character bones var bones = character.skeleton.bones;
        

        let p = new Vector3();
        let s = new Vector3();
        let q = new Quaternion();
        let e = new Euler();
        let mtx = new Matrix4();

        let tmpMtx = new Matrix4();
        let tmpMtxR = new Matrix4();

        let p1 = new Vector3();
        let p2 = new Vector3();

        //let headDone = false

        let i, lng = this.bones.length, name, n, bone, parent;///, child, o, parentName;
        let size, dist, rot, type, kinematic, translate, phyName, motion;

        for( i = 0; i < lng; i++ ){

        	type = null;
            bone = this.bones[i];
            name = bone.name;
            parent = bone.parent;

            if( parent ) {

            	n = parent.name;

            	p1.setFromMatrixPosition( parent.matrixWorld );
            	p2.setFromMatrixPosition( bone.matrixWorld );
                dist = p1.distanceTo( p2 );

	            //translate = [ -dist * 0.5, 0, 0 ];
	            translate = [ 0, 0, dist * 0.5 ];
                size = [ dist, 1, 1 ];
                rot = null;//[0,0,0];
                kinematic = true;
                motion = false;


                // body

                if( n==='hip' && name==='abdomen' ){ type = 'capsule'; size = [  dist*1.8, 0.08 ]; translate = [ 0, 0, -dist * 0.5 ]; rot = [0,0,90];}
                if( n==='abdomen' && name==='chest'  ){ type = 'capsule'; size = [ dist*0.7, 0.08   ]; translate = [ 0, 0, (-dist * 0.5)-0.06 ]; rot = [90,0,0];}
                if( n==='chest' && name==='neck' ){ type = 'capsule'; size = [  dist*0.4, 0.04  ]; translate = [ 0, 0, (-dist * 0.5)-0.02 ]; rot = [0,0,90];}
                if( n==='neck' && name === 'head' ){ type = 'capsule'; size = [ 0.06, dist ]; translate = [ 0, 0, -dist * 0.5 ]; rot = [90,0,0]; }
                if( n==='head' && name === 'End_head' ){ type = 'capsule'; size = [ 0.1, dist-0.17 ]; translate = [ 0, 0.02, (-dist * 0.5)+0.02 ]; rot = [90,0,0]; }
                
                //if( n==='head' && !headDone ){ console.log(name); headDone = true; type = 'sphere'; dist=0.08; size = [ 0.08, 0.2, dist ]; translate = [ 0, 0.025, -0.08 ]; }

	            /*if( n==='chest' && name==='neck' ){ type = 'box'; size = [  0.28, 0.24, dist ]; translate = [ 0, 0, -dist * 0.5 ]; }
	            if( n==='abdomen' && name==='chest'  ){ type = 'box'; size = [ 0.24, 0.20,  dist ]; translate = [ 0, 0, -dist * 0.5 ]; }
                if( n==='hip' && name==='abdomen' ){ type = 'box'; size = [  0.28, 0.24, dist ]; translate = [ 0, 0, -dist * 0.5 ]; }*/

                
                
                


                if( n==='chest' && name==='rBreast' && root.engine!=='HAVOK' ){ n='rBreast'; parent = bone; type = 'sphere'; size = [ 0.065 ]; translate = [ 0.065,0,0 ]; this.breast=true; motion = true; }
                if( n==='chest' && name==='lBreast' && root.engine!=='HAVOK' ){ n='lBreast'; parent = bone; type = 'sphere'; size = [ 0.065 ]; translate = [ 0.065,0,0 ]; this.breast=true; motion = true; }
                

                // arm

                if( n==='lCollar' && name==='lShldr'){ type = 'capsule'; size = [  0.05, dist*0.3 ]; translate = [dist*0.6 , 0, 0 ]; rot = [0,0,90]; }
                if( n==='lShldr' && name==='lForeArm'){ type = 'capsule'; size = [  0.05, dist ]; translate = [dist * 0.5, 0, 0 ]; rot = [0,0,90]; }
                if( n==='lForeArm' && name==='lHand'){ type = 'capsule'; size = [ 0.04, dist ]; translate = [dist * 0.5, 0, 0 ]; rot = [0,0,90]; }
                if( n==='lHand' && name==='lMid1'){ type = 'box'; size = [ dist*2, 0.09, 0.05 ]; translate = [dist, 0, 0 ]; }

                if( n==='rCollar' && name==='rShldr'){ type = 'capsule'; size = [  0.05, dist*0.3 ]; translate = [-dist*0.6, 0, 0 ]; rot = [0,0,90]; }
                if( n==='rShldr' && name==='rForeArm'){ type = 'capsule'; size = [  0.05, dist ]; translate = [-dist * 0.5, 0, 0 ]; rot = [0,0,90]; }
                if( n==='rForeArm' && name==='rHand' ){ type = 'capsule'; size = [ 0.04, dist ]; translate = [-dist * 0.5, 0, 0 ]; rot = [0,0,90]; }
                if( n==='rHand' && name==='rMid1'){ type = 'box'; size = [ dist*2, 0.09, 0.05 ]; translate = [-dist, 0, 0 ]; }

                


	            // legs

                if( n==='lThigh' ){ type = 'capsule'; size = [  0.08, dist ]; rot = [90,0,0]; }
                if( n==='lShin' ){ type = 'capsule'; size = [  0.065, dist ]; rot = [90,0,0]; }
                //if( n==='lFoot' ){ type = 'box'; size = [  0.1, dist*1.4, 0.06 ]; translate = [0, (dist * 0.5)-0.025, 0.06 ]; link:'lShin'; }
                if( n==='lFoot' ){ type = 'capsule'; size = [  0.05, dist ]; translate = [0, (dist * 0.5)-0.025, 0.04 ]; }

                if( n==='rThigh' ){ type = 'capsule'; size = [  0.08, dist ]; rot = [90,0,0]; }
                if( n==='rShin' ){ type = 'capsule'; size = [  0.065, dist ]; rot = [90,0,0]; }
                //if( n==='rFoot' ){ type = 'box'; size = [  0.1, dist*1.4, 0.06 ]; translate = [0, (dist * 0.5)-0.025, 0.06 ]; link:'rShin';}
                if( n==='rFoot' ){ type = 'capsule'; size = [  0.05, dist ]; translate = [0, (dist * 0.5)-0.025, 0.04 ]; }



                //if( n==='rFoot' && name==='lToes' ){ n='lToes'; parent = bone; type = 'capsule'; size = [  0.05, 0.1 ]; translate = [0, 0, 0 ]; link='rFoot'; rot = [0,0,0]; }
                //if( n==='lFoot' && name==='rToes' ){ n='rToes'; parent = bone; type = 'capsule'; size = [  0.05, 0.1 ]; translate = [0, 0, 0 ]; link='rFoot'; rot = [0,0,0]; }

                if( this.withFinger ) {

                    if( n==='lHand' && name==='lMid1'){ type = 'box'; size = [ dist, 0.09, 0.05 ]; translate = [dist*0.5, 0, 0 ]; }
                    if( n==='rHand' && name==='rMid1'){ type = 'box'; size = [ dist, 0.09, 0.05 ]; translate = [-dist*0.5, 0, 0 ]; }


                    if( n==='rThumb1' && name==='rThumb2' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90]; }
                    if( n==='rThumb2' && name==='rThumb3' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90]; }


                    if( n==='rHand' && name==='rMid1' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90];translate = [-dist*0.6, 0, 0 ]; }
                    if( n==='rMid1' && name==='rMid2' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90];translate = [-dist*0.6, 0, 0 ]; }
                    if( n==='rMid2' && name==='rMid3' ){ type = 'capsule'; size = [  0.02, dist ]; rot = [0,0,90];translate = [-dist*0.6, 0, 0 ]; }

                }

                

	            

                if( type !== null ){

                    phyName = this.prefix +'_bone_'+n;

                	// translation
                    tmpMtx.makeTranslation( translate[0], translate[1], translate[2] );
                    // rotation
                    if( rot ){
                        tmpMtxR.makeRotationFromEuler( e.set( rot[0]*torad$1, rot[1]*torad$1, rot[2]*torad$1 ) );
                        tmpMtx.multiply( tmpMtxR );
                    }

                    mtx.copy( parent.matrixWorld );
                    mtx.decompose( p, q, s );

                    this.posRef[phyName] = p.toArray();
                    if( n==='lForeArm' || n==='rForeArm' ){
                        _q.setFromAxisAngle( {x:0, y:1, z:0}, -90*torad$1 );
                        q.multiply( _q );
                    } 

                    this.quatRef[phyName] = q.toArray();
                     
                    mtx.multiplyMatrices( parent.matrixWorld, tmpMtx );
                    mtx.decompose( p, q, s );

                	let physicData = {

                        name: phyName,
                        density:1,
                        //mass:1,
                        type: type,
                        size: MathTool.scaleArray(size,1,3),
                        pos: p.toArray(),
                        //rot: rot,
                        quat: q.toArray(),
                        kinematic: kinematic,
                        friction: 0.5,
                        restitution:0.1,
                        group:1,
                        mask:1|2,
                        material:'bones2',
                        shadow:false,
                        neverSleep: true,

                        //linked:link,
                        //iterations:[4,4],


                        /*bone:parent,
                        decal:tmpMtx.clone(),
                        decalinv:tmpMtx.clone().invert(),*/
                        
                    };

                    /*if( this.useSolver ){
                        physicData['solver'] = this.prefix+'_solver'
                        physicData['linked'] = this.prefix+'_bone_'+link
                        physicData['kinematic'] = false
                    }*/

                    data.push( physicData );

                    this.nameList.push( phyName );

                    this.nodes.push({
                    	name: phyName,
                        kinematic: kinematic,
                        motion:motion,// auto move
                    	bone:parent,
                        decal:tmpMtx.clone(),
                        decalinv:tmpMtx.clone().invert(),
                        quat:q.toArray(),
                        pos:p.toArray(),
                        cc:0,
                    });
                }

            }
        }

        //console.log( data )

        root.motor.add( data );

        //if( this.useSolver ) this.solver.start();
       
        this.addLink();

        this.ready = true;

	}

    addLink () {

        // Stiffness / Damping
        // raideur / amortissement
        //let sp = [0.05,1]
        let sp = [0.05, 1, 0];
        if(root.engine==='PHYSX'){
            // stiffness / damping / restitution / bounceThreshold / contactDistance
            //[0,0, 0, 0.5]
            // raideur / amortissement
            sp = [50,10, 0, 0.5];
        }




        let p = this.prefix+'_bone_';
        let data = [];
        let sett = {
            type:'joint', 
            mode:'d6',
            visible:false,
            lm:[  ['ry',-180,180,...sp], ['rz',-180,180,...sp] ],

            collision:false,
            helperSize:0.05,

            //acc:true,

            //worldAxis:[1,0,0],

            autoDrive: true,

        };

        let breastMotion = [-0.001, 0.001, 100, 0.2, 0.5];
        

        data.push({ ...sett, b1:p+'hip', b2:p+'abdomen', worldPos:this.posRef[p+'abdomen'], worldQuat:this.quatRef[p+'hip'], lm:[ ['rx',-20,20,...sp], ['ry',-20,20,...sp], ['rz',-20,20,...sp]] });
        data.push({ ...sett, b1:p+'abdomen', b2:p+'chest', worldPos:this.posRef[p+'chest'], worldQuat:this.quatRef[p+'chest'], lm:[ ['rx',-20,20,...sp], ['ry',-20,20,...sp], ['rz',-20,20,...sp]] });
        data.push({ ...sett, b1:p+'chest', b2:p+'neck', worldPos:this.posRef[p+'neck'], worldQuat:this.quatRef[p+'neck'], lm:[ ['rx',-60,60,...sp], ['ry',-1,1,...sp], ['rz',-30,30,...sp]] });
        data.push({ ...sett, b1:p+'neck', b2:p+'head', worldPos:this.posRef[p+'head'], worldQuat:this.quatRef[p+'head'], lm:[ ['rx',-60,60,...sp], ['ry',-1,1,...sp], ['rz',-30,30,...sp]] });
        //data.push({ type:'joint', mode:'d6', b1:this.prefix*'chest', b2:this.prefix*'abdomen' })

        // arm

        data.push({ ...sett, b1:p+'chest', b2:p+'rCollar', worldPos:this.posRef[p+'rCollar'],  worldQuat:this.quatRef[p+'rCollar'], lm:[ ['rx',-10,10,...sp], ['ry',-10,10,...sp], ['rz',-10,10,...sp]] });
        data.push({ ...sett, b1:p+'chest', b2:p+'lCollar', worldPos:this.posRef[p+'lCollar'],  worldQuat:this.quatRef[p+'lCollar'], lm:[ ['rx',-10,10,...sp], ['ry',-10,10,...sp], ['rz',-10,10,...sp]] });

        data.push({ ...sett, b1:p+'rCollar', b2:p+'rShldr', worldPos:this.posRef[p+'rShldr'],  worldQuat:this.quatRef[p+'rShldr'] });
        data.push({ ...sett, b1:p+'lCollar', b2:p+'lShldr', worldPos:this.posRef[p+'lShldr'],  worldQuat:this.quatRef[p+'lShldr'] });

       //data.push({ ...sett, b1:p+'chest', b2:p+'rShldr', worldPos:this.posRef[p+'rShldr'], worldQuat:this.quatRef[p+'rShldr'] })
        //data.push({ ...sett, b1:p+'chest', b2:p+'lShldr', worldPos:this.posRef[p+'lShldr'], worldQuat:this.quatRef[p+'lShldr'] })

        data.push({ ...sett, b1:p+'rShldr', b2:p+'rForeArm', worldPos:this.posRef[p+'rForeArm'], worldQuat:this.quatRef[p+'rForeArm'], lm:[['rx',0,160,...sp]] });
        data.push({ ...sett, b1:p+'lShldr', b2:p+'lForeArm', worldPos:this.posRef[p+'lForeArm'], worldQuat:this.quatRef[p+'lForeArm'], lm:[['rx',0,160,...sp]] });

        data.push({ ...sett, b1:p+'rForeArm', b2:p+'rHand', worldPos:this.posRef[p+'rHand'], worldQuat:this.quatRef[p+'rHand'], lm:[['rx',0,160,...sp], ['ry',-10,10,...sp]] });
        data.push({ ...sett, b1:p+'lForeArm', b2:p+'lHand', worldPos:this.posRef[p+'lHand'], worldQuat:this.quatRef[p+'lHand'], lm:[['rx',0,160,...sp], ['ry',-10,10,...sp]] });

        //data.push({ ...sett, b1:p+'rShldr', b2:p+'rForeArm', worldPos:this.posRef[p+'rForeArm'], worldAxis:[1,0,0], lm:[['rx',-120, 0]] })
        //data.push({ ...sett, b1:p+'lShldr', b2:p+'lForeArm', worldPos:this.posRef[p+'lForeArm'], worldAxis:[1,0,0], lm:[['rx',-120, 0]] })

        // leg

        data.push({ ...sett, b1:p+'hip', b2:p+'rThigh', worldPos:this.posRef[p+'rThigh'],  worldQuat:this.quatRef[p+'rThigh'] });
        data.push({ ...sett, b1:p+'hip', b2:p+'lThigh', worldPos:this.posRef[p+'lThigh'],  worldQuat:this.quatRef[p+'lThigh'] });

        data.push({ ...sett, b1:p+'rThigh', b2:p+'rShin', worldPos:this.posRef[p+'rShin'], lm:[['rx',0,160,...sp]], worldQuat:this.quatRef[p+'rShin'] });
        data.push({ ...sett, b1:p+'lThigh', b2:p+'lShin', worldPos:this.posRef[p+'lShin'], lm:[['rx',0,160,...sp]], worldQuat:this.quatRef[p+'lShin'] });

        data.push({ ...sett, b1:p+'rShin', b2:p+'rFoot', worldPos:this.posRef[p+'rFoot'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]], worldQuat:this.quatRef[p+'rFoot'] });
        data.push({ ...sett, b1:p+'lShin', b2:p+'lFoot', worldPos:this.posRef[p+'lFoot'], lm:[['rx',-10,30,...sp], ['rz',-10,10,...sp]], worldQuat:this.quatRef[p+'lFoot'] });

        if(this.breast){
            data.push({ ...sett, b1:p+'chest', b2:p+'rBreast', worldPos:this.posRef[p+'rBreast'], worldQuat:this.quatRef[p+'rBreast'], lm:[['x',...breastMotion], ['y',...breastMotion], ['z',...breastMotion]] });
            data.push({ ...sett, b1:p+'chest', b2:p+'lBreast', worldPos:this.posRef[p+'lBreast'], worldQuat:this.quatRef[p+'lBreast'], lm:[['x',...breastMotion], ['y',...breastMotion], ['z',...breastMotion]] });
        }

        let x = 0;
        for( let j in data ){
            data[j].name = this.prefix + '_joint_'+ x;
            this.nameList.push( data[j].name );
            this.jointList.push( data[j].name );
            x++;
        }


        root.motor.add( data );

    }





    /*makeLink () {

        let p = this.prefix;
        let data = []
        data.push({ type:'joint', mode:'d6', b1:p+'hip', b2:p+'abdomen', visible:true })
        data.push({ type:'joint', mode:'d6', b1:p+'abdomen', b2:p+'chest', visible:true })
        //data.push({ type:'joint', mode:'d6', b1:this.prefix*'chest', b2:this.prefix*'abdomen' })

        //console.log(this.prefix, data)

        root.motor.add( data )

    }*/

	updateMatrixWorld( force ){

        if(!this.ready) return

		let up = [];

		const nodes = this.nodes;
		let i = nodes.length, node, bone, body;


		while( i-- ){

            node = nodes[i];
            bone = node.bone;

            if( node.kinematic ){


                //_tmpMatrix.multiplyMatrices( _rootMatrix, bone.matrixWorld );
                _endMatrix.multiplyMatrices( bone.matrixWorld, node.decal );
                _endMatrix.decompose( _p, _q, _s );

                node.pos = _p.toArray();
                node.quat = _q.toArray();

                up.push({ name:node.name, pos:node.pos, quat:node.quat });

                if( node.motion ) this.freeBone(node);

            } else {

                body = Utils.byName( node.name );

                if(body){

                    _endMatrix.copy( body.matrixWorld ).multiply( node.decalinv );

                    //_endMatrix.multiplyMatrices( node.decalinv, bone.matrixWorld );

                    //_endMatrix
                    //.copy( body.matrixWorld )
                    //.decompose( _p, _q, _s )
                    //.compose( _p, _q, _s.set( 1, 1, 1 ) )
                    //.multiply( node.decalinv );

                    /*if ( bone.parent && bone.parent.isBone ) {

                        //_tmpMatrix.getInverse( bone.parent.matrixWorld );
                        _tmpMatrix.copy( bone.parent.matrixWorld ).invert()
                        _tmpMatrix.multiply( _endMatrix );

                    } else {

                        _tmpMatrix.copy( _endMatrix );

                    }*/

                    bone.phyMtx.copy( _endMatrix );
                    bone.isPhysics = true;// .copy( _endMatrix );
                }
            }

        }

        if( up.length !== 0 ) root.motor.change( up, true );

	}

	dispose(){

        root.motor.remove( this.nameList );

        this.nodes = [];
        this.posRef = {};
        this.quatRef = {};
		this.parent.remove( this );

        this.nameList = [];
        this.jointList = [];
		
	}

}

// THREE CHARACTER

class Character extends Item {

	constructor() {

		super();

		this.Utils = Utils;
		this.type = 'character';
		this.num = Num[this.type];

	}

	/*prestep () {

		let i = this.list.length;

		while( i-- ){

			this.list[i].preStep( );

		}

	}*/

	step ( AR, N ) {

		let i = this.list.length, n, s;

		while( i-- ){

			s = this.list[i];
			n = N + ( i * this.num );
			s.step( AR, n );

		}

	}

	add ( o = {} ) {

		this.setName( o );
		const hero = new Hero( o );

		return hero

	}

	set ( o = {}, b = null ) {

		if( b === null ) b = this.byName( o.name );
		if( b === null ) return

		b.set(o);

	}
	
}

// HERO

class Hero extends Basic3D {

	constructor( o = {} ) {

		super();

		this.type = 'character';
		this.name = o.name || 'hero';
		o.name = this.name;

		this.isRay = false;

		this.ray = null;
		this.model = null;
		this.static = false;

		this.radius = o.radius || 0.3;
		this.height = o.height || 1.8;
		if( o.radius ) delete o.radius;

		this.fall = false;
		this.floor = true;

		this.distance = 0;
		this.rayAngle = 0;
		this.rayStart = -(this.height*0.5)+this.radius;
		this.rayEnd = this.rayStart - this.height; 
		this.maxRayDistance = this.height;

		this.contact = false;

		this.tmpV1 = new Vector3();
		this.tmpV2 = new Vector3();
		this.ease = new Vector3();
		this.tmpAcc = 0;
		this.rs = 0;
		this.ts = 0;
		this.diagonal = 1/Math.sqrt(2);

		this.jump = false;
		this.crouch = false;
		this.toggle = true;
		this.oy = 0;
		this.vy = 0;

		this.timeScale = 1.25;

		this.angle = ( o.angle || 0 ) * torad$1;

		this.speed = {
		    idle:1,
		    fight:1,
		    walk:7.8,
		    crouch:7,
		    run:12,
		};

		this.valheimStyle = true;
		this.globalRay = o.ray || false;

		this.callback = o.callback || function (){};

		if( o.callback ) delete o.callback;

		this.init( o );

	}

	init( o ){

	    if(!o.size) o.size = [ this.radius ,this.height-(2*this.radius) ];
		if(!o.pos) o.pos = [0,this.height*0.5,0];

		this.py = -this.height*0.5;//(o.size[1]*0.5)-o.size[0]

		if( this.globalRay ) root.items.body.geometry( { ...o, type:'capsule', ray:true }, this, Mat.get('hide') );

		o.density = o.density || 1; 
        //o.damping = [0.01,0] 
        o.friction = 0.5;

		o.angularFactor = [0,0,0];
		//o.maxDamping = 1000
		o.group = 16;
		//o.mask = o.mask !== undefined ? o.mask : 1|2
		o.regular = true;
		o.filter = [1,-1,[1, 3, 4,5,9], 0];
		o.inertia = [0,0,0]; 
		//o.kinematic = true
		o.noGravity = true;

		o.volume = MathTool.getVolume( 'capsule', o.size );
	

		// add to world
		root.items.character.addToWorld( this, o.id );

        // add capsule to physics
        root.post({ m:'add', o:o });


        this.ray = root.motor.add({ type:'ray', name:this.name + '_ray', begin:[0,this.rayStart,0], end:[0,this.rayEnd, 0], callback:this.selfRay.bind(this), visible:false, parent:this.name });


        // add skinning character model
        if( o.gender ) this.addModel( o );
        else this.showHelper( true );
		
	}

    selfRay( r ){

    	if( r.hit ){ 
    		this.distance = MathTool.toFixed(r.distance-this.radius);
    		this.rayAngle = r.angle;
    	} else { 
	        this.distance = this.maxRayDistance;
	        this.rayAngle = 0;
	    }

    }

    hit( d ){
    	this.contact = d;
    }

    showHelper( b ){

    	if(b){
    		if(!this.helper){
    			this.helper = new CapsuleHelper(this.radius, this.height, true, Mat.get('line') );
		        this.add(this.helper);
    		}
    	} else {
    		if(this.helper){
    			this.remove(this.helper);
    			this.helper.dispose();
    			this.helper = null;
    		}
    	}

    	if(this.ray) this.ray.visible = b;

    }

    addSkeleton(){

    	if( this.skeletonBody ) return

    	this.skeletonBody = new SkeletonBody( this );
    	root.scene.add( this.skeletonBody );
    	this.skeletonBody.isVisible( false );

    }

    debugMode( v ){

    	if( this.skeletonBody ) this.skeletonBody.isVisible(v);
    	if( this.model ) this.model.setMaterial( {wireframe: v});
    	this.showHelper( v );
        

    }

    setMode( name ){

    	if( this.skeletonBody ) this.skeletonBody.setMode( name );

    	//this.skeletonBody = new SkeletonBody( this )
    	//this.model.add( this.skeletonBody )

    }

	addModel( o ){

		this.model = new Avatar({ 
			type:o.gender, 
			anim: o.anim !== undefined ? o.anim : 'idle', 
			compact:true, 
			material:!o.noMat, 
			morph:o.morph || false, 
			callback:this.callback 
		});

		this.add( this.model );
		///this.model.rotation.order = 'YXZ'
		this.model.setPosition(0, this.py+this.model.decalY, 0);
		this.model.rotation.y = this.angle;
		this.model.updateMatrix();

	}

	raycast(){
		return
	}

	/*preStep(){
		if(this.skeletonBody) this.skeletonBody.update()
	}*/

	step ( AR, n ) {
		
		this.position.fromArray( AR, n + 1 );
		this.quaternion.fromArray( AR, n + 4 );
		this.fall = this.position.y < this.oy;
		this.floor = MathTool.nearEquals(this.position.y, this.oy, 0.1);
		this.oy = this.position.y;
		this.updateMatrix();

		if( this.model ) this.model.update( root.delta );
		//if(this.skeletonBody) this.skeletonBody.update()

	}

	set ( o ) {

		//console.log('set', o)
		if(o.morph){
			if(this.model) this.model.setMorph( o.morph, o.value );
		}

	}

	dispose () {

		this.callback = null;
		if( this.skeletonBody ) this.skeletonBody.dispose();
		if( this.model ) this.model.dispose();
		if( this.helper ) this.showHelper();

		console.log('model remove');

		super.dispose();
	}

	move ( ) {

		const key = root.motor.getKey();
		const azimut = root.motor.getAzimut();
		const delta = root.delta;


		let anim = key[7] !== 0 ? 'run' : 'walk';
	    if( key[0] === 0 && key[1] === 0 ) anim = 'idle';//*= 0.9
	    let m = key[0] !== 0 && key[1] !== 0 ? this.diagonal : 1;

	    if( key[5] && this.toggle ){ 
	    	this.crouch = !this.crouch;
	    	this.toggle = false;
	    }

	    if( key[5] === 0 ) this.toggle = true;

	    if( ( anim==='walk' || anim==='run') && this.crouch ) anim = 'crouch';

	    if( key[6] === 1 ) anim = 'fight';



	    if( !this.jump && key[4] ){ this.vy = 22; this.jump = true; } // SPACE KEY

	    if( this.jump ){
	        this.vy-=1;
	        if(this.vy <= 0 ){ 
	            this.vy = 0; 
	            if( this.floor ) this.jump = false;

	            //if( MathTool.nearEquals(this.position.y, this.oy, 0.1)) this.jump = false;
	             //this.position.y === this.oy 
	        }
	    }

	    //this.oy = this.position.y;

	    /*if(this.crouch){
	    	if( anim==='run' || anim==='walk' ) anim = 'crouch'
	    	if( anim==='idle' ) anim = 'crouchIdle'
	    }*/


	    let mAnim = 'idle';
	    switch( anim ){
	    	case 'idle':
	    	   mAnim = this.crouch ? 'Crouch Idle' : 'idle';
	    	   //if( key[6] === 1 ) mAnim = 'Attack';
	    	break;
	    	case 'walk':
	    	    mAnim = 'Jog Forward';
	    	break;
	    	case 'run': mAnim = 'Standard Run'; break;
	    	case 'crouch': mAnim = 'Crouch Walk'; break;
	    	case 'fight': mAnim = 'Attack'; break;
	    	//case 'crouchIdle': mAnim = 'Crouch Idle'; break;
	    }

	    //if(this.jump) 
	    //this.model.setWeight(, this.jump ? 1:0 )

	    const genSpeed = 1.0;

	    let speed = this.speed[anim] * genSpeed;

	    
	    //this.tmpAcc *= 0.9
	    

	    if( key[0] !== 0 || key[1] !== 0 ){ 

	        this.tmpAcc += delta*4;//MathTool.lerp( tmpAcc, 1, delta/10 )
	        //this.tmpAcc += MathTool.lerp( this.tmpAcc, 1, delta/10 )
	        //this.tmpAcc = MathTool.clamp( this.tmpAcc, 1, speed )

	        //this.rs += key[0] //* this.tmpAcc 
	        //this.ts += key[1] //* this.tmpAcc

	        this.rs = key[0] * speed;//* this.tmpAcc 
	        this.ts = key[1] * speed;//* this.tmpAcc
	    }

	    if( key[0] === 0 && key[1] === 0 ) this.tmpAcc = 0;//*= 0.9
	    //if( key[0] === 0 ) this.rs = 0
	    //if( key[1] === 0 ) this.ts = 0

	    //if( key[0] === 0 ) this.rs *= 0.9
	    //if( key[1] === 0 ) this.ts *= 0.9

	    if(this.tmpAcc>1) this.tmpAcc = 1;

	    //dir.multiplyScalar(tmpAcc)

	    //this.rs = MathTool.clamp( this.rs, -speed, speed ) 
	    //this.ts = MathTool.clamp( this.ts, -speed, speed ) 

	    //this.ease.set( this.ts/speed, 0, this.rs/speed )
	    //this.ease.set( this.rs/speed, 0, this.ts/speed )
	    this.ease.set( this.rs, 0, this.ts ).multiplyScalar( this.tmpAcc * m );

	    //let angle = math.unwrapRad( (Math.atan2(this.ease.z, this.ease.x)) + azimut );
	    let angle = MathTool.unwrapRad( ( Math.atan2(this.ease.x, this.ease.z)) + azimut );

	    this.ease.length(); //((Math.abs(this.ease.x) + Math.abs(this.ease.z)))

	    //console.log(jj, this.ease.length() )

	    //if(jj!== 0)

	    // help climb montagne
	   /* if( !this.jump ){ 
	    	if( !this.fall ) this.vy = acc*8
	    	else this.vy = 0
	    }*/

	    

	    
        //if(anim==='walk' || anim==='run')

        //if(this.static) this.ts = this.rs = 0
        if( this.static ) this.ease.x = this.ease.z = 0;


	    // gravity
	    //let g = this.vy - (this.distance>0.1 ? 9.81 : 0);
	    let g = this.vy - 9.81;

	   // console.log(this.distance)

	    this.ease.y = g;

	    //this.tmpV1.set( this.rs, g, this.ts ).applyAxisAngle( { x:0, y:1, z:0 }, azimut );

	    this.tmpV1.copy( this.ease ).applyAxisAngle( { x:0, y:1, z:0 }, azimut );
	    //math.tmpV2.set( 0, rs, 0 );
	    this.tmpV2.set( 0, 0, 0 );

	    root.motor.change({

		    name:this.name,
		    //force: this.tmpV1.toArray(), forceMode:'velocity', 
		    linearVelocity: this.tmpV1.toArray(), 
		    ///angularVelocity: this.tmpV2.toArray(), 
		    //wake:true, 
		    //noGravity:true 
		});


		if( this.helper ){ 

			//this.helper.updateMatrix()
			this.helper.cone.rotation.y = azimut;//angle
			if( anim !== 'idle' ) this.helper.setDirection( angle ); 

		}


	   // if(anim!=='idle') this.model.setRotation( 0, azimut + Math.PI, 0, 0.25 )
        
        if( !this.model ) return

        //this.model.setTimescale(this.tmpAcc)

        //this.model.setWeight( 'idle', 1-jj )
	    /*this.model.setWeight( 'Jog Forward', -this.ease.x )
	    this.model.setWeight( 'Jog Backward', this.ease.x )
	    this.model.setWeight( 'Jog Strafe Left',-this.ease.z )
	    this.model.setWeight( 'Jog Strafe Right', this.ease.z )*/
	    
	   

	    //if(anim!=='idle') this.model.syncro('Jog Forward')

	    //console.log(tmpAcc)

        
	    if( this.jump ){
	    	this.model.play( 'Jump', 0 );
	    	//this.model.setTimescale( 1 )
	    }else {
	    	this.model.play( mAnim, 0.5 );
	    	//this.model.setTimescale( this.timeScale )
	    	//this.model.setTimescale( 1 )
	    }

	    if( anim !== 'idle' ){

	    	//this.model.setTimescale( 0.5 )

	    	let pp = MathTool.unwrapRad( this.model.rotation.y );
	    	//if( anim === 'fight' ) pp = math.unwrapRad( azimut + Math.PI )
	    	let aa = MathTool.nearAngle( angle, pp );
	    	let diff = Math.abs(Math.floor((pp - aa)*math.todeg)/180);
	    	//console.log(diff)
	    	//this.model.rotation.y = anim === 'fight' ? (azimut + Math.PI) : math.lerp( pp, aa, 0.25 )
	    	this.model.rotation.y = anim === 'fight' ? (azimut + Math.PI) : MathTool.lerp( pp, aa, 0.2 - (diff*0.1) );
	    	this.model.updateMatrix();
	    	//this.model.setTimescale( this.tmpAcc * (1*genSpeed) )

	    	//let m = this.model.getAction( anim )
	    	//if( m ) m.setEffectiveTimeScale( this.tmpAcc * (1*genSpeed) );
	    	//if( m ) m.setEffectiveTimeScale( 0 );
	    }

	    //if( this.helper ) this.helper.setDirection( this.model.rotation.y )

	}


}

class Landscape extends Mesh {

    constructor( o = {} ) {

        super();

        this.ready = false;
        this.needUpdate = false;

        this.type = 'terrain';
        this.name = o.name;

        this.folder = o.folder || './assets/textures/terrain/';

        this.mapN = 0;
        this.mapMax = 7;//7

        // terrain, water, road
        this.ttype = o.terrainType || 'terrain';

        this.callback = o.callback || function(){};
        
        this.physicsUpdate = () => {};

        this.uvx = [ o.uv || 18, o.uv || 18 ];


        this.sample = o.sample == undefined ? [128,128] : o.sample;
        this.size = o.size === undefined ? [100,30,100] : o.size;

        let sx = this.sample[0] - 1;
        let sz = this.sample[1] - 1;

        this.rx = sx / this.size[0];
        this.rz = sz / this.size[2];

        this.zone = o.zone || 1;

        // why ??
        /*let pp = 0
        if( this.zone === 0.5 ) pp=2
        if( this.zone === 0.25 ) pp=3
        if( this.zone === 0.125 ) pp=7*/
        let square = [this.size[0]/sx, this.size[2]/sz];
        //let dx = (this.size[0]/sx)//*pp
        //let dz = (this.size[2]/sz)//**pp

        

        this.sampleZ = [o.sample[0] * this.zone, o.sample[1] * this.zone];
        //this.sizeZ = [(o.size[0]-dx) * this.zone, o.size[1], (o.size[2]-dz) * this.zone];

        this.sizeZ = [(this.sampleZ[0]-1) * square[0], o.size[1], ((this.sampleZ[1]-1)) * square[1]];

        this.lng = this.sample[0] * this.sample[1];
        this.lngZ = this.sampleZ[0] * this.sampleZ[1];

        //console.log(  this.sample, this.sampleZ)

        this.getZid();


        this.data = {
            level: o.level || [1,0.2,0.05],
            frequency: o.frequency || [0.016,0.05,0.2],
            expo: o.expo || 1,
        };

        this.isWater = o.water || false;

        this.isBorder = false;
        this.wantBorder = o.border || false;

        this.isBottom = false;
        this.wantBottom = o.bottom || false;
        this.wantBorder = o.border || false;

        this.colorBase = this.isWater ? { r:0, g:0.7, b:1 } : { r:0.25, g:0.25, b:0.25 };

        this.maxspeed = o.maxSpeed || 0.1;
        this.acc = o.acc == undefined ? 0.01 : o.acc;
        this.dec = o.dec == undefined ? 0.01 : o.dec;

        this.deep = o.deep == undefined ? 0 : o.deep;

        this.ease = new Vector2();

        // for perlin
        this.complexity = o.complexity == undefined ? 30 : o.complexity;
        this.complexity2 = o.complexity2 == undefined ? null : o.complexity2;

        this.local = new Vector3();
        if( o.local ) this.local.fromArray( o.local );

        this.pp = new Vector3();

        this.ratioZ = 1 / this.sampleZ[0];
        this.ratio = 1 / this.sample[0];
        this.ruvx =  1.0 / ( this.size[0] / this.uvx[0] );
        this.ruvy = - ( 1.0 / ( this.size[2] / this.uvx[1] ) );

        this.is64 = o.is64 || false;
        this.isTurn = o.turn || false;

        this.heightData = new Float32Array( this.lngZ );
        this.height = [];

        // for physx 
        this.isAbsolute = o.isAbsolute || false;
        this.isTurned = o.isTurned || false;

        this.isReverse = o.isReverse || false;

        this.changeId = this.isReverse || this.isTurned;
       // console.log(this.changeId)


        if( this.changeId ) this.getReverseID();

        this.colors = new Float32Array( this.lng * 3 );
        this.geometry = new PlaneGeometry( this.size[0], this.size[2], this.sample[0] - 1, this.sample[1] - 1 );
        this.geometry.rotateX( -math$1.PI90 );
        //if( this.isTurn ) 
        //this.geometry.rotateY( -math.PI90 );
        //if( this.isTurned ) this.geometry.rotateY( math.PI90 );


       // this.geometry.computeBoundingSphere();

        this.geometry.setAttribute( 'color', new BufferAttribute( this.colors, 3 ) );
        //this.geometry.setAttribute( 'uv2', this.geometry.attributes.uv );
        this.vertices = this.geometry.attributes.position.array;
        var clevels = new Quaternion( 0.5, 0.5, 0.1, 0.2 );//0.95, 0.8, 0.1, 0.05 ); 
        if( o.maplevels ) clevels.fromArray( o.maplevels );
        var T = TerrainShader;
        var maps = o.maps || [ 'sand', 'grass3', 'rock' ], txt = {};
        var name;

        if(this.isWater) maps = ['water'];

        for( let i in maps ){

            name = maps[i];

            txt[name+'_c'] = Pool.texture({ url:this.folder + name +'_c.jpg', flip:false, repeat:this.uvx, encoding:o.encoding || true , callback: this.mapcallback.bind(this)  });
            txt[name+'_n'] = Pool.texture({ url:this.folder + name +'_n.jpg', flip:false, repeat:this.uvx, callback: this.mapcallback.bind(this) });

            //txt[name+'_c'] = Pool.directTexture(this.folder + name +'_c.jpg', { flip:false, repeat:this.uvx, encoding:o.encoding || true , callback: this.mapcallback.bind(this)  });
            //txt[name+'_n'] = Pool.directTexture(this.folder + name +'_n.jpg', { flip:false, repeat:this.uvx, callback: this.mapcallback.bind(this) });
           // if( isORM )txt[name+'_n'] = Pool.directTexture('./assets/textures/terrain/'+name+'_n.jpg', { flip:false, repeat:this.uvx, callback: this.mapcallback.bind(this) });

        }

        //txt['noise'] = Pool.directTexture(this.folder + 'noise.png', { flip:false, repeat:[1,1], encoding:false , callback: this.mapcallback.bind(this)  });
        //txt['noise'] = Pool.texture({ url:this.folder + 'noise.png', flip:false, repeat:[1,1], encoding:false , callback: this.mapcallback.bind(this)  });

        this.txt = txt;

        this.material = new MeshPhysicalMaterial({ name:'terrain', vertexColors:true, color:0xFFFFFF, map:txt[maps[0]+'_c'], normalMap:txt[maps[0]+'_n'] });

        if( o.envmap !== undefined ) this.material.envMap = o.envmap;

        if( this.isWater ){
            this.material.transparent = true;
            this.material.opacity = o.opacity || 0.4;
            this.material.side = DoubleSide;
            this.material.alphaMap = txt[maps[0]+'_c'];
            this.material.map = null;
            this.material.metalness  = 0.9;
            this.material.roughness = 0.1;
        } else {
            this.material.reflectivity = 0.0;
            this.material.metalness = o.metalness || 0.0;
            this.material.roughness = o.roughness || 0.77; 
        }

        var ns = o.nScale || 1;
        this.material.normalScale.set(ns,ns);

        if( !this.isWater ){

            this.material.onBeforeCompile = function ( shader ) {

                let uniforms = shader.uniforms;

                //uniforms['fogTime'] = { value: 0 };

                uniforms['clevels'] = { value: clevels };

                uniforms['map1'] = { value: txt[maps[1]+'_c'] };
                uniforms['map2'] = { value: txt[maps[2]+'_c'] };

                uniforms['randomUv'] = { value: 1 };

                uniforms['normalMap1'] = { value: txt[maps[1]+'_n'] };
                uniforms['normalMap2'] = { value: txt[maps[2]+'_n'] };

                //uniforms['noise'] = { value: txt['noise'] };

                shader.uniforms = uniforms;

                Shader.addParsFragment( shader, Shader.getRandomUv() + T.fragmentAdd );

                let fragment = shader.fragmentShader;

                fragment = fragment.replace( '#include <map_fragment>', T.map );
                fragment = fragment.replace( '#include <normal_fragment_maps>', T.normal );
                fragment = fragment.replace( '#include <color_fragment>', '' );
                
                shader.fragmentShader = fragment;

                this.userData.shader = shader;

                //if( o.shader ) o.shader.modify( shader );

                Shader.modify( shader );

            };


            Object.defineProperty( this.material, 'randomUv', {
                  get() { return this.userData.shader.uniforms.randomUv.value ? true : false; },
                  set( value ) { this.userData.shader.uniforms.randomUv.value = value ? 1 : 0; }
            });

            Object.defineProperty( this.material, 'map1', {
                  get() { return this.userData.shader.uniforms.map1.value; },
                  set( value ) { this.userData.shader.uniforms.map1.value = value; }
            });

            Object.defineProperty( this.material, 'map2', {
                  get() { return this.userData.shader.uniforms.map2.value; },
                  set( value ) { this.userData.shader.uniforms.map2.value = value; }
            });

            Object.defineProperty( this.material, 'normalMap1', {
                  get() { return this.userData.shader.uniforms.normalMap1.value; },
                  set( value ) { this.userData.shader.uniforms.normalMap1.value = value; }
            });

            Object.defineProperty( this.material, 'normalMap2', {
                  get() { return this.userData.shader.uniforms.normalMap2.value; },
                  set( value ) { this.userData.shader.uniforms.normalMap2.value = value; }
            });

        } else {

            this.material.onBeforeCompile = function ( shader ) {

                var fragment = shader.fragmentShader;

                fragment = fragment.replace( '#include <alphamap_fragment>', T.alphamap );
           
                shader.fragmentShader = fragment;

            };

        }


        //THREE.Mesh.call( this, this.geometry, this.material );

       // super( this.geometry, this.material );

        if(o.debug){
            this.debugZone(o);
        }

        //root.garbage.push( this.geometry );
        

        if( this.wantBorder ) this.addBorder( o );
        if( this.wantBottom ) this.addBottom( o );

        if( o.pos ) this.position.fromArray( o.pos );


        // rotation is in degree or Quaternion
        o.quat = o.quat === undefined ? [ 0, 0, 0, 1 ] : o.quat;
        if( o.rot !== undefined ){ o.quat = math$1.toQuatArray( o.rot ); delete o.rot; }
        //console.log(o.quat)
        this.quaternion.fromArray( o.quat );

        if( o.decal ) this.position.y += o.decal;

        this.castShadow = true;
        this.receiveShadow = true;

        Pool.set( 'terrain' + this.name, this.material, 'material', true );

        this.update();

    }

    getZid(){

        this.zid = {};

        let lx = (this.sample[0] - this.sampleZ[0])*0.5;
        let lz = (this.sample[1] - this.sampleZ[1])*0.5;
        let first = (this.sample[0] * lz) + lx;
        let line = 0;
        for (let j = 0; j<this.lngZ; j++ ){
            //line = j % this.sampleZ[0];
            line = Math.floor(j / this.sampleZ[0]);
            this.zid[ first + j + (line*((lx*2))) ] = j;
        }
    }

    debugZone(o) {

        this.geometryZ = new PlaneGeometry( this.sizeZ[0], this.sizeZ[2], this.sampleZ[0] - 1, this.sampleZ[1] - 1 );
        this.geometryZ.rotateX( -math$1.PI90 );
        this.verticesZ = this.geometryZ.attributes.position.array;
        
        const debuger = new Mesh( this.geometryZ, new MeshBasicMaterial({color:0xff0000, wireframe:true } ));
        if( o.pos ) debuger.position.fromArray( o.pos );
        this.add( debuger );

        

    }

    mapcallback (){

        this.mapN++;
        if( this.mapN == this.mapMax ){ 
           // this.material.needsUpdate = true;
            this.callback();
        }

    }

    addBottom ( o ){

    	var geometry = new PlaneGeometry( this.size[0], this.size[2], 1, 1 );
        geometry.rotateX( math$1.PI90 );
        

        this.bottomMesh = new Mesh( geometry, this.borderMaterial );

        this.add( this.bottomMesh );

        this.isBottom = true;
    }

    addBorder ( o ){

    	this.borderMaterial = new MeshStandardMaterial({ 

    		vertexColors: true, 
    		metalness: this.isWater ? 0.8 : 0.4, 
       		roughness: this.isWater ? 0.2 : 0.6, 
       
            //envMap: view.getEnvMap(),
            //normalMap:this.wn,
            normalScale:this.isWater ?  [0.25,0.25]:[2,2],
            transparent:this.isWater ? true : false,
            opacity: this.isWater ? (o.opacity || 0.8) : 1,
            envMap: o.envmap || null, 

    		//shadowSide : false

    	});

    	//view.getMat()[this.name+'border'] = this.borderMaterial;

        var front = new PlaneGeometry( this.size[0], 2, this.sample[0] - 1, 1 );
        var back = new PlaneGeometry( this.size[0], 2, this.sample[0] - 1, 1 );
        var left = new PlaneGeometry( this.size[2], 2, this.sample[1] - 1, 1 );
        var right = new PlaneGeometry( this.size[2], 2, this.sample[1] - 1, 1 );

        front.translate( 0,1, this.size[2]*0.5);
        back.rotateY( -math$1.Pi );
        back.translate( 0,1, -this.size[2]*0.5);
        left.rotateY( -math$1.PI90 );
        left.translate( -this.size[0]*0.5,1, 0);
        right.rotateY( math$1.PI90 );
        right.translate( this.size[0]*0.5,1, 0);

        this.borderGeometry = mergeVertices( mergeBufferGeometries( [ front, back, left, right ] ) );
        this.borderVertices = this.borderGeometry.attributes.position.array;
        this.lng2 = this.borderVertices.length / 3;
        this.list = new Array( this.lng2 );
        this.borderColors = new Float32Array( this.lng * 3 );
        this.borderGeometry.setAttribute( 'color', new BufferAttribute( this.borderColors, 3 ) );
        this.borderMesh = new Mesh( this.borderGeometry, this.borderMaterial );

        var j = this.lng2, n, i;
        while(j--){
            n = j*3;
            i = this.borderVertices[n+1] > 0 ? this.findPoint( this.borderVertices[n], this.borderVertices[n+2] ) : -1;
            this.list[j] = i;

        }

        this.add( this.borderMesh );

        this.borderMesh.castShadow = true;
        this.borderMesh.receiveShadow = true;

        this.isBorder = true;

    }

    dispose () {

        if(this.isBottom){
            this.remove( this.bottomMesh );
            this.bottomMesh.geometry.dispose();
        }

        if(this.isBorder){
            this.remove( this.borderMesh );
            this.borderMesh.geometry.dispose();
            this.borderMesh.material.dispose();
        }

        this.geometry.dispose();
        this.material.dispose();
        for(let t in this.txt) this.txt[t].dispose();
        
    }

    easing ( key, azimuthal, wait ) {

        //var key = user.key;
        if( key[0]===0 && key[1]===0 ) return;

        //if( !key[0] || !key[1] ) return;

        var r = azimuthal || 0;//view.getAzimuthal();

        if( key[7] ) this.maxspeed = 1.5;
        else this.maxspeed = 0.25;

        //acceleration
        this.ease.y += key[1] * this.acc; // up down
        this.ease.x += key[0] * this.acc; // left right
        //speed limite
        this.ease.x = this.ease.x > this.maxspeed ? this.maxspeed : this.ease.x;
        this.ease.x = this.ease.x < -this.maxspeed ? -this.maxspeed : this.ease.x;
        this.ease.y = this.ease.y > this.maxspeed ? this.maxspeed : this.ease.y;
        this.ease.y = this.ease.y < -this.maxspeed ? -this.maxspeed : this.ease.y;

        //break
        if (!key[1]) {
            if (this.ease.y > this.dec) this.ease.y -= this.dec;
            else if (this.ease.y < -this.dec) this.ease.y += this.dec;
            else this.ease.y = 0;
        }
        if (!key[0]) {
            if (this.ease.x > this.dec) this.ease.x -= this.dec;
            else if (this.ease.x < -this.dec) this.ease.x += this.dec;
            else this.ease.x = 0;
        }

        if ( !this.ease.x && !this.ease.y ) return;

        this.local.z += Math.sin(r) * this.ease.x + Math.cos(r) * this.ease.y;
        this.local.x += Math.cos(r) * this.ease.x - Math.sin(r) * this.ease.y;

        this.update( wait );

    }

    

    getTri (){

        return this.geometry


    }

    getHeight ( x, z ) {



        x *= this.rx;
        z *= this.rz; 
        x += this.sample[0]*0.5;
        z += this.sample[1]*0.5;

        //this.pv.set( x, 0, z ).applyAxisAngle( {x:0, y:1, z:0}, -math.PI90 )

        /*if( this.isTurn ){
            x = Math.floor(-z);
            z = Math.floor(x);
        }else {*/
            x = Math.floor(x);
            z = Math.floor(z);
        //}

        
        
        var h = this.isTurn ? this.height[ this.findId2( x, z ) ] : this.height[ this.findId( x, z ) ];
        return ( h * this.size[ 1 ] ) + this.position.y;

    }

    findIdZ( x, z ){

        return x+(z*this.sampleZ[1]) //|| 1;

    }

    findId( x, z ){

        return x+(z*this.sample[1]) //|| 1;

    }

    findId2( x, z ){

        return z+(-x*this.sample[0]) || 1;

    }

    /*findId3( x, z ){

        return z+(x*this.sample[0]) //|| 1;

    }*/

    findPoint( x, z ){

        var i = this.lng, n;
        while( i-- ){
            n = i * 3;
            if( this.vertices[ n ] === x && this.vertices[ n + 2 ] === z ) return i;
        }

        return -1;

    }

    getReverseID () {

        this.invId = [];

        let i = this.lngZ, x, z;
        const sz = this.sampleZ[1] - 1;
        this.sampleZ[0] - 1;

        while(i--){

            x = i % this.sampleZ[0];
            z = Math.floor( i * this.ratioZ );
            if( this.isReverse ) z = sz - z;
            //xr = sx - x;
            //this.invId[i] = this.findId( x, sz - z )//
            this.invId[i] = this.isTurned ?  (this.lngZ-1)-this.findIdZ( z, x ) : this.findIdZ( x, z );

            //console.log(i, this.findId( x, sz - z ), (this.lng-1)-this.findId( z, x ))
        }

    }

    set( o ) {

        if( o.ease ) this.easing( o.key, o.azimut );
        if( o.decal ) this.decal( o.decal, true );

    }

    decal( v, wait ){

        this.local.x += v[0];
        this.local.y += v[1];
        this.local.z += v[2];
        this.update( wait );

    }

    updateUv () {

        if( this.isWater ){ 
            this.material.normalMap.offset.x+=0.002;
            this.material.normalMap.offset.y+=0.001;
        } else {
            let v = { x: this.local.x * this.ruvx, y: this.local.z * this.ruvy };
            if(this.material.map) this.material.map.offset.copy(v);
            if(this.material.normalMap) this.material.normalMap.offset.copy(v);
            
        }

    }

    update ( wait ) {

        let v = this.pp;
        let cc = [1,1,1];
        let i = this.lng, n, x, z,  c, id, result, idz;
        let oldz, oldh, ccY, ccc;

        while( i-- ){


            n = i * 3;
            x = i % this.sample[0];
            z = Math.floor( i * this.ratio );

            v.set( x + ( this.local.x*this.rx ), this.local.y, z + ( this.local.z*this.rz ) );

            c = math$1.noise( v, this.data );



            //c = Math.quinticSCurve(c);
            //c = Math.cubicSCurve(c)
            //c = Math.linear(c,0.2, 1);
            //c = Math.clamp(c,0.2,1)

            c = Math.pow( c, this.data.expo );

            c = c>1 ? 1:c;
            c = c<0 ? 0:c;
            
            
            if( this.ttype === 'road' ) {

                if(oldz === z){
                    if(x===1 || x===2 || x===29 || x===30) c = oldh + 0.1;
                    else c = oldh;
                } else { 
                    oldz = z;
                    oldh = c;
                }

                //console.log(x)
            }

            this.height[ i ] = c;

            ccY = (c * this.size[ 1 ]) + this.deep;
            this.vertices[ n + 1 ] = ccY;

            //id = this.changeId ? this.invId[i] : i;
            result = this.isAbsolute ? c : c * this.size[1];

            if( this.zid[ i ] !== undefined ){
                idz = this.zid[ i ];
                id = this.changeId ? this.invId[idz] : idz;

                 // for physics
                this.heightData[ id ] = result;

                // for debug
                if(this.verticesZ) this.verticesZ[ ( idz * 3 ) + 1 ] = ccY;

            }

            // for physics
            //this.heightData[ id ] = result;

            

            

            if( this.isWater ){

                cc = [ c * this.colorBase.r, c * this.colorBase.g, c * this.colorBase.b ];

            } else {

                cc = [ c, 0, 0];

            }

            //ccc = math.clamp(cc[0]+0.25, 0.25, 1)
            ccc = cc[0];

            //if(ccc>mm) mm = ccc
            //if(ccc<mi) mi = ccc

            

            this.colors[ n ] = ccc;
            this.colors[ n + 1 ] = ccc;
            this.colors[ n + 2 ] = ccc;
            //oldx = x;
            

        }

        //console.log(mm, mi)


        if( this.isBorder ){

            let j = this.lng2, h;
            while(j--){
                n = j*3;
                if(this.list[j]!==-1){
                    h = this.height[ this.list[j] ];
                    this.borderVertices[n+1] = (h * this.size[1]) + this.deep;
                    ccc = math$1.clamp(h+0.25, 0.25, 1);
                    this.borderColors[n] = ccc; //* this.colorBase.r;//h * this.colorBase.r//ee;
                    this.borderColors[n+1] = ccc; //* this.colorBase.g;// h * this.colorBase.g//ee*0.5;
                    this.borderColors[n+2] = ccc; //* this.colorBase.b;// h * this.colorBase.b//ee*0.3;

                } else {
                    this.borderColors[n] = this.colorBase.r;//0.5;
                    this.borderColors[n+1] = this.colorBase.g;//0.25;
                    this.borderColors[n+2] = this.colorBase.b;//0.15;
                }
            }

        }

        if( wait ) this.needUpdate = true;
        else this.updateGeometry();

        

        if( this.ready ) this.physicsUpdate( this.name, this.heightData );

        this.ready = true;

        //if( phy ) root.view.update( { name:'terra', heightData:this.heightData, sample:this.sample } );

    }

    step (n) {

        if( !this.needUpdate ) return
        this.updateGeometry();
        this.needUpdate = false;
        
    }

    updateGeometry () {

        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.color.needsUpdate = true;
        this.geometry.computeVertexNormals();

        this.updateUv();

        if(this.geometryZ) this.geometryZ.attributes.position.needsUpdate = true;

        if( this.isBorder ){
        	this.borderGeometry.attributes.position.needsUpdate = true;
            this.borderGeometry.attributes.color.needsUpdate = true;
        }

    }

}

// SHADERS

// about no tiles
// https://iquilezles.org/articles/texturerepetition/

const TerrainShader = {

    fragmentAdd : /* glsl */`
        uniform vec4 clevels;
        uniform float randomUv;

        uniform sampler2D noise;

        uniform sampler2D normalMap1;
        uniform sampler2D normalMap2;

        uniform sampler2D roughnessMap1;
        uniform sampler2D roughnessMap2;

        uniform float aoMapIntensity;
        uniform sampler2D map1;
        uniform sampler2D map2;

        vec4 textureMAP( sampler2D mapper, in vec2 uv ){
            if( randomUv == 1.0 ) return textureNoTile( mapper, uv );
            else return texture2D( mapper, uv );
        }

        vec4 MappingMix( float slope, vec4 level, vec4 rocks, vec4 grasss, vec4 sands ){
            vec4 cc = rocks;
            if (slope < level.x) cc = grasss;
            if (slope < level.z) cc = sands;
            //if (( slope < level.x ) && (slope >= level.y)) cc = mix( grasss , rocks, (slope - level.y) * (1. / (level.x - level.y)));
            //if (( slope < level.y ) && (slope >= level.z)) cc = mix( sands , grasss, (slope - level.z) * (1. / (level.y - level.z)));

            float d = level.y;
            float rx = 1.0/level.y;

            if (( slope < level.x + d ) && (slope > level.x)) cc = mix( grasss , rocks, ( slope - (level.x) ) * rx );

            d = level.w;
            rx = 1.0/level.w;
            if (( slope < level.z + d ) && (slope > level.z )) cc = mix( sands , grasss, ( slope - (level.z) ) * rx );

            //cc = mix( grasss, cc, smoothstep(0.0,1.0, slope)*20.0 );
            return cc;
        }
    `,

    // roughnessmap_fragment

    rough : /* glsl */`
        float roughnessFactor = roughness;
        float metalnessFactor = metalness;
        #ifdef USE_ROUGHNESSMAP

            vec4 sandR = textureMAP( roughnessMap, vRoughnessMapUv );
            vec4 grassR = textureMAP( roughnessMap1, vRoughnessMapUv );
            vec4 rockR = textureMAP( roughnessMap2, vRoughnessMapUv );

            vec4 baseColorR = MappingMix( vColor.r, clevels, rockR, grassR, sandR );
            // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
            float ambientOcclusion =( baseColorR.r - 1.0 ) * aoMapIntensity + 1.0;
            roughnessFactor *= baseColorR.g;
            metalnessFactor *= baseColorR.b;
        #endif
    `,

    // aomap_fragment

    ao : /* glsl */`
        reflectedLight.indirectDiffuse *= ambientOcclusion;
        #if defined( USE_ENVMAP ) && defined( STANDARD )
            float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
            reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
        #endif
    `,

    // map_fragment.glsl

    map : /* glsl */`
        #ifdef USE_MAP

            vec4 sand = textureMAP( map, vMapUv );
            vec4 grass = textureMAP( map1, vMapUv );
            vec4 rock = textureMAP( map2, vMapUv ); 

            vec4 baseColor = MappingMix(vColor.r, clevels, rock, grass, sand);
            diffuseColor *= baseColor;

        #endif
    `,

    // normal_fragment_maps

    normal : /* glsl */`

        #ifdef USE_NORMALMAP_OBJECTSPACE

            normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

            #ifdef FLIP_SIDED

                normal = - normal;

            #endif

            #ifdef DOUBLE_SIDED

                normal = normal * faceDirection;

            #endif

            normal = normalize( normalMatrix * normal );

        #elif defined( USE_NORMALMAP_TANGENTSPACE )

            vec4 sandN = textureMAP( normalMap, vNormalMapUv );
            vec4 grassN = textureMAP( normalMap1, vNormalMapUv );
            vec4 rockN = textureMAP( normalMap2, vNormalMapUv );
            vec3 mapN = MappingMix(vColor.r, clevels, rockN, grassN, sandN).xyz * 2.0 - 1.0;

            ///vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;

            mapN.xy *= normalScale;
            normal = normalize( tbn * mapN );

        #elif defined( USE_BUMPMAP )

            normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

        #endif
    `,

    normal2 : /* glsl */`

        #ifdef OBJECTSPACE_NORMALMAP

            normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

            #ifdef FLIP_SIDED

                normal = - normal;

            #endif

            #ifdef DOUBLE_SIDED

                normal = normal * faceDirection;

            #endif

            normal = normalize( normalMatrix * normal );

        #elif defined( TANGENTSPACE_NORMALMAP )

            vec4 sandN = textureMAP( normalMap, vNormalMapUv );
            vec4 grassN = textureMAP( normalMap1, vNormalMapUv );
            vec4 rockN = textureMAP( normalMap2, vNormalMapUv );

            vec3 mapN = MappingMix(vColor.r, clevels, rockN, grassN, sandN).xyz * 2.0 - 1.0;

            //vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
            mapN.xy *= normalScale;

            normal = normalize( tbn * mapN );

        #elif defined( USE_BUMPMAP )

            normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

        #endif
    `,

    alphamap : /* glsl */`
        #ifdef USE_ALPHAMAP
            diffuseColor.a = opacity +( texture2D( alphaMap, vAlphaMapUv ).g * opacity) * (1.0-opacity);
        #endif
    `,
    
};

// THREE TERRAIN

class Terrain extends Item {

	constructor() {

		super();

		this.Utils = Utils;
		this.type = 'terrain';
		this.num = Num[this.type];

	}

	step ( AR, N ) {

		let i = this.list.length, s;

		while( i-- ){

			s = this.list[i];
			//n = N + ( i * this.num );
			s.step();// AR[n] );

		}

	}

	add ( o = {} ) {

		this.setName( o );

		if( root.engine === 'PHYSX' ){
			o.isAbsolute = true;
			o.isTurned = true;
		}

		if( root.engine === 'HAVOK'){
			o.isAbsolute = true;
			o.isTurned = true;
			o.isReverse = false;
		}

		if( root.engine !== 'OIMO'){
			o.zone = o.zone || 0.25;
			//o.debuger = true
		}

		const t = new Landscape( o );

		t.physicsUpdate = ( name, h ) =>{

			root.flow.tmp.push( { name:name, heightData:h } );
			//root.post({m:'change', o:{ name:'terra', heightData:h }})
		};

		// add to world
		this.addToWorld( t, o.id );

        // add to physics
        root.post({ m:'add', o:toPhysics(t) });

		return t

	}

	set ( o = {}, b = null ) {

		if( b === null ) b = this.byName( o.name );
		if( b === null ) return

		b.set(o);

	}
	
}

const toPhysics = function( t ) {

	const o = {
		name:t.name,
		type:t.type,
		pos:t.position.toArray(),
		quat:root.engine === 'PHYSX' ? [0,0,0,1]:t.quaternion.toArray(), // physx terrain can't turn !!
	};

	if( root.engine === 'PHYSX' || root.engine === 'AMMO' || root.engine === 'HAVOK' ){
		o.type = 'terrain';
		o.size = t.sizeZ;
		o.sample = t.sampleZ;
		o.zone = t.zone;
		o.heightData = t.heightData;
	} else {
		o.type = 'mesh';
		o.v = MathTool.getVertex( t.geometry, root.engine === 'OIMO' );
		o.index = root.engine === 'OIMO' ? null : MathTool.getIndex( t.geometry );
	}

	return o

};

class Solver extends Item {

	constructor () {

		super();

		this.Utils = Utils;
		this.type = 'solver';

	}

	step ( AR, N ) {

		let i = this.list.length, n;

		while( i-- ){

			n = N + ( i * Num[this.type] );
			this.list[i].update( AR, n );

		}

	}

	///

	add ( o = {} ) {

		this.setName( o );

        let solver = new Articulation( o );

        // add to world
		this.addToWorld( solver, o.id );

        // add to worker
        root.post({ m:'add', o:o });

        return solver;


	}

	set ( o = {} ) {

	}

}

// ARTICULATION SOLVER

class Articulation {//extends Basic3D 

	constructor( o ) {

		//super();

		this.name = o.name;
		this.type = 'solver';
		this.needData = o.needData || false;
		this.joints = [];
		this.jid = 0;
		this.speed = 1;

	}

	update ( AR, n ){

		if( !this.needData ) return

		let k = this.joints.length, j, m;

		while(k--){

			m = n + (k*7);

			j = this.joints[k];

			j.data.target.x = AR[ m + 0];
			j.data.target.y = AR[ m + 1];
			j.data.target.z = AR[ m + 2];

			j.data.target.rx = Math.round( AR[ m + 3] );
			j.data.target.ry = Math.round( AR[ m + 4] );
			j.data.target.rz = Math.round( AR[ m + 5] );

			/*j.data.target.twiwt = Math.round( AR[ m + 3] )
			j.data.target.swing1 = Math.round( AR[ m + 4] )
			j.data.target.swing2 = Math.round( AR[ m + 5] )*/

			j.data.target.count = AR[ m + 6 ];

		}

	}

	start (){

		root.post({ m:'startArticulation', o:{ name:this.name } });

	}

	stop (){

		root.post({ m:'stopArticulation', o:{ name:this.name } });

	}

	commonInit (){

		root.post({ m:'commonInitArticulation', o:{ name:this.name } });

	}

	addJoint ( o ) {

		this.jid = this.joints.length;

		o.name = o.name || ( this.name + '_Joint_' + this.jid );
		o.solver = this.name;

		if( o.rot1 !== undefined ){ o.quat1 = MathTool.quatFromEuler( o.rot1 ); delete ( o.rot1 ); }
		if( o.rot2 !== undefined ){ o.quat2 = MathTool.quatFromEuler( o.rot2 ); delete ( o.rot2 ); }
		
		if(o.type !== 'fixe') {
			this.joints.push( new SolverJoint( o, this ) );
		}

		root.post({ m:'addSolverJoint', o:o });

	}

	/*addBone ( mesh ) {

		console.log('bone is add')

		this.add( mesh );

	}*/

	driveJoints ( dt ) {

		let isInDrive = false;

		let k = this.joints.length, j, d, nup = [];

		while(k--){ 

			j = this.joints[k];
			j.update( dt );
			d = j.isDrive;
			if( d ) nup.push( j.nup );
			isInDrive = d ? true : isInDrive;

		}

		// update or die
		if( isInDrive ) root.motor.change( nup );
		else {
			if(this.resolve){
				this.resolve();
				delete this.resolve;
			}
		}

	}

    setAngles ( angles, time ){

    	if(!angles) return

    	let j = this.joints.length;

    	while(j--){ 
    		this.joints[j].pose( angles[j] !== undefined ?  angles[j] : 0, time !== undefined ? time : this.speed );
    	}

    	return new Promise((resolve) => this.resolve = resolve );

    }


}

// ARTICULATION JOINT

class SolverJoint {

	constructor( o, solver ) {

		this.name = o.name;
		this.solver = solver;
		this.type = 'solverJoint';
		this.isDrive = false;
		//this.inverse = o.inverse || false

		this.current = 0;
		this.tmp = 0;
		this.target = 0;
		this.start = 0;
		this.time = 0;
		this.nup = null;

		this.data = {

			target:{ x:0, y:0, z:0, rx:0, ry:0, rz:0, count:0 },

			//target:{ x:0, y:0, z:0, twist:0, swing1:0, swing2:0, count:0 },

		};

		if( o.limits ){
			this.driveType = o.limits[0][0];
			this.min = o.limits[0][1];
			this.max = o.limits[0][2];
		}

		if( o.position ){
			let i = o.position.length, t;

			while(i--){
				t = o.position[i];
				this.data.target[ t[0] ] = t[1];
				//if(t[0]===this.driveType)  this.current = t[1]

			}
		}

		//stiffness, damping, forceLimit, acceleration drive flag
		//o.drives = [[this.driveType, 100000, 0, Infinity, true ]];
		//solver.addJoint(o);
		
	}

	start (){

	}

	pose( target, time ){



		// linear target need to be clamp ?!
		this.target = MathTool.clamp( target, this.min, this.max );
		//this.current = this.data.target[ this.driveType ];
		this.current = MathTool.clamp( this.data.target[ this.driveType ], this.min, this.max );

		//console.log( this.target, this.current )

		if( this.target === this.current ) return;


		this.start = this.current;
		this.tmp = 0;
		this.time = time;

		this.isDrive = true;

		/*if( this.driveType !== 'z' ) this.isDrive = true;
		else{ 
			/*if(target===0.3 || target===-0.3) this.start = 0;
			else{

				if(this.name = 'A7') this.start = -0.3;
				else this.start = 0.3;
			}*/
		//	console.log( this.driveType, this.current )
		//}
		
		//return new Promise((resolve) => this.resolve = resolve);

	}
	
	update( dt ){

		if( this.isDrive ){

			this.tmp += dt;
			let t = this.tmp / this.time;
			t = (t > 1) ? 1 : t;
			let move = MathTool.lerp( this.start, this.target, t );//this.current + (this.target - this.current) * t;

			this.nup = { name:this.name, drivesTarget: [[ this.driveType, move ]] };

		    if( t === 1 ) this.isDrive = false;

		}

	}

}

class Textfield extends Mesh {

	constructor( o={} ) {

		super( new PlaneGeometry(), new MeshBasicMaterial({polygonOffset: true, polygonOffsetFactor: -4}));

		this.name = o.nam || 'text';
		this.canvas = null;

		this.w = o.w || 0;
		this.h = o.h || 0;

		this.weight = o.weight ?? 700;

		this.font = o.font ?? "'Mulish', sans-serif";
		this.fontSize = o.fontSize ?? 32;
		this.backgroundColor = o.backgroundColor ?? "#00000000";
		this.fontColor = o.fontColor ?? "#FFFFFF";
		this.material.alphaTest = 0.5;
		this.set( o.text );
		
		if( o.pos ) this.position.fromArray(o.pos);
		if( o.rot ) this.quaternion.fromArray( MathTool.quatFromEuler( o.rot ) );
		
	}

	set( str ){

		if(!this.canvas) this.canvas = document.createElement("canvas");
		let ctx = this.canvas.getContext("2d"), w, h, r;
		
		ctx.font = this.weight + " " + this.fontSize + "px " + this.font;
		

		let metrics = ctx.measureText( str );

		//resize to nearest power of 2
		w = 2 ** Math.ceil(Math.log2(metrics.width));
		h = 2 ** Math.ceil(Math.log2(ctx.measureText('M').width));



		
		this.canvas.width = w;
		this.canvas.height = h;

		ctx.fillStyle = this.backgroundColor;
		ctx.fillRect(0, 0, w, h);
		//var backgroundAlpha = ctx.getImageData(0, 0, 1, 1).data[3];

        ctx.fillStyle = this.fontColor;
		//ctx.font = this.fontSize + "px " + this.font;
		ctx.font = this.weight + " " + this.fontSize + "px " + this.font;
		ctx.textAlign = "center";
		ctx.textBaseline = 'middle';
		
		ctx.fillText( str, w*0.5, h*0.5 );

		this.material.map = new CanvasTexture(this.canvas);

		//if(this.w===0) this.w = w*0.02

		if( this.h !== 0 ){
			r = this.h / h;
			this.scale.set(w*r,this.h,0);
		}

		else if( this.w !== 0 ){
			r = this.w / h;
			this.scale.set(this.w,h*r,0);
		}

		else {
			this.scale.set(w*0.025,h*0.025,0);
		}


		//this.scale.set(this.w,h*r,0)

		/*let img = new Image(w, h);
        img.src = canvas.toDataURL( 'image/png' );

        let self = this

        img.onload = ()=>{

			//
			self.material.map = new Texture(img);
			self.material.map.needsUpdate = true
			//self.material.needsUpdate = true

			self.scale.set(w*0.05,h*0.05,0)
		}*/

	}

	dispose(){

		this.parent.remove(this);
		this.material.map.dispose();
		this.material.dispose();
		this.geometry.dispose();

	}

}

let Nb = 0;

class Button {

	constructor ( o={} ) {

		this.down = false;


		this.time = o.time || 250;

		this.p = o.pos || [0,0,0];

		this.type = o.type || 'box';
		this.name = o.name || 'button' + Nb++;
		this.pos = o.pos || [0,0,0];
		this.size = o.size || [1,1,1];
		this.radius = o.radius || 0;
		this.axe = o.axe !== undefined ? o.axe : 1;

		this.fontSize = o.fontSize || 0.8; 
		this.fontScale = o.fontScale || 1.0;

		this.extraForce = true; 


		this.decal = this.type === 'sphere'? this.size[1]*0.5 : (this.size[1]*0.5) - this.radius;

		if( this.type !== 'sphere' ) this.pos[ this.axe ] += this.decal;


		this.origin = this.pos[this.axe];
	    let height = this.size[this.axe]-(this.radius*2);

		//this.range = [ this.origin - this.decal - (this.radius*2), this.origin ]
		this.range = [ this.origin - height, this.origin ];

		this.value = this.origin;
		this.target = this.origin;

		this.speed = (this.size[this.axe]/3) / (this.size[this.axe]);

	

		this.callback = function(){ 
			console.log("action down"); 
		};

		if( o.callback ){ 
			this.callback = o.callback; 
			delete o.callback;
		}

		o.button = true;
		o.pos = this.pos; 
		if(!o.material) o.material = 'button';
		o.kinematic = true;
		o.mask = 1;

		

		this.timeout = null;

		// add model & physics
		this.b = root.motor.add( o );

		this.b.userData['action'] = this.action.bind(this);
		this.b.userData['out'] = this.out.bind(this);

		// extra text on top 
		if( o.text ) this.addText( o.text );

	}

	addText( txt, size ){

		this.fontSize = this.type==='box' ? this.size[this.axe] * 0.8 : this.size[0] * 0.8;
		this.fontSize *= this.fontScale;
		let dt = { text:txt, pos:[ 0,this.size[1]*0.5,0 ], rot:[-90,0,0], h:this.fontSize };
		if( this.axe === 2 ) dt = { text:txt, pos:[ 0,0, this.size[2]*0.5 ], rot:[0,0,0], h:this.fontSize };
		this.txt = new Textfield( dt );
		this.b.add( this.txt );

	}

	action( p ){

		if(this.down) return

		this.down = true;
	    this.target = this.range[0];
	    if(this.extraForce) root.motor.explosion( p || this.p, this.size[0]*2, 0.01 );
		this.callback();

	}

	out(){

		if(!this.down) return

		this.down = false;
	    this.target = this.range[1];
	    if(this.extraForce) root.motor.explosion( this.p, this.size[0]*2, 0.01 );

	}

	update(){

		if( this.value !== this.target ){

			//let side = this.target > this.value ? 1 : -1

			this.value = MathTool.lerp( this.value, this.target, this.speed );

			//this.value += 0.1 * side

			let t = MathTool.nearEquals( this.value, this.target, 0.0001);

			if(!t){
			    this.pos[this.axe] = this.value;
			    root.motor.change( {name:this.b.name, pos:this.pos} );
			} else {
				this.value = this.target;
			}


		}

	}

	dispose(){

		if(this.txt) this.txt.dispose();
	}

}

class Container {

	constructor ( o = {} ) {

		this.isCompound = true;

		this.init(o);

	}

	init ( o ) {


		let s = o.size || [5,3,8];
		let p = o.pos || [0,2,0];
		let w = 0.1;
		let mw = w * 0.5;
		let xw = w * 2;

		let geometry = new ChamferBox( s[ 0 ], s[ 1 ], s[ 2 ], o.radius || mw );
		//let geometry = new BoxGeometry( s[ 0 ], s[ 1 ], s[ 2 ] );
		let mesh = new Mesh( geometry );


		let size = [

		    [w, s[1]-xw, s[2]],
			[w, s[1]-xw, s[2]],

			[s[0], w, s[2]],
			[s[0], w, s[2]],

			[s[0]-xw, s[1]-xw, w],
			[s[0]-xw, s[1]-xw, w],

		];

		let pos = [

		    [mw-s[0]*0.5, 0, 0 ],
			[s[0]*0.5-mw, 0, 0 ],

			[0, mw-s[1]*0.5, 0 ],
			[0, s[1]*0.5-mw, 0 ],

			[0, 0, mw-s[2]*0.5],
			[0, 0, s[2]*0.5-mw],

		];

		const faces = [];
		let i = 6, n=0, pp;
		while( i-- ){

			pp = this.isCompound ? pos[n] : MathTool.addArray(p, pos[n]);
			faces.push( { type:'box', size:size[n], pos:pp, material:o.material } );
			n++;

		}

		if(this.isCompound){
			root.motor.add({
				...o,
				shapes:faces,
				mesh:mesh,
		        type:'compound',
		    });	
		} else {
			root.motor.add( faces );
		}
		
	}

}

//let needRay = false;

class MouseTool {

	constructor ( controler, mode = 'drag' ) {

		this.needRay = true;

		//this.tmpSelected = null

		//root.viewSize = { w:window.innerWidth, h:window.innerHeight, r:0}
		//root.viewSize.r = root.viewSize.w/root.viewSize.h

		this.moveDirect = false;
		this.moveDeep = false;

		this.mode = mode;
		this.option = {};

		this.controler = controler;
		this.dom = this.controler.domElement;

		//this.dom.style.cursor =  "url('./assets/icons/logo.png'), move";

		this.selected = null;
		this.buttonRef = null;

		this.numBullet = 0;
		this.maxBullet = 10;

		this.sticky = false;

		this.pz = 0;

		this.isActive = false;
		this.raycastTest = false;
		this.firstSelect = false;
		this.mouseDown = false;
		this.mouseDown2 = false;
		this.mouseMove = false;
		//this.controlFirst = true;

		this.decal = new Vector3();
		this.tmpPos = new Vector3();
		this.tmpD = new Vector3();

		this.mouse = new Vector2();
		this.oldMouse = new Vector2();
		this.raycast = new Raycaster();
		this.raycast.far = 1000;

		this.button = 0;

		this.pos = new Vector3();
		this.velocity = new Vector3();
		this.angle = 0;

		this.helper = null;

		this.dragPlane = null;

	    //if( this.mode === 'drag' ) 
	    this.activeDragMouse( true );

	}

	addDrag(){

		if( this.dragPlane ) return

		this.helper = new MoveHelper();
		this.dragPlane = new Mesh( new PlaneGeometry( 1, 1 ), Mat.get('hide') );
	    this.dragPlane.castShadow = false;
	    this.dragPlane.receiveShadow = false;
	    this.dragPlane.scale.set( 1, 1, 1 ).multiplyScalar( 200 );

	    root.scenePlus.add( this.helper );
	    root.scenePlus.add( this.dragPlane );

	}

	clearDrag(){

		if( !this.dragPlane ) return

		root.scenePlus.remove( this.dragPlane );
		root.scenePlus.remove( this.helper );

		this.dragPlane.geometry.dispose();
		this.helper.geometry.dispose();

		this.dragPlane = null;
		this.helper = null;

	}

    setMode ( mode, o={} ) {

    	if( mode === this.mode ) return
    	this.mode = mode;
        this.option = o;

        if( this.mode === 'blast' && this.option.visible ) root.motor.initParticle();

    }

	activeDragMouse ( b ) {

		if( b ){
			if( !this.isActive ){
				this.dom.addEventListener( 'pointermove', this.mousemove.bind(this), false );
		        this.dom.addEventListener( 'pointerdown', this.mousedown.bind(this), false );
		        document.addEventListener( 'pointerup', this.mouseup.bind(this), false );
		        document.addEventListener( 'contextmenu', this.contextmenu.bind(this), false );

		        this.controler.addEventListener( 'end', this.controleEnd.bind(this), false );
		        this.controler.addEventListener( 'change', this.controleChange.bind(this), false );

		        this.isActive = true;
		        this.raycastTest = true;
		    }

		} else {
			if( this.isActive ){
				this.dom.removeEventListener( 'pointermove', this.mousemove.bind(this) );
			    this.dom.removeEventListener( 'pointerdown', this.mousedown.bind(this) );
			    document.removeEventListener( 'pointerup', this.mouseup.bind(this) );

			    this.controler.removeEventListener( 'end', this.controleEnd.bind(this) );
		        this.controler.removeEventListener( 'change', this.controleChange.bind(this) );

			    this.isActive = false;
			}
		}
	}

	controleEnd ( e ) {
		//this.controlFirst = true
		this.raycastTest = true;
		if( this.controler.getInfo ) this.controler.getInfo();
	}

	controleChange ( e ) {

		//console.log('change')

		let state = this.controler.getState();

		if( state !== -1 ) this.raycastTest = false;

		/*let state = this.controler.getState();
		console.log(state)
		if( state !== -1 ){
			if( this.controlFirst ) this.controlFirst = false;
			else this.raycastTest = false;
		}*/

		//this.controler.getInfo();
	}

	getMouse ( e ) {

		if(root.viewSize){
			this.mouse.x =   ( e.offsetX / root.viewSize.w ) * 2 - 1;
		    this.mouse.y = - ( e.offsetY / root.viewSize.h ) * 2 + 1;
		} else {
			this.mouse.x =   ( e.offsetX / this.dom.clientWidth ) * 2 - 1;
			this.mouse.y = - ( e.offsetY / this.dom.clientHeight ) * 2 + 1;
		}

		//console.log(e.button)
		
		this.button = e.pointerType !== 'touch' ? e.button : 0;
		//if(this.button===2)this.moveDeep = !this.moveDeep

	}

	contextmenu ( e ) {
		e.preventDefault();
		//this.mouseDown2 = true
		//this.controler.enabled = false;
		/*if( this.mouseDown ){

			//this.moveDeep = true
			console.log('yo ')
		}*/
	}

	mousedown ( e ) {

		if( this.sticky ){ 
			this.unSelect();
			console.log('unstick');
		}

		this.getMouse( e );

		switch( this.mode ){

			case 'drag': this.drag(); break;
			case 'shoot': this.shoot(); break;
			case 'blast': this.blast(); break;

		}

	}

	mouseup ( e ) {

		this.mouseMove = this.oldMouse.distanceTo( this.mouse ) < 0.01 ? false : true;
		this.mouseDown = false;
		this.mouseDown2 = false;
		root.mouseDown = false;

		if( this.sticky ) { this.controler.enabled = true; return; }
		this.unSelect();
		this.resetButton();

	}

	mousemove ( e ) {

		switch( this.mode ){

			case 'drag':
			this.getMouse( e );
			this.needRay = true;
		    //this.castray()
			break

		}

	}

	castray () {

		let inters, m, g, h, id, cursor = 'auto';

		if( this.selected !== null ){

			this.raycast.setFromCamera( this.mouse, this.controler.object );
			inters = this.raycast.intersectObject( this.dragPlane );
			if ( inters.length && this.mouseDown ){ 
				this.moveSelect( inters[0].point );
				//if( this.moveDirect ) root.motor.change({ name:this.selected.name, pos:inters[0].point.toArray() }, true )
				//else root.motor.change({ name:'mouse', pos:inters[0].point.toArray() }, true )
			}
			//return
		} else {

			if( !this.raycastTest ) return;

			//this.controler.enabled = false

			this.controler.enableRotate = false;
			this.controler.enablePan = false;

			this.raycast.setFromCamera( this.mouse, this.controler.object );

			inters = this.raycast.intersectObjects( root.scene.children, true );

			this.tmpSelected = null;

			if ( inters.length > 0 ) {

				g = inters[ 0 ].object;
				id = inters[ 0 ].instanceId;

				//console.log(inters[ 0 ])

				if( id !== undefined ){
					m = root.motor.byName( g.name+id );
				} else {
					if( g.parent !== root.scene ){
						h = g.parent;
						if( h.parent !== root.scene ) m = h.parent;
						else m = h;
					} else m = g;
				}

				if( this.mouseDown2 ){
					if( m.extra ) m.extra( m.name );
					//console.log(m)
				}

				if( !m.isButton ){ 
					cursor = this.select( m, inters[ 0 ].point );
					//this.tmpSelected = m
					//this.tmpPoint = inters[ 0 ].point
				}
				else cursor = this.actionButton( m, inters[ 0 ] );

			}else {
				this.controler.enableRotate = true;
				this.controler.enablePan = true;
				//this.controler.enabled = true
			}

			document.body.style.cursor = cursor;
		} 

	}

	drag () {

		if( !this.mouseDown ){
			if( this.firstSelect ) this.firstSelect = false;
			this.oldMouse.copy( this.mouse );
		}

		if( this.button === 2 ){
		    this.mouseDown2 = true;
		    //this.castray()
		}

	    //if( this.button === 0 ){
		    this.mouseDown = true;
		    root.mouseDown = true;
		    this.needRay = true;

		    //if(this.tmpSelected!== null) this.select(this.tmpSelected, this.tmpPoint )
		    //this.castray()
		//}

		

	}

	blast () {

		let hit = null;
		this.raycast.setFromCamera( this.mouse, this.controler.object );
		let inters = this.raycast.intersectObjects( root.scene.children, true );

		if ( inters.length > 0 ) {hit = inters[ 0 ];
		} else {
			inters = this.raycast.intersectObjects( root.scenePlus.children, true );
			if ( inters.length > 0 ) hit = inters[ 0 ];
		}

	    const o = this.option;

		if(hit){ 

			root.motor.explosion( hit.point, o.radius || 3, o.power || 0.1 );

			if( o.visible ) root.motor.addParticle({
				name:'blast',
				type:"cube",
				position:hit.point.toArray(),
				numParticles: 60,
				radius:0.2,
				radiusRange:0.1,
				//accelerationRange:[0.3,0.3,0.3],
				acceleration:[5*10,5,5*10],
				lifeTime: 0.5,
		        endTime: 0.5,
		        startTime: 0,
		        gravity:[0,0.2,0],
		        startSize: 0.5,
		        endSize: 0.1,
		        //spinSpeedRange:2,
		        tween:"outQuad",
		        //velocityRange: [ 0.6, 0.6, 0.6 ]
		        //lifeTimeRange:1,
		        //startTime: 0,
		        //startSize: 0.1,

			});
		}
		

	}

	shoot () {

		this.raycast.setFromCamera( this.mouse, this.controler.object );
		this.pos.copy( this.raycast.ray.direction ).add(  this.raycast.ray.origin );
		this.velocity.copy( this.raycast.ray.direction ).multiplyScalar( 60 );

		root.motor.add({
			name: 'bullet_' + this.numBullet,
			type:'sphere',
			density:20,
			size:[0.2], 
			material:'chrome',
			pos:this.pos.toArray(),
			linearVelocity:this.velocity.toArray(),
			bullet:true,
			/*ccdThreshold:0.0000001,
            ccdRadius:0.1,*/
		});

		this.numBullet++;
		if(this.numBullet > this.maxBullet) this.numBullet = 0;

	}

    resetButton () {

		if( this.buttonRef ){
			if( this.buttonRef.userData.out ) this.buttonRef.userData.out();
			this.buttonRef = null;
		}

		this.raycastTest = true;
		this.selected = null;
		this.firstSelect = true;
		//this.controler.enabled = true
		this.controler.enableRotate = true;
		this.controler.enablePan = true;

	}

	actionButton ( obj, inters ) {

		if( this.buttonRef ){
			if( this.buttonRef.name !== obj.name ){ 
				if( this.buttonRef.userData.out ) this.buttonRef.userData.out();
				this.buttonRef = obj;
			}
		} else {
			if( this.mouseDown ) this.buttonRef = obj;
		}
		if( this.mouseDown && this.buttonRef.userData.action ){ 
			let pos = inters.point;
			this.buttonRef.userData.action( pos );
		}

		//if( this.mouseDown ) this.controler.enabled = false
		   
		//return 'grab'
	    return 'pointer'

	}

	

	select ( obj, point ) {

		//this.controler.enabled = false

		//if( this.selected !== null ) return 'pointer'
		//if( !this.mouseDown ) return 'pointer'

		if( !this.mouseDown || this.selected === obj ) return 'pointer'

		this.pz = 0;

		let pos = point;
	    let quat = [0,0,0,1];

		this.selected = obj;
		/*if( this.selected.isInstance ) quat = this.selected.instance.getInfo( this.selected.id ).quat;
		else if( this.selected.isObject3D ){
			this.selected.updateMatrix()
			quat = this.selected.quaternion.toArray()
		}*/

		this.decal.copy( pos ).sub( this.selected.position );
		this.tmpPos.copy( pos ).sub( this.decal );
		this.angle = this.controler.getAzimuthalAngle();


		

		let q = this.selected.quaternion;
		quat = [ q._x, q._y, q._z, q._w ];


		/*if( this.selected.isInstance ){
			console.log(this.selected)
			return
		}*/

		/*if( this.selected.isButton ){
			if( this.buttonRef ){
				if(this.buttonRef.name !== this.selected.name ) this.buttonRef = obj
			} else {
				this.buttonRef = obj
			}
			if( this.buttonRef.userData.action ) this.buttonRef.userData.action()
			    this.unSelect ()
			return 'grab'
		}*/

		this.addDrag();

		//8root.scenePlus.add( this.helper )
	    //root.scenePlus.add( this.dragPlane )

	    this.dragPlane.rotation.set( 0, this.angle, 0 );
	    this.dragPlane.position.copy( pos );
	    this.dragPlane.position.y = 0;

	    this.helper.position.copy( pos );

	    let p = pos.toArray();

	    root.motor.change({ name: this.selected.name, neverSleep:true, wake:true });
		//Motor.add({ name:'mouse', type:'sphere', size:[0.01], pos:p, quat:quat, mask:0, density:0, noGravity:true, kinematic:true, flags:'noCollision' })
		//root.motor.add({ name:'mouse', type:'null', pos:p, quat:quat })

		//let def = [-0.03, 0.03, 60, 5]
		//let defr = [-3, 3, 60, 5]

		//let def = [-0.03, 0.03, 60, 2]
		//let defr = [-3, 3, 60, 2]

		if( this.moveDirect ){
			root.motor.change({ name:this.selected.name, kinematic:false, gravity:false, damping:[0.9,0.9]  });
		} else {
			let def = [-0.01, 0.01, 60, 1];
			let defr = [-0.1, 0.1, 60, 1];
			let notUseKinematic = root.engine === 'OIMO' || root.engine ==='RAPIER' || root.engine ==='HAVOK';
			let jtype = root.engine === 'HAVOK' ? 'fixe' : 'd6';

			root.motor.add([
				{ name:'mouse', type:'null', pos:p, quat:quat, kinematic:notUseKinematic ? false : true },
				{ 
					name:'mouseJoint', type:'joint',
					mode:jtype,//mode:'spherical', //lm:[-0.2, 0.2],
					lm:[['x',...def], ['y',...def], ['z',...def], 
					['rx',...defr], ['ry',...defr], ['rz',...defr]],
					autoDrive: true,
					b1:'mouse',
					b2:this.selected.name,  
					worldAnchor: p, 
					worldAxis:[1,0,0],
					//friction:0.5,
					//tolerance:[1, 10],
					//noPreProcess:true,
					//improveSlerp:true,
					visible:false,
					//noFix:true,
				}
			]);

		}
		

		//this.raycastTest = false
		//this.controler.enabled = false

		//document.body.style.cursor = 'move'

		return "url('./assets/icons/point.png') 8 8, move" //'move'

	}

	moveSelect ( point ) {

		if( this.selected === null ) return

		if( point ){ 
			this.tmpPos.copy( point ).sub( this.decal ); 
		}

		if( this.moveDeep ){ // Z deep move

			let y = this.selected.position.y;
			let diff  = y-this.tmpPos.y;
			this.tmpPos.y = y;
			this.tmpD.set(0,0,diff).applyAxisAngle({x:0, y:1, z:0}, this.angle);
			this.tmpPos.add( this.tmpD );

		}

		this.helper.position.copy( this.tmpPos );

		let pos = this.tmpPos.toArray();

		if( this.moveDirect ){ 
			root.motor.change({ name:this.selected.name, pos:pos, reset:true });
		} else {
			root.motor.change({ name:'mouse', pos:point.toArray() }, true );
		}
	}

	unSelect () {

		if( this.selected === null ) return

		this.clearDrag();

		//this.dragPlane.geometry.dispose()
		//root.scenePlus.remove( this.dragPlane )
		//root.scenePlus.remove( this.helper )

		if( this.moveDirect ){
			root.motor.change({ name:this.selected.name, kinematic:false, wake:true, gravity:true, damping:[0,0.1] });
		} else {
			root.motor.remove(['mouseJoint','mouse']);
			root.motor.change({ name:this.selected.name, neverSleep:false, wake:true });
		}
		
		this.raycastTest = true;
		this.selected = null;
		this.firstSelect = true;
		//this.controler.enabled = true

	}

	step(){

		if( this.needRay ) this.castray();
	    this.needRay = false;

		if( this.selected === null ) return

		let key = root.flow.key;


		if( key[1] !== 0 ){
			let pz = key[1] * 0.1;
			this.dragPlane.translateZ(pz);
			this.needRay = true;
		}



		//this.castray()
		if( this.moveDirect ) this.moveSelect();

		

	}


}






class MoveHelper extends Line$1 {

	constructor( o = {} ) {

		super( new BufferGeometry(), Mat.get('line') );

		let c = 0.75;

		const positions = [0,0,0, 0,-100,0];
	    const colors = [c,c,c, 0,0,0];

	    //this.geometry = new BufferGeometry();
	    this.geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	    this.geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	    //this.geometry.computeBoundingSphere();

	    this.vertices = this.geometry.attributes.position;
	    this.colors = this.geometry.attributes.color;
	    this.local = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];

	    //this.matrixAutoUpdate = false;
	    this.frustumCulled = false;

	}
}

/**
 * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.
 *
 * Usage:
 *
 * Use the function prepareBreakableObject to prepare a Mesh object to be broken.
 *
 * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)
 *
 * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.
 *
 * Requisites for the object:
 *
 *  - Mesh object must have a buffer geometry and a material
 *
 *  - Vertex normals must be planar (not smoothed)
 *
 *  - The geometry must be convex (this is not checked in the library). You can create convex
 *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives
 *  can also be used.
 *
 * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)
 * Use with caution and read the code when using with other libs.
 *
 * @param {double} minSizeForBreak Min size a debris can have to break.
 * @param {double} smallDelta Max distance to consider that a point belongs to a plane.
 *
*/

const _v1 = new Vector3();

class ConvexObjectBreaker {

	constructor( minSizeForBreak = 1.4, smallDelta = 0.0001 ) {

		this.minSizeForBreak = minSizeForBreak;
		this.smallDelta = smallDelta;

		this.tempLine1 = new Line3();
		this.tempPlane1 = new Plane();
		this.tempPlane2 = new Plane();
		this.tempPlane_Cut = new Plane();
		this.tempCM1 = new Vector3();
		this.tempCM2 = new Vector3();
		this.tempVector3 = new Vector3();
		this.tempVector3_2 = new Vector3();
		this.tempVector3_3 = new Vector3();
		this.tempVector3_P0 = new Vector3();
		this.tempVector3_P1 = new Vector3();
		this.tempVector3_P2 = new Vector3();
		this.tempVector3_N0 = new Vector3();
		this.tempVector3_N1 = new Vector3();
		this.tempVector3_AB = new Vector3();
		this.tempVector3_CB = new Vector3();
		this.tempResultObjects = { object1: null, object2: null };

		this.box1 = new Box3();
		this.box2 = new Box3();

		this.sph1 = new Sphere();
		this.sph2 = new Sphere();

		this.tt = new Vector3();
		this.s1 = new Vector3();
		this.s2 = new Vector3();


		this.segments = [];
		const n = 30 * 30;
		for ( let i = 0; i < n; i ++ ) this.segments[ i ] = false;

	}

	prepareBreakableObject( object, mass, velocity, angularVelocity, breakable ) {

		// object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.
		// Its material property is propagated to its children (sub-pieces)
		// mass must be > 0

		const userData = object.userData;
		userData.mass = mass;
		userData.velocity = velocity.clone();
		userData.angularVelocity = angularVelocity.clone();
		userData.breakable = breakable;

	}

	/*
	 * @param {int} maxRadialIterations Iterations for radial cuts.
	 * @param {int} maxRandomIterations Max random iterations for not-radial cuts
	 *
	 * Returns the array of pieces
	 */
	subdivideByImpact( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {

		const debris = [];

		const tempPlane1 = this.tempPlane1;
		const tempPlane2 = this.tempPlane2;

		this.tempVector3.addVectors( pointOfImpact, normal );
		tempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );

		const maxTotalIterations = maxRandomIterations + maxRadialIterations;

		const scope = this;

		function subdivideRadial( subObject, startAngle, endAngle, numIterations ) {

			if ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {

				debris.push( subObject );

				return;

			}

			let angle = Math.PI;

			if ( numIterations === 0 ) {

				tempPlane2.normal.copy( tempPlane1.normal );
				tempPlane2.constant = tempPlane1.constant;

			} else {

				if ( numIterations <= maxRadialIterations ) {

					angle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;

					// Rotate tempPlane2 at impact point around normal axis and the angle
					scope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );
					tempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );

				} else {

					angle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;

					// Rotate tempPlane2 at object position around normal axis and the angle
					scope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );
					scope.tempVector3_3.copy( normal ).add( subObject.position );
					tempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );

				}

			}

			// Perform the cut
			scope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );

			const obj1 = scope.tempResultObjects.object1;
			const obj2 = scope.tempResultObjects.object2;

			if ( obj1 ) {

				subdivideRadial( obj1, startAngle, angle, numIterations + 1 );

			}

			if ( obj2 ) {

				subdivideRadial( obj2, angle, endAngle, numIterations + 1 );

			}

		}

		subdivideRadial( object, 0, 2 * Math.PI, 0 );

		return debris;

	}

	cutByPlane( object, plane, output ) {

		let k;

		// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.
		// object2 can be null if the plane doesn't cut the object.
		// object1 can be null only in case of internal error
		// Returned value is number of pieces, 0 for error.

		const geometry = object.geometry;
		const coords = geometry.attributes.position.array;
		const normals = geometry.attributes.normal.array;

		const numPoints = coords.length / 3;
		let numFaces = numPoints / 3;

		let indices = geometry.getIndex();

		if ( indices ) {

			indices = indices.array;
			numFaces = indices.length / 3;

		}

		function getVertexIndex( faceIdx, vert ) {

			// vert = 0, 1 or 2.

			const idx = faceIdx * 3 + vert;

			return indices ? indices[ idx ] : idx;

		}

		const points1 = [];
		const points2 = [];

		const delta = this.smallDelta;

		// Reset segments mark
		const numPointPairs = numPoints * numPoints;
		for ( let i = 0; i < numPointPairs; i ++ ) this.segments[ i ] = false;

		const p0 = this.tempVector3_P0;
		const p1 = this.tempVector3_P1;
		const n0 = this.tempVector3_N0;
		const n1 = this.tempVector3_N1;

		// Iterate through the faces to mark edges shared by coplanar faces
		for ( let i = 0; i < numFaces - 1; i ++ ) {

			const a1 = getVertexIndex( i, 0 );
			const b1 = getVertexIndex( i, 1 );
			const c1 = getVertexIndex( i, 2 );

			// Assuming all 3 vertices have the same normal
			n0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );

			for ( let j = i + 1; j < numFaces; j ++ ) {

				const a2 = getVertexIndex( j, 0 );
				const b2 = getVertexIndex( j, 1 );
				const c2 = getVertexIndex( j, 2 );

				// Assuming all 3 vertices have the same normal
				n1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );

				const coplanar = 1 - n0.dot( n1 ) < delta;

				if ( coplanar ) {

					if ( a1 === a2 || a1 === b2 || a1 === c2 ) {

						if ( b1 === a2 || b1 === b2 || b1 === c2 ) {

							this.segments[ a1 * numPoints + b1 ] = true;
							this.segments[ b1 * numPoints + a1 ] = true;

						}	else {

							this.segments[ c1 * numPoints + a1 ] = true;
							this.segments[ a1 * numPoints + c1 ] = true;

						}

					}	else if ( b1 === a2 || b1 === b2 || b1 === c2 ) {

						this.segments[ c1 * numPoints + b1 ] = true;
						this.segments[ b1 * numPoints + c1 ] = true;

					}

				}

			}

		}

		// Transform the plane to object local space
		const localPlane = this.tempPlane_Cut;
		object.updateMatrix();
		ConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );

		// Iterate through the faces adding points to both pieces
		for ( let i = 0; i < numFaces; i ++ ) {

			const va = getVertexIndex( i, 0 );
			const vb = getVertexIndex( i, 1 );
			const vc = getVertexIndex( i, 2 );

			for ( let segment = 0; segment < 3; segment ++ ) {

				const i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );
				const i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );

				const segmentState = this.segments[ i0 * numPoints + i1 ];

				if ( segmentState ) continue; // The segment already has been processed in another face

				// Mark segment as processed (also inverted segment)
				this.segments[ i0 * numPoints + i1 ] = true;
				this.segments[ i1 * numPoints + i0 ] = true;

				p0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );
				p1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );

				// mark: 1 for negative side, 2 for positive side, 3 for coplanar point
				let mark0 = 0;

				let d = localPlane.distanceToPoint( p0 );

				if ( d > delta ) {

					mark0 = 2;
					points2.push( p0.clone() );

				} else if ( d < - delta ) {

					mark0 = 1;
					points1.push( p0.clone() );

				} else {

					mark0 = 3;
					points1.push( p0.clone() );
					points2.push( p0.clone() );

				}

				// mark: 1 for negative side, 2 for positive side, 3 for coplanar point
				let mark1 = 0;

				d = localPlane.distanceToPoint( p1 );

				if ( d > delta ) {

					mark1 = 2;
					points2.push( p1.clone() );

				} else if ( d < - delta ) {

					mark1 = 1;
					points1.push( p1.clone() );

				}	else {

					mark1 = 3;
					points1.push( p1.clone() );
					points2.push( p1.clone() );

				}

				if ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {

					// Intersection of segment with the plane

					this.tempLine1.start.copy( p0 );
					this.tempLine1.end.copy( p1 );

					let intersection = new Vector3();
					intersection = localPlane.intersectLine( this.tempLine1, intersection );

					if ( intersection === null ) {

						// Shouldn't happen
						console.error( 'Internal error: segment does not intersect plane.' );
						output.segmentedObject1 = null;
						output.segmentedObject2 = null;
						return 0;

					}

					points1.push( intersection );
					points2.push( intersection.clone() );

				}

			}

		}

		// Calculate debris mass (very fast and imprecise):
		object.userData.mass * 0.5;

		let box1 = this.box1;
		let box2 = this.box2;
		let numPoints1 = points1.length;
		let numPoints2 = points2.length;

		// reset box3
		box1.makeEmpty();
		box2.makeEmpty();
		
		// expand box3
		k = numPoints1;
		while(k--) box1.expandByPoint(points1[ k ]);

		k = numPoints2;
		while(k--) box2.expandByPoint(points2[ k ]);
	
		box1.getBoundingSphere(this.sph1);
		box2.getBoundingSphere(this.sph2);

		// Calculate debris Center of Mass Fastest
		this.tempCM1.copy(this.sph1.center);
		this.tempCM2.copy(this.sph2.center);
		k = numPoints1;
		while ( k-- ) points1[ k ].sub( this.tempCM1 );
		k = numPoints2;
		while ( k-- ) points2[ k ].sub( this.tempCM2 );

		this.tempCM1.add(object.position);
		this.tempCM2.add(object.position);

		box1.getSize(this.s1);
		box2.getSize(this.s2);

		// avoid too low radius
		if(2 * this.sph1.radius < this.minSizeForBreak) numPoints1 = 0;
		if(2 * this.sph2.radius < this.minSizeForBreak) numPoints2 = 0;

		// avoid too low size
		if(this.testSize(this.s1)) numPoints1 = 0;
		if(this.testSize(this.s2)) numPoints2 = 0;

		//this.tempCM1.add( object.position );
		//this.tempCM2.add( object.position )

		//let sizer1 = this.tt.copy(box1.max).add(box1.min).manhattanLength()
		//let sizer2 = this.tt.copy(box2.max).add(box2.min).manhattanLength()

		//if(sizer1<s) numPoints1 = 0
		//if(sizer2<s) numPoints2 = 0
	    //box1 = {x:Math.abs(box1.x), y:Math.abs(box1.y), z:Math.abs(box1.z)}
	    //box2 = {x:Math.abs(box2.x), y:Math.abs(box2.y), z:Math.abs(box2.z)}

	    //console.log(radius1, radius2)
	    //console.log(box1.manhattanLength(), box2.manhattanLength())

	    //console.log(box1, box2)



	    //console.log(sizer1, sizer2)


		//if( box1.x<s || box1.y<s || box1.z<s ) numPoints1 = 0
		//if( box2.x<s || box2.y<s || box2.z<s ) numPoints2 = 0

			//if( box1.x+box1.y+box1.z<s ) numPoints1 = 0
			//if( box2.x+box2.y+box2.z<s ) numPoints1 = 0
		//if( box1.manhattanLength()<s ) numPoints1 = 0
		//if( box2.manhattanLength()<s ) numPoints2 = 0

		//if( box1.length()<s ) numPoints1 = 0
		//if( box2.length()<s ) numPoints2 = 0


	

		let object1 = null;
		let object2 = null;

		let numObjects = 0;

		if ( numPoints1 > 4 ) {

			object1 = new Mesh( new ConvexGeometry( points1 ), object.material );
			object1.position.copy( this.tempCM1 );
			object1.quaternion.copy( object.quaternion );

			//this.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );

			numObjects ++;

		}

		if ( numPoints2 > 4 ) {


			object2 = new Mesh( new ConvexGeometry( points2 ), object.material );
			object2.position.copy( this.tempCM2 );
			object2.quaternion.copy( object.quaternion );

			//this.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );

			numObjects ++;

		}

		output.object1 = object1;
		output.object2 = object2;

		return numObjects;

	}

	testSize( s ) {
		let n = 0;
		if(s.x < 0.01 ) n++; 
		if(s.y < 0.01 ) n++; 
		if(s.z < 0.01 ) n++;
		return n>1 
	}

	static transformFreeVector( v, m ) {

		// input:
		// vector interpreted as a free vector
		// THREE.Matrix4 orthogonal matrix (matrix without scale)

		const x = v.x, y = v.y, z = v.z;
		const e = m.elements;

		v.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		v.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		v.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return v;

	}

	static transformFreeVectorInverse( v, m ) {

		// input:
		// vector interpreted as a free vector
		// THREE.Matrix4 orthogonal matrix (matrix without scale)

		const x = v.x, y = v.y, z = v.z;
		const e = m.elements;

		v.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;
		v.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;
		v.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;

		return v;

	}

	static transformTiedVectorInverse( v, m ) {

		// input:
		// vector interpreted as a tied (ordinary) vector
		// THREE.Matrix4 orthogonal matrix (matrix without scale)

		const x = v.x, y = v.y, z = v.z;
		const e = m.elements;

		v.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];
		v.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];
		v.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];

		return v;

	}

	static transformPlaneToLocalSpace( plane, m, resultPlane ) {

		resultPlane.normal.copy( plane.normal );
		resultPlane.constant = plane.constant;

		const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( _v1 ), m );

		ConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );

		// recalculate constant (like in setFromNormalAndCoplanarPoint)
		resultPlane.constant = - referencePoint.dot( resultPlane.normal );

	}

}

class Breaker {

	constructor () {

		this.convexBreaker = new ConvexObjectBreaker();
		this.tmpI = new THREE.Vector3();

		this.tpos = new THREE.Vector3();
		this.tnormal = new THREE.Vector3();

		this.nDebris = 0;
		this.maxDebris = 300;

		this.tt = null;

	}

	step () {

		let p;

		for( let n in root.reflow.point ){

			p = root.reflow.point[n];

			//if ( !b1.breakable && !b2.breakable ) continue;

			

			if ( p.distance !== 0 ) {

				this.makeBreak( p.b1, p.pos, p.normal, p.impulse, p.v1 );
				this.makeBreak( p.b2, p.pos, p.normal, p.impulse, p.v2 );
				
			} 
		}
	}

	makeBreak ( name, pos, normal, impulse, v ) {

		let mesh = Utils.byName( name );

		if ( !mesh ) return;
		if ( !mesh.breakable ) return;



		let breakOption = mesh.breakOption;
		//let imp = this.tmpI.fromArray( impulse ).length();

		//console.log( name, impulse )

		// not enoputh impulse to break
		if ( impulse < breakOption[ 0 ] ) return;


		//let parentMatrix = mesh.matrix.clone().invert()

		let debris = this.convexBreaker.subdivideByImpact( mesh, this.tpos.fromArray(pos), this.tnormal.fromArray(normal), breakOption[ 1 ], breakOption[ 2 ] );

		//console.log( debris.length )

		if(debris.length<1) return

		// remove one level
		breakOption[ 3 ] -= 1;
		
		const eritage = {
			material: mesh.material,
			linearVelocity: [v[0], v[1], v[2]],
			angularVelocity: [v[3], v[4], v[5]],
			density: mesh.density,
		};

		// add debris
		let list = [];
		let i = debris.length, n = 0;
		while ( i -- ){ 
			list.push( this.addDebris( debris[ n ], breakOption, eritage ) );
			n++;
		}

        // remove original object and add debrit
        //root.motor.remove( name, true )
        this.tt = setTimeout( ()=>{
        	root.motor.remove( name );
		    root.motor.add( list );
        }, 0 );
		

	}

	addDebris ( mesh, breakOption, eritage ) {

		let breakable = breakOption[ 3 ] > 0 ? true : false;

		let name = 'debris_' + (this.nDebris++);

		let deb = {

			...eritage,

			name: name,
			type: 'convex',
			shape: mesh.geometry,
			//size:[1,1,1],
			pos: mesh.position.toArray(),
			quat: mesh.quaternion.toArray(),
			breakable: breakable,
			breakOption:breakOption,

		};

		//this.nDebris++
		if( this.nDebris>this.maxDebris ) this.nDebris = 0;


		return deb

	}

}

//const SPHSystem_getNeighbors_dist = new Vector3()

// Temp vectors for calculation
new Vector3(); // Relative velocity

const SPHSystem_update_a_pressure = new Vector3();
const SPHSystem_update_a_visc = new Vector3();
const SPHSystem_update_gradW = new Vector3();
const SPHSystem_update_r_vec = new Vector3();
const SPHSystem_update_u = new Vector3();


class Particle {

	constructor ( o = {} ) {

		this.name = o.name  || 'ppp';

		this.particles = [];
	    this.density = 0.01;
	    this.smoothingRadius = 0.2;
	    this.speedOfSound = 0.1;
	    this.viscosity = 0.03;
	    this.eps = 0.000001;

	    this.group = 1 << 8;

	    // Stuff Computed per particle
	    this.pressures = [];
	    this.densities = [];
	    this.neighbors = [];

	}

	add( pos ){

		let p = root.motor.add({ 

            instance:this.name,
            type:'particle', 
            //type:'sphere',
            flags:'noQuery',
            size:[0.1],

            inertia:[0,0,0], 
            pos:pos, 
            mass:0.01, 
            restitution:0.0, 
            friction:0.5, 
            maxVelocity:[2,100],
            //damping:[0,0.005],
            group:this.group, 
            mask:1|2,
            material:'hide',

        });

        p.force = new Vector3();

        this.particles.push( p );
        if (this.neighbors.length < this.particles.length) {
	        this.neighbors.push([]);
	    }

	}

	connect( link ){

		let i = link.length;
		let tmp = [], l;

		while(i--){
			l = link[i];
			tmp.push({ type:'joint', mode:'distance', b1:this.name+l[0], b2:this.name+l[1], lm:[0.01, 0.15], spring:[100, 0.01], /*visible:true, helperSize:0.02*/ });
		}

		root.motor.add(tmp);

	}

	getPosition(){

		let ar = [];
		let i = this.particles.length, p, n;
		while(i--){

			n = i*3;
	    	p = this.particles[i];
	    	ar[n] = p.position.x;
	    	ar[n+1] = p.position.y;
	    	ar[n+2] = p.position.z;
	    }

	    return ar

	}

	
    // Get neighbors within smoothing volume, save in the array neighbors
    getNeighbors( particle, neighbors ) {

	    const N = this.particles.length;
	    const id = particle.id;
	    const R2 = this.smoothingRadius * this.smoothingRadius;
	    let distance = 0;//SPHSystem_getNeighbors_dist
	    for (let i = 0; i !== N; i++) {
	        const p = this.particles[i];
	        //const dx = p.position.x - particle.position.x, dy = p.position.y - particle.position.y, dz = p.position.z - particle.position.z;
	        distance = this.distance(p, particle );//dx * dx + dy * dy + dz * dz
	        if (id !== p.id && distance < R2) {
	            neighbors.push(p);
	        }
	    }	
    }

    distance(p, v) {
	    const dx = p.position.x - v.position.x, dy = p.position.y - v.position.y, dz = p.position.z - v.position.z;
	    return dx * dx + dy * dy + dz * dz
	}

    // Calculate the weight using the W(r) weightfunction
	w(r) {
	    // 315
	    const h = this.smoothingRadius;
	    return (315.0 / (64.0 * Math.PI * h ** 9)) * (h * h - r * r) ** 3
	}

	// calculate gradient of the weight function
	gradw(rVec, resultVec) {

	    const r = rVec.length();
	    const h = this.smoothingRadius;
	    resultVec.copy(rVec).multiplyScalar( (945.0 / (32.0 * Math.PI * h ** 9)) * (h * h - r * r) ** 2 );
	    //rVec.scale((945.0 / (32.0 * Math.PI * h ** 9)) * (h * h - r * r) ** 2, resultVec)
	}

	// Calculate nabla(W)
	nablaw(r) {
	    const h = this.smoothingRadius;
	    const nabla = (945.0 / (32.0 * Math.PI * h ** 9)) * (h * h - r * r) * (7 * r * r - 3 * h * h);
	    return nabla
	}

	update() {

		const TMP = [];

		const N = this.particles.length;
	    const cs = this.speedOfSound;
	    const eps = this.eps;

	    let i = N, j;

	   //for (let i = 0; i !== N; i++) {
	    while(i--){

	    	const p = this.particles[i]; // Current particle
	    	p.force.set(0,0,0);
            const neighbors = this.neighbors[i];

            // Get neighbors
		    neighbors.length = 0;
		    this.getNeighbors(p, neighbors);
		    neighbors.push(this.particles[i]); // Add current too
		    const numNeighbors = neighbors.length;

		    // Accumulate density for the particle
		    let sum = 0.0;
		    j = numNeighbors;
		    while(j--){
		    //for (let j = 0; j !== numNeighbors; j++) {
		        //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
		        const weight = this.w( this.distance( p, neighbors[j] ) );
		        sum += neighbors[j].mass * weight;
		    }

		    // Save
		    this.densities[i] = sum;
		    this.pressures[i] = cs * cs * (this.densities[i] - this.density);

	    }

	    // Add forces

	    // Sum to these accelerations
	    const a_pressure = SPHSystem_update_a_pressure;
	    const a_visc = SPHSystem_update_a_visc;
	    const gradW = SPHSystem_update_gradW;
	    const r_vec = SPHSystem_update_r_vec;
	    const u = SPHSystem_update_u;

	    i = N;

	   //for (let i = 0; i !== N; i++) {
	    while(i--){

	    	const particle = this.particles[i];

		    a_pressure.set(0, 0, 0);
		    a_visc.set(0, 0, 0);

		    // Init vars
		    let Pij;
		    let nabla;

		    // Sum up for all other neighbors
		    const neighbors = this.neighbors[i];
		    const numNeighbors = neighbors.length;

		    j = numNeighbors;
		    while(j--){
		    //for (let j = 0; j !== numNeighbors; j++) {
		    	const neighbor = neighbors[j];

		    	// Get r once for all..
		    	r_vec.copy(particle.position).sub(neighbor.position);
		        //particle.position.vsub(neighbor.position, r_vec)
		        const r = r_vec.length();

		        // Pressure contribution
		        Pij =
		          -neighbor.mass *
		          (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) +
		            this.pressures[j] / (this.densities[j] * this.densities[j] + eps));

		        this.gradw(r_vec, gradW);
		        // Add to pressure acceleration
		        gradW.multiplyScalar(Pij); //scale(Pij, gradW)
		        a_pressure.add(gradW);//.vadd(gradW, a_pressure)


		        // Viscosity contribution
		        u.copy(neighbor.velocity).sub(particle.velocity);

		        /*TMP.push({
			    	name:neighbor.name,
			    	velocity : u.toArray()
			    })*/
		        //neighbor.velocity.vsub(particle.velocity, u)
		        u.multiplyScalar((1.0 / (0.0001 + this.densities[i] * this.densities[j])) * this.viscosity * neighbor.mass);
		        nabla = this.nablaw(r);
		        u.multiplyScalar(nabla);
		        // Add to viscosity acceleration
		        a_visc.add(u);


		    }

		    // Calculate force
		    a_visc.multiplyScalar(particle.mass);
		    a_pressure.multiplyScalar(particle.mass);

		    // Add force to particles

		    particle.force.add(a_visc);
            particle.force.add(a_pressure);

		    TMP.push({
		    	name: particle.name,
		    	force: particle.force.toArray()
		    });
            
	    }

	    root.motor.change(TMP);



	}

}

const _offsetMatrix = new Matrix4();
const _identityMatrix = new Matrix4();
new Vector3();

let K = Skeleton.prototype;

K.byName = function ( name ) {

    let i = this.bones.length;
    while(i--) if( this.bones[i].name === name ) return this.bones[i]
    return null

};

K.getId = function ( name ) {

    let i = this.bones.length;
    while(i--) if( this.bones[i].name === name ) return i
    return null

};

K.setExtraRotation = function ( b, x, y, z ) {

    //this.pose()

    /*let name = b.isBone ? b.name : b
    let degtorad = MathUtils.DEG2RAD

    let bone = this.byName( name )
    if( !bone ) return

    let id = this.getId( name )
    let tt = new Matrix4().makeRotationFromEuler( {x:x*degtorad, y:y*degtorad, z:z*degtorad, order:'XYZ'});

    //bone.matrixWorld.multiply( tt );
    bone.matrix.multiply( tt );
    bone.matrixWorld.multiplyMatrices( bone.parent.matrixWorld, bone.matrix );
    bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
    //bone.updateMatrixWorld( true )

    //bone.updateWorldMatrix( true, true )

    let j = bone.children.length, child;
    while(j--){
        child = bone.children[ j ]
        child.matrixWorld.multiplyMatrices( bone.matrixWorld, child.matrix )
    }



    this.calculateInverses()*/
//this.pose()


    let bone = b.isBone ? b : this.byName( b );
    if( !bone ) return
    MathUtils.DEG2RAD;
    
    //bone.extraRotation = new Matrix4().makeRotationFromEuler( {x:x*degtorad, y:y*degtorad, z:z*degtorad, order:'XYZ'});
    //bone.extraRotation = new Quaternion().setFromEuler( {_x:x*degtorad, _y:y*degtorad, _z:z*degtorad, _order:'XYZ'}).invert();

    //this.applyScalling()

};

K.setScalling = function ( b, x, y, z ) {

    let bone = b.isBone ? b : this.byName( b );
    if( !bone ) return
    bone.scalling = new Vector3(x, y, z);

};

K.resetScalling = function (b) {

    this.pose();

    this.scalled = true;

    for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

        //this.bones[i].scalling = new Vector3(1,1,1);
        this.bones[i].isPhysics = false;
        this.bones[i].phyMtx = new Matrix4();

    }

    if(!b) this.applyScalling();

};

K.childScale = function ( bone, matrix ) {

    if( !this.scalled ) return

    //

    if( bone.scalling ) matrix.scale( bone.scalling );
    //if( bone.extraRotation ) matrix.multiply( bone.extraRotation );
    //if( !bone.isBone ) return

    //if(bone.name === 'head') console.log(bone.children.length)

    let j = bone.children.length, child;

    while(j--){

        child = bone.children[ j ];

        if( child.isBone ) {
            child.matrixWorld.multiplyMatrices( matrix, child.matrix );
            
        } else {
            child.matrixWorld.multiplyMatrices( matrix, child.matrix );
            //child.updateWorldMatrix(false,true)
            //child.updateWorldMatrix(false, true);
            //child.updateMatrixWorld(true);
            //child.updateMatrix()
            //child.updateWorldMatrix( false, true );

            // BUG WITH HAIR !!!
         //   child.matrixWorld.multiplyMatrices( matrix, child.matrix )
           // child.matrixWorld.multiplyMatrices( matrix, child.matrix )

            //child.updateWorldMatrix(false, true)
            //child.matrix = matrix.clone();
            //child.matrixWorld.premultiply( matrix.clone() )
            //child.matrixAutoUpdate = false;
        }

        
        //child.matrixAutoUpdate = true
        //if( child.matrixAutoUpdate ) child.matrixAutoUpdate = false
        //if( child.matrixWorldAutoUpdate ) child.matrixWorldAutoUpdate = false
        //child.matrixWorldNeedsUpdate = false;
        //child.matrixWorld.copy( child.matrix ).premultiply( matrix )

        //child.matrixWorld.copy( matrix ).multiply( child.matrix )
        


        //scaleMatrix = matrix.clone()
        //scaleMatrix.multiply( child.matrix )
        //child.matrixWorld.copy( scaleMatrix )

       // if( child.isBone ) 
            //child.matrix.premultiply(matrix)
            //child.matrixWorld.copy( child.matrix );
            
            ///child.matrixWorldNeedsUpdate = true;
        //child.matrix.premultiply(matrix)
        //child.matrixWorld.setPosition( _decal.setFromMatrixPosition( scaleMatrix ) );
        //child.matrixWorld.setPosition( _decal.setFromMatrixPosition( scaleMatrix ) );
        //k++
    }

};

K.applyScalling = function ( fingerPos ) {

    let b, i, lng = this.bones.length;
    let parent;

    for ( i = 0; i < lng; i ++ ) {

        b = this.bones[ i ];
        parent = b.parent || null;

        if( parent !== null && parent.scalling && b.name!=='root' ){//

          //  if( parent.scalling ) 
            b.position.multiply( parent.scalling );
            //if(parent.extraRotation) b.quaternion.premultiply( parent.extraRotation );
            //b.updateWorldMatrix( false, true )
            b.updateMatrixWorld( true );

        }

    }

    this.calculateInverses();

};


K.update = function () {

    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;

    // flatten bone matrices to array

    let i = bones.length, bone, n=0;

    while( i-- ){

        bone = bones[ n ];

        // compute the offset between the current and the original transform

        //if( bone.isPhysics ) bone.matrixWorld.copy( bone.phyMtx )

        const matrix = bone ? ( bone.isPhysics ? bone.phyMtx : bone.matrixWorld ) : _identityMatrix;

        if( bone.isPhysics ) this.scalled = true;
        
        this.childScale( bone, matrix );

        _offsetMatrix.multiplyMatrices( matrix, boneInverses[ n ] );
        _offsetMatrix.toArray( boneMatrices, n * 16 );

        n++;

    }

    if ( boneTexture !== null ) {

        boneTexture.needsUpdate = true;

    }

};

let items;
let currentControle = null;
let callback = null;
let Ar = null, ArPos = {};
let worker = null;
let isWorker = false;
let isBuffer = false;
let isTimeout = false;
let outsideStep = true;

let engineReady = false;


let breaker = null;

let timetest = {
	t1:0,
	t2:0,
	t3:0,
	t4:0,
};

let mouseTool = null;


let isPause = false;

let directMessage = null;
let controls$1 = null;
let first = true;

let timout = null;
let timoutFunction = null;
let timoutTime = 0;
let elapsedTime = 0;

const user = new User();
const timer = new Timer(60);


//let particles = null

//const threeScene = null

let azimut = function(){ return 0 };
let endReset = function(){};
let postUpdate = function(){};
let addControl$1 = function(){};




let buttons = [];
let textfields = [];
let particles$1 = [];
//let skeletons = []

const settings = {

	//full:false,
	//jointVisible:false,


	fps: 60,
	fixe: true,
	full: false,
	substep: 2,
	gravity: [0,-9.81,0],
	

};


class Motor {

	static getSetting () { return settings; }

	static setGravity(){

		root.post({ m:'setGravity', o:{ gravity:settings.gravity } });

	}

	static set ( o = {} ){


		settings.fixe = o.fixe !== undefined ? o.fixe : true;
		settings.full = o.full !== undefined ? o.full : false;
		settings.gravity = o.gravity ? o.gravity : [0,-9.81,0];
	    settings.substep = o.substep ? o.substep : 2;
	    settings.fps = o.fps ? o.fps : 60;


	    //console.log(settings)

		//if( o.full === undefined ) o.full = false

		if( o.key ) addControl$1();

		items.body.setFull( settings.full );
		Motor.initArray( settings.full );

		elapsedTime = 0;

		isTimeout = isWorker;
		outsideStep = !isTimeout;

	    root.jointVisible = o.jointVisible || false;

		if( outsideStep ) timer.setFramerate( settings.fps );

		const data = {
			...settings,
			ArPos:ArPos,
			isTimeout:isTimeout,
			outsideStep:outsideStep,
		};

		root.post({ m:'set', o:data });

	}

	static math = MathTool//math

	static activeMouse ( controler, mode ) { 
		if( !mouseTool ) mouseTool = new MouseTool( controler, mode ); 
	}

    static mouseMode ( mode, o ) { 
		if( mouseTool ) mouseTool.setMode( mode, o );
	}


	static getTimeTest () { return timetest }

	static setMaxFps ( v ) { }

	//static setExtraTexture ( f ) { extraTexture = f }

	static getMouse () { return mouseTool ? mouseTool.mouse:null }

	

	static setAddControl ( f ) { addControl$1 = f; }

	static setPostUpdate ( f ) { postUpdate = f !== null ? f : function(){}; }
	static setAzimut ( f ) { azimut = f; }

	static setKey (i, v) { return user.setKey(i,v) }
	static getKey () { return user.key }
	static getKey2 () { return user.key2 }
	static getAzimut () { return azimut() }

	static setContent ( Scene ) {
		root.threeScene = Scene;
		Scene.add( root.scene );
		Scene.add( root.scenePlus );
	}

	static setControl ( Controls ) { 

		controls$1 = Controls;
		azimut = controls$1.getAzimuthalAngle;

	}

	static message ( m ){

		let e = m.data;
		if( e.Ar ) Ar = e.Ar;//new Float32Array( e.Ar )//;
		if( e.reflow ){
			root.reflow = e.reflow;
			if(root.reflow.stat.delta) elapsedTime += root.reflow.stat.delta;
		}
	
		Motor[ e.m ]( e.o );

	}

	static post ( e, buffer=null, direct = false ){

		if( isWorker ){

		    if(e.o)if( e.o.type === 'solver' || e.o.solver !== undefined) direct = true;
		    if(!direct){
		    	if ( e.m === 'add' ) root.flow.add.push( e.o );
		    	else if ( e.m === 'remove' ) root.flow.remove.push( e.o );
		    	else worker.postMessage( e, buffer );
		    } else {
		    	worker.postMessage( e, buffer );
		    }

			/*if ( e.m === 'add' ){ 
				if( e.o.type === 'solver' ) worker.postMessage( e )// direct
				else if( e.o.solver !== undefined ) worker.postMessage( e )// direct
				else{ 
					if( direct ) worker.postMessage( e ) 
				    else root.flow.add.push( e.o )// in temp 
			    }
			}
			else if ( e.m === 'remove' ){ 
				if( direct ) worker.postMessage( e ) 
				else root.flow.remove.push( e.o )
			}
			else worker.postMessage( e, buffer )*/

		} else {

			/*if(e.o)if( e.o.type === 'solver' || e.o.solver !== undefined) direct = true
		    if(!direct){
		    	if ( e.m === 'add' ) root.flow.add.push( e.o )
		    	else if ( e.m === 'remove' ) root.flow.remove.push( e.o )
		    	else directMessage( { data : e } )
		    } else {
		    	directMessage( { data : e } )
		    }*/

			directMessage( { data : e } );

		}

	}

	/*static post ( e, buffer, direct = false ){

		if( isWorker ){ 

			if ( e.m === 'add' ){ 
				if( e.o.type === 'solver' ) worker.postMessage( e )// direct
				else if( e.o.solver !== undefined ) worker.postMessage( e )// direct
				else{ 
					if( direct ) worker.postMessage( e ) 
				    else root.flow.add.push( e.o )// in temp 
			    }
			}
			else if ( e.m === 'remove' ){ 
				if( direct ) worker.postMessage( e ) 
				else root.flow.remove.push( e.o )
			}
			else worker.postMessage( e, buffer )

		} else {

			directMessage( { data : e } )

		}

	}*/

	static makeView () {

	}

	static getScene () { return root.scene; }

	

	static resize ( size ) { root.viewSize = size; }

	//static getMat ( mode ) { return mode === 'HIGH' ? mat : matLow; }

	static init ( o = {} ) {

		//root.viewSize = {w:window.innerWidth, h:window.innerHeight, r:0}
		//root.viewSize.r = root.viewSize.w/root.viewSize.h



		/*let q1 = new Quaternion().setFromAxisAngle({x:1, y:0, z:0}, 45*math.torad)
		let q2 = new Quaternion().setFromAxisAngle({x:1, y:0, z:0}, 90*math.torad)

		Utils.quatToAngular( q1.toArray(), q2.toArray() ) */

		// TODO find better solution
		let rootURL = document.location.href.replace(/\/[^/]*$/,"/");
		var arr = rootURL.split("/");
		rootURL = arr[0] + "//" + arr[2] + '/';

		if( rootURL === 'https://lo-th.github.io/' ) rootURL = 'https://lo-th.github.io/phy/';

		//console.log('link', rootURL)

		const path = o.path || 'build/';

		const wasmLink = {
		    Ammo: path + 'ammo3.wasm.js',
		    Physx: path + 'physx-js-webidl.js',
		    Havok: path + 'HavokPhysics.js',
		};

		let type = o.type || 'PHYSX';
		let name = type.toLowerCase();
		let mini = name.charAt(0).toUpperCase() + name.slice(1);
		let st = '';

		navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

		root.engine = type;

		Motor.initItems();

		// garbage material
		Pool.materialRoot = Mat.set;//Motor.getMaterialRoot

		//items.body.extraConvex = mini === 'Physx'
		//items.solid.extraConvex = mini === 'Physx'

		if( o.callback ){ 
			callback = o.callback;
			delete ( o.callback );
		}

		isWorker = o.worker || false;

		root.scene = new Group$1();
		root.scene.name = 'phy_scene';
		root.scenePlus = new Group$1();
		root.scenePlus.name = 'phy_scenePlus';

		if(o.scene){ 
			Motor.setContent( o.scene );
			delete ( o.scene );
		}

		//root.update = Motor.update
		//root.change = Motor.change
		//root.remove = Motor.remove
		root.post = Motor.post;
		//root.add = Motor.add

		root.motor = Motor;

		if( isWorker ){ // is worker version

			/*switch( type ){

				case 'OIMO':

				    worker = new Worker( path + mini + '.min.js' )

				    if( isFirefox ) worker = new Worker( path + mini + '.min.js' )
				    else {
				    	try {
					        worker = new Worker( path + mini + '.module.js', {type:'module'})
						    st = 'ES6'
						} catch (error) {
						    worker = new Worker( path + mini + '.js' )
						}
				    }

				break
				
				default :

				    if( type === 'RAPIER' ) { name = 'rapier3d'; mini = 'rapier3d'; }

					//let coep = '?coep=require-corp&coop=same-origin&corp=same-origin&'
					// https://cross-origin-isolation.glitch.me/?coep=require-corp&coop=same-origin&corp=same-origin&
				    // for wasm side
				    if( wasmLink[mini] ) o.blob = rootURL + wasmLink[mini];

				    console.log(rootURL +path + mini + '.min.js')

				    //worker = new Worker( path + mini + '.module.js', {type:'module'})
					worker = new Worker( rootURL + path + mini + '.min.js' )
					//worker = new Worker( 'http://localhost:8612/build/'+mini+'.min.js'+coep )

				break

			}*/


			// if( type === 'RAPIER' ) { name = 'rapier3d'; mini = 'rapier3d'; }

		    // for wasm side
		    if( wasmLink[mini] ) o.blob = rootURL + wasmLink[mini];

		    //worker = new Worker( path + mini + '.module.js', {type:'module'})
			worker = new Worker( rootURL + path + mini + '.min.js' );



			worker.postMessage = worker.webkitPostMessage || worker.postMessage;
			worker.onmessage = Motor.message;

			let ab = new ArrayBuffer( 1 );
			worker.postMessage( { m: 'test', ab:ab }, [ ab ] );
			isBuffer = ab.byteLength ? false : true;


			o.isBuffer = isBuffer;
			console.log( st  + ' Worker '+ type + (o.isBuffer ? ' with Shared Buffer' : '') );


			Motor.initPhysics( o );


			/// ???
			//Cross-Origin-Embedder-Policy: require-corp
			//Cross-Origin-Opener-Policy: same-origin
			//const buffer = new SharedArrayBuffer( 1024  );

			//console.log(crossOriginIsolated)

			//isWorker = true;


		} else { // is direct version

			if( wasmLink[mini] ) Motor.loadWasmDirect( wasmLink[mini], o, mini, rootURL );
			else Motor.preLoad( mini, o, rootURL );

			/*directMessage = o.direct;
			o.message = Motor.message;
			console.log( type + ' is direct' );*/

		}

		//Motor.initPhysics( o )

	}

	static loadWasmDirect( link, o, name, rootURL ) {

	    let s = document.createElement("script");
	    s.src = rootURL + link;
	    document.body.appendChild( s );
	    s.onload = () => { 
	    	Motor.preLoad( name, o, rootURL );
	    };

	}

	static async preLoad( name, o, rootURL ) {
	
	    let M = await import( o.devMode ? rootURL + 'src/'+name+'.js' : rootURL + 'build/'+name+'.module.js');
	    directMessage = M.engine.message;
		o.message = Motor.message;
		Motor.initPhysics( o );

	}

	////

	static initPhysics( o ) {
	
	    root.post({ m:'init', o:o });
	    engineReady = true;

	}
	
	static getPause (){

		return isPause

	}

	static pause ( v ){

		if( v === isPause ) return
		isPause = v;
		if( isPause ) Motor.pausetimout();
		else Motor.playtimout();
		root.post({ m:'pause', o:{ value:isPause } });

	}

	static flowReset ( ){

		root.flow = { 
			stamp:0,
			current:'',
			key:[],
			tmp:[],
			add:[],
			remove:[],
			//point:[]
		};

	}

	static reset ( callback ){

		if( first ){
			first = false;
			callback();
			return
		}

		buttons = [];

		Motor.clearText();
		//Motor.clearSkeleton()
		Motor.clearParticleSolver();

		Motor.cleartimout();

		currentControle = null;

		if( controls$1 ) controls$1.resetAll();
		if( mouseTool ) mouseTool.unSelect();

		endReset = callback;

		postUpdate = function () {};

		Motor.flowReset();

		// clear instance
	    Motor.clearInstance();

	    // reset all items
	    Motor.resetItems();

		// clear temporary geometry
		Geo.dispose();

	    // clear temporary material
	    Mat.dispose();

	    // clear temporary mesh
		root.disposeTmp();

		if( breaker !== null ) breaker = null;
			
		root.tmpTex = [];
	    root.scenePlus.children = [];
	    root.scene.children = [];

		root.post({ m:'reset' });

	}

	static resetCallback (){

		endReset();

	}

	static ready (){

		console.log( (isWorker? 'Worker ': 'Direct ') + root.engine + ' is ready !' );
		if( callback ) callback();

	}

	static start ( o = {} ){

		root.post({ m:'start', o:o });

	}

	//static setTimeout ( b ){ isTimeout = b; }
	//static getTimeout ( b ){ return isTimeout }

	

	

	static morph ( obj, name, value ){ Utils.morph( obj, name, value ); }

	static getFps (){ return root.reflow.stat.fps }
	
	static getDelta2(){ return root.reflow.stat.delta }
	static getElapsedTime2(){ return elapsedTime }
	
	static getDelta(){ return timer.delta }
	static getElapsedTime(){ return timer.elapsedTime }

	static doStep ( stamp ){

		if( !engineReady ) return
		if( !outsideStep ) return

        //if( isWorker && realtime ) return

		if( timer.up( stamp ) ) {
			root.post( { m:'step', o:stamp } );
		}

		/*if( isBuffer ) root.post( { m:'poststep', flow:root.flow, Ar:Ar }, [ Ar.buffer ] )
		else root.post( { m:'poststep', flow:root.flow, Ar:Ar })
		Motor.flowReset()*/

	}

	static step (){

		//let stamp = root.reflow.stat.stamp 
		//timetest.t1 = root.reflow.stat.time 
		//timetest.t2 = root.reflow.stat.endTime 

		/*if( root.reflow.stat.time > timer.time.interval ){ 
			//timer.force = true
			timetest.t2++
		}*/

		//console.time('step')

		root.delta = root.reflow.stat.delta;//outsideStep ? timer.delta : root.reflow.stat.delta;





		Motor.stepItems();
    
		// user key interaction 
		
		root.flow.key = user.update();
		root.flow.current = currentControle !== null ? currentControle.name : '';
		//root.flow.tmp = []

		if( breaker !== null ) breaker.step();

		if( currentControle !== null ) currentControle.move();

		if( mouseTool ) mouseTool.step();

		//postUpdate( root.reflow.stat.delta )
		postUpdate( timer.delta );

		//items.character.prestep()

		//  update static object for this side !
		Motor.changes( root.flow.tmp );


		// finally post flow change to physx
		if( isBuffer ) root.post( { m:'poststep', flow:root.flow, Ar:Ar }, [ Ar.buffer ] );
		else root.post( { m:'poststep', flow:root.flow });

		//	Motor.stepItems()

		Motor.flowReset();

	}

    

	static initArray ( full = false ) {

	    // dynamics array
		ArPos = getArray( root.engine, full );

	}

    static upInstance() {

    	for( let n in root.instanceMesh ) root.instanceMesh[n].update();

    	//Motor.updateParticleSolver()

    }

	static clearInstance() {

    	for( let n in root.instanceMesh ) root.instanceMesh[n].dispose();
    	root.instanceMesh = {};

	}

	

	static texture( o = {} ) {
		return Pool.texture( o )
	}


	//-----------------------
	//  MATERIAL
	//-----------------------

	static material ( o = {} ){ return Mat.create( o ) }

	static setExtendShader ( f ) { Mat.extendShader = f; }

	static getMaterialList(){ return Mat.getList(); }

	static getOneMaterial( name ){ 
		console.log('use getMat');
		return Mat.get( name ) 
	}

	static addMaterial( m, direct ){ Mat.set( m, direct ); }

	static setEnvmapIntensity ( v ) { Mat.setEnvmapIntensity(v); }

	static getMat( name ){ return Mat.get( name ) }

	//static getMat () { return Mat; }

	//static getHideMat() { return Mat.get('hide'); }

	
	





	static control ( name ){ // for character and vehicle

		if(currentControle !== null){
			if( name !== currentControle.name ){ 
				currentControle = Motor.byName( name );
			}
		} else {
			currentControle = Motor.byName( name );
		}

	}

	static byName ( name ){

		return Utils.byName( name )

	}

	static getAllBody ( name ){

		return items.body.list

	}

	static explosion ( position = [0,0,0], radius = 10, force = 1 ){

		let r = [];
	    let pos = new Vector3();

	    if( position ){
	    	if( position.isVector3 ) pos.copy(position);
	    	else pos.fromArray( position );
	    }
	    
	    let dir = new Vector3();
	    let i = items.body.list.length, b, scaling;

//
	    while( i-- ){

	        b = items.body.list[i];
	        dir.copy( b.position ).sub( pos );
	        scaling = 1.0 - dir.length() / radius;

	        if( b.isKinematic ) continue;
	        if ( scaling < 0 ) continue;
	        


	       // if ( scaling < 0 ){
	        	dir.setLength( scaling );
	            dir.multiplyScalar( force );
	       // }
	        

	        r.push({ name:b.name, impulse:dir.toArray(), wake:true });
	        //r.push({ name:b.name, impulse:[0,0.01,0], impulseCenter:pos.toArray(), wake:true })


	    }
	    
		Motor.change( r );

	}

	//-----------------------
	//  BUTTON
	//-----------------------

	static addButton (o) {

		let b = new Button( o );
		buttons.push( b );
		return b//.b

	}

	static upButton (o) {

		for ( const key in buttons ) buttons[key].update();

	}


	//-----------------------
	//  ITEMS
	//-----------------------

	static getBodyRef () {
		return items.body
	}

	static initItems () {

		items = {
			body : new Body(), 
			solid : new Solid(), 
			character : new Character(),
			ray : new Ray(),
			joint : new Joint(), 
			contact : new Contact(), 
			terrain : new Terrain(), 
			
			
		};

		if( root.engine === 'PHYSX' || root.engine === 'AMMO' ){ 
			items['vehicle'] = new Vehicle();
		}

		if( root.engine === 'PHYSX' ){ 
			items['solver'] = new Solver();
		}

		root.items = items;

		//root.bodyRef = items.body
		

	}

	static clearBody() {

		items.body.reset();

	}

	static resetItems() {

		for (const key in items) items[key].reset();

	}

	static stepItems () {

		if(Ar===null) return

		Motor.upButton();

		for ( const key in items ) items[key].step( Ar, ArPos[key] );

		Motor.upInstance();



		// update follow camera
		/*if( controls ){ 
			if( controls.enableDamping && controls.enable ) controls.update()
			if( controls.follow ) controls.follow( Motor.getDelta() )
		}*/
	}


	

	static addDirect( b ) {

		root.scenePlus.add( b );
		root.tmpMesh.push( b );

	}

	static adds ( r = [], direct ){

		let i = r.length, n = 0;
		while(i--){
			 Motor.add( r[n], direct );
			 n++;
		}

	}

	static add ( o = {}, direct = false ) {

		if( o.isObject3D ) return Motor.addDirect( o );
		if( o.constructor === Array ) return Motor.adds( o, direct );
		if( o.type === 'container' ) return new Container( o );
		
		if( o.bounce !== undefined ) o.restitution = o.bounce;
		if( o.type === undefined ) o.type = 'box';

		let type = getType( o );

		return items[type].add( o );

	}


	static removes ( r = [], direct ){ for( let o in r ) Motor.remove( r[o], direct ); }
	
	static remove ( name, direct = false ){

		if ( name.constructor === Array ) return Motor.removes( name, direct )

		let b = Motor.byName( name );
		if( b === null ) return;

		// remove on three side
		items[b.type].clear( b );
		// remove on physics side
		root.post( { m:'remove', o:{ name:name, type:b.type } }, null, direct );

	}



	static up ( list ) {

		console.log('up is old');
		Motor.change( list, true );

	}

	static update ( list ) {

		console.log('update is old');
		Motor.change( list );

	}

    static change ( o, direct = false ) {

    	if( direct ){
    		if( o instanceof Array ) Motor.changes( o, true );
    		else Motor.changeOne( o, true );
    	} else {
    		if( o instanceof Array ) root.flow.tmp.push( ...o );
    		else root.flow.tmp.push( o );
    	}

	}


	static changes ( r = [], direct = false ){ for( let o in r ) Motor.changeOne( r[o], direct ); }

	static changeOne ( o = {}, direct = false ){

		if( o.heightData ) return

		let b = Motor.byName( o.name );
		if( b === null ) return null;
		let type = b.type;

		if( o.drivePosition ){
			if( o.drivePosition.rot !== undefined ){  o.drivePosition.quat = MathTool.quatFromEuler( o.drivePosition.rot ); delete ( o.drivePosition.rot ); }
		}
		if( o.rot !== undefined ){ o.quat = MathTool.quatFromEuler( o.rot ); delete ( o.rot ); }
		//if( o.rot1 !== undefined ){ o.quat1 = math.toQuatArray( o.rot1 ); delete ( o.rot1 ); }
		//if( o.rot2 !== undefined ){ o.quat2 = math.toQuatArray( o.rot2 ); delete ( o.rot2 ); }
		if( o.localRot !== undefined ){ o.quat = MathTool.toLocalQuatArray( o.localRot, b ); delete ( o.localRot ); }

		switch( type ){

			case 'terrain': b = items.terrain.set( o, b ); direct = false; break;
			case 'ray': b = items.ray.set( o, b ); direct = false; break;
			case 'character': b = items.character.set( o, b ); break;
			case 'solid': b = items.solid.set( o, b ); break;
			case 'joint': b = items.joint.set( o, b );  break;
			case 'body':
			if( b.isKinematic ) items.body.set( o, b );

			//b = body.set( o, b ); 
			break;

		}
		
		if( direct ){
			root.post( { m:'change', o:o });
		}

	}


	//-----------------------
	//  CAMERA CONTROLS
	//-----------------------

	static setCamera ( o = {} ){

		controls$1.moveCam( o );

	}

	static follow ( m = '', o = {} ){

		let mesh = null;

		if ( typeof m === 'string' || m instanceof String ) mesh = m === '' ? null : Motor.byName( m );
		else if ( m.isObject3D ) mesh = m;

		//	console.log(m, mesh)

		if( mesh === null ) controls$1.resetFollow();
		else controls$1.startFollow( mesh, o );

	}


    //-----------------------
	// INTERN timout
	//-----------------------

	static setTimeout ( f, time = 0 ){

		timoutFunction = f; 
		timoutTime = time; 
		timout = setTimeout( timoutFunction, timoutTime ); 

	}

	static playtimout (){

		if( timoutFunction === null ) return
		timout = setTimeout( timoutFunction, timoutTime ); 

	}

	static pausetimout (){

		if( timout === null ) return
		clearTimeout( timout ); 

	}

	static cleartimout ( f, time ){

		if( timout === null ) return
		timoutFunction = null;
		timoutTime = 0; 
		clearTimeout( timout );
		timout = null;

	}

	//-----------------------
	// BREAK
	//-----------------------

	static addBreaker() {

		if( breaker !== null ) return;
		breaker = new Breaker();

	}

	//-----------------------
	// FROM POOL
	//-----------------------

	static load ( Urls, Callback, Path = '', msg = '' ){
		Pool.load( Urls, Callback, Path, msg );
	}

	static applyMorph ( modelName, meshs = null, normal = true, relative = true ){
		Pool.applyMorph( modelName, meshs = null, normal = true, relative = true );
	}

	/*static uv2 ( model ){
		Pool.uv2( model )
	}*/

	static getMesh ( obj, keepMaterial ){
		if(keepMaterial){
			let mm = Pool.getMaterials(obj);
			for( let m in mm ){
				Motor.addMaterial( mm[m] );
			}
		}
		return Pool.getMesh( obj, keepMaterial )
	}

	static getGroup ( obj, autoMesh, autoMaterial ){
		return Pool.getGroup( obj, autoMesh, autoMaterial )
	}

	/*static getMaterial ( name ){
		return Pool.getMaterial( name )
	}*/

	static getTexture ( name, o ){
		return Pool.getTexture( obj, autoMesh, autoMaterial )
	}

	static getScript ( name ){
		return Pool.getScript( name )
	}

	static get ( name, type ){
		return Pool.get( name, type )
	}

	static poolDispose (){
		return Pool.dispose()
	}

	static setDracoPath ( src ){
		return Pool.dracoPath = src
	}


	//-----------------------
	// PARTICLE
	//-----------------------

	static initParticle (){}
	static addParticle (){}
	static getParticle (){}

	static addParticleSolver ( o ){
		let s = new Particle( o );
		particles$1.push(s);
		return s
	}

	static updateParticleSolver () { 

		let i = particles$1.length;
		while( i-- ) particles$1[i].update();
		
	}

	static clearParticleSolver () { 

		particles$1.length;
		//while( i-- ) particles[i].dispose()
    	particles$1 = [];
		
	}


	//-----------------------
	// TEXT
	//-----------------------

	static addText ( o ){ 
		let t = new Textfield(o);

		if( o.parent ) o.parent.add( t );
		else root.scenePlus.add( t );
		textfields.push(t);
		return t
	}

	static clearText () { 

		let i = textfields.length;
		while( i-- ) textfields[i].dispose();

		//for( let n in textfields ) textfields[n].dispose()
    	textfields = [];
		
	}


}



//--------------
//
//  SOLID ONLY 
//
//--------------

class Solid extends Body {
	constructor () {
		super();
		this.type = 'solid';
	}
	step ( AR, N ) {}
}

//import * as UIL from 'uil'
//import { Main } from '../Main.js'

/** __
*    _)_|_|_
*   __) |_| | 2023
* @author lo.th / https://github.com/lo-th
*/

let Main$3 = null;

let svg$1 = h$2.dom;
let setSvg = h$2.setSvg;
let grad = h$2.makeGradiant;

let parent;
let content$1, cross = null, border, txt, loader, textRight;
let unselectable = '-o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none; pointer-events:none; ';

let menu, title, engine, demo, downMenu, innerMenu, zoning, guiButton;

let top$1 = null;
let maxHeight = 0;
let maxListItem = 10;

let guiOpen = false;

let currentMenu = '';

let h1,h2;

const listdata = {
    home : ['Code', 'Worker', 'Github', 'Docs'],
    engine : [],
    demo:[],
    visited:[],
};

let isDisplay = false;

let a_base = [ 1, 0, 0, 1,   0, 1, -1, 0,  -1, 0, 0, -1,   0, -1, 1, 0 ];
let fps = null;
let statistics = null;
let debug$1 = null;

let joy = null;

let lock = false;

let color$1 = '#001';
let colorVisite = '#335';

let setting$1 = {
    cross:4,
    border:'#020206',
};

let p0 = 'M 0.5 1.5 L 9.5 1.5 M 0.5 5.5 L 9.5 5.5 M 0.5 9.5 L 9.5 9.5';
let p1 = 'M 1.5 0.5 L 1.5 9.5 M 5.5 0.5 L 5.5 9.5 M 9.5 0.5 L 9.5 9.5';

class Hub {

    static setMain( r ) { Main$3 = r; }

    static colors( day ) {

        if(day){
            color$1 = '#001';
            colorVisite = '#335';
        } else {
            color$1 = '#FFE';
            colorVisite = '#DDC';
        }

        content$1.style.color = color$1;
        document.querySelector("#svgLogo").setAttributeNS(null, 'stroke', color$1 );
        document.querySelector("#guiPath").setAttributeNS(null, 'stroke', color$1 );
        document.querySelector("#svgLoader").setAttributeNS(null, 'fill', color$1 );

    }

    static reset() {

        Hub.log();
        if( cross ) content$1.removeChild( cross );
        cross = null;
        //guiOpen = false

        if( joy ) this.removeJoystick();
        
    }

    static resize ( s ){

        content$1.style.left = s.left + "px";
        content$1.style.width = s.left !== 0 ? 'calc(100% - ' + s.left + 'px)' : '100%';
        if( joy !== null ) joy.rezone();

    }

    static init ( Camera, Size, text, Parent ) {

        if( isDisplay ) return;
        parent = Parent || document.body;

        content$1 = document.createElement( 'div' );
        content$1.style.cssText = unselectable + 'position:absolute; margin:0; padding:0; top:0px; left:0px; width:100%; height:100%; display:block; color:'+color$1+'; font-family: Mulish,sans-serif;';
        parent.appendChild( content$1 );
        
        txt = document.createElement( 'div' );
        txt.style.cssText = " color: #fff; font-size:16px; text-align:center; position:absolute; margin:0; padding:0; top:50%; left:50%; width:512px; height:20px; margin-left:-256px; margin-top:-38px; display:block; pointer-events:none; text-shadow: 1px 1px #000000;";
        txt.textContent = text || 'load...';
        content$1.appendChild( txt );

        loader = document.createElement( 'div' );
        loader.style.cssText = "position:absolute; top:50%; left:50%; width:60px; height:60px; margin-left:-30px; margin-top:-30px; display:block; ";
        loader.innerHTML = this.miniLoader( '#000' );
        content$1.appendChild( loader );
        

        //loader.textContent = 'load...';
        //this.addJoystick()

        //this.addBorder()
        //this.init3dHub()

        isDisplay = true;

    }

    static removeJoystick() {
        if(joy === null ) return
        joy.dispose();
        joy = null;
    }

    static addJoystick () {
        let colors = {
            joyOut: 'rgba(255,255,255,0.25)',
            joyOver:'rgba(127,255,0,0.5)',
            joySelect: '#7fFF00',
        };
        joy = T$1('Joystick', {  w:120, mode:1, text:false, precision:1, pos:{left:'10px', bottom:'10px' }, target:content$1, simple:true, ...colors }).onChange( function(v){ Motor.setKey(0, v[0]); Motor.setKey(1, v[1]); } );
        //joy.neverlock = true
    }

    static snipperMode ( b ) {

    }

    /*static loadSvg ( url, div ) {

        var xhr = new XMLHttpRequest();
        xhr.open("GET",url,true);
        xhr.overrideMimeType("image/svg+xml");
        xhr.onload = function(e) {
            if( this.status == 200 ) div.appendChild( xhr.responseXML.documentElement );
        }
        xhr.send("");

    }*/

    /*clear: function () {

        if( !isDisplay ) return;

        if( tween !== null ){ TWEEN.remove( tween ); alpha = { n:1 } }

        tween = new TWEEN.Tween( alpha ).to( { n:0 }, 2000 )
            .easing( TWEEN.Easing.Quadratic.Out )
            .onUpdate( function() { intro.opacity ( alpha.n ); } )
            .onComplete( function () { intro.dispose(); } )
            .start();

    },*/

    static log ( t = '' ) {

        if( debug$1 === null ) return;
        debug$1.innerHTML = t;

    }

    static setFps ( t ) {

        if( fps === null ) return;
        fps.innerHTML = t;

    }

    static showTimeTest ( t ) {

        if( statistics === null ) return;
        let txt = JSON.stringify(t, null, 2);
        txt = txt.replace(/[",*+?^${}()|[\]\\]/g, '');
        statistics.textContent = txt;

    }

    static setStats ( txt = '' ) {

        statistics.textContent = txt;

    }

    static endLoading () {

        loader.style.top = '38px';
        loader.style.left = '90px';
        //content.removeChild( loader )
        
        content$1.removeChild( txt );
        //txt.style.top = '50px'
        //txt.textContent ='';
        //txt.style.display = 'none'

        Pool.setLoadEvent(
            function(){ loader.style.display = 'block'; },
            function(){ loader.style.display = 'none'; }
        );

        


        /*let logo = `<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none;' 
        preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 256 256'>
        <path id='svgLogo' stroke='${color}' stroke-width='30' style='stroke-opacity: 1;' stroke-linejoin='round' stroke-linecap='round' 
        fill='none' d='M 72.85 52.85 Q 70.9 53.8 69.15 55 45 72.35 45 96.5 45 120.65 69.15 137.7 93.55 155 127.95 155 L 127.95 37.95 Q 
        162.35 37.95 186.5 55 210.9 72.35 210.9 96.5 210.9 120.65 186.5 137.7 162.35 155 127.95 155 L 127.95 237.95'/></svg>`*/

        /*let logo = `<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none;' 
        preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 40 40'>
        <path id='svgLogo' stroke='${color}' stroke-width='4' transform='translate(0, 4)' stroke-linejoin='round' stroke-linecap='round' 
        fill='none' d='${iLogo}''></svg>`*/



        let bg = 'none';//'rgba(255,255,255,0.1)'
        let bg2 = 'none';//'rgba(255,255,255,0.01)'

        zoning = document.createElement( 'div' );
        zoning.style.cssText = 'position:absolute; top:0px; background:'+bg2+'; left:60px; pointer-events:auto; ';
        zoning.id = 'zone';
        content$1.appendChild( zoning );

        menu = document.createElement( 'div' );
        menu.style.cssText = 'position:absolute; top:25px; background:'+bg+'; left:80px; display:flex; align-self: stretch; justify-content: flex-start; gap: 10px 20px; align-items:baseline; ';
        content$1.appendChild( menu );

        downMenu = document.createElement( 'div' );
        downMenu.style.cssText = 'position:absolute; top:54px; left:80px; overflow:hidden; background:'+bg+'; height:0px; width:0px;';//' width:0px;' //transition: all .1s ease-in-out;
        content$1.appendChild( downMenu );

        innerMenu = document.createElement( 'div' );
        innerMenu.style.cssText = 'position:absolute; top:0px; left:0px; top:0px; overflow:hidden; background:'+bg+'; display:flex; flex-wrap:warp;';//flex-direction: column; '
        downMenu.appendChild( innerMenu );

        zoning.addEventListener("pointerleave", (e) => {
            lock = false;
           // Hub.hideMenu()
            setTimeout( function(){if(!lock) Hub.hideMenu(); }, 100 );
        });
        //zoning.addEventListener("pointerdown", (e) => { lock = true });

        zoning.addEventListener("pointermove", Hub.moving );

        title = document.createElement( 'div' );
        menu.appendChild( title );
        title.id = 'home';
        title.innerHTML = Hub.miniIcon('logo', color$1 );

        engine = document.createElement( 'div' );
        engine.style.cssText = 'font-size:16px; font-weight:700; ';
        engine.id = 'engine';
        menu.appendChild( engine );
        
        demo = document.createElement( 'div' );
        demo.style.cssText = 'font-size:16px; font-weight:500;';
        demo.id = 'demo';
        menu.appendChild( demo );
        
        this.effect(title);
        this.effect(engine);
        this.effect(demo);

        

        debug$1 = document.createElement( 'div' );
        debug$1.style.cssText = 'position:absolute; width:300px; bottom:25px; left:80px; font-size:14px; font-weight:500; vertical-align:bottom; text-align:left;';
        //debug.style.cssText = 'position:absolute; background:'+bg+'; width:300px; margin-left:-150px; bottom:25px; left:50%; font-size:14px; font-weight:500; vertical-align:bottom; text-align:center;'
        content$1.appendChild( debug$1 );

        statistics = document.createElement( 'div' );
        statistics.style.cssText = 'position:absolute; bottom:25px; left:10px; font-size:14px; font-weight:500; width:400px; white-space: pre; line-height:20px;';
        content$1.appendChild( statistics );


        top$1 = document.createElement( 'div' );
        top$1.style.cssText = unselectable + "position:absolute; top:0px; right:0px; width:260px; height:100%; background:rgba(0,0,0,0.4); display:none;";
        //top.style.cssText = unselectable + "position:absolute; top:0px; right:5px; width:250px; height:100%; background:#000008; display:none; opacity: 0.7;"
        top$1.style.backdropFilter = 'blur(4px)';
        content$1.appendChild( top$1 );



        fps = document.createElement( 'div' );
        fps.style.cssText = 'position:absolute; top:33px; right:100px; text-align:right; font-size:14px; font-weight:500; ';
        content$1.appendChild( fps );




        guiButton = document.createElement( 'div' );
        guiButton.style.cssText = 'position:absolute; right:80px;  top:31px; pointer-events:auto; cursor: pointer;';
        content$1.appendChild( guiButton );
        guiButton.innerHTML = `<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none;' 
        preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='10px' height='10px' viewBox='0 0 10 10'>
        <path stroke='${color$1}' id='guiPath' stroke-width='1' fill='none' d='${p0}'/></svg>`;
        guiButton.addEventListener("pointerdown", Main$3.showGui );

        /*let mouse = document.createElement( 'div' );
        mouse.style.cssText = 'position:absolute; right:80px;  top:27px; pointer-events:auto; cursor: pointer;'
        content.appendChild( mouse )
        mouse.id = 'mouse'
        mouse.innerHTML = Hub.miniIcon('drag', color );*/


        //Hub.colors(false)

    }

    static setTopColor ( c = '#000000' ) {
        if(top$1) top$1.style.background = c;
    }

    static harmony ( v ) {

        let lineColor = 'rgba(0,0,0,0.5)';

        if(v ){
            if(!h1 && !h2){
                h1 = document.createElement( 'div' );
                h1.style.cssText = 'position:absolute; top:33.33%; width:100%; height:33.33%; border-top:1px dashed '+lineColor+'; border-bottom:1px dashed '+lineColor+';';
                content$1.appendChild( h1 );

                h2 = document.createElement( 'div' );
                h2.style.cssText = 'position:absolute; left:33.33%; height:100%; width:33.33%; border-left:1px dashed '+lineColor+'; border-right:1px dashed '+lineColor+';';
                content$1.appendChild( h2 );
            }
        } else {
            if(h1 && h2){
                content$1.removeChild( h1 );
                content$1.removeChild( h2 );
                h1 = null;
                h2 = null;
            }
        }
        
    }

    static miniLoader( color ){
        return `
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
        viewBox="0 0 100 100" enable-background="new 0 0 0 0" xml:space="preserve">
        <path id="svgLoader" fill="${color}" d="M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50 M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50">
        <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="1s" from="0 50 50" to="360 50 50" repeatCount="indefinite" />
        </path></svg>
        `
    }

    static miniIcon( name, color ){

        let p;

        switch(name){
            case 'logo' : p = 'M 11.2 7.3 Q 10.9 7.45 10.6 7.7 6.75 10.45 6.75 14.35 6.75 18.15 10.6 20.9 14.5 23.65 20 23.65 L 20 4.95 Q 25.5 4.95 29.4 7.7 33.25 10.45 33.25 14.35 33.25 18.15 29.4 20.9 25.5 23.65 20 23.65 L 20 35'; break
            case 'drag' : p = 'M 23.975 7.025 Q 21.93 5 19 5 L 5 5 M 12 19 L 5 19 M 19 12 L 19 35 35.15 28.9 19 12 Z'; break
            case 'build' : p = 'M 20 20 L 20 5 35 5 35 20 35 35 20 35 5 35 5 20 20 20 35 20 M 20 20 L 20 35'; break
            case 'cible' : p = 'M 27.05 12.95 Q 30 15.8 30 20 30 24.1 27.05 27.05 24.1 30 20 30 15.8 30 12.95 27.05 10 24.1 10 20 10 15.8 12.95 12.95 15.8 10 20 10 24.1 10 27.05 12.95 Z M 35 20 L 32 20 M 20 5 L 20 8 M 8 20 L 5 20 M 20 32 L 20 35'; break
        }

        return `<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none;' 
        preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 40 40'>
        <path id='svgLogo' stroke='${color}' stroke-width='4' transform='translate(0, 4)' stroke-linejoin='round' stroke-linecap='round' 
        fill='none' d='${p}''></svg>`

    }

    static switchGuiButton(b){

        document.querySelector("#guiPath").setAttributeNS(null, 'd', b ? p1 : p0);

        guiOpen = b;

        top$1.style.display = b ? 'block':'none';

        let color = b ? '#FFE' : '#001';
        document.querySelector("#guiPath").setAttributeNS(null, 'stroke', color );
        fps.style.color = color;

        

    }

    static hideMenu () {
        downMenu.style.height = '0px';
        innerMenu.innerHTML = '';
        zoning.style.width = '0px';
        zoning.style.height = '0px';
        currentMenu = '';
    }

    static showMenu ( target ) {

        let type = target.id;

        if( currentMenu === type ) return

        Hub.hideMenu();

        currentMenu = type;

        downMenu.style.left = (type==='engine' ? 120:80) + 'px';

        //if(type==='home') list.


        let list = listdata[ type ];
        /*type === 'demo' ?  demolist : engineList
        if( type === 'logo') list = ['Github', 'About']*/
        let i = list.length, m, n=0, itemH = 0, name;

        innerMenu.style.top = '0px';
        innerMenu.style.width = 'auto';
        innerMenu.style.display = 'flex';
        innerMenu.style.flexDirection = 'column';
        
        while(i--){

            name = list[n];
            m = document.createElement( 'div' );
            innerMenu.appendChild( m );
            m.classList.add("down");
            
            m.style.cssText = type === 'demo' ? 'font-size:16px; font-weight:500;' : 'font-size:16px; font-weight:700;';
            m.id = name;
            m.textContent = name;

            if( listdata.visited.indexOf(name) !== -1 ) m.style.color = colorVisite;
            if( name === 'Worker' ) m.style.color = Main$3.isWorker ? color$1 : colorVisite;
            if( name === 'Code' ) m.style.color = Main$3.isEditor ? color$1 : colorVisite;

            if( n===0 ) itemH = m.offsetHeight;
            //bb[n] = m
            
            this.effect( m, true );
            n++;
        }

        
        let rect = innerMenu.getBoundingClientRect();

        let max = maxListItem * itemH;
        let maxH = n * itemH; 
        maxHeight = maxH > max ? max : rect.height;

        //if( ratio !== 1 && full ){
        if( type === 'demo' ){

            innerMenu.style.display = 'grid';
            innerMenu.style.gridTemplateColumns = 'repeat(auto-fill, 120px)';
            innerMenu.style.justifyContent = 'space-between';
            let dw = guiOpen ? (255+80) : 160; 

            downMenu.style.left = 80 + 'px';
            downMenu.style.width = 'calc(100% - '+dw+'px)';
            innerMenu.style.width = '100%';
            rect = innerMenu.getBoundingClientRect();
            
            downMenu.style.height = rect.height+'px';//maxHeight + 'px'


        } else {
            downMenu.style.width = rect.width + 'px';
            downMenu.style.height = maxHeight + 'px';
        }

        zoning.style.left = (rect.left-20) + 'px';
        zoning.style.width = (rect.width + 40) + 'px';
        zoning.style.height = (rect.height + 70) + 'px';

    }

    static upMenu () {

        engine.textContent = this.reformat( Main$3.engineType );
        demo.textContent = this.reformat( Main$3.currentDemo );

        listdata.visited.push( demo.textContent );

        let list = [...Main$3.demoList];
        list.splice(list.indexOf(Main$3.currentDemo), 1);
        list.sort();
        list = list.map( x => Hub.reformat(x) );

        listdata.demo = list;

        list = [...Main$3.engineList];
        list.sort();
        list.splice(list.indexOf(Main$3.engineType), 1);
        list = list.map( x => Hub.reformat(x) );

        listdata.engine = list;

    }

    static reformat ( n ) {

        return n.toUpperCase().substring(0,1) + n.substring(1).toLowerCase();

    }

    static effect ( dom, item ) {

        dom.classList.add("menu");

        if(!Main$3.isMobile) dom.addEventListener("pointermove", Hub.moving );

        dom.addEventListener( 'pointerleave', (e) => {
            e.target.style.textDecoration = 'none';
            //lock = false
            //timeout = setTimeout( function(){ if(!lock) Hub.hideMenu() }, 1000 )
        });

        dom.addEventListener("pointerdown", (e) => {
            e.target.style.textDecoration = 'underline ' + color$1;
            if( e.target.id === 'home' || e.target.id === 'engine' || e.target.id === 'demo' ) Hub.showMenu(e.target);
            else Hub.onClick( e.target.id );
        });

    }

    static onClick ( name ) {

        lock = false;
        Hub.hideMenu();
        
        setTimeout( function(){ 
            if( listdata.engine.indexOf(name) !== -1 ) Hub.swapEngine( name );
            else if( listdata.home.indexOf(name) !== -1 ) Hub.homeLink( name );
            else Main$3.loadDemo( name.toLowerCase() ); 
        }, 100 ); 

    }

    static homeLink ( type ) {
        switch(type){
            case 'Github': window.open( 'https://github.com/lo-th/phy', '_blank'); break;
            case 'Docs': window.open( './docs/index.html#manual/Welcome', '_blank'); break;
            case 'Worker': Hub.swapWorker(); break;
            case 'Code': Hub.swapCode(); break;
        }
    }

    static swapWorker () {
        Main$3.isWorker = !Main$3.isWorker;
        Hub.swapEngine();
    }

    static swapCode () {
        Main$3.isEditor = !Main$3.isEditor;
        Main$3.showEditor(Main$3.isEditor);
    }

    static swapEngine ( type ) {
        if( !type ) type = Main$3.engineType;
        let name = type.toLowerCase();
        let hash = location.hash;
        let url = 'index';
        let param = 'E=';
        if( Main$3.devMode ) param += 'dev_';
        if( Main$3.isWorker ) param += 'w_';
        param += name;
        window.open( url+'.html?'+param+hash, '_self');
    }

    static moving ( e ) {

        lock = true;
        if( e.target.id === 'zone') return

        e.target.style.textDecoration = 'underline '+color$1;

        if( e.target.id === 'home' || e.target.id === 'engine' || e.target.id === 'demo' ){ 
            Hub.showMenu( e.target );
            return 
        }

        return 

    }

    static count ( data, fire ) {

        if( fire ){
            data.n--;
            data.t--;
        }

        textRight.textContent = data.n + ' / '+ data.t;

        if( data.n === 0 ) return 'reload';
        if( data.t === 0 ) return 'empty';
        return 'fire';

    }

    static dispose () {

        if( !isDisplay ) return;

        while (content$1.firstChild) content$1.removeChild(content$1.lastChild);
        parent.removeChild( content$1 );
        isDisplay = false;

    }

    //-------------------------
    //
    //  BORDER
    //
    //-------------------------


    static addBorder() {

        let ccc = [ 
            [68, setting$1.border, 0], 
            [75, setting$1.border, 0.08], 
            [93, setting$1.border, 0.4],
            [100, setting$1.border, 0.6],
        ];

        var css =  "position:absolute; margin:0; padding:0; top:0; left:0; width:100%; height:100%; display:block; pointer-events:none;";

        border = svg$1( 'svg', css , { viewBox:'0 0 512 512', width:512, height:512, preserveAspectRatio:'none' } );
        svg$1( 'defs', '', {}, border );
        grad( 'radialGradient', { id:'grad', cx:0, cy:0, r:338, fx:0, fy:0, gradientTransform:'matrix( 0, 1, -1, 0, 256, 256 )', gradientUnits:"userSpaceOnUse" }, border, ccc );
        svg$1( 'rect', '', {  x:0, y:0, width:512, height:512, fill:'url(#grad)' }, border );

        content$1.appendChild( border );

    }


    //-------------------------
    //
    //  CROSS
    //
    //-------------------------

    static hideCross( b ) {

        cross.style.visibility = !b ? 'visible' : 'hidden';

    }

    static addCross() {

        var css =  "position:absolute; margin:0; padding:0; top:50%; left:50%; width:128px; height:128px; margin-left:-64px; margin-top:-64px; display:block;";
        cross = svg$1( 'svg', css , { viewBox:'0 0 64 64', width:64, height:64, preserveAspectRatio:'none' } );

        svg$1( 'defs', '', {}, cross );
        svg$1( 'path', '', { id:'cc', d:'M 0 1.5 L 0 -1.5', stroke:'#FFFFFF', 'stroke-width':2, fill:'none', 'stroke-linecap':'butt', 'vector-effect':'non-scaling-stroke' }, cross, 0 );
        svg$1( 'g', '', {}, cross );

        var g = cross.childNodes[1];

        for( var i = 0; i<4; i++ ){
            svg$1( 'g', '', {}, g );
            svg$1( 'use', '', { link:'#cc' }, g, i );
        }

        this.setCrossSize( setting$1.cross );

        content$1.appendChild( cross );

    }

    static setCross ( n, time ) {

        /*if( crossTween !== null ) TWEEN.remove( crossTween );

        crossTween = new TWEEN.Tween( setting ).to( { cross:n }, time || 300 )
        .easing( TWEEN.Easing.Quartic.Out )
        .onUpdate( function( o ) { this.setCrossSize( o.cross ); }.bind(this) )
        .start();*/

    }

    static setCrossSize ( d ) {

        let i,n, m, t = a_base;
        let p = [ 32, 32-d,   32+d, 32,   32, 32+d,   32-d, 32 ];

        for( i = 0; i<4; i++){
            m=i*4;
            n = i*2;
            setSvg( cross, 'transform', 'matrix( '+ t[m]+' '+t[m+1]+' '+t[m+2]+' '+t[m+3]+' '+p[n]+' '+p[n+1] +' )', 1, i );
        }

    }

    //-------------------------
    //
    //  3D HUB
    //
    //-------------------------

    /*static init3dHub() {

        console.log('HUB 3D!!')

        //camera = root.view.getCamera();

        //var s = root.view.getSizer()

        panelMat = new ShaderMaterial( {

            uniforms: {

                renderMode:{ value: 0 },
                ratio: { value: 1 },//s.w/s.h
                radius: { value: 2 },
                step: { value: new Vector4(0.6, 0.7, 1.25, 1.5 ) },

            },

            vertexShader:`
            varying vec2 vUv;

            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
            `,
            fragmentShader:`

            uniform int renderMode;

            uniform float ratio;
            uniform float radius;
            uniform vec4 step;
            varying vec2 vUv;
            void main() {
                vec2 c = vec2(0.5, 0.5);
                vec2 pos = (vUv - 0.5) * vec2(ratio, 1) + 0.5;
      
                float dist = length( pos - c ) * radius;

                vec4 cOne = vec4(0.0, 0.0, 0.0, 0.0);
                vec4 cTwo = vec4(0.0, 0.0, 0.0, 0.0);
                vec4 cTree = vec4(0.0, 0.0, 0.0, 0.25);
                vec4 cFour = vec4(0.0, 0.0, 0.0, 0.95);

                vec4 color = mix( cOne, cTwo, smoothstep( step.x, step.y, dist ));
                color = mix( color, cTree, smoothstep(step.y, step.z, dist ));
                color = mix( color, cFour, smoothstep(step.z, step.w, dist ));

                if( renderMode == 0 ) gl_FragColor = color;
                else discard;

            }
            `, 
            transparent:true,
            depthWrite:false,
            depthTest:false,
            toneMapped: false,

        } );

        panel = new Mesh( new PlaneGeometry(1,1, 2,2), panelMat  );
        panel.frustumCulled = false;
        //panel = new THREE.Mesh( new THREE.SphereBufferGeometry(1) );
        //panel.position.z = -0.1
        camera.add( panel )

        panel.renderOrder = 1000000;

        

        isPanel3D = true

        this.update()

    }

    static setRenderMode ( v ){

        if(!isPanel3D) return
        panelMat.uniforms.renderMode.value = v
        
    }

    static hide( b ){

        panel.visible = b

    }

    static setFocus ( v ){

        

    }

    static update ( Size, type ) {

        console.log('HUB UP!!')

        if( Size ) size = Size;
        let s = size;

        type = type || '';

        //let s = root.view.getSizer();
        let fov = camera.fov;
        let z = camera.zoom;
        let d = 0, r = 1;


        if( s.w !== old.w || s.h !== old.h || fov !== old.f || z !== old.z ){ 

            this.resizeOld( s, fov, z );

            if(!isPanel3D) return

            if( isSnipper && type === 'fps' ){

                r = (z-1.2)/12.8;

                panelMat.uniforms.ratio.value = math.lerp( 1, old.ratio, r ); 
                panelMat.uniforms.radius.value = math.lerp( 2, 3, r );

            } else {
                d = type === 'tps' ? z - 0.6 : z-1.2;
                d*=0.25;
                panelMat.uniforms.step.value.x = 0.6 - d;
                panelMat.uniforms.step.value.y = 0.7 - d;
                panelMat.uniforms.step.value.z = 1.25 - d*0.5;
            }

            
            //panelMat.uniforms.step.value.w = 1.5 - d 

        }

    }

    static resizeOld ( s, fov, z ){

        content.style.left = (s.left + 10) + "px"



        if(!isPanel3D) return


        //var d = 0.0001
        let d = 0.001
        let v = fov * math.torad; // convert to radians
        let r = (s.h / ( 2 * Math.tan( v * 0.5 ) ));
        let e = 1//3/5; // ???

        panel.scale.set( s.w, s.h, 0 ).multiplyScalar(d);
        //panel.scale.set( 50, 50, 0 ).multiplyScalar(0.0001);
        //panel.scale.z = 1;
        panel.position.z = -r*d*z;

        old.f = fov;
        old.z = z;
        old.w = s.w;
        old.h = s.h;
        old.ratio = s.w / s.h;

    }*/

}

//import { Main } from '../Main.js'

class Video {

    constructor () {

        //this.renderer = renderer;
        this.isCapture = false;
        this.ready = false;

    }

    update(){
        if( this.isCapture ) this.capturer.capture( Shader.renderer.domElement );
    }
    
    stop(){

        if( !this.isCapture ) return;

        this.capturer.stop();
        this.capturer.save();
        
        this.isCapture = false;

    }

    start () {

        if( this.isCapture ) return;
        if( !this.ready ){ 
            this.loadCCapture();
            return
        }

        this.capturer = new CCapture( {

            verbose: false,
            display: false,
            framerate: 60,
            //motionBlurFrames: 1,//( 960 / framerate ) * 0 ,
            quality: 50,//80
            format:"webm-mediarecorder",
            //format:"webm",
            currentTime:0,
            timeLimit: 60,
            frameLimit: 0,
            autoSaveTime: 0,
            //autoSaveTime:10,
            //workersPath:'./js/',
            //timeLimit: 60,//second
            //frameLimit: 0,
            //autoSaveTime: 0,
            //onProgress: function( p ) { progress.style.width = ( p * 100 ) + '%' }
        });

        //console.log('CCapture is ready', this.capturer )
        this.isCapture = true;
        this.capturer.start();
        
    }

    

    loadCCapture () {

        var xml = new XMLHttpRequest();
        xml.open('GET', './src/libs/CCapture.all.min.js');
        xml.overrideMimeType( "text/javascript" );
        xml.onreadystatechange = function() {
            if ( xml.readyState === 4 ) {
                if ( xml.status === 200 || xml.status === 0 ) {
                    let n = document.createElement("script");
                    n.type = "text/javascript";
                    n.async = true;
                    n.charset = "utf-8";
                    n.text = xml.responseText;
                    document.getElementsByTagName('head')[0].appendChild(n);
                    this.ready = true;
                    this.start();
                }
                else console.error( "Couldn't load [ccapture] [" + xml.status + "]" );
            }
            
        }.bind(this);
        xml.send();

    }

   /* mode(){

        this.isCaptureMode = b;

        if( this.isCaptureMode ){

            window.removeEventListener( 'resize', view.resize );

            renderer.domElement.style.position = "absolute";
            renderer.domElement.style.left = "50%";
            renderer.domElement.style.top = "50%";
            renderer.domElement.style.border = '1px solid #F00';

            view.setVideoSize();
            view.initCapture();

        } else {

            renderer.domElement.style.position = "absolute";
            renderer.domElement.style.left = "0px";
            renderer.domElement.style.top = "0px";
            renderer.domElement.style.margin = '0px 0px';
            renderer.domElement.style.border = 'none';

            window.addEventListener( 'resize', view.resize );
            view.resize();

        }

    }*/

    /*size(){

        if( !isCaptureMode ) return;

        if( v !== undefined ) view.videoSize = v;

        var w = view.videoSize[0];
        var h = view.videoSize[1];
        renderer.domElement.style.margin = (-h*0.5)+'px '+ (-w*0.5)+'px';
        view.resize( null, w, h );

    }*/


}

/**
 * Ground projected env map adapted from @react-three/drei.
 * https://github.com/pmndrs/drei/blob/master/src/core/Environment.tsx
 */
class GroundProjectedEnv extends Mesh {

	constructor( texture, options = {} ) {

		const isCubeMap = texture.isCubeTexture;

		const defines = [
			isCubeMap ? '#define ENVMAP_TYPE_CUBE' : ''
		];

		const vertexShader = /* glsl */ `
        varying vec3 vWorldPosition;

        void main() 
        {

            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

        }
        `;
		const fragmentShader = defines.join( '\n' ) + /* glsl */ `

        varying vec3 vWorldPosition;

        uniform float radius;
        uniform float height;
        uniform float angle;

        #ifdef ENVMAP_TYPE_CUBE

            uniform samplerCube map;

        #else

            uniform sampler2D map;

        #endif

        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {

            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;

        }

        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {

            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;

        }

        vec3 project() 
        {

            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;

            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;

            } else {

                p = vec3( 0.0, 1.0, 0.0 );

            }

            return p;

        }

        #include <common>

        void main() 
        {

            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE

                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;

            #else

                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;

            #endif

            gl_FragColor = vec4( outcolor, 1.0 );

            #include <tonemapping_fragment>
            #include <encodings_fragment>

        }
        `;

		const uniforms = {
			map: { value: texture },
			height: { value: options.height || 15 },
			radius: { value: options.radius || 100 },
		};

		const geometry = new IcosahedronGeometry( 1, 16 );
		const material = new ShaderMaterial( {
			uniforms,
			fragmentShader,
			vertexShader,
			side: DoubleSide,
		} );

		super( geometry, material );

	}

	set radius( radius ) {

		this.material.uniforms.radius.value = radius;

	}

	get radius() {

		return this.material.uniforms.radius.value;

	}

	set height( height ) {

		this.material.uniforms.height.value = height;

	}

	get height() {

		return this.material.uniforms.height.value;

	}

}

/*! 
 * quantize.js Copyright 2008 Nick Rabinowitz.
 * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php
 */

 
/**
 * Basic Javascript port of the MMCQ (modified median cut quantization)
 * algorithm from the Leptonica library (http://www.leptonica.com/).
 * Returns a color map you can use to map original pixels to the reduced
 * palette. Still a work in progress.
 * 
 * @author Nick Rabinowitz
 * @example
// array of pixels as [R,G,B] arrays
var myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]
                // etc
                ];
var maxColors = 4;
var cmap = MMCQ.quantize(myPixels, maxColors);
var newPalette = cmap.palette();
var newPixels = myPixels.map(function(p) { 
    return cmap.map(p); 
});
 
 */
//var MMCQ = (function() {

    // fill out a couple protovis dependencies
    /*!
    * Block below copied from Protovis: http://mbostock.github.com/protovis/
    * Copyright 2010 Stanford Visualization Group
    * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php
    */
    const pv = {
        map: function(array, f) {
          var o = {};
          return f
              ? array.map(function(d, i) { o.index = i; return f.call(o, d); })
              : array.slice();
        },
        naturalOrder: function(a, b) {
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        },
        sum: function(array, f) {
          var o = {};
          return array.reduce(f
              ? function(p, d, i) { o.index = i; return p + f.call(o, d); }
              : function(p, d) { return p + d; }, 0);
        },
        max: function(array, f) {
          return Math.max.apply(null, f ? pv.map(array, f) : array);
        }
    };

    // private constants
    var sigbits = 5,
        rshift = 8 - sigbits,
        maxIterations = 1000,
        fractByPopulations = 0.75;
    
    // get reduced-space color index for a pixel
    function getColorIndex(r, g, b) {
        return (r << (2 * sigbits)) + (g << sigbits) + b;
    }
    
    // Simple priority queue
    function PQueue( comparator ) {
        var contents = [],
            sorted = false;
        
        function sort() {
            contents.sort(comparator);
            sorted = true;
        }
        
        return {
            push: function(o) {
                contents.push(o);
                sorted = false;
            },
            peek: function(index) {
                if (!sorted) sort();
                if (index===undefined) index = contents.length - 1;
                return contents[index];
            },
            pop: function() {
                if (!sorted) sort();
                return contents.pop();
            },
            size: function() {
                return contents.length;
            },
            map: function(f) {
                return contents.map(f);
            },
            debug: function() {
                if (!sorted) sort();
                return contents;
            }
        };
    }

    





    
    // histo (1-d array, giving the number of pixels in
    // each quantized region of color space), or null on error

    function getHisto( pixels ) {

        var histosize = 1 << (3 * sigbits), histo = new Array(histosize), index, rval, gval, bval;

        pixels.forEach(function(pixel) {
            rval = pixel[0] >> rshift;
            gval = pixel[1] >> rshift;
            bval = pixel[2] >> rshift;
            index = getColorIndex(rval, gval, bval);
            histo[index] = (histo[index] || 0) + 1;
        });
        return histo;

    }
    
    function vboxFromPixels( pixels, histo ) {

        var rmin=1000000, rmax=0, gmin=1000000, gmax=0, bmin=1000000, bmax=0, rval, gval, bval;
        // find min/max
        pixels.forEach(function(pixel) {
            rval = pixel[0] >> rshift;
            gval = pixel[1] >> rshift;
            bval = pixel[2] >> rshift;
            if (rval < rmin) rmin = rval;
            else if (rval > rmax) rmax = rval;
            if (gval < gmin) gmin = gval;
            else if (gval > gmax) gmax = gval;
            if (bval < bmin) bmin = bval;
            else if (bval > bmax)  bmax = bval;
        });
        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);

    }
    
    function medianCutApply( histo, vbox ) {

        if (!vbox.count()) return;
        
        var rw = vbox.r2 - vbox.r1 + 1, gw = vbox.g2 - vbox.g1 + 1, bw = vbox.b2 - vbox.b1 + 1, maxw = pv.max([rw, gw, bw]);
        // only one pixel, no split
        if (vbox.count() == 1) {
            return [vbox.copy()]
        }
        /* Find the partial sum arrays along the selected axis. */
        var total = 0,
            partialsum = [],
            lookaheadsum = [],
            i, j, k, sum, index;
        if (maxw == rw) {
            for (i = vbox.r1; i <= vbox.r2; i++) {
                sum = 0;
                for (j = vbox.g1; j <= vbox.g2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = getColorIndex(i,j,k);
                        sum += (histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        }
        else if (maxw == gw) {
            for (i = vbox.g1; i <= vbox.g2; i++) {
                sum = 0;
                for (j = vbox.r1; j <= vbox.r2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = getColorIndex(j,i,k);
                        sum += (histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        }
        else {  /* maxw == bw */
            for (i = vbox.b1; i <= vbox.b2; i++) {
                sum = 0;
                for (j = vbox.r1; j <= vbox.r2; j++) {
                    for (k = vbox.g1; k <= vbox.g2; k++) {
                        index = getColorIndex(j,k,i);
                        sum += (histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        }
        partialsum.forEach(function(d,i) { 
            lookaheadsum[i] = total-d; 
        });

        function doCut(color) {
            var dim1 = color + '1',
                dim2 = color + '2', 
                left, right, vbox1, vbox2, d2, count2=0;
            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {
                if (partialsum[i] > total / 2) {
                    vbox1 = vbox.copy();
                    vbox2 = vbox.copy();
                    left = i - vbox[dim1];
                    right = vbox[dim2] - i;
                    if (left <= right)
                        d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));
                    else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));
                    // avoid 0-count boxes
                    while (!partialsum[d2]) d2++;
                    count2 = lookaheadsum[d2];
                    while (!count2 && partialsum[d2-1]) count2 = lookaheadsum[--d2];
                    // set dimensions
                    vbox1[dim2] = d2;
                    vbox2[dim1] = vbox1[dim2] + 1;
                    //console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());
                    return [vbox1, vbox2];
                }
            }
        
        }
        // determine the cut planes
        return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');

    }

    function quantize( pixels, maxcolors ) {

        // short-circuit
        if ( !pixels.length || maxcolors < 2 || maxcolors > 256 ) {
            console.log('wrong number of maxcolors');
            return false;
        }
        
        // XXX: check color content and convert to grayscale if insufficient
        
        var histo = getHisto(pixels);
        histo.forEach(function() { });
        //if (nColors <= maxcolors) {
            // XXX: generate the new colors from the histo and return
        //}
        
        // get the beginning vbox from the colors
        var vbox = vboxFromPixels(pixels, histo),
            pq = new PQueue(function(a,b) { return pv.naturalOrder(a.count(), b.count()) });
        pq.push(vbox);
        
        // inner function to do the iteration
        function iter( lh, target ) {
            var ncolors = 1,
                niters = 0,
                vbox;
            while (niters < maxIterations) {
                vbox = lh.pop();
                if (!vbox.count())  { /* just put it back */
                    lh.push(vbox);
                    niters++;
                    continue;
                }
                // do the cut
                var vboxes = medianCutApply(histo, vbox),
                    vbox1 = vboxes[0],
                    vbox2 = vboxes[1];
                    
                if (!vbox1) {
                    console.log("vbox1 not defined; shouldn't happen!");
                    return;
                }
                lh.push(vbox1);
                if (vbox2) {  /* vbox2 can be null */
                    lh.push(vbox2);
                    ncolors++;
                }
                if (ncolors >= target) return;
                if (niters++ > maxIterations) {
                    console.log("infinite loop; perhaps too few pixels!");
                    return;
                }
            }
        }
        
        // first set of colors, sorted by population
        iter( pq, fractByPopulations * maxcolors );
        // console.log(pq.size(), pq.debug().length, pq.debug().slice());
        
        // Re-sort by the product of pixel occupancy times the size in color space.
        var pq2 = new PQueue(function(a,b) { 
            return pv.naturalOrder(a.count()*a.volume(), b.count()*b.volume()) 
        });

        while ( pq.size() ) { pq2.push(pq.pop()); }
        
        // next set - generate the median cuts using the (npix * vol) sorting.
        iter( pq2, maxcolors - pq2.size() );
        
        // calculate the actual colors
        var cmap = new CMap();
        while (pq2.size()) { cmap.push(pq2.pop()); }
        
        return cmap;

    }
    
/*    return { 
        quantize: quantize
    }

})();*/



var URL$1 = (window.URL || window.webkitURL);

var canvas = null, context, w, h;

var colors = [];
var maxCount = 0;
var highestColor = '';
var ambientColor = '';
var luminousColor = '';
var darkerColor = '';

var range = {

    lumTargetDark: 0.26,
    lumMaxDark: 0.45,

    lumMinLight : 0.55,
    lumTargetLight : 0.74,

    lumMinNormal : 0.3,
    lumTargetNormal : 0.5,
    lumMaxNormal : 0.7,

    satTargetMuted : 0.3,
    satMaxMuted : 0.4,

    satTargetVibrant : 1.0,
    satMinVibrant : 0.35,

    satWeight : 3,
    lumWeight : 6.5,
    nWeight : 0.5,

};

var vibrants = {};



var adaptiveRange = {};

var slice = [].slice;


const ImgTool = {

    format:'html',
    //format:'hex',

    makeCanvasFromImage: function ( image ) {

        if( canvas === null ) canvas = document.createElement('canvas');
        context = canvas.getContext('2d',{ willReadFrequently: true });
        w = canvas.width  = image.width;
        h = canvas.height = image.height;
        context.drawImage( image, 0, 0, w, h );

    },

    makeCanvasFromData: function ( data ) {

        if( canvas === null ) canvas = document.createElement('canvas');
        context = canvas.getContext('2d',{ willReadFrequently: true });
        w = canvas.width  = data.w;
        h = canvas.height = data.h;
        let dt = context.createImageData( w, h );
        let k = dt.data.length;
        while(k--) dt.data[k] = data.data[k];
        context.putImageData( dt, 0, 0 );

    },

    clear: function() {

        context.clearRect(0, 0, w, h);

    },

    getImageData: function() {

        return context.getImageData(0, 0, w, h);

    },
    
    getPalette: function( sourceImage, colorCount, Quality ) {

        //this.makeCanvasFromImage( sourceImage );
        this.makeCanvasFromData( sourceImage );

        colorCount = colorCount || 64; // between 2 and 256
        var quality = Math.round( w / 256 ); // pixel space less = more quality & calculation

        if( Quality !== undefined ) quality = Quality;


        // Create custom CanvasImage object
        
        var imageData  = this.getImageData();
        var pixelCount = w * h;

        var pixelArray = this.createPixelArray( imageData.data, pixelCount, quality );

        // Send array to quantize function which clusters values
        // using median cut algorithm
        var cmap = quantize( pixelArray, colorCount );

        // color palette of full color
        //var palette = cmap ? cmap.palette() : null;

        colors = cmap.colors();

        //console.log(colors)

        this.getRange();

        var r = adaptiveRange ;

        vibrants = {
            
            vibrant : this.findColorVariation( r.lumTargetNormal, r.lumMinNormal, r.lumMaxNormal, r.satTargetVibrant, r.satMinVibrant, 1),
            lightVibrant: this.findColorVariation(r.lumTargetLight, r.lumMinLight, 1, r.satTargetVibrant, r.satMinVibrant, 1),
            darkVibrant : this.findColorVariation(r.lumTargetDark, 0, r.lumMaxDark, r.satTargetVibrant, r.satMinVibrant, 1),
            muted : this.findColorVariation( r.lumTargetNormal, r.lumMinNormal, r.lumMaxNormal, r.satTargetMuted, 0, r.satMaxMuted),
            lightMuted : this.findColorVariation(r.lumTargetLight, r.lumMinLight, 1, r.satTargetMuted, 0, r.satMaxMuted),
            darkMuted : this.findColorVariation(r.lumTargetDark, 0, r.lumMaxDark, r.satTargetMuted, 0, r.satMaxMuted, true),
            highest : highestColor,
            ambient : ambientColor,
            maxLuma: luminousColor,
            minLuma: darkerColor,
        };



        this.clear();

        //if( this.format === 'hex' ) ImgTool.getHex();

        return vibrants;

    },

    getHex: function () {

        let vibrantsHex = {};

        for( var c in vibrants ){
            
            if( vibrants[c]!==undefined ) vibrantsHex[c] = Tools.htmlToHex( vibrants[c] );
        }

        return vibrantsHex

    },

    getRange: function () {

        var count = 0;
        var minLuma = 1;
        var maxLuma = 0;

        var minSat = 1;
        var maxSat = 0;
        var i = colors.length;

        var g = [0,0,0];
        var gn = 0;
        var n = 0;
        
        while( i-- ){ 

            n = colors[i].count;

            count = Math.max( count, n );

            minLuma = Math.min( minLuma, colors[i].hsl[2] );
            maxLuma = Math.max( maxLuma, colors[i].hsl[2] );

            minSat = Math.min( minSat, colors[i].hsl[1] );
            maxSat = Math.max( maxSat, colors[i].hsl[1] );

            g[0] += colors[i].rgb[0] * n;
            g[1] += colors[i].rgb[1] * n;
            g[2] += colors[i].rgb[2] * n;
            gn += n;

        }

        g[0] /= gn;
        g[1] /= gn;
        g[2] /= gn;

        ambientColor = Tools.getHtml( g );

       
        var lumaRange = (maxLuma - minLuma);
        var satRange = (maxSat - minSat);

        var min = 0;

        {


            // luminosity
            //min = minLuma;
            adaptiveRange.lumTargetDark = min + range.lumTargetDark * lumaRange;
            adaptiveRange.lumMaxDark = min + range.lumMaxDark * lumaRange;
            adaptiveRange.lumMinLight = min + range.lumMinLight * lumaRange;
            adaptiveRange.lumTargetLight = min + range.lumTargetLight * lumaRange;
            adaptiveRange.lumMinNormal = min + range.lumMinNormal * lumaRange;
            adaptiveRange.lumTargetNormal = min + range.lumTargetNormal * lumaRange;
            adaptiveRange.lumMaxNormal = min + range.lumMaxNormal * lumaRange;

            adaptiveRange.lumWeight = min + range.lumWeight * lumaRange;

            

            // saturation
            //min = minSat;
            adaptiveRange.satTargetMuted = min + range.satTargetMuted * satRange;
            adaptiveRange.satMaxMuted = min + range.satMaxMuted * satRange;
            //adaptiveRange.satTargetVibrant = min + range.satTargetVibrant * satRange;
            //adaptiveRange.satMinVibrant = min + range.satMinVibrant * satRange;

            adaptiveRange.satTargetVibrant = maxSat;
            adaptiveRange.satMinVibrant = minSat;

            adaptiveRange.satWeight = min + range.satWeight * satRange;

        }

        

        //console.log( lumaRange, satRange, colors.length )

        maxCount = count;

        var i = colors.length;
        while( i-- ){
            if( colors[i].count === maxCount ) highestColor = colors[i].hex;
            if( colors[i].hsl[2] === maxLuma ) luminousColor = colors[i].hex;
            if( colors[i].hsl[2] === minLuma ) darkerColor = colors[i].hex;
        }

    },

    findColorVariation: function( targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation, tt ) {

        let j, len, luma, maxValue, sat, c, value;
        let color = null;
       
        maxValue = 0;
        for (j = 0, len = colors.length; j < len; j++) {
            c = colors[j];
            sat = c.hsl[1];
            luma = c.hsl[2];

            //if( tt ) console.log( sat <= maxSaturation , luma <= maxLuma )

            //if( tt ) console.log(sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !c.select)
            
            if ( sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !c.select ) {
                value = this.createComparisonValue( sat, targetSaturation, luma, targetLuma, c.count );

                if ( color === null || value > maxValue ) {

                   color = c;
                   maxValue = value;
                }
            }
        }

        if( color !== null ){ 
            color.select = true;
            return color.hex;
        } else {
            
            return '#000'
        }
        
    },

    createComparisonValue: function( saturation, targetSaturation, luma, targetLuma, count ) {
        return this.weightedMean( this.invertDiff( saturation, targetSaturation ), adaptiveRange.satWeight, this.invertDiff( luma, targetLuma ), adaptiveRange.lumWeight, count / maxCount, range.nWeight );
    },

    invertDiff: function( value, targetValue ) {

        return 1 - Math.abs( value - targetValue );

    },

    weightedMean: function() {

        var i, sum, sumWeight, value, values, weight;
        values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        sum = 0;
        sumWeight = 0;
        i = 0;
        while ( i < values.length ) {
            value = values[i];
            weight = values[i + 1];
            sum += value * weight;
            sumWeight += weight;
            i += 2;
        }
        return sum / sumWeight;

    },


    createPixelArray : function ( imgData, pixelCount, quality ) {

        var pixels = imgData;
        var pixelArray = [];

        for ( var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality ) {

            offset = i * 4;
            r = pixels[offset + 0];
            g = pixels[offset + 1];
            b = pixels[offset + 2];
            a = pixels[offset + 3];

            // If pixel is mostly opaque and not white
            if (typeof a === 'undefined' || a >= 125) {
                if (!(r > 250 && g > 250 && b > 250)) {
                    pixelArray.push([r, g, b]);
                }
            }
        }

        return pixelArray;

    },


    getColorFromUrl: function( url, callback ) {

        var _this = this;

        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'blob';
        xhr.onload = function() {
            if ( xhr.readyState === 2 ) ; else if ( xhr.readyState === 3 ) ; else if ( xhr.readyState === 4 ) {
                if ( xhr.status === 200 || xhr.status === 0 ) {
                    
                    var img = new Image();

                    img.onload = function(e) {
                        URL$1.revokeObjectURL( img.src );
                        callback( _this.getPalette( img ), img );
                    };

                    img.src = URL$1.createObjectURL( xhr.response );

                }
                else console.error( "Couldn't load [image] [" + xhr.status + "]" );
            }
        };

        xhr.send();

    },

};





// color conversion

const Tools = {

    getHtml: function(rgb) {

        return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1, 7);

    },

    getHsl: function( rgb ) {

        var d, h, l, max, min, s;
        var r = rgb[0]/255;
        var g = rgb[1]/255;
        var b = rgb[2]/255;
        max = Math.max(r, g, b);
        min = Math.min(r, g, b);
        h = 0;
        s = 0;
        l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return [h, s, l];

    },

    htmlToHex: function ( v ) { 
        return  v.toUpperCase().replace( "#", "0x" );
    },

    hexToHtml: function ( v ) {
        v = v === undefined ? 0x000000 : v;
        return "#" + ("000000" + v.toString(16)).substr(-6);
    },

};



    
// 3d color space box

class VBox {

    constructor ( r1, r2, g1, g2, b1, b2, histo ) {

        var vbox = this;
        vbox.r1 = r1;
        vbox.r2 = r2;
        vbox.g1 = g1;
        vbox.g2 = g2;
        vbox.b1 = b1;
        vbox.b2 = b2;
        vbox.histo = histo;

    }

    volume ( force ) {

        var vbox = this;
        if (!vbox._volume || force) {
            vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));
        }
        return vbox._volume;

    }

    count ( force ) {

        var vbox = this, histo = vbox.histo;

        if (!vbox._count_set || force) {
            var npix = 0, i, j, k, index;
            for (i = vbox.r1; i <= vbox.r2; i++) {
                for (j = vbox.g1; j <= vbox.g2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = getColorIndex(i,j,k);
                        npix += (histo[index] || 0);
                    }
                }
            }
            vbox._count = npix;
            vbox._count_set = true;
        }
        return vbox._count;

    }

    copy () {

        var vbox = this;
        return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);

    }

    avg ( force ) {
        var vbox = this,
            histo = vbox.histo;
        if (!vbox._avg || force) {
            var ntot = 0, mult = 1 << (8 - sigbits), rsum = 0, gsum = 0, bsum = 0, hval, i, j, k, histoindex;
            for (i = vbox.r1; i <= vbox.r2; i++) {
                for (j = vbox.g1; j <= vbox.g2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        histoindex = getColorIndex(i,j,k);
                        hval = histo[histoindex] || 0;
                        ntot += hval;
                        rsum += (hval * (i + 0.5) * mult);
                        gsum += (hval * (j + 0.5) * mult);
                        bsum += (hval * (k + 0.5) * mult);
                    }
                }
            }
            if (ntot) {
                vbox._avg = [~~(rsum/ntot), ~~(gsum/ntot), ~~(bsum/ntot)];
            } else {
                //console.log('empty box');
                vbox._avg = [
                    ~~(mult * (vbox.r1 + vbox.r2 + 1) / 2),
                    ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2),
                    ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)
                ];
            }
        }
        return vbox._avg;
    }

    contains ( pixel ) {

        var vbox = this, rval = pixel[0] >> rshift; 
        var gval = pixel[1] >> rshift;
        var bval = pixel[2] >> rshift;
        return (rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && rval <= vbox.g2 && bval >= vbox.b1 && rval <= vbox.b2);

    }

}
    
    
 // Color map

class CMap {

    constructor() {

        this.vboxes = new PQueue(function(a,b) { 
            return pv.naturalOrder(
                a.vbox.count()*a.vbox.volume(), 
                b.vbox.count()*b.vbox.volume()
            )
        });

    }

    push ( vbox ) {
        this.vboxes.push({ vbox: vbox, color: vbox.avg() });
    }

    palette () {
        return this.vboxes.map( function(vb) { return vb.color } );
    }

    colors () {

        var c = [];

        this.vboxes.map( function(vb) {
            
            var count = vb.vbox.count() || 0;
            var color = vb.color;
            if( count ) c.push({ rgb:color, hsl:Tools.getHsl( color ), hex:Tools.getHtml( color ), count:count, select:false });

        });

        return c;

    }

    size () {
        return this.vboxes.size();
    }

    map (color) {
        var vboxes = this.vboxes;
        for (var i=0; i<vboxes.size(); i++) {
            if (vboxes.peek(i).vbox.contains(color)) {
                return vboxes.peek(i).color;
            }
        }
        return this.nearest(color);
    }

    nearest (color) {
        var vboxes = this.vboxes,
            d1, d2, pColor;
        for (var i=0; i<vboxes.size(); i++) {
            d2 = Math.sqrt(
                Math.pow(color[0] - vboxes.peek(i).color[0], 2) +
                Math.pow(color[1] - vboxes.peek(i).color[1], 2) +
                Math.pow(color[1] - vboxes.peek(i).color[1], 2)
            );
            if (d2 < d1 || d1 === undefined) {
                d1 = d2;
                pColor = vboxes.peek(i).color;
            }
        }
        return pColor;
    }

    forcebw () {
        // XXX: won't  work yet
        var vboxes = this.vboxes;
        vboxes.sort(function(a,b) { return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color) )});
        
        // force darkest color to black if everything < 5
        var lowest = vboxes[0].color;
        if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)
            vboxes[0].color = [0,0,0];
        
        // force lightest color to white if everything > 251
        var idx = vboxes.length-1,
            highest = vboxes[idx].color;
        if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)
            vboxes[idx].color = [255,255,255];
    }

}

class DirectionalHelper extends DirectionalLightHelper {

	constructor( light, size, color ) {

		size = size || 1;

		super( light, size, color );

		let g = new PlaneGeometry( size*2, size*2 );
		let m = new MeshBasicMaterial( { color: this.light.color, fog: false, toneMapped: false } );

		this.m2 = new Mesh( g, m );

		this.shadow = new CameraHelper( light.shadow.camera );
		this.shadow.setColors( light.color, new Color( 0x222222 ), new Color( 0x222222 ), light.color, new Color( 0x666666) );

		this.children[ 0 ].add( this.m2 );

	}

	dispose() {
		super.dispose();
		if(this.m2){
			this.m2.geometry.dispose();
			this.m2.material.dispose();
		}
	}

	update() {

		super.update();
		if(this.m2) this.m2.material.color.copy( this.light.color );

	}

}

let light = [];
let LL = {};
let helper = [];
let debug = false;


class Lights {

	//get debug() { return debug; }
    //set debug( value ) { Lights.debug(value) }

    static update ( o = {} ) {

    	let move = false;

    	if(o.sunIntensity){
    		if( LL.sun ) LL.sun.intensity = o.sunIntensity*0.3;
    		if( LL.sun2 ) LL.sun2.intensity = o.sunIntensity*0.7;
    	}

    	if(o.hemiIntensity){
    		if( LL.hemi ) LL.hemi.intensity = o.hemiIntensity*0.7;
    	}

    	if(o.sunPos){
    		if( LL.sun ){ 
    			LL.sun.position.fromArray( o.sunPos ).multiplyScalar( LL.sun.distance );
    			LL.sun.target.position.set( 0, 0, 0 );
    			move = true;
    			//LL.sun.updateMatrixWorld();
    		}
    		if( LL.sun2 ){ 
    			LL.sun2.position.fromArray( o.sunPos ).multiplyScalar( LL.sun2.distance );
    			LL.sun2.target.position.set( 0, 0, 0 );
    			move = true;
    			//LL.sun2.updateMatrixWorld();
    		}
    	}

    	if(o.sunColor){
    		if( LL.sun ) Lights.setColor(LL.sun.color, o.sunColor );
    		if( LL.sun2 ) Lights.setColor(LL.sun2.color, o.sunColor );
    		move = true;
    	}

    	if( LL.hemi ){
    		if(o.skyColor) Lights.setColor(LL.hemi.color, o.skyColor );
    		if(o.groundColor) Lights.setColor(LL.hemi.groundColor, o.groundColor );
    		move = true;
    	}

    	if( move ) Lights.updateHelper();
    
    }

    static setColor ( c, v ) {
    	if( v.isColor ) c.copy( v );
    	else c.setHex( v );
    }

    static adds ( ar ) {

    	let i = ar.length, n = 0;
    	while(i--){
    		Lights.add( ar[n] );
    		n++;
    	}
    }

	static add ( o = {} ) {

		if ( o.constructor === Array ) return Lights.adds( o );

		let l = null;

		if(!o.color) o.color = 0xFFFFFF;

		switch(o.type){
			case 'direct':
			l = new DirectionalLight( o.color, o.intensity );
			l.distance = o.distance !== undefined ? o.distance : 2.0;
			break;
			case 'spot':
			l = new SpotLight( o.color, o.intensity, o.distance, o.angle, o.penumbra, o.decay );
			break;
			case 'point':
			l = new PointLight( o.color, o.intensity, o.distance, o.decay );
			break;
			case 'ambient':
			l = new AmbientLight( o.color, o.intensity );
			break;
			case 'rec':
			l = new RectAreaLight( o.color, o.intensity, o.width = 10, o.height );
			break;
			case 'hemi':
			l = new HemisphereLight( o.skyColor || 0x000000, o.groundColor || 0x000000, o.intensity );
			break;
		}

		if(!l) return

		l.name = o.name || 'light' + light.length;

		if( o.pos ) l.position.fromArray( o.pos );

		if( o.parent ){
			if( l.target ) o.parent.add( l.target );
			o.parent.add( l );
		}

		if( l.shadow && o.shadow ){

			const s = l.shadow;
			const v = o.shadow;
			s.mapSize.width = s.mapSize.height = v.quality;
			const cam = s.camera;

			if( cam.isOrthographicCamera ){
				if(v.range){
					cam.top = cam.right = v.range;
					cam.bottom = cam.left = -v.range;
				}
				if(v.near) cam.near = v.near;
				if(v.far) cam.far = v.far;
			}
			if(v.bias) s.bias = v.bias;
			if(v.radius) s.radius = v.radius;
			if(v.blurSamples) s.blurSamples = v.blurSamples; // only for VSM 

			l.castShadow = true;

		}

	    light.push(l);
	    LL[l.name] = l;

	    return l

	}

	static byName ( name ) {
		return LL[name]
	}

	static dispose () {

		Lights.disposeHelper();

		let i = light.length, l;
		while(i--){
			l = light[i];
			if( l.parent ) l.parent.remove(l);
			if( l.target && l.target.parent ) l.target.parent.remove(l.target);
			l.dispose();
		}

		light = [];
		LL = {};

	}

	static castShadow ( v ) {

		let i = light.length, l;
		while(i--){
			l = light[i];
			if( l.shadow !== undefined ){ 
				l.castShadow = v;
				if(!v) l.shadow.dispose();
			}
		}

	}


	//--------------------
	//   HELPER
	//--------------------

	static addHelper ( b, pp ) {

		if( b && !debug ){

			let i = light.length, l, h;
			while(i--){
				l = light[i];
				switch(l.type){
					case 'DirectionalLight':
					h = new DirectionalHelper( l );
					break;
					case 'PointLight':
					h = new PointLightHelper( l, 0.25, l.color );
					break;
					case 'SpotLight':
					h = new SpotLightHelper( l, l.color );
					break;
					case 'HemisphereLight':
					h = new HemisphereLightHelper( l, 0.25 );
					h.material.wireframe = false;
					break;
				}

				if(h){ 
					helper.push(h);
					pp.add( h );
					if( h.shadow ){ 
						helper.push( h.shadow );
						pp.add( h.shadow );
						//h.shadow.update()
					}
				}
			}

			debug = true;

		}

		if( !b ){
			Lights.disposeHelper();
		}

		return debug;

	}

	static updateHelper () {

		if( !debug ) return;

		let i = helper.length;
		while(i--){
			helper[i].update();
		}

	}

	static disposeHelper () {

		if( !debug ) return;

		let i = helper.length, h;
		while(i--){
			h = helper[i];
			h.parent.remove(h);
			h.dispose();
		}
		helper = [];
		debug = false;

	}

}

//import { HDRTool } from './utils/HDRTool.js';

const autoSize = 0.25;

let gamma = 2.2;
let envName = '';

let usePmrem = true;
let isWebGPU$1 = false;
let autosun = true;

let sunColor = new Color();
let fogColor = new Color();
let skyColor = new Color();
let groundColor$1 = new Color();

let previewCanvas = null;
let previewPalette = null;
let isPreviewDisplay = false;
let isPaletteDisplay = false;
let previewData = null;

let pm = null;
let env = null;
let hdr = null;
let pmrem = null;
let floor = null;
let data = {};
let palette = {};
let color =  new Color();
let scene$1 = null, renderer$1 = null;

const s1 = new Spherical();
new Spherical();

const tmpV = new Vector3();

new Color();
new Color();
new Color();

let tt = 0;

new Vector2();
const hdrLoader = new RGBELoader();
const exrLoader = new EXRLoader();

let main = null;



// https://discourse.threejs.org/t/how-to-dispose-scene-background-with-webglrendertarget/19935

let plane, sceneR, cameraR, targetR = null, read = null, read16 = null;

class Env {

	static setMain (m) { main = m; }

	static get () { return env }
	static getData () { return data }

	static dispose () {

	    if( scene$1.background && scene$1.background.dispose ){ scene$1.background.dispose(); }
	    if( scene$1.environment && scene$1.environment.dispose ){ scene$1.environment.dispose(); }

	    scene$1.background = null;
		scene$1.environment = null;
	    
	    this.clearTargetRender();

		if( env ) env.dispose();
		if( hdr ) hdr.dispose();
		if( pm ) pm.dispose();
		//

	//console.log(renderer)
		
		env = null;
		hdr = null;

		//renderer.dispose()

	}

    static set ( value, callback = ()=>{} ) {

    	Env.dispose();

    	if( typeof value  === 'string' ){
    		if( value !== 'null' ){ 
    			if( value.search('/') !== -1 ) this.load( value, callback );
    			else {
    				envName = value;
    				this.load( './assets/textures/equirectangular/'+value+'.hdr', callback );
    			}
    		} else {
    			scene$1.environment = null;
    			scene$1.background = null;
    			callback();
    		}
		} else if (!isNaN(value)){
			this.setBackgroud( value );
			callback();
		}

    }

    static setFloorRadius ( v ) {
    	if(!floor) return
    	floor.radius = v;
    }

    static setFloorHeight ( v ) {
    	if(!floor) return
    	floor.height = v;
    }

    static setBlur ( v ) {
    	if(!scene$1) return
    	scene$1.backgroundBlurriness = v;
    }

    static addFloor ( v, s=2 ) {

    	console.log('addFloor', v);

    	if( v ){
    		floor = new GroundProjectedEnv( env );
			floor.scale.setScalar( 100 );
			floor.radius = 100;
			floor.height = 10;
			scene$1.add( floor );
    	} else {
    		if(floor){
    			scene$1.remove( floor );
    		}
    	}

		

		//floor.radius = params.radius;
		//floor.height = params.height;

	}

    static setBackgroud ( c ) {

		//if( c !== undefined ) renderer.setClearColor ( color.setHex(c) ) //
		if( c !== undefined ) scene$1.background = color.setHex(c);
		else scene$1.background = env;

	}

    static init ( Renderer, Scene, Autosun = true ) {

    	if( Renderer ){ 
    		renderer$1 = Renderer;
    		isWebGPU$1 = renderer$1.isWebGPURenderer || false;
    		usePmrem = isWebGPU$1 ? false : usePmrem;
    	}
		if( Scene ) scene$1 = Scene;
		autosun = Autosun !== undefined ? Autosun : true;
	    if( isWebGPU$1 ) autosun = false;

	    //if( useHdrTool ) hdrTool = new HDRTool()

	    if( usePmrem ){
			pmrem = new PMREMGenerator( renderer$1 );
			pmrem.compileEquirectangularShader();
		}

	    //this.initTargetRender()

    }

	static async load ( url, callback, type = 'hdr' ) {

		data = {
			pos: new Vector3(0,1,0),
			sun: new Color(0xffffff),
			fog: new Color(0x000000),
			envmap:null,
		};

		if( type === 'hdr' ) hdr = await hdrLoader.loadAsync( url );
		else if( type === 'exr' ) hdr = await exrLoader.loadAsync( url );

		//console.log(hdr)

		gamma = 2.2;
		if(envName==='basic') gamma = 2.68;
		if(envName==='alien') gamma = 1.88;

		//console.log(hdr)

		Env.process();
		
		if( callback ) callback();

	}

    static process () {

		if( usePmrem ){ 
			pm = pmrem.fromEquirectangular( hdr );
			env = pm.texture;
			pmrem.dispose();
		} else {
			env = hdr;
		    env.mapping = EquirectangularReflectionMapping;
		}
	
		if( scene$1 ) {
			scene$1.environment = env;
			if( floor ) floor.map = env;
			else {
				scene$1.background = env;

			}
			
		}

		// autosun
		tt = 0;
		if(autosun) Env.up();

	}

	/*static processOLD () {

		if( usePmrem ){ 
			pm = pmrem.fromEquirectangular( hdr )
			env = pm.texture;
			pmrem.dispose()
		} else {
			if( isWebGPU ) {
				env = texture( hdr, equirectUV(), 0 );
			} else {
				env = hdr;
			    env.mapping = EquirectangularReflectionMapping;
			}
		}
	
		if( scene ) {
			if( !isWebGPU ) scene.environment = env;
			if( floor ) floor.map = env;
			else { 
				if( isWebGPU ) scene.backgroundNode = env;
				else scene.background = env;
				
			}
			//if( scene.ground ) scene.ground.setColor( data.fog.getHex(), true )
		}

		// autosun
		tt = 0
		if(autosun) Env.up()

	}*/

	

	static initTargetRender (w,h) {

		if( targetR !== null ) return

		plane = new Mesh( new PlaneGeometry( 4, 2 ), new MeshBasicMaterial({ toneMapped: true }) );
		plane.scale.y = -1;
		sceneR = new Scene();
		sceneR.add( plane );
		cameraR = new OrthographicCamera( - 2, 2, 1, - 1, 0, 1 );
		//targetR = new WebGLRenderTarget( 1, 1, { /*format: RGBAFormat,*/ type:FloatType } )
		targetR = new WebGLRenderTarget( 1, 1, { format: RGBAFormat, type:HalfFloatType  } );
		targetR.setSize( w, h );
		//read = new Float32Array( w * h * 4 )
	    read = new Float32Array( w * h * 4 );
		read16 = new Uint16Array( w * h * 4 );

	}

	static clearTargetRender () {

		if( targetR === null ) return

		if(targetR.texture) targetR.texture.dispose();

		targetR.dispose();
		sceneR.remove( plane );
		plane.material.map.dispose();
		plane.geometry.dispose();
		plane.material.dispose();

		plane = null;
		sceneR = null;
		cameraR = null;
		targetR = null;
		read = null;
		read16 = null;

	}

	static renderTarget ( texture ) {

		

		//renderer.getSize( tmpSize )
		//let old = renderer.toneMappingExposure
		//let toneMapping = renderer.toneMapping
		//const originalAutoClear = renderer.autoClear
		//texture.encoding = sRGBEncoding
		//console.log(texture, HalfFloatType)

		
		

		let w = texture.image.width * autoSize;
		let h = texture.image.height * autoSize;

		//renderer.autoClear = false;

		this.initTargetRender(w,h);

		plane.material.map = texture;
		plane.material.needsUpdate = true;
		
		//renderer.setSize( w, h )
		renderer$1.setRenderTarget( targetR );
		//renderer.outputEncoding = LinearEncoding
		//renderer.toneMapping = NoToneMapping;
		//renderer.toneMappingExposure = old*2.2//1.25 // why ?
		//renderer.toneMapping = THREE.LinearToneMapping//THREE.ACESFilmicToneMapping
		//renderer.clear()

		renderer$1.render( sceneR, cameraR );

		renderer$1.setRenderTarget( null );
		//renderer.setSize( tmpSize.x, tmpSize.y )
		//renderer.toneMappingExposure = old
		//renderer.toneMapping = toneMapping
		//renderer.autoClear = originalAutoClear
		//renderer.outputEncoding = sRGBEncoding

		//let read = new Float32Array( w * h * 4 )
		renderer$1.readRenderTargetPixels( targetR, 0, 0, w, h, read16  );
		{
			//read8 = read.map( x => x  )
			let i = read.length/4, n;
			
			while(i--) {
				n = i * 4;

				read[n] = this.float16ToNumber(read16[n]) * 255;
				read[n+1] = this.float16ToNumber(read16[n+1]) * 255;
				read[n+2] = this.float16ToNumber(read16[n+2]) * 255;
				read[n+3] = this.float16ToNumber(read16[n+3]) * 255;
			}
		//	while(i--) read8[i] = (read[i])
		}
		

		//this.clearTargetRender()

		return read

	}

	static up () {
		if(tt=== 0){
			Env.autoSun();
			Env.upLight();
		}
		tt++;
		if(tt<6) tt = 0;
		tt = 0;
		
	}

	static getCanvas () {

		const ref = previewData;

		if( previewCanvas === null ) previewCanvas = document.createElement("canvas");
		previewCanvas.style.cssText = 'position:absolute; left:10px; bottom:20px; width:'+ref.w+'px; height:'+ref.h+'px; border:1px solid #222;';
        previewCanvas.width = ref.w;
        previewCanvas.height = ref.h;
        let ctx = previewCanvas.getContext("2d");
		let dt = ctx.createImageData( ref.w, ref.h );
		let k = dt.data.length;
		while(k--) dt.data[k] = ref.data[k];
		ctx.putImageData( dt, 0, 0 );
		/*ctx.lineWidth = 2;
		ctx.strokeStyle = 'red';
		ctx.beginPath();
		ctx.arc(ref.x, ref.y, 20*autoSize, 0, 2 * Math.PI);
		ctx.stroke()*/
		
	}

	static getPalette () {

		return palette;//ImgTool.getPalette( previewData )
		
	}

	static preview ( b ) {

		Env.palettePreview( b );

		const ref = previewData;
		if( ref === null ) return
		if(b){
			if( previewCanvas === null ) previewCanvas = document.createElement("canvas");
			previewCanvas.style.cssText = 'position:absolute; left:10px; bottom:10px; width:'+ref.w+'px; height:'+ref.h+'px; border:1px solid #222;';
	        previewCanvas.width = ref.w;
	        previewCanvas.height = ref.h;
	        let ctx = previewCanvas.getContext("2d");
			let dt = ctx.createImageData( ref.w, ref.h );

			//dt.data = [...ref.data]
			let k = dt.data.length;
			while(k--) dt.data[k] = ref.data[k];
			ctx.putImageData( dt, 0, 0 );
			ctx.lineWidth = 2;
			ctx.strokeStyle = 'red';
			ctx.beginPath();
			ctx.arc(ref.x, ref.y, 20*autoSize, 0, 2 * Math.PI);
			ctx.stroke();

			if( !isPreviewDisplay ) {
				document.body.appendChild( previewCanvas );
				isPreviewDisplay = true;
			}
			
		} else {
			if( isPreviewDisplay ){
				document.body.removeChild( previewCanvas );
				isPreviewDisplay = false;
			}
		}
	}

	static palettePreview ( b ) {
		
		let size = 25.6;
		let n = 0, y = 0, x = 0, d = 5;
		//let num = 10 + 4 
		let w = (size * 3) + d;
		let h = size * 5;
		

		if(b){
			if( previewPalette === null ) previewPalette = document.createElement("canvas");			previewPalette.style.cssText = 'position:absolute; left:271px; bottom:10px; width:'+w+'px; height:'+h+'px; border:1px solid #222;';
			previewPalette.width = w;
	        previewPalette.height = h;
	        const ctx = previewPalette.getContext("2d");

	        ctx.fillStyle = '#000';
			ctx.fillRect(0, 0, w, h);

			for(let m in palette){
				
				if(palette[m]!==undefined){

					x = Math.floor( n / 5 );
					y = (n - (x*5)); 
					
					ctx.fillStyle = palette[m];
					ctx.fillRect(x*size+(x>0? d : 0), y* size, size, size);
					
				}
				
				n++;

			}

			if( !isPaletteDisplay ) {
				document.body.appendChild( previewPalette );
				isPaletteDisplay = true;
			}

		} else {

			if( isPaletteDisplay ){
				document.body.removeChild( previewPalette );
				isPaletteDisplay = false;
			}

		}

	}

	static autoSun () {

		const d = this.renderTarget( hdr );
		const image = hdr.image;
		const w = image.width * autoSize;
		const h = image.height * autoSize;
		const lng = d.length/4;
        const dt = [];
		const color = new Uint8ClampedArray( 4 );

		const gammaCorrection = 1 / gamma;

		//const tmpColor = new Color()

		let maxId;
		let i = lng, n, r, g, b, t, x, y, rs = 1/255, fr=0, fg=0, fb=0;
		let br=0, bg=0, bb=0;
		let cr=0, cg=0, cb=0;
		let max = 0;

		while( i-- ){

			n = i*4;

			x = i % w;
			y = Math.floor((i-x)/w);

			/*tmpColor.setRGB( d[n+0], d[n+1], d[n+2]).convertLinearToSRGB()

			r = tmpColor.r
			g = tmpColor.g
			b = tmpColor.b*/

			r = 255 * Math.pow((d[n+0] / 255), gammaCorrection);
			g = 255 * Math.pow((d[n+1] / 255), gammaCorrection);
			b = 255 * Math.pow((d[n+2] / 255), gammaCorrection);

			t = ( r + g + b );

			if( y === h * 0.5 ){

				fr += r;
				fg += g;
				fb += b;
				
			}

			if( y === h * 0.25 ){

				cr += r;
				cg += g;
				cb += b;
				
			}

			if( y === h * 0.75 ){

				br += r;
				bg += g;
				bb += b;
				
			}

			if( t > max ){ 
				
				color[0] = r;
				color[1] = g;
				color[2] = b;
				color[3] = 255;

				maxId = i;
				max = t;

			}

			dt[n] = r;
			dt[n+1] = g;
			dt[n+2] = b;
			dt[n+3] = 255;

		}

		x = maxId % w;
		y = Math.floor((maxId-x)/w);


		sunColor.setRGB( color[0] * rs, color[1] * rs, color[1] * rs, SRGBColorSpace );//.convertSRGBToLinear()
		fogColor.setRGB( (fr/w)*rs, (fg/w)*rs, (fb/w)*rs, SRGBColorSpace );
		skyColor.setRGB( (cr/w)*rs, (cg/w)*rs, (cb/w)*rs, SRGBColorSpace );//.convertSRGBToLinear()
		groundColor$1.setRGB( (br/w)*rs, (bg/w)*rs, (bb/w)*rs, SRGBColorSpace );//.convertSRGBToLinear()

		//let sunColor = new Color( color[0] * rs, color[1] * rs, color[1] * rs);
		//let fogColor = new Color( (fr/w)*rs, (fg/w)*rs, (fb/w)*rs )
		//let skyColor = new Color( (cr/w)*rs, (cg/w)*rs, (cb/w)*rs )
		//let groundColor = new Color( (br/w)*rs, (bg/w)*rs, (bb/w)*rs )

		// sun position spherical
		s1.set( 1,  (y / h)*Math.PI, -(x / w)*(Math.PI * 2)-(Math.PI*0.5) );

		data['sun'] = sunColor;
		data['fog'] = fogColor;
		data['sky'] = skyColor;
		data['ground'] = groundColor$1;

		previewData = { data:dt, x:x, y:y, w:w, h:h };

		palette = ImgTool.getPalette( previewData );//Env.getPalette()

		let extra = {

			sun: '#' + sunColor.getHexString(),
			m: undefined,
			fog: '#' + fogColor.getHexString(),
			
			sky: '#' + skyColor.getHexString(),
			ground: '#' + groundColor$1.getHexString()

		};

		palette = {...extra, ...palette };


		if( main ) main.setColors( palette );
		

		/*palette['sun'] = '#' + sunColor.getHexString()
		palette['fog'] = '#' + fogColor.getHexString()
		palette['m'] = undefined
		palette['sky'] = '#' + skyColor.getHexString()
		palette['ground'] = '#' + groundColor.getHexString()*/

		//console.log(palette)

		//Env.palettePreview( true )

		Env.preview( isPreviewDisplay );

	}

	static getFogColor () {
		return fogColor
	}

	static upLight () {

		//if( !light ) return

		if( scene$1.fog ) scene$1.fog.color.copy( data.fog );
			
		const dt = {
			sunPos: tmpV.setFromSpherical(s1).toArray(),
			sunColor: data.sun,
			skyColor: data.sky,
			groundColor: data.ground, 
		};

		Lights.update( dt );
	
	}

	static float16ToNumber (input) {
	    // Create a 32 bit DataView to store the input
	    const arr = new ArrayBuffer(4);
	    const dv = new DataView(arr);

	    // Set the Float16 into the last 16 bits of the dataview
	    // So our dataView is [00xx]
	    dv.setUint16(2, input, false);

	    // Get all 32 bits as a 32 bit integer
	    // (JS bitwise operations are performed on 32 bit signed integers)
	    const asInt32 = dv.getInt32(0, false);

	    // All bits aside from the sign
	    let rest = asInt32 & 0x7fff;
	    // Sign bit
	    let sign = asInt32 & 0x8000;
	    // Exponent bits
	    const exponent = asInt32 & 0x7c00;

	    // Shift the non-sign bits into place for a 32 bit Float
	    rest <<= 13;
	    // Shift the sign bit into place for a 32 bit Float
	    sign <<= 16;

	    // Adjust bias
	    // https://en.wikipedia.org/wiki/Half-precision_floating-point_format#Exponent_encoding
	    rest += 0x38000000;
	    // Denormals-as-zero
	    rest = (exponent === 0 ? 0 : rest);
	    // Re-insert sign bit
	    rest |= sign;

	    // Set the adjusted float32 (stored as int32) back into the dataview
	    dv.setInt32(0, rest, false);

	    // Get it back out as a float32 (which js will convert to a Number)
	    const asFloat32 = dv.getFloat32(0, false);

	    return asFloat32;
	}

}

//import * as UIL from 'uil'
/** __
*    _)_|_|_
*   __) |_| | 2023
* @author lo.th / https://github.com/lo-th
*/
const menuList = ['ENV', 'PHY', 'CAM', 'POST', 'MAT', 'OBJ'];

let Main$2 = null;

const Gui = {

	tool:h$2,

	open:false,
	isInit:false,

	ui:null,
	gp:null,
	video:null,
	envui:null,





	CameraOptions:[],

	//mat:null,
	startMode:'ENV',
	mode:'',
	currentMat:'',
	matList:null,

	imageMap: ['map', 'map1', 'map2', 'emissiveMap', 'sheenColorMap'],
	imageNormal: [ 'normalMap', 'normalMap1','normalMap2','aoMap', 'metalnessMap', 'roughnessMap', 'alphaMap','anisotropyMap', 'specularIntensityMap' ],
	
	MaterialMesh:[ 'Basic', 'Physical', 'Standard', 'Toon', 'Lambert', 'Phong', 'Shader' ],

	joy: null,
	p0: 'M 0.5 1.5 L 9.5 1.5 M 0.5 5.5 L 9.5 5.5 M 0.5 9.5 L 9.5 9.5',
	p1: 'M 1.5 0.5 L 1.5 9.5 M 5.5 0.5 L 5.5 9.5 M 9.5 0.5 L 9.5 9.5',

	bg:'rgba(0,0,8,0.5)',

	colors:{

		//content:'rgba(0,0,8,0.5)',
		fontShadow:'#000',
		//sx: 4,
        //sy: 4,
        radius:0,

        showOver:0,
		background:'none', //'none',
		backgroundOver:'none',//'rgba(255,255,255,0.02)',

		//font:"'Roboto Mono', 'Source Code Pro', Consolas, monospace", 
		font:"Mulish, sans-serif", 
		fontSize:12,
		weight:'500',

		text:'#fff',
		title:'#eee',

		/*text:'rgba(0,0,6,1)',
		title:'rgba(0,0,6,1)',
		titleoff: '#000',
		textOver: '#7fFF00',
		textSelect: '#7fFF00',

		button:'rgba(255,255,255,0.1)',
		overoff : 'rgba(0,0,6,0.3)',
		over:'rgba(0,0,6,0.2)',
		select:'rgba(0,0,6,0.75)',
		
		//fontShadow:'#000006',
		
		border:'rgba(255,255,255,0.2)',//
		borderSize:1,
		//overoff:'rgba(255,255,255,0.1)',*/

		
		borderSize:1,
		
		//groups:'rgba(255,255,255,0.1)',
		//gborder:'rgba(255,255,255,0.2)',

		joyOut: 'rgba(255,255,255,0.1)',
		joyOver:'rgba(127,255,0,0.2)',
        joySelect: '#7fFF00',

	},

	setMain: ( r ) => { 
		Main$2 = r;
	},

	


	showHide: () => { 

		if( !Gui.isInit ) Gui.init();

		if( Gui.open ) Gui.open = false;
		else Gui.open = true;

		//if( Gui.ui.isOpen ) Gui.ui.isOpen = false;
		//else Gui.ui.isOpen = true;

		Gui.ui.isOpen = Gui.open;

		Hub.switchGuiButton( Gui.open );
		//Hub.switchColor( Gui.ui.isOpen )

		Gui.menu.display( Gui.open );

		//UIL.Tools.setSvg( )


		//document.querySelector("#path").setAttributeNS(null, 'd', Gui.ui.isOpen ? Gui.p1 : Gui.p0)


		///Gui.button.childNodes[0].childNodes[ 0 ].setAttributeNS(null, 'd', Gui.ui.isOpen ? Gui.p1 : Gui.p0)

		//Gui.ui.calc()
		//Gui.ui.mode('def')

		Gui.ui.calc();
		Gui.ui.mode('def');

	},

	init:() => {

		//Gui.colors.content = Gui.bg

		//Gui.colors.background = Gui.bg
		//Gui.colors.backgroundOver = Gui.bg
		//Gui.colors.groups = Gui.bg
		//Gui.colors.gborder = Gui.bg

		h$2.setStyle(Gui.colors);

		//const options = Main.getOption();

		

		//const ui = new UIL.Gui( { w:250, h:25, open:false, close:false, css:'top:54px; right:5px;', colors:Gui.colors, transition:0 } )

		//ui.add( 'empty', {h:6})

		Gui.menu = T$1( 'button', { type:'button', values:menuList, value:Gui.startMode, selectable:true, unselect:false, p:0, h:30,w:250, radius:4, pos:{right:'5px', top:'60px'} }).onChange( Gui.setMode );

		Gui.menu.icon( iconUI('env'), 0, 2 );
		Gui.menu.icon( iconUI('phy'), 0, 3 );
		Gui.menu.icon( iconUI('cam'), 0, 4 );
		Gui.menu.icon( iconUI('post'), 0, 5 );
		Gui.menu.icon( iconUI('mat'), 0, 6 );
		Gui.menu.icon( iconUI('asset'), 0, 7 );

		Gui.ui = new D( { w:250, h:25, open:false, close:false, css:'top:97px; right:5px;', colors:Gui.colors, transition:0 } );//


		//Gui.display()

		Gui.setMode(Gui.startMode);

		Gui.isInit = true;


		//return

		/*let unselectable = '-o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none; pointer-events:none; '


		*/

		//console.log(ui)
		//if( options.mode === 'HIGH' ) ui.content.style.backdropFilter = 'blur(4px)'




		

		//ui.add( 'empty', {h:3})

		


		//ui.add( 'empty', {h:6})

		
		

		//ui.add( 'empty', {h:3})

		
		

		

		//Gui.display()

	},

	setMode( name ){

		if(Gui.mode === name) return
		Gui.mode = name;
	    Gui.ui.clear();

	    switch(Gui.mode){
	    	case 'ENV': Gui.display(); break;
	    	case 'PHY': Gui.physics(); break;
	    	case 'CAM': Gui.camera(); break;
	    	case 'POST': Gui.postprocess(); break;
	    	case 'MAT': Gui.material(); break;
	    }

	    Gui.ui.add( 'empty', {h:6});

	},

	doReset: () => {

		if( !Gui.isInit ) return
		if( !Gui.open ) return
		setTimeout( Gui.reset, 0 ); 

	},

	reset: () => {

		if( !Gui.isInit ) return
		if( !Gui.open ) return

		let oldMode = Gui.mode;
	    Gui.mode = '';
	    Gui.currentMat = '';
	    if(oldMode) Gui.setMode(oldMode);

	},






	display:() => {

		if( Gui.mode !== 'ENV' ) return

		const ui = Gui.ui;

		const mode = 2;

		const options = Main$2.getOption();
		Main$2.getSetting();
		const renderer = Main$2.getRenderer();
		Main$2.getScene();
		const toneMappingOptions = Main$2.getToneMappingOptions();

		ui.add( options, 'mode', { type:'button', values:['LOW', 'HIGH'], selectable:true, unselect:false, p:0 }).onChange( Main$2.changeMode );

		ui.add( options, 'harmony', { type:'bool' }).onChange( Hub.harmony );
		ui.add( options, 'show_light', { type:'bool' }).onChange( Main$2.showDebugLight );
		ui.add( options, 'show_stat', { type:'bool' }).onChange( Main$2.showStatistic );

		ui.add( options, 'fogMode', { type:'selector', values:[0,1], selectable:true, unselect:false, h:24 }).onChange( function(n){ Shader.up( options ); });

		ui.add( options, 'exposure', { min:0, max:4, mode:mode } ).onChange( function( v ){ 
			renderer.toneMappingExposure = v; 
			Env.up();
		});

		ui.add( options, 'tone',  { type:'list', list:toneMappingOptions, full:true }).onChange( function(v){
			renderer.toneMapping  = toneMappingOptions[ options.tone ];
		});

		ui.add( options, 'legacy',  { type:'bool' }).onChange( function(v){ renderer.useLegacyLights  = v; });

		ui.add( options, 'shadow', { min:0, max:1, mode:mode, color:'#8ff' } ).onChange( Main$2.setShadow );//.listen()
		ui.add( options, 'reflect', { min:0, max:1, mode:mode, color:'#8ff' } ).onChange( Main$2.setReflect );//.listen()


		ui.add( options, 'light_1', { rename:'Light Direct', min:0, max:10, mode:mode, color:'#ff0' } ).onChange( Main$2.lightIntensity );
		ui.add( options, 'light_2', { rename:'Light Sphere', min:0, max:10, mode:mode, color:'#ff0' } ).onChange( Main$2.lightIntensity );
		ui.add( options, 'envPower', { min:0, max:3, mode:mode, color:'#ff0' } ).onChange( Main$2.envmapIntensity );
		ui.add( options, 'envBlur', { min:0, max:1, mode:mode, color:'#ff0' } ).onChange( Main$2.setBlur );

		Gui.envui = ui.add( 'list', { name:'Envmap', list:Main$2.envList, value:options.envmap, path:'assets/textures/equirectangular/mini/', format:'.jpg', m:0, imageSize: [128,64], h:40}).onChange( Main$2.setEnv );



		const hub3d = Main$2.getHub3d();
		if(hub3d){
			ui.add( hub3d, 'offset', { min:0, max:2, mode:mode, color:'#8ff' } );
			ui.add( hub3d, 'darkness', { min:0, max:1, mode:mode, color:'#8ff' } );
			ui.add( hub3d, 'color', { type:'color' } ).listen();
		}

		

		

		//return

		
		

		
		

		/*g.add( 'bool', { name:'ground', value:setting.ground }).onChange( showGround )

		g.add( 'bool', { name:'floor', value:false }).onChange( Env.addFloor )
		g.add( 'slide', { name:'height', min:1, max:100, precision:0, value:10, mode:mode } ).onChange( Env.setFloorHeight )
		g.add( 'slide', { name:'radius', min:1, max:600, precision:0, value:100, mode:mode } ).onChange( Env.setFloorRadius )

		g.add( options, 'reflect', { min:0, max:1, mode:mode } ).onChange( setReflect ).listen()

		
		g.add( options, 'shadowType', { type:'list', rename:'type', list:shadowMapType, full:true }).onChange( function(v){
			renderer.shadowMap.type = shadowMapType[options.shadowType]
		})

		g.add( options, 'lightSizeUV', { min:1, max:10, precision:4, mode:mode } ).onChange( upShader )
		g.add( options, 'nearPlane', { min:1, max:20, precision:2, mode:mode } ).onChange( upShader )
		g.add( options, 'rings', { min:1, max:30, precision:0, mode:mode} ).onChange( upShader )
		//grV.add( options, 'nSample', {min:2, max:32, precision:0} ).onChange( function(){ Shader.up( options ) } )
		*/

		

	},

	objects:() => {
		if( Gui.mode !== 'OBJ' ) return


	},

	physics:() => {

		if( Gui.mode !== 'PHY' ) return

		const ui = Gui.ui;

	    const setting = Main$2.motor.getSetting();

	    ui.add('button', { values:Main$2.engineList, selectable:true, value:Main$2.engineType, h:30  }).onChange( Gui.swapEngine );
		//if( Main.devMode ) ui.add('button', { values:['RAPIER','CANNON'], selectable:true, value:Main.engineType }).onChange( Gui.swapEngine )
		ui.add( 'bool', { name:'WORKER OFF', onName:'WORKER ON', value:Main$2.isWorker, mode:1 }).onChange( Gui.swapWorker );
		

	    let rrr = ui.add( 'button', { type:'button', values:['REPLAY', 'PAUSE'], p:0 }).onChange( (n)=>{ 
			//if(n === 'EDIT'){ Main.showEditor(true); this.switchValues(0, 'CLOSE' ); }
			//if(n === 'CLOSE'){ Main.showEditor(false); this.switchValues(0, 'EDIT' ); }
			if(n === 'PAUSE'){ phy.pause( true ); rrr.switchValues(1, 'PLAY' ); }
			if(n === 'PLAY'){ phy.pause( false ); rrr.switchValues(1, 'PAUSE' ); }
			if(n === 'REPLAY') Main$2.injectCode( Main$2.getCode() );
		});



		ui.add( 'empty', {h:6});

	    ui.add( 'button', { type:'button', values:['DRAG', 'SHOOT', 'BUILD'], value:'DRAG', selectable:true, unselect:false, p:0 }).onChange( (n)=>{ 
			phy.mouseMode( n.toLowerCase() );
		});

		//ui.add( 'number', { name:'Gravity', value:[0,-9.81,0] })

		ui.add( setting, 'gravity', { type:'number' }).onChange( Main$2.motor.setGravity );
		//ui.add( setting, 'substep', { type:'number' })
		//ui.add( setting, 'fps', { type:'number' })

	},

	camera:() => {

		if( Gui.mode !== 'CAM' ) return

		const ui = Gui.ui;

	    const controler = Main$2.getControler();

	    //Gui.CameraOptions = 
	    const up = function(){ 
	    	Main$2.setCamera( {...controler.info } );
	    };
	    const mode = 2;

	    //console.log(options)

	    
	    ui.add( 'empty', {h:6});
	    ui.add( controler.info, 'phi', {min:-90, max:90, precision:1, mode:mode, color:'#ff0' }).onChange( up ).listen();
	    ui.add( controler.info, 'theta', {min:-180, max:180, precision:1, mode:mode, color:'#ff0'  }).onChange( up ).listen();
	    ui.add( 'empty', {h:6});
	    ui.add( controler.info, 'fov', {min:1, max:180, precision:1, mode:mode, color:'#8ff' }).onChange( up ).listen();
	    ui.add( controler.info, 'zoom', {min:0.1, max:10, precision:1, mode:mode, color:'#8ff'  }).onChange( up ).listen();
	    ui.add( 'empty', {h:6});

	    //ui.add( controler.info, 'target', { type:'number' }).onChange( up ).listen()
	    ui.add( controler.info, 'distance', { type:'number', min:0, max:100, mode:mode} ).onChange( up ).listen();
	    ui.add( controler.info, 'x', { type:'number', min:-50, max:50, precision:2, mode:mode }).onChange( up ).listen();
	    ui.add( controler.info, 'y', { type:'number', min:-50, max:50, precision:2, mode:mode  }).onChange( up ).listen();
	    ui.add( controler.info, 'z', { type:'number', min:-50, max:50, precision:2, mode:mode }).onChange( up ).listen();

	   

	    //ui.add( 'bool', { name:'CAPTURE', onName:'STOP', value:false, mode:1 }).onChange( Gui.capture )
		//ui.add('button', { name:'CAMERA' }).onChange( function(){ console.log( controls.getInfo() )} )

	},

	postprocess:( direct ) => {

		if( Gui.mode !== 'POST' ) return

    	const ui = Gui.ui;

        const options = Main$2.getOption();

        if(!direct){
        	ui.clear(); 
        	ui.add( options, 'renderMode', { type:'selector', values:[0,1,2,3], selectable:true, unselect:false, p:0, h:24 }).onChange( function(n){ 

				if( n!== 0 ) scene.helper.visible = false;
				if( n===1 ) { Env.setBackgroud(0x000000); /*camera.near = 1; camera.updateProjectionMatrix();*/}
				else if( n===2 ) Env.setBackgroud(0x7777ff);
				else if( n===3 ) Env.setBackgroud(0xffffff);
				else {
					Env.setBackgroud();
					scene.helper.visible = true;
				}
				//Hub.setRenderMode( n )
				Shader.up( options ); 
			});
        	ui.add( options, 'composer', { type:'bool', rename:'POST PROCESS OFF', onName:'POST PROCESS ON', mode:1, h:40 }).onChange( Main$2.setComposer );
        	Gui.gp = ui.add('group', { name:'OPTION' });
        }

        let g = Gui.gp;
        g.clear();

		const composer = Main$2.getComposer();
		const scene = Main$2.getScene();
		const mode = 0;
		if(!composer) return

		g.add( composer.pass.focus, 'enabled', { type:'bool', rename:'focus', onName:'focus' });
		g.add( composer.options, 'focus', {min:0, max:100} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'aperture', {min:0, max:5,  precision:2} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'maxblur', {min:0, max:0.01,  step:0.001, precision:3} ).onChange( function(){ composer.update(); } );
	    g.add( 'empty', {h:6});
	    /**/

	    g.add( composer.pass.sao, 'enabled', { type:'bool', rename:'sao' });
		g.add( composer.options, 'saoBias', {min:-1, max:1, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'saoIntensity', {min:0, max:1, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'saoScale', {min:0, max:50, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'saoKernelRadius', {min:1, max:100, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'saoMinResolution', {min:0, max:1, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( 'empty', {h:6});

	    //grV.add( composer.pass.bloom, 'enabled', { type:'bool', rename:'bloom' })
	    g.add( composer.pass.bloom, 'enabled', { type:'bool', rename:'bloom' });
		g.add( composer.options, 'threshold', {min:0, max:1, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'strength', {min:0, max:10, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'bloomRadius', {min:0, max:1, step:0.01, mode:mode} ).onChange( function(){ composer.update(); } );
	    g.add( 'empty', {h:6});

	    g.add( composer.pass.distortion, 'enabled', { type:'bool', rename:'distortion' });
	    g.add( composer.options, 'distortion', {min:0, max:1, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'horizontal', {min:0, max:360, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( composer.options, 'cylindrical', {min:0, max:5, step:0.01, mode:mode} ).onChange( function(){ composer.update(); } );
		g.add( 'empty', {h:6});

		g.add( composer.pass.lut, 'enabled', { type:'bool', rename:'lut' });
		//g.add('button', { name:'LOAD', p:10, drag:true }).onChange( function(a,b,c){ composer.changeLut(a,b,c) } )
		g.add('button', { name:'LOAD', p:10 }).onChange( function(a,b,c){ o$1.load( { callback:function(a,b,c){ composer.changeLut(a,b,c); }, type:'lut' } ); } );
		g.add( 'empty', {h:6});

	    g.add( composer.pass.sharpen, 'enabled', { type:'bool', rename:'sharpen' });
	    g.add( composer.options, 'power', {min:0, max:1, mode:mode} ).onChange( function(){ composer.update(); } );
	    g.add( 'empty', {h:6});

	    g.open();
	    
	    
	    /*
	    g.add( 'empty', {h:6})
		g.add( composer.options, 'kernelRadius', {min:0.01, max:1} ).onChange( function(){ composer.update() } )
		g.add( composer.options, 'minDistance', {min:0, max:0.001, precision:5} ).onChange( function(){ composer.update() } )
		g.add( composer.options, 'maxDistance', {min:0, max:20} ).onChange( function(){ composer.update() } )
	    */

	},

	/*demo:(gg) => {

		return

		let data = Main.getDemos()

		/*let colors = [
		'rgba(180,255,180,0.1)',
		'rgba(255,255,180,0.1)',
		'rgba(255,180,180,0.1)'
		]*/

	/*	let colors = [
		'rgba(255,255,255,0.1)',
		'rgba(200,200,200,0.1)',
		'rgba(150,150,150,0.1)'
		]

		let grB = gg.add('group', { name:'BASIC', open:true, bg:colors[0] })
		Gui.g1 = grB.add( 'grid', { values:data.Basic, selectable:true } ).onChange( Main.loadDemo )

		let grA = gg.add('group', { name:'ADVANCED', open:true, bg:colors[1] })
		Gui.g2 = grA.add( 'grid', { values:data.Advanced, selectable:true } ).onChange( Main.loadDemo )

		if( data[Main.engineType] ){
			let grC = gg.add('group', { name:'SPECIFIC', open:true, bg:colors[2] })
			Gui.g3 = grC.add( 'grid', { values:data[Main.engineType], selectable:true } ).onChange( Main.loadDemo )
		}

		gg.add( 'empty', {h:3})



		gg.reset()

	},*/

	

	/*resetDemoGroup: ( name ) => {

		return

		let cc1 = false, cc2 = false, cc3 = false;

		if(Gui.g1) { Gui.g1.setValue(name); cc1 = Gui.g1.reset() }
		if(Gui.g2) { Gui.g2.setValue(name); cc2 = Gui.g2.reset() }
		if(Gui.g3) { Gui.g3.setValue(name); cc3 = Gui.g3.reset() }

		// if demo not existe reset to default demo 
		if(!cc1 && !cc2 && !cc3){ 
			if(Gui.g1) { Gui.g1.setValue('start'); cc1 = Gui.g1.reset() }
			return false
		}
		else return true

	},*/

	gotoGithub: () => { window.open( 'https://github.com/lo-th/phy', '_blank' ); },

	

	swapWorker: ( b ) => {
		Main$2.isWorker = b;
		Gui.swapEngine();
	},

	swapEngine: ( type ) => {
		if( !type ) type = Main$2.engineType;
		let name = type.toLowerCase();
		let hash = location.hash;
		let url = 'index';
		let param = 'E=';
		if( Main$2.devMode ) param += 'dev_';
		if( Main$2.isWorker ) param += 'w_';
		param += name;
		window.open( url+'.html?'+param+hash, '_self');
	},

	capture: ( B ) => {
		if(!Gui.video && B ) Gui.video = new Video();
		else {
			if( B ) Gui.video.start();
			else {
				Gui.video.stop();
				Gui.video = null;
			}
		}
		
	},

    update: () => {
		if( Gui.video ) Gui.video.update(  );
	},

    /*addJoystick:() => {
    	Gui.joy = UIL.add('Joystick', {  w:160, mode:1, text:false, pos:{left:'10px', bottom:'30px' }, simple:true })//.onChange( callbackSize )
    }*/

    material:() => {

    	if( Gui.mode !== 'MAT' ) return

    	const ui = Gui.ui;

        ui.clear();

		let mats = Main$2.motor.getMaterialList();
		const matList = ui.add( 'list', { name:'', list:mats, p:0, value:Gui.currentMat, h:40 }).onChange( Gui.materialEdit );

		if( !Gui.currentMat ) {

			matList.text('Select Material');
			return

		}
		
		let m = mats[ Gui.currentMat ];

		console.log(m);

		let type = m.type;
		if( type.search( 'Mesh' )!==-1 ) type = type.substring( 4 ); 

		let mm = type.search( 'Material' );
		type = type.substring( 0, mm );

		ui.add( 'list', { name:'Type', list:Gui.MaterialMesh, value:type, h:30 }).onChange();

		if(m.side!==undefined) ui.add( m, 'side', { type:'list', list:{ front:0, back:1, double:2 } }).onChange( function( c ){ m.side = this.list.indexOf(c); });
		if(m.shadowSide!==undefined) ui.add( m, 'shadowSide', { type:'list', list:{ front:0, back:1, double:2 } }).onChange( function( c ){ m.shadowSide = this.list.indexOf(c); });

		//return

		let g0 = ui.add('group', { name:'COLORS', open:true });

	    if(m.color!==undefined){
		    m.cc = m.color.getHex();
		    g0.add( m, 'cc', { type:'color', rename:'color' } ).onChange( function( c ){ m.color.setHex( c ); } );
		}

		if(m.specularColor!==undefined){
	    	m.sp = m.specularColor.getHex();
	    	g0.add( m, 'sp', { type:'color', rename:'specular' } ).onChange( function( c ){ m.specularColor.setHex( c ); } );
	    }

		if(m.emissive!==undefined){
		    m.em = m.emissive.getHex();
		    g0.add( m, 'em', { type:'color', rename:'emissive' } ).onChange( function( c ){ m.emissive.setHex( c ); } );
		}

		if(m.sheen!==undefined){
	    	m.ss = m.sheenColor.getHex();
	    	g0.add( m, 'ss', { type:'color', rename:'sheen' } ).onChange( function( c ){ m.sheenColor.setHex( c ); } );
	    } 


		let g1 = ui.add('group', { name:'IMAGES' });


	    let images = [...Gui.imageMap, ...Gui.imageNormal ], t, str;

	    for( let i = 0; i<images.length; i++ ){
	    	t = images[i];
	    	name = 'null';
	    	if(m[t]){
	    		str = m[t].source.data.currentSrc || 'Direct';
	    	    name = str.substring( str.lastIndexOf('/')+1 );
	    	} 
	    	if(m[t]!==undefined) g1.add( 'bitmap',  { name:t, value:name, type:'bitmap' }).onChange( function( file, img, name ){ Gui.setTexure(file, img, name, m ); } );

	    }

	    let g2 = ui.add('group', { name:'OPTIONS' });

	    if(m.randomUv!==undefined) g2.add( m, 'randomUv', {  });
		if(m.wireframe!==undefined) g2.add( m, 'wireframe', {  });
		if(m.vertexColors!==undefined) g2.add( m, 'vertexColors', {  });
		if(m.forceSinglePass!==undefined) g2.add( m, 'forceSinglePass', { rename:'singlePass' });
		if(m.visible!==undefined) g2.add( m, 'visible', {  });
		if(m.depthTest!==undefined) g2.add( m, 'depthTest', {  });
		if(m.depthWrite!==undefined) g2.add( m, 'depthWrite', {  });
		if(m.alphaToCoverage!==undefined) g2.add( m, 'alphaToCoverage', {  });
		if(m.premultipliedAlpha!==undefined) g2.add( m, 'premultipliedAlpha', {  });
		if(m.transparent!==undefined) g2.add( m, 'transparent', {  });

		let g3 = ui.add('group', { name:'VALUES', open:true });

		if(m.normalScale!==undefined){
			g3.add( m.normalScale, 'x', { min:-10, max:10, precision:1 });
			g3.add( m.normalScale, 'y', { min:-10, max:10, precision:1 });
		}

		


	    if(m.metalness!==undefined) g3.add( m, 'metalness', { min:0, max:1 });
		if(m.roughness!==undefined) g3.add( m, 'roughness', { min:0, max:1 });

		if(m.specularIntensity!==undefined) g3.add( m, 'specularIntensity', { min:0, max:1 });
		if(m.aoMapIntensity!==undefined) g3.add( m, 'aoMapIntensity', { min:0, max:1 });
		if(m.emissiveIntensity!==undefined) g3.add( m, 'emissiveIntensity', { min:0, max:1 });

		if(m.opacity!==undefined) g3.add( m, 'opacity', { min:0, max:1 });
		if(m.reflectivity!==undefined) g3.add( m, 'reflectivity', {min:0, max:1});

		if(m.reflectif!==undefined) g3.add( m, 'reflectif', { min:0, max:1 });

	    if(m.envMapIntensity!==undefined) g3.add( m, 'envMapIntensity', { rename:'env', min:0, max:4 });
	    if(m.thickness!==undefined) g3.add( m, 'thickness', { min:-4, max:4 });
	    if(m.clearcoat!==undefined) g3.add( m, 'clearcoat', { min:0, max:1 });
	    if(m.clearcoatRoughness!==undefined) g3.add( m, 'clearcoatRoughness', { min:0, max:1 });



	    if(m.sheen!==undefined){ 
	    	g3.add( m, 'sheen', {min:0, max:4});
	    	g3.add( m, 'sheenRoughness', {min:0, max:1});
	    	
	    }

	    if(m.iridescence!==undefined) g3.add( m, 'iridescence', {min:0, max:1});

	    if(m.anisotropy!==undefined) g3.add( m, 'anisotropy', {min:0, max:1});
	    if(m.anisotropyRotation!==undefined) g3.add( m, 'anisotropyRotation', {min:0, max:1});

	    if(m.ior!==undefined) g3.add( m, 'ior', { min:0, max:4 });
	    if(m.transmission!==undefined) g3.add( m, 'transmission', { min:0, max:1 });


		//Gui.mat.open()

		//

	},

	setTexure:( file, img, name, mat, o = {} ) => {

		let ref = mat[name];
		if(ref){
			o.repeat = ref.repeat.toArray();
		}

		o.encoding = Gui.imageMap.indexOf(name) !== -1;
		o.flipY = false;
		
		let fileName = file.substring( 0, file.lastIndexOf('.') );
		let fileType = file.substring( file.lastIndexOf('.')+1 );
		

		if(fileType==='exr'){
			//console.log(img)
			//mat[name] = 
			Pool.load_EXR( file, fileName, function(t){mat[name] = t;} );
		} else {
			let im = new Image();
			im.src = img;
			im.onload = function (){

				Pool.data.set( 'I_' + fileName, im );
			    mat[name] = Pool.getTexture( fileName, o );

			};
		}


		

	},

	materialEdit:( name ) => {

		if( Gui.mode !== 'MAT' ) return
		if( name === Gui.currentMat ) return

		Gui.currentMat = name;
	    setTimeout( Gui.material, 0 );

	},

	postprocessEdit:( name ) => {

		if( Gui.mode !== 'POST' ) return

		Gui.postprocess(true);

	    //setTimeout( Gui.postprocess, 100 )

	},

};







const iconUI =  function ( type, over = false ){

    var viewBox = '0 0 30 26';
    var d = '';

    var c = over ? ['#baabfb', '#9e87fb', '#7463b8', '#221d36'] : ['#E5E5E5', '#D1D1D1', '#999999', '#383838'];

    var t = ["<svg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' style='pointer-events:none; margin-top:0px;' preserveAspectRatio='none' x='0px' y='0px' width='30px' height='26px' viewBox='"+viewBox+"'><g>"];
    switch(type){

        case 'phy':
        d = 'M 22.2 11.35 Q 21.95 10.15 21.25 9.1 L 22.45 7.85 Q 21.95 7.2 21.4 6.65 20.8 6 20.1 5.55 L 18.95 6.75 Q 17.9 6.05 16.65 5.8 L 16.65 4.15 Q 15.9 4 15.05 4 14.2 4 13.4 4.2 L 13.4 5.8 Q 12.15 6.05 11.15 6.75 L 9.95 5.55 Q 9.25 6 8.65 6.65 8.1 7.2 7.65 7.9 L 8.8 9.05 Q 8.1 10.1 7.85 11.35 L 6.2 11.35 Q 6.1 12.15 6.1 13 6.1 13.85 6.2 14.65 L 7.85 14.65 Q 8.1 15.85 8.8 16.9 L 7.6 18.05 Q 8.1 18.7 8.7 19.3 9.25 19.9 9.95 20.4 L 11.1 19.25 Q 12.15 19.9 13.4 20.2 L 13.4 21.85 Q 14.2 21.95 15.05 21.95 15.9 21.95 16.65 21.85 L 16.65 20.2 Q 17.9 19.9 19 19.25 L 20.15 20.4 Q 20.8 19.95 21.4 19.35 22 18.75 22.45 18.05 L 21.25 16.85 Q 21.95 15.85 22.2 14.65 L 23.95 14.65 Q 24.05 13.85 24.05 13 24.05 12.15 23.95 11.35 L 22.2 11.35 M 13.25 11.3 Q 14 10.55 15.05 10.55 16 10.55 16.75 11.3 17.5 12 17.5 13 17.5 14.05 16.75 14.7 16 15.45 15.05 15.45 14 15.45 13.25 14.7 12.6 14.05 12.6 13 12.6 12 13.25 11.3 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='"+d+"'/>";
       break;

       case 'env':
        d = 'M 7.95 18.65 L 9.35 20.05 10.75 18.65 9.35 17.25 7.95 18.65 M 9.35 5.95 L 7.95 7.35 9.35 8.75 10.75 7.35 9.35 5.95 M 20.65 20.05 L 22.05 18.65 20.65 17.25 19.25 18.65 20.65 20.05 M 20.65 8.75 L 22.05 7.35 20.65 5.95 19.25 7.35 20.65 8.75 M 14 22 L 16 22 16 20 14 20 14 22 M 16 6 L 16 4 14 4 14 6 16 6 M 24 12 L 22 12 22 14 24 14 24 12 M 8 12 L 6 12 6 14 8 14 8 12 M 19.3 17.3 Q 21.05 15.55 21.05 13.05 21.05 10.5 19.3 8.75 17.55 7.05 15.05 7.05 12.55 7.05 10.8 8.75 9.05 10.5 9.05 13.05 9.05 15.55 10.8 17.3 12.55 19.05 15.05 19.05 17.55 19.05 19.3 17.3 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='"+d+"'/>";
       break;

       case 'post':
        d = 'M 24 22 L 24 8 20 8 20 4 6 4 6 18 10 18 10 22 24 22 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='M 20 8 L 20 4 6 4 6 18 10 18 10 8 20 8 Z'/>";
        break;

        case 'cam':
        d = 'M 23 20 L 24 20 24 6 23 6 19 10 18.05 10 18.05 6.05 6.05 6.05 6.05 20.3 18.05 20.3 18.05 16 19 16 23 20 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='M 23 20 L 24 20 24 6 23 6 19 10 19 16 23 20 M 18 6.05 L 8 6.05 8 18.15 18 18.15 18 6.05 Z'/>";
        //t[1]+="<path fill="+c[0]+" stroke='none' d='M 10 4 L 6 8 19 8 24 4 10 4 Z'/>";
        break;

        /*case 'post':
        d = 'M 24 15 L 24 11 17 11 17 4 13 4 13 11 6 11 6 15 13 15 13 22 17 22 17 15 24 15 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='"+d+"'/>";
        break;*/

        case 'mat':
        d = 'M 24 4 L 6 4 6 22 24 22 24 4 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='M 15 4 L 6 4 6 13 15 13 15 4 M 24 13 L 15 13 15 22 24 22 24 13 Z'/>";
        break;

        /*case 'cam':
        d = 'M 24 18 L 24 4 10 4 6 8 6 22 19 22 24 18 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='M 19 8 L 6 8 6 22 19 22 19 8 Z'/>";
        t[1]+="<path fill="+c[0]+" stroke='none' d='M 10 4 L 6 8 19 8 24 4 10 4 Z'/>";
        break;*/

        case 'asset':
        d = 'M 24 19.8 L 24 14.2 19.5 11.95 19.5 6.3 15 4.05 10.5 6.3 10.5 11.95 6 14.2 6 19.8 10.5 22.05 15 19.8 19.5 22.05 24 19.8 Z';
        t[1]="<path stroke="+c[3]+" stroke-width='2' stroke-linejoin='round' stroke-linecap='round' fill='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[2]+" stroke='none' d='"+d+"'/>";
        t[1]+="<path fill="+c[1]+" stroke='none' d='M 6 14.2 L 6 19.8 10.5 22.05 10.5 16.45 6 14.2 M 19.5 22.05 L 19.5 16.45 15 14.2 15 19.8 19.5 22.05 M 15 8.55 L 10.5 6.3 10.5 11.95 15 14.2 15 8.55 Z'/>";
        t[1]+="<path fill="+c[0]+" stroke='none' d='M 15 14.2 L 19.5 16.45 24 14.2 19.5 11.95 15 14.2 M 10.5 16.45 L 15 14.2 10.5 11.95 6 14.2 10.5 16.45 M 10.5 6.3 L 15 8.55 19.5 6.3 15 4.05 10.5 6.3 Z'/>";
        break;


    }
    t[2] = "</g></svg>";
    return t.join("\n");

};

var BACKGROUND_COLOR="#282923",LINE_HEIGHT="19px",FONT_SIZE="15px",defaultCssTheme="\n.codeflask {\n  background: "+BACKGROUND_COLOR+";\n  //color: rgba(0, 0, 0, 0);\n  color: #f8f8f2;\n  //border-radius: 12px;\n  //text-shadow: 1px 1px 1px black;\n  //resize: true;\n}\n\n.codeflask ::-webkit-scrollbar {\n  width: 15px;\n  height:15px;\n}\n\n.codeflask ::-webkit-scrollbar-track {\n  background:none;\n  /*background-clip: content-box;*/\n  \n}\n\n.codeflask ::-webkit-scrollbar-thumb {\n  background-color: #555652; \n  width: 7px;\n  //border-radius: 12px;\n  border: 4px solid "+BACKGROUND_COLOR+";\n}\n\n.codeflask ::-webkit-scrollbar-corner {\n  background-color: rgba(0,0,0,0);\n}\n\n\n\n.codeflask ::selection {\n  color: transparent;\n  background-color: #47473d; //rgba(71, 71, 61, 0.5);\n}\n\n.codeflask ::-moz-selection{\n  color: transparent;\n  background-color: #47473d; //rgba(71, 71, 61, 0.5);\n}\n\n\n.codeflask .token.punctuation { color: #f8f8f2; /* white */ }\n\n.codeflask .token.function { color: #67d8ef; /* blue */ } \n.codeflask .token.keyword { color: #67d8ef; font-style: italic; /* blue */ }\n\n.codeflask .token.function-variable { color: #a6e22c; /* green */ }\n.codeflask .token.class-name { color: #a6e22c; /* green */ }\n.codeflask .token.function-extra { color: #a6e22c; /* green */ }\n\n.codeflask .token.keyword-variable { color: #f92672; font-style: normal; /* red */ }\n.codeflask .token.operator { color: #f92672; /* red */ }\n\n.codeflask .token.parameter { color: #fd9621;/* orange */}\n.codeflask .token.parameter-variable { color: #fd9621;/* orange */}\n\n.codeflask .token.string { color: #e7db75; /* yellow */ }\n\n.codeflask .token.comment { color: #75715e; /* grey */ }\n\n\n\n.codeflask .token.boolean { color: #ae81ff; /* purple */ }\n.codeflask .token.number { color: #ae81ff; /* purple */ }\n\n.codeflask .token-template-string { color: #000000; }\n.codeflask .token-class-name { color: #000000; }\n.codeflask .token-regex { color: #000000; }\n\n.codeflask .token.selector { color: #00FF00; }\n.codeflask .token.property { color: #ac80ff;}\n.codeflask .token.tag { color: #FFFF00; }\n.codeflask .token.attr-value { color: #0000FF;}\n\n";function cssSupports(e,t){return "undefined"!=typeof CSS?CSS.supports(e,t):"undefined"!=typeof document&&toCamelCase(e)in document.body.style}function toCamelCase(e){return (e=e.split("-").filter(function(e){return !!e}).map(function(e){return e[0].toUpperCase()+e.substr(1)}).join(""))[0].toLowerCase()+e.substr(1)}var FONT_FAMILY="Consolas, Menlo, Courier, monospace",COLOR=cssSupports("caret-color","#F00")?BACKGROUND_COLOR:"#ccc",LINE_NUMBER_WIDTH="40px",editorCss="\n  .codeflask {\n    -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none;\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n\n  .codeflask, .codeflask * {\n    box-sizing: border-box;\n    border: none;\n    resize: none;\n    outline: none;\n  }\n\n  .codeflask__pre {\n    -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none; pointer-events:none;\n    z-index: 3;\n    transform:translate3d(0, 0, 0);\n    box-sizing: border-box;\n    //white-space: pre;\n    padding:0px;\n    word-wrap: normal;\n    box-sizing: border-box;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: visible; !important;\n  }\n\n  .codeflask__textarea {\n\n    background: none;\n    //background:red;\n    border: none;\n    color: "+COLOR+";\n    color: rgba(0, 0, 0, 0);\n    z-index: 1;\n    resize: none;\n    //font-family: "+FONT_FAMILY+";\n    //text-rendering: optimizeSpeed;\n    //text-rendering: inherit;\n    //-webkit-appearance: pre;\n    caret-color: #fff;\n    z-index: 2;\n    width: 100%;\n    height: 100%;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n\n    border: none;\n    outline: none;\n    spellcheck:false;\n    //overflow: hidden;\n    overflow: scroll !important;\n\n  }\n\n  .codeflask--has-line-numbers .codeflask__textarea {\n    width: calc(100% - "+LINE_NUMBER_WIDTH+");\n  }\n\n  .codeflask__code {\n    //padding: 10px;\n    //background:black;\n    display:block;\n    font-size: "+FONT_SIZE+";\n    line-height: "+LINE_HEIGHT+";\n    font-family: "+FONT_FAMILY+";\n    //overflow: hidden;\n    //overflow: scroll !important;\n    //left:3px;\n    //width: auto;\n    //position: absolute;\n    outline: none;\n    resize: none;\n    box-sizing: content-box;\n    display: inline-block;\n  }\n\n  .codeflask__flatten {\n\n    //background:grey;\n    padding: 10px;\n    font-size: "+FONT_SIZE+";\n    line-height: "+LINE_HEIGHT+";\n    font-family: "+FONT_FAMILY+";\n    text-rendering: optimizeLegibility;\n    //letter-spacing: 1px;\n    white-space: pre;\n    word-wrap: normal;\n    box-sizing: border-box;\n    position: absolute;\n    top: 0;\n    left: 0;\n    margin: 0 !important;\n    outline: none;\n    text-align: left;\n    cursor:auto;\n    outline: none;\n    border-radius: 0;\n    border-width: 0;\n    background: transparent;\n    //-webkit-background-clip: padding-box;\n    background-clip: padding-box;\n    resize: none;\n\n  }\n\n  .codeflask--has-line-numbers .codeflask__flatten {\n    width: calc(100% - "+LINE_NUMBER_WIDTH+");\n    left: "+LINE_NUMBER_WIDTH+";\n    outline: none;\n  }\n\n  .codeflask__line-highlight {\n    position: absolute;\n    top: 10px;\n    left: 0;\n    width: 100%;\n    height: "+LINE_HEIGHT+";\n    background: rgba(0,0,0,0.1);\n\n    z-index: 1;\n    //visibility: hidden;\n    outline: none;\n  }\n\n  .codeflask__lines {\n    padding: 10px 4px;\n    font-size:  "+FONT_SIZE+";\n    line-height: "+LINE_HEIGHT+";\n    font-family: "+FONT_FAMILY+";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: "+LINE_NUMBER_WIDTH+";\n    height: 100%;\n    text-align: right;\n    color: #90918b;\n    z-index: 2;\n    outline: none;\n  }\n\n  .codeflask__lines__line {\n    display: block;\n    outline: none;\n  }\n\n  .codeflask.codeflask--has-line-numbers {\n    padding-left: "+LINE_NUMBER_WIDTH+";\n  }\n\n  .codeflask.codeflask--has-line-numbers:before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: "+LINE_NUMBER_WIDTH+";\n    height: 100%;\n    //background: "+BACKGROUND_COLOR+";\n    z-index: 1;\n    outline: none;\n  }\n\n  .codeflask__error {\n    padding: 0px 0px;\n    padding-right:4px;\n    font-size:  "+FONT_SIZE+";\n    font-family: "+FONT_FAMILY+";\n    position: absolute;\n    left: 0;\n    width: "+LINE_NUMBER_WIDTH+";\n    height: "+LINE_HEIGHT+";\n    text-align: right;\n    color: #FF0000;\n    background:rgba(255,0,0,0.3);\n    outline: none;\n    z-index: 3;\n    display:none;\n  }\n";function injectCss(e,t,n){var a=t||"codeflask-style",r=n||document.head;if(!e)return !1;if(document.getElementById(a))return !0;var s=document.createElement("style");return s.innerHTML=e,s.id=a,r.appendChild(s),!0}var entityMap={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;","`":"&#x60;","=":"&#x3D;"};function escapeHtml(e){return String(e).replace(/[&<>"'`=/]/g,function(e){return entityMap[e]})}var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(e){var t=/(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,n=0,a={},r={manual:e.Prism&&e.Prism.manual,disableWorkerMessageHandler:e.Prism&&e.Prism.disableWorkerMessageHandler,util:{encode:function e(t){return t instanceof s?new s(t.type,e(t.content),t.alias):Array.isArray(t)?t.map(e):t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++n}),e.__id},clone:function e(t,n){var a,s;switch(n=n||{},r.util.type(t)){case"Object":if(s=r.util.objId(t),n[s])return n[s];for(var i in a={},n[s]=a,t)t.hasOwnProperty(i)&&(a[i]=e(t[i],n));return a;case"Array":return s=r.util.objId(t),n[s]?n[s]:(a=[],n[s]=a,t.forEach(function(t,r){a[r]=e(t,n);}),a);default:return t}},getLanguage:function(e){for(;e;){var n=t.exec(e.className);if(n)return n[1].toLowerCase();e=e.parentElement;}return "none"},setLanguage:function(e,n){e.className=e.className.replace(RegExp(t,"gi"),""),e.classList.add("language-"+n);},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(a){var e=(/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(a.stack)||[])[1];if(e){var t=document.getElementsByTagName("script");for(var n in t)if(t[n].src==e)return t[n]}return null}},isActive:function(e,t,n){for(var a="no-"+t;e;){var r=e.classList;if(r.contains(t))return !0;if(r.contains(a))return !1;e=e.parentElement;}return !!n}},languages:{plain:a,plaintext:a,text:a,txt:a,extend:function(e,t){var n=r.util.clone(r.languages[e]);for(var a in t)n[a]=t[a];return n},insertBefore:function(e,t,n,a){var s=(a=a||r.languages)[e],i={};for(var o in s)if(s.hasOwnProperty(o)){if(o==t)for(var l in n)n.hasOwnProperty(l)&&(i[l]=n[l]);n.hasOwnProperty(o)||(i[o]=s[o]);}var c=a[e];return a[e]=i,r.languages.DFS(r.languages,function(t,n){n===c&&t!=e&&(this[t]=i);}),i},DFS:function e(t,n,a,s){s=s||{};var i=r.util.objId;for(var o in t)if(t.hasOwnProperty(o)){n.call(t,o,t[o],a||o);var l=t[o],c=r.util.type(l);"Object"!==c||s[i(l)]?"Array"!==c||s[i(l)]||(s[i(l)]=!0,e(l,n,o,s)):(s[i(l)]=!0,e(l,n,null,s));}}},plugins:{},highlightAll:function(e,t){r.highlightAllUnder(document,e,t);},highlightAllUnder:function(e,t,n){var a={callback:n,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};r.hooks.run("before-highlightall",a),a.elements=Array.prototype.slice.apply(a.container.querySelectorAll(a.selector)),r.hooks.run("before-all-elements-highlight",a);for(var s,i=0;s=a.elements[i++];)r.highlightElement(s,!0===t,a.callback);},highlightElement:function(t,n,a){var s=r.util.getLanguage(t),i=r.languages[s];r.util.setLanguage(t,s);var o=t.parentElement;o&&"pre"===o.nodeName.toLowerCase()&&r.util.setLanguage(o,s);var l={element:t,language:s,grammar:i,code:t.textContent};function c(e){l.highlightedCode=e,r.hooks.run("before-insert",l),l.element.innerHTML=l.highlightedCode,r.hooks.run("after-highlight",l),r.hooks.run("complete",l),a&&a.call(l.element);}if(r.hooks.run("before-sanity-check",l),(o=l.element.parentElement)&&"pre"===o.nodeName.toLowerCase()&&!o.hasAttribute("tabindex")&&o.setAttribute("tabindex","0"),!l.code)return r.hooks.run("complete",l),void(a&&a.call(l.element));if(r.hooks.run("before-highlight",l),l.grammar)if(n&&e.Worker){var u=new Worker(r.filename);u.onmessage=function(e){c(e.data);},u.postMessage(JSON.stringify({language:l.language,code:l.code,immediateClose:!0}));}else c(r.highlight(l.code,l.grammar,l.language));else c(r.util.encode(l.code));},highlight:function(e,t,n){var a={code:e,grammar:t,language:n};if(r.hooks.run("before-tokenize",a),!a.grammar)throw new Error('The language "'+a.language+'" has no grammar.');return a.tokens=r.tokenize(a.code,a.grammar),r.hooks.run("after-tokenize",a),s.stringify(r.util.encode(a.tokens),a.language)},tokenize:function(e,t){var n=t.rest;if(n){for(var a in n)t[a]=n[a];delete t.rest;}var c=new function(){var e={value:null,prev:null,next:null},t={value:null,prev:e,next:null};e.next=t,this.head=e,this.tail=t,this.length=0;};return o(c,c.head,e),function e(t,n,a,c,u,d){for(var p in a)if(a.hasOwnProperty(p)&&a[p]){var h=a[p];h=Array.isArray(h)?h:[h];for(var g=0;g<h.length;++g){if(d&&d.cause==p+","+g)return;var f=h[g],m=f.inside,b=!!f.lookbehind,k=!!f.greedy,y=f.alias;if(k&&!f.pattern.global){var x=f.pattern.toString().match(/[imsuy]*$/)[0];f.pattern=RegExp(f.pattern.source,x+"g");}for(var v=f.pattern||f,F=c.next,w=u;F!==n.tail&&!(d&&w>=d.reach);w+=F.value.length,F=F.next){var _=F.value;if(n.length>t.length)return;if(!(_ instanceof s)){var C,E=1;if(k){if(!(C=i(v,w,t,b))||C.index>=t.length)break;var A=C.index,T=C.index+C[0].length,L=w;for(L+=F.value.length;A>=L;)F=F.next,L+=F.value.length;if(L-=F.value.length,w=L,F.value instanceof s)continue;for(var P=F;P!==n.tail&&(L<T||"string"==typeof P.value);P=P.next)E++,L+=P.value.length;E--,_=t.slice(w,L),C.index-=w;}else if(!(C=i(v,0,_,b)))continue;var A=C.index,S=C[0],N=_.slice(0,A),I=_.slice(A+S.length),z=w+_.length;d&&z>d.reach&&(d.reach=z);var $=F.prev;N&&($=o(n,$,N),w+=N.length),l(n,$,E);var O=new s(p,m?r.tokenize(S,m):S,y,S);if(F=o(n,$,O),I&&o(n,F,I),E>1){var D={cause:p+","+g,reach:z};e(t,n,a,F.prev,w,D),d&&D.reach>d.reach&&(d.reach=D.reach);}}}}}}(e,c,t,c.head,0),function(e){var t=[],n=e.head.next;for(;n!==e.tail;)t.push(n.value),n=n.next;return t}(c)},hooks:{all:{},add:function(e,t){var n=r.hooks.all;n[e]=n[e]||[],n[e].push(t);},run:function(e,t){var n=r.hooks.all[e];if(n&&n.length)for(var a,s=0;a=n[s++];)a(t);}},Token:s};function s(e,t,n,a){this.type=e,this.content=t,this.alias=n,this.length=0|(a||"").length;}function i(e,t,n,a){e.lastIndex=t;var r=e.exec(n);if(r&&a&&r[1]){var s=r[1].length;r.index+=s,r[0]=r[0].slice(s);}return r}function o(e,t,n){var a=t.next,r={value:n,prev:t,next:a};return t.next=r,a.prev=r,e.length++,r}function l(e,t,n){for(var a=t.next,r=0;r<n&&a!==e.tail;r++)a=a.next;t.next=a,a.prev=t,e.length-=r;}if(e.Prism=r,s.stringify=function e(t,n){if("string"==typeof t)return t;if(Array.isArray(t)){var a="";return t.forEach(function(t){a+=e(t,n);}),a}var s={type:t.type,content:e(t.content,n),tag:"span",classes:["token",t.type],attributes:{},language:n},i=t.alias;i&&(Array.isArray(i)?Array.prototype.push.apply(s.classes,i):s.classes.push(i)),r.hooks.run("wrap",s);var o="";for(var l in s.attributes)o+=" "+l+'="'+(s.attributes[l]||"").replace(/"/g,"&quot;")+'"';return "<"+s.tag+' class="'+s.classes.join(" ")+'"'+o+">"+s.content+"</"+s.tag+">"},!e.document)return e.addEventListener?(r.disableWorkerMessageHandler||e.addEventListener("message",function(t){var n=JSON.parse(t.data),a=n.language,s=n.code,i=n.immediateClose;e.postMessage(r.highlight(s,r.languages[a],a)),i&&e.close();},!1),r):r;var c=r.util.currentScript();function u(){r.manual||r.highlightAll();}if(c&&(r.filename=c.src,c.hasAttribute("data-manual")&&(r.manual=!0)),!r.manual){var d=document.readyState;"loading"===d||"interactive"===d&&c&&c.defer?document.addEventListener("DOMContentLoaded",u):window.requestAnimationFrame?window.requestAnimationFrame(u):window.setTimeout(u,16);}return r}(_self);"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism),Prism.languages.markup={comment:{pattern:/<!--(?:(?!<!--)[\s\S])*?-->/,greedy:!0},prolog:{pattern:/<\?[\s\S]+?\?>/,greedy:!0},doctype:{pattern:/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,greedy:!0,inside:{"internal-subset":{pattern:/(^[^\[]*\[)[\s\S]+(?=\]>$)/,lookbehind:!0,greedy:!0,inside:null},string:{pattern:/"[^"]*"|'[^']*'/,greedy:!0},punctuation:/^<!|>$|[[\]]/,"doctype-tag":/^DOCTYPE/i,name:/[^\s<>'"]+/}},cdata:{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,greedy:!0},tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"special-attr":[],"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,inside:{punctuation:[{pattern:/^=/,alias:"attr-equals"},{pattern:/^(\s*)["']|["']$/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:[{pattern:/&[\da-z]{1,8};/i,alias:"named-entity"},/&#x?[\da-f]{1,8};/i]},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.languages.markup.doctype.inside["internal-subset"].inside=Prism.languages.markup,Prism.hooks.add("wrap",function(e){"entity"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,"&"));}),Object.defineProperty(Prism.languages.markup.tag,"addInlined",{value:function(e,t){var n={};n["language-"+t]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:!0,inside:Prism.languages[t]},n.cdata=/^<!\[CDATA\[|\]\]>$/i;var a={"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:n}};a["language-"+t]={pattern:/[\s\S]+/,inside:Prism.languages[t]};var r={};r[e]={pattern:RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g,function(){return e}),"i"),lookbehind:!0,greedy:!0,inside:a},Prism.languages.insertBefore("markup","cdata",r);}}),Object.defineProperty(Prism.languages.markup.tag,"addAttribute",{value:function(e,t){Prism.languages.markup.tag.inside["special-attr"].push({pattern:RegExp(/(^|["'\s])/.source+"(?:"+e+")"+/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,"i"),lookbehind:!0,inside:{"attr-name":/^[^\s=]+/,"attr-value":{pattern:/=[\s\S]+/,inside:{value:{pattern:/(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,lookbehind:!0,alias:[t,"language-"+t],inside:Prism.languages[t]},punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}}}});}}),Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup,Prism.languages.xml=Prism.languages.extend("markup",{}),Prism.languages.ssml=Prism.languages.xml,Prism.languages.atom=Prism.languages.xml,Prism.languages.rss=Prism.languages.xml,function(e){var t=/(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;e.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:RegExp("@[\\w-](?:"+/[^;{\s"']|\s+(?!\s)/.source+"|"+t.source+")*?"+/(?:;|(?=\s*\{))/.source),inside:{rule:/^@[\w-]+/,"selector-function-argument":{pattern:/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,lookbehind:!0,alias:"selector"},keyword:{pattern:/(^|[^\w-])(?:and|not|only|or)(?![\w-])/,lookbehind:!0}}},url:{pattern:RegExp("\\burl\\((?:"+t.source+"|"+/(?:[^\\\r\n()"']|\\[\s\S])*/.source+")\\)","i"),greedy:!0,inside:{function:/^url/i,punctuation:/^\(|\)$/,string:{pattern:RegExp("^"+t.source+"$"),alias:"url"}}},selector:{pattern:RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|"+t.source+")*(?=\\s*\\{)"),lookbehind:!0},string:{pattern:t,greedy:!0},property:{pattern:/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,lookbehind:!0},important:/!important\b/i,function:{pattern:/(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,lookbehind:!0},punctuation:/[(){};:,]/},e.languages.css.atrule.inside.rest=e.languages.css;var n=e.languages.markup;n&&(n.tag.addInlined("style","css"),n.tag.addAttribute("style","css"));}(Prism),Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0,greedy:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,boolean:/\b(?:false|true)\b/,function:/\b\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,punctuation:/[{}[\];(),.:]/},Prism.languages.javascript=Prism.languages.extend("clike",{"class-name":[Prism.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype))/,lookbehind:!0}],keyword:[{pattern:/((?:^|\})\s*)catch\b/,lookbehind:!0},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|window|document|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|of|package|private|protected|public|return|static|super|switch|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],function:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,number:{pattern:RegExp(/(^|[^\w$])/.source+"(?:"+/NaN|Infinity|null/.source+"|"+/0[bB][01]+(?:_[01]+)*n?/.source+"|"+/0[oO][0-7]+(?:_[0-7]+)*n?/.source+"|"+/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source+"|"+/\d+(?:_\d+)*n/.source+"|"+/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source+")"+/(?![\w$])/.source),lookbehind:!0},operator:/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?/}),Prism.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new|)\s+)[\w.\\]+/,Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source+/\//.source+"(?:"+/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source+"|"+/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source+")"+/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),lookbehind:!0,greedy:!0,inside:{"regex-source":{pattern:/^(\/)[\s\S]+(?=\/[a-z]*$)/,lookbehind:!0,alias:"language-regex",inside:Prism.languages.regex},"regex-delimiter":/^\/|\/$/,"regex-flags":/^[a-z]+$/}},"function-variable":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,alias:"function"},"function-extra":{pattern:/(?:constructor)/,alias:"keyword"},"keyword-variable":{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|continue|debugger|default|delete|do|else|enum|export|default|extends|for|from|(?:get|set)(?=\s*[\[$\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|new|of|package|private|protected|public|return|static|super|switch|throw|try|typeof|undefined|void|while|with|yield)\b/,alias:"keyword"},"parameter-variable":{pattern:/this/,alias:"keyword"},parameter:[{pattern:/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,inside:Prism.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,lookbehind:!0,inside:Prism.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),Prism.languages.insertBefore("javascript","string",{hashbang:{pattern:/^#!.*/,greedy:!0,alias:"comment"},"template-string":{pattern:/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}},"string-property":{pattern:/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,lookbehind:!0,greedy:!0,alias:"property"}}),Prism.languages.markup&&(Prism.languages.markup.tag.addInlined("script","javascript"),Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,"javascript")),Prism.languages.js=Prism.languages.javascript,Prism.languages.c=Prism.languages.extend("clike",{comment:{pattern:/\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,greedy:!0},string:{pattern:/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,greedy:!0},"class-name":{pattern:/(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,lookbehind:!0},keyword:/\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,function:/\b[a-z_]\w*(?=\s*\()/i,number:/(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/}),Prism.languages.insertBefore("c","string",{char:{pattern:/'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,greedy:!0}}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,lookbehind:!0,greedy:!0,alias:"property",inside:{string:[{pattern:/^(#\s*include\s*)<[^>]+>/,lookbehind:!0},Prism.languages.c.string],char:Prism.languages.c.char,comment:Prism.languages.c.comment,"macro-name":[{pattern:/(^#\s*define\s+)\w+\b(?!\()/i,lookbehind:!0},{pattern:/(^#\s*define\s+)\w+\b(?=\()/i,lookbehind:!0,alias:"function"}],directive:{pattern:/^(#\s*)[a-z]+/,lookbehind:!0,alias:"keyword"},"directive-hash":/^#/,punctuation:/##|\\(?=[\r\n])/,expression:{pattern:/\S[\s\S]*/,inside:Prism.languages.c}}}}),Prism.languages.insertBefore("c","function",{constant:/\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/}),delete Prism.languages.c.boolean,Prism.languages.glsl=Prism.languages.extend("c",{keyword:/\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/});var CodeFlask=function(e,t){if(!e)throw Error("CodeFlask expects a parameter which is Element or a String selector");if(!t)throw Error("CodeFlask expects an object containing options as second parameter");if(e.nodeType)this.editorRoot=e;else {var n=document.querySelector(e);n&&(this.editorRoot=n);}this.opts=t,this.startEditor();};CodeFlask.prototype.clear=function(){this.elPre.removeChild(this.elCode),this.opts.lineNumbers&&this.elWrapper.removeChild(this.elLineNumbers),this.elWrapper.removeChild(this.elPre),this.elWrapper.removeChild(this.elTextarea),this.editorRoot.removeChild(this.elWrapper),this.code="",this.editorRoot.innerHTML="";},CodeFlask.prototype.startEditor=function(){if(!injectCss(editorCss,null,this.opts.styleParent))throw Error("Failed to inject CodeFlask CSS.");this.isEdit=!1,this.createWrapper(),this.createTextarea(),this.createPre(),this.createCode(),this.runOptions(),this.listenTextarea(),this.populateDefault(),this.updateCode(this.code);},CodeFlask.prototype.getDom=function(){return this.elWrapper},CodeFlask.prototype.getText=function(){return this.elTextarea},CodeFlask.prototype.createWrapper=function(){this.code=this.editorRoot.innerHTML,this.editorRoot.innerHTML="",this.elWrapper=this.createElement("div",this.editorRoot),this.elWrapper.classList.add("codeflask");},CodeFlask.prototype.createTextarea=function(){this.elTextarea=this.createElement("textarea",this.elWrapper),this.elTextarea.classList.add("codeflask__textarea","codeflask__flatten");},CodeFlask.prototype.createPre=function(){this.elPre=this.createElement("pre",this.elWrapper),this.elPre.classList.add("codeflask__pre","codeflask__flatten");},CodeFlask.prototype.createCode=function(){this.elCode=this.createElement("code",this.elPre),this.elCode.classList.add("codeflask__code","language-"+(this.opts.language||"html"));},CodeFlask.prototype.createLineNumbers=function(){this.elLineNumbers=this.createElement("div",this.elWrapper),this.elLineNumbers.classList.add("codeflask__lines"),this.setLineNumber();},CodeFlask.prototype.createError=function(){this.elError=this.createElement("div",this.elWrapper),this.elError.classList.add("codeflask__error");},CodeFlask.prototype.createElement=function(e,t){var n=document.createElement(e);return t.appendChild(n),n},CodeFlask.prototype.runOptions=function(){this.opts.rtl=this.opts.rtl||!1,this.opts.tabSize=this.opts.tabSize||4,this.opts.enableAutocorrect=this.opts.enableAutocorrect||!1,this.opts.lineNumbers=this.opts.lineNumbers||!1,this.opts.defaultTheme=!1!==this.opts.defaultTheme,this.opts.areaId=this.opts.areaId||null,this.opts.ariaLabelledby=this.opts.ariaLabelledby||null,this.opts.readonly=this.opts.readonly||null,"boolean"!=typeof this.opts.handleTabs&&(this.opts.handleTabs=!0),"boolean"!=typeof this.opts.handleSelfClosingCharacters&&(this.opts.handleSelfClosingCharacters=!0),"boolean"!=typeof this.opts.handleNewLineIndentation&&(this.opts.handleNewLineIndentation=!0),!0===this.opts.rtl&&(this.elTextarea.setAttribute("dir","rtl"),this.elPre.setAttribute("dir","rtl")),!1===this.opts.enableAutocorrect&&(this.elTextarea.setAttribute("spellcheck","false"),this.elTextarea.setAttribute("autocapitalize","off"),this.elTextarea.setAttribute("autocomplete","off"),this.elTextarea.setAttribute("autocorrect","off")),this.opts.lineNumbers&&(this.elWrapper.classList.add("codeflask--has-line-numbers"),this.createLineNumbers(),this.createError()),this.opts.defaultTheme&&injectCss(defaultCssTheme,"theme-default",this.opts.styleParent),this.opts.areaId&&this.elTextarea.setAttribute("id",this.opts.areaId),this.opts.ariaLabelledby&&this.elTextarea.setAttribute("aria-labelledby",this.opts.ariaLabelledby),this.opts.readonly&&this.enableReadonlyMode();},CodeFlask.prototype.updateLineNumbersCount=function(){for(var e="",t=1;t<=this.lineNumber;t++)e=e+'<span class="codeflask__lines__line">'+t+"</span>";this.elLineNumbers.innerHTML=e;},CodeFlask.prototype.listenTextarea=function(){var e=this;this.elTextarea.addEventListener("input",function(t){e.code=t.target.value,e.elCode.innerHTML=escapeHtml(t.target.value),e.highlight(),setTimeout(function(){e.runUpdate(),e.setLineNumber();},1);}),this.elTextarea.addEventListener("keydown",function(t){if(!e.opts.readonly){e.handleTabs(t),e.handleSelfClosingCharacters(t),e.handleNewLineIndentation(t),e.isEdit=!0;}}),this.elTextarea.addEventListener("scroll",function(t){e.scroll(t);});},CodeFlask.prototype.wheel=function(e){var t=e.deltaY>0?1:-1;this.elTextarea.scrollTop+=100*t,this.elPre.style.transform="translate3d(0, -"+this.elTextarea.scrollTop+"px, 0)",this.elLineNumbers&&(this.elLineNumbers.style.transform="translate3d(0, -"+this.elTextarea.scrollTop+"px, 0)"),this.elError&&(this.elError.style.transform="translate3d(0, -"+this.elTextarea.scrollTop+"px, 0)");},CodeFlask.prototype.scroll=function(e){this.elPre.style.transform="translate3d(-"+e.target.scrollLeft+"px, -"+e.target.scrollTop+"px, 0)",this.elLineNumbers&&(this.elLineNumbers.style.transform="translate3d(-"+this.elTextarea.scrollLeft+"px, -"+e.target.scrollTop+"px, 0)"),this.elError&&(this.elError.style.transform="translate3d(-"+this.elTextarea.scrollLeft+"px, -"+e.target.scrollTop+"px, 0)");},CodeFlask.prototype.handleTabs=function(e){if(this.opts.handleTabs){if(9!==e.keyCode)return !1;e.preventDefault();var t=this.elTextarea,n=t.selectionDirection,a=t.selectionStart,r=t.selectionEnd,s=t.value,i=s.substr(0,a),o=s.substring(a,r),l=s.substring(r),c=" ".repeat(this.opts.tabSize);if(a!==r&&o.length>=c.length){var u=a-i.split("\n").pop().length,d=c.length,p=c.length;if(e.shiftKey)s.substr(u,c.length)===c?(d=-d,u>a?(o=o.substring(0,u)+o.substring(u+c.length),p=0):u===a?(d=0,p=0,o=o.substring(c.length)):(p=-p,i=i.substring(0,u)+i.substring(u+c.length))):(d=0,p=0),o=o.replace(new RegExp("\n"+c.split("").join("\\"),"g"),"\n");else i=i.substr(0,u)+c+i.substring(u,a),o=o.replace(/\n/g,"\n"+c);t.value=i+o+l,t.selectionStart=a+d,t.selectionEnd=a+o.length+p,t.selectionDirection=n;}else t.value=i+c+l,t.selectionStart=a+c.length,t.selectionEnd=a+c.length;var h=t.value;this.updateCode(h),this.elTextarea.selectionEnd=r+this.opts.tabSize;}return !0},CodeFlask.prototype.handleSelfClosingCharacters=function(e){if(this.opts.handleSelfClosingCharacters){var t=e.key;if(!["(","[","{","<","'",'"'].includes(t)&&![")","]","}",">","'",'"'].includes(t))return !1;switch(t){case"(":case")":this.closeCharacter(t);break;case"[":case"]":this.closeCharacter(t);break;case"{":case"}":this.closeCharacter(t);break;case"<":case">":case"'":case'"':this.closeCharacter(t);}return !0}},CodeFlask.prototype.setLineNumber=function(){this.lineNumber=this.code.split("\n").length,this.opts.lineNumbers&&this.updateLineNumbersCount();},CodeFlask.prototype.handleNewLineIndentation=function(e){if(!this.opts.handleNewLineIndentation)return !1;if(13!==e.keyCode)return !1;e.preventDefault();var t=this.elTextarea,n=t.selectionStart,a=t.selectionEnd,r=t.value,s=r.substr(0,n),i=r.substring(a),o=r.lastIndexOf("\n",n-1),l=o+r.slice(o+1).search(/[^ ]|$/),c=l>o?l-o:0,u=s+"\n"+" ".repeat(c)+i;return t.value=u,t.selectionStart=n+c+1,t.selectionEnd=n+c+1,this.updateCode(t.value),!0},CodeFlask.prototype.closeCharacter=function(e){var t=this.elTextarea.selectionStart,n=this.elTextarea.selectionEnd;if(this.skipCloseChar(e)){var a=this.code.substr(n,1)===e,r=a?n+1:n,s=!a&&["'",'"'].includes(e)?e:"",i=""+this.code.substring(0,t)+s+this.code.substring(r);this.updateCode(i),this.elTextarea.selectionEnd=++this.elTextarea.selectionStart;}else {var o=e;switch(e){case"(":o=String.fromCharCode(e.charCodeAt()+1);break;case"<":case"{":case"[":o=String.fromCharCode(e.charCodeAt()+2);}var l=this.code.substring(t,n),c=""+this.code.substring(0,t)+l+o+this.code.substring(n);this.updateCode(c);}this.elTextarea.selectionEnd=t;},CodeFlask.prototype.skipCloseChar=function(e){var t=this.elTextarea.selectionStart,n=this.elTextarea.selectionEnd,a=Math.abs(n-t)>0;return [")","}","]",">"].includes(e)||["'",'"'].includes(e)&&!a},CodeFlask.prototype.updateCode=function(e){this.isEdit=!1,this.code=e,this.elTextarea.value=e,this.elCode.innerHTML=escapeHtml(e),this.highlight(),this.setLineNumber(),setTimeout(this.runUpdate.bind(this),1);},CodeFlask.prototype.updateLanguage=function(e){var t=this.opts.language;this.elCode.classList.remove("language-"+t),this.elCode.classList.add("language-"+e),this.opts.language=e,this.highlight();},CodeFlask.prototype.addLanguage=function(e,t){Prism.languages[e]=t;},CodeFlask.prototype.populateDefault=function(){this.updateCode(this.code);},CodeFlask.prototype.highlight=function(){Prism.highlightElement(this.elCode,!1);},CodeFlask.prototype.onUpdate=function(e){if(e&&"[object Function]"!=={}.toString.call(e))throw Error("CodeFlask expects callback of type Function");this.updateCallBack=e;},CodeFlask.prototype.getCode=function(){return this.code},CodeFlask.prototype.runUpdate=function(){this.updateCallBack&&this.updateCallBack(this.code);},CodeFlask.prototype.enableReadonlyMode=function(){this.elTextarea.setAttribute("readonly",!0);},CodeFlask.prototype.disableReadonlyMode=function(){this.elTextarea.removeAttribute("readonly");},CodeFlask.prototype.noError=function(){this.elError&&(this.elError.innerHTML="",this.elError.style.display="none");},CodeFlask.prototype.addError=function(e,t,n){this.elError&&(this.elError.style.display="block",this.elError.innerHTML=t,this.elError.style.marginTop=19*t-9+"px");};

class Text{constructor(){}lineAt(e){if(e<0||e>this.length)throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);return this.lineInner(e,!1,1,0)}line(e){if(e<1||e>this.lines)throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);return this.lineInner(e,!0,1,0)}replace(e,t,i){let n=[];return this.decompose(0,e,n,2),i.length&&i.decompose(0,i.length,n,3),this.decompose(t,this.length,n,1),TextNode.from(n,this.length-(t-e)+i.length)}append(e){return this.replace(this.length,this.length,e)}slice(e,t=this.length){let i=[];return this.decompose(e,t,i,0),TextNode.from(i,t-e)}eq(e){if(e==this)return !0;if(e.length!=this.length||e.lines!=this.lines)return !1;let t=this.scanIdentical(e,1),i=this.length-this.scanIdentical(e,-1),n=new RawTextCursor(this),o=new RawTextCursor(e);for(let e=t,r=t;;){if(n.next(e),o.next(e),e=0,n.lineBreak!=o.lineBreak||n.done!=o.done||n.value!=o.value)return !1;if(r+=n.value.length,n.done||r>=i)return !0}}iter(e=1){return new RawTextCursor(this,e)}iterRange(e,t=this.length){return new PartialTextCursor(this,e,t)}iterLines(e,t){let i;if(null==e)i=this.iter();else {null==t&&(t=this.lines+1);let n=this.line(e).from;i=this.iterRange(n,Math.max(n,t==this.lines+1?this.length:t<=1?0:this.line(t-1).to));}return new LineCursor(i)}toString(){return this.sliceString(0)}toJSON(){let e=[];return this.flatten(e),e}static of(e){if(0==e.length)throw new RangeError("A document must have at least one line");return 1!=e.length||e[0]?e.length<=32?new TextLeaf(e):TextNode.from(TextLeaf.split(e,[])):Text.empty}}class TextLeaf extends Text{constructor(e,t=textLength(e)){super(),this.text=e,this.length=t;}get lines(){return this.text.length}get children(){return null}lineInner(e,t,i,n){for(let o=0;;o++){let r=this.text[o],s=n+r.length;if((t?i:s)>=e)return new Line(n,s,i,r);n=s+1,i++;}}decompose(e,t,i,n){let o=e<=0&&t>=this.length?this:new TextLeaf(sliceText(this.text,e,t),Math.min(t,this.length)-Math.max(0,e));if(1&n){let e=i.pop(),t=appendText(o.text,e.text.slice(),0,o.length);if(t.length<=32)i.push(new TextLeaf(t,e.length+o.length));else {let e=t.length>>1;i.push(new TextLeaf(t.slice(0,e)),new TextLeaf(t.slice(e)));}}else i.push(o);}replace(e,t,i){if(!(i instanceof TextLeaf))return super.replace(e,t,i);let n=appendText(this.text,appendText(i.text,sliceText(this.text,0,e)),t),o=this.length+i.length-(t-e);return n.length<=32?new TextLeaf(n,o):TextNode.from(TextLeaf.split(n,[]),o)}sliceString(e,t=this.length,i="\n"){let n="";for(let o=0,r=0;o<=t&&r<this.text.length;r++){let s=this.text[r],a=o+s.length;o>e&&r&&(n+=i),e<a&&t>o&&(n+=s.slice(Math.max(0,e-o),t-o)),o=a+1;}return n}flatten(e){for(let t of this.text)e.push(t);}scanIdentical(){return 0}static split(e,t){let i=[],n=-1;for(let o of e)i.push(o),n+=o.length+1,32==i.length&&(t.push(new TextLeaf(i,n)),i=[],n=-1);return n>-1&&t.push(new TextLeaf(i,n)),t}}class TextNode extends Text{constructor(e,t){super(),this.children=e,this.length=t,this.lines=0;for(let t of e)this.lines+=t.lines;}lineInner(e,t,i,n){for(let o=0;;o++){let r=this.children[o],s=n+r.length,a=i+r.lines-1;if((t?a:s)>=e)return r.lineInner(e,t,i,n);n=s+1,i=a+1;}}decompose(e,t,i,n){for(let o=0,r=0;r<=t&&o<this.children.length;o++){let s=this.children[o],a=r+s.length;if(e<=a&&t>=r){let o=n&((r<=e?1:0)|(a>=t?2:0));r>=e&&a<=t&&!o?i.push(s):s.decompose(e-r,t-r,i,o);}r=a+1;}}replace(e,t,i){if(i.lines<this.lines)for(let n=0,o=0;n<this.children.length;n++){let r=this.children[n],s=o+r.length;if(e>=o&&t<=s){let a=r.replace(e-o,t-o,i),l=this.lines-r.lines+a.lines;if(a.lines<l>>4&&a.lines>l>>6){let o=this.children.slice();return o[n]=a,new TextNode(o,this.length-(t-e)+i.length)}return super.replace(o,s,a)}o=s+1;}return super.replace(e,t,i)}sliceString(e,t=this.length,i="\n"){let n="";for(let o=0,r=0;o<this.children.length&&r<=t;o++){let s=this.children[o],a=r+s.length;r>e&&o&&(n+=i),e<a&&t>r&&(n+=s.sliceString(e-r,t-r,i)),r=a+1;}return n}flatten(e){for(let t of this.children)t.flatten(e);}scanIdentical(e,t){if(!(e instanceof TextNode))return 0;let i=0,[n,o,r,s]=t>0?[0,0,this.children.length,e.children.length]:[this.children.length-1,e.children.length-1,-1,-1];for(;;n+=t,o+=t){if(n==r||o==s)return i;let a=this.children[n],l=e.children[o];if(a!=l)return i+a.scanIdentical(l,t);i+=a.length+1;}}static from(e,t=e.reduce((e,t)=>e+t.length+1,-1)){let i=0;for(let t of e)i+=t.lines;if(i<32){let i=[];for(let t of e)t.flatten(i);return new TextLeaf(i,t)}let n=Math.max(32,i>>5),o=n<<1,r=n>>1,s=[],a=0,l=-1,h=[];function c(e){let t;if(e.lines>o&&e instanceof TextNode)for(let t of e.children)c(t);else e.lines>r&&(a>r||!a)?(d(),s.push(e)):e instanceof TextLeaf&&a&&(t=h[h.length-1])instanceof TextLeaf&&e.lines+t.lines<=32?(a+=e.lines,l+=e.length+1,h[h.length-1]=new TextLeaf(t.text.concat(e.text),t.length+1+e.length)):(a+e.lines>n&&d(),a+=e.lines,l+=e.length+1,h.push(e));}function d(){0!=a&&(s.push(1==h.length?h[0]:TextNode.from(h,l)),l=-1,a=h.length=0);}for(let t of e)c(t);return d(),1==s.length?s[0]:new TextNode(s,t)}}function textLength(e){let t=-1;for(let i of e)t+=i.length+1;return t}function appendText(e,t,i=0,n=1e9){for(let o=0,r=0,s=!0;r<e.length&&o<=n;r++){let a=e[r],l=o+a.length;l>=i&&(l>n&&(a=a.slice(0,n-o)),o<i&&(a=a.slice(i-o)),s?(t[t.length-1]+=a,s=!1):t.push(a)),o=l+1;}return t}function sliceText(e,t,i){return appendText(e,[""],t,i)}Text.empty=new TextLeaf([""],0);class RawTextCursor{constructor(e,t=1){this.dir=t,this.done=!1,this.lineBreak=!1,this.value="",this.nodes=[e],this.offsets=[t>0?1:(e instanceof TextLeaf?e.text.length:e.children.length)<<1];}nextInner(e,t){for(this.done=this.lineBreak=!1;;){let i=this.nodes.length-1,n=this.nodes[i],o=this.offsets[i],r=o>>1,s=n instanceof TextLeaf?n.text.length:n.children.length;if(r==(t>0?s:0)){if(0==i)return this.done=!0,this.value="",this;t>0&&this.offsets[i-1]++,this.nodes.pop(),this.offsets.pop();}else if((1&o)==(t>0?0:1)){if(this.offsets[i]+=t,0==e)return this.lineBreak=!0,this.value="\n",this;e--;}else if(n instanceof TextLeaf){let o=n.text[r+(t<0?-1:0)];if(this.offsets[i]+=t,o.length>Math.max(0,e))return this.value=0==e?o:t>0?o.slice(e):o.slice(0,o.length-e),this;e-=o.length;}else {let o=n.children[r+(t<0?-1:0)];e>o.length?(e-=o.length,this.offsets[i]+=t):(t<0&&this.offsets[i]--,this.nodes.push(o),this.offsets.push(t>0?1:(o instanceof TextLeaf?o.text.length:o.children.length)<<1));}}}next(e=0){return e<0&&(this.nextInner(-e,-this.dir),e=this.value.length),this.nextInner(e,this.dir)}}class PartialTextCursor{constructor(e,t,i){this.value="",this.done=!1,this.cursor=new RawTextCursor(e,t>i?-1:1),this.pos=t>i?e.length:0,this.from=Math.min(t,i),this.to=Math.max(t,i);}nextInner(e,t){if(t<0?this.pos<=this.from:this.pos>=this.to)return this.value="",this.done=!0,this;e+=Math.max(0,t<0?this.pos-this.to:this.from-this.pos);let i=t<0?this.pos-this.from:this.to-this.pos;e>i&&(e=i),i-=e;let{value:n}=this.cursor.next(e);return this.pos+=(n.length+e)*t,this.value=n.length<=i?n:t<0?n.slice(n.length-i):n.slice(0,i),this.done=!this.value,this}next(e=0){return e<0?e=Math.max(e,this.from-this.pos):e>0&&(e=Math.min(e,this.to-this.pos)),this.nextInner(e,this.cursor.dir)}get lineBreak(){return this.cursor.lineBreak&&""!=this.value}}class LineCursor{constructor(e){this.inner=e,this.afterBreak=!0,this.value="",this.done=!1;}next(e=0){let{done:t,lineBreak:i,value:n}=this.inner.next(e);return t?(this.done=!0,this.value=""):i?this.afterBreak?this.value="":(this.afterBreak=!0,this.next()):(this.value=n,this.afterBreak=!1),this}get lineBreak(){return !1}}"undefined"!=typeof Symbol&&(Text.prototype[Symbol.iterator]=function(){return this.iter()},RawTextCursor.prototype[Symbol.iterator]=PartialTextCursor.prototype[Symbol.iterator]=LineCursor.prototype[Symbol.iterator]=function(){return this});class Line{constructor(e,t,i,n){this.from=e,this.to=t,this.number=i,this.text=n;}get length(){return this.to-this.from}}let extend="lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(e=>e?parseInt(e,36):1);for(let e=1;e<extend.length;e++)extend[e]+=extend[e-1];function isExtendingChar(e){for(let t=1;t<extend.length;t+=2)if(extend[t]>e)return extend[t-1]<=e;return !1}function isRegionalIndicator(e){return e>=127462&&e<=127487}const ZWJ=8205;function findClusterBreak(e,t,i=!0,n=!0){return (i?nextClusterBreak:prevClusterBreak)(e,t,n)}function nextClusterBreak(e,t,i){if(t==e.length)return t;t&&surrogateLow(e.charCodeAt(t))&&surrogateHigh(e.charCodeAt(t-1))&&t--;let n=codePointAt(e,t);for(t+=codePointSize(n);t<e.length;){let o=codePointAt(e,t);if(n==ZWJ||o==ZWJ||i&&isExtendingChar(o))t+=codePointSize(o),n=o;else {if(!isRegionalIndicator(o))break;{let i=0,n=t-2;for(;n>=0&&isRegionalIndicator(codePointAt(e,n));)i++,n-=2;if(i%2==0)break;t+=2;}}}return t}function prevClusterBreak(e,t,i){for(;t>0;){let n=nextClusterBreak(e,t-2,i);if(n<t)return n;t--;}return 0}function surrogateLow(e){return e>=56320&&e<57344}function surrogateHigh(e){return e>=55296&&e<56320}function codePointAt(e,t){let i=e.charCodeAt(t);if(!surrogateHigh(i)||t+1==e.length)return i;let n=e.charCodeAt(t+1);return surrogateLow(n)?n-56320+(i-55296<<10)+65536:i}function fromCodePoint(e){return e<=65535?String.fromCharCode(e):(e-=65536,String.fromCharCode(55296+(e>>10),56320+(1023&e)))}function codePointSize(e){return e<65536?1:2}const DefaultSplit=/\r\n?|\n/;var MapMode=function(e){return e[e.Simple=0]="Simple",e[e.TrackDel=1]="TrackDel",e[e.TrackBefore=2]="TrackBefore",e[e.TrackAfter=3]="TrackAfter",e}(MapMode||(MapMode={}));class ChangeDesc{constructor(e){this.sections=e;}get length(){let e=0;for(let t=0;t<this.sections.length;t+=2)e+=this.sections[t];return e}get newLength(){let e=0;for(let t=0;t<this.sections.length;t+=2){let i=this.sections[t+1];e+=i<0?this.sections[t]:i;}return e}get empty(){return 0==this.sections.length||2==this.sections.length&&this.sections[1]<0}iterGaps(e){for(let t=0,i=0,n=0;t<this.sections.length;){let o=this.sections[t++],r=this.sections[t++];r<0?(e(i,n,o),n+=o):n+=r,i+=o;}}iterChangedRanges(e,t=!1){iterChanges(this,e,t);}get invertedDesc(){let e=[];for(let t=0;t<this.sections.length;){let i=this.sections[t++],n=this.sections[t++];n<0?e.push(i,n):e.push(n,i);}return new ChangeDesc(e)}composeDesc(e){return this.empty?e:e.empty?this:composeSets(this,e)}mapDesc(e,t=!1){return e.empty?this:mapSet(this,e,t)}mapPos(e,t=-1,i=MapMode.Simple){let n=0,o=0;for(let r=0;r<this.sections.length;){let s=this.sections[r++],a=this.sections[r++],l=n+s;if(a<0){if(l>e)return o+(e-n);o+=s;}else {if(i!=MapMode.Simple&&l>=e&&(i==MapMode.TrackDel&&n<e&&l>e||i==MapMode.TrackBefore&&n<e||i==MapMode.TrackAfter&&l>e))return null;if(l>e||l==e&&t<0&&!s)return e==n||t<0?o:o+a;o+=a;}n=l;}if(e>n)throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);return o}touchesRange(e,t=e){for(let i=0,n=0;i<this.sections.length&&n<=t;){let o=n+this.sections[i++];if(this.sections[i++]>=0&&n<=t&&o>=e)return !(n<e&&o>t)||"cover";n=o;}return !1}toString(){let e="";for(let t=0;t<this.sections.length;){let i=this.sections[t++],n=this.sections[t++];e+=(e?" ":"")+i+(n>=0?":"+n:"");}return e}toJSON(){return this.sections}static fromJSON(e){if(!Array.isArray(e)||e.length%2||e.some(e=>"number"!=typeof e))throw new RangeError("Invalid JSON representation of ChangeDesc");return new ChangeDesc(e)}static create(e){return new ChangeDesc(e)}}class ChangeSet extends ChangeDesc{constructor(e,t){super(e),this.inserted=t;}apply(e){if(this.length!=e.length)throw new RangeError("Applying change set to a document with the wrong length");return iterChanges(this,(t,i,n,o,r)=>e=e.replace(n,n+(i-t),r),!1),e}mapDesc(e,t=!1){return mapSet(this,e,t,!0)}invert(e){let t=this.sections.slice(),i=[];for(let n=0,o=0;n<t.length;n+=2){let r=t[n],s=t[n+1];if(s>=0){t[n]=s,t[n+1]=r;let a=n>>1;for(;i.length<a;)i.push(Text.empty);i.push(r?e.slice(o,o+r):Text.empty);}o+=r;}return new ChangeSet(t,i)}compose(e){return this.empty?e:e.empty?this:composeSets(this,e,!0)}map(e,t=!1){return e.empty?this:mapSet(this,e,t,!0)}iterChanges(e,t=!1){iterChanges(this,e,t);}get desc(){return ChangeDesc.create(this.sections)}filter(e){let t=[],i=[],n=[],o=new SectionIter(this);e:for(let r=0,s=0;;){let a=r==e.length?1e9:e[r++];for(;s<a||s==a&&0==o.len;){if(o.done)break e;let e=Math.min(o.len,a-s);addSection(n,e,-1);let r=-1==o.ins?-1:0==o.off?o.ins:0;addSection(t,e,r),r>0&&addInsert(i,t,o.text),o.forward(e),s+=e;}let l=e[r++];for(;s<l;){if(o.done)break e;let e=Math.min(o.len,l-s);addSection(t,e,-1),addSection(n,e,-1==o.ins?-1:0==o.off?o.ins:0),o.forward(e),s+=e;}}return {changes:new ChangeSet(t,i),filtered:ChangeDesc.create(n)}}toJSON(){let e=[];for(let t=0;t<this.sections.length;t+=2){let i=this.sections[t],n=this.sections[t+1];n<0?e.push(i):0==n?e.push([i]):e.push([i].concat(this.inserted[t>>1].toJSON()));}return e}static of(e,t,i){let n=[],o=[],r=0,s=null;function a(e=!1){if(!e&&!n.length)return;r<t&&addSection(n,t-r,-1);let i=new ChangeSet(n,o);s=s?s.compose(i.map(s)):i,n=[],o=[],r=0;}return function e(l){if(Array.isArray(l))for(let t of l)e(t);else if(l instanceof ChangeSet){if(l.length!=t)throw new RangeError(`Mismatched change set length (got ${l.length}, expected ${t})`);a(),s=s?s.compose(l.map(s)):l;}else {let{from:e,to:s=e,insert:h}=l;if(e>s||e<0||s>t)throw new RangeError(`Invalid change range ${e} to ${s} (in doc of length ${t})`);let c=h?"string"==typeof h?Text.of(h.split(i||DefaultSplit)):h:Text.empty,d=c.length;if(e==s&&0==d)return;e<r&&a(),e>r&&addSection(n,e-r,-1),addSection(n,s-e,d),addInsert(o,n,c),r=s;}}(e),a(!s),s}static empty(e){return new ChangeSet(e?[e,-1]:[],[])}static fromJSON(e){if(!Array.isArray(e))throw new RangeError("Invalid JSON representation of ChangeSet");let t=[],i=[];for(let n=0;n<e.length;n++){let o=e[n];if("number"==typeof o)t.push(o,-1);else {if(!Array.isArray(o)||"number"!=typeof o[0]||o.some((e,t)=>t&&"string"!=typeof e))throw new RangeError("Invalid JSON representation of ChangeSet");if(1==o.length)t.push(o[0],0);else {for(;i.length<n;)i.push(Text.empty);i[n]=Text.of(o.slice(1)),t.push(o[0],i[n].length);}}}return new ChangeSet(t,i)}static createSet(e,t){return new ChangeSet(e,t)}}function addSection(e,t,i,n=!1){if(0==t&&i<=0)return;let o=e.length-2;o>=0&&i<=0&&i==e[o+1]?e[o]+=t:0==t&&0==e[o]?e[o+1]+=i:n?(e[o]+=t,e[o+1]+=i):e.push(t,i);}function addInsert(e,t,i){if(0==i.length)return;let n=t.length-2>>1;if(n<e.length)e[e.length-1]=e[e.length-1].append(i);else {for(;e.length<n;)e.push(Text.empty);e.push(i);}}function iterChanges(e,t,i){let n=e.inserted;for(let o=0,r=0,s=0;s<e.sections.length;){let a=e.sections[s++],l=e.sections[s++];if(l<0)o+=a,r+=a;else {let h=o,c=r,d=Text.empty;for(;h+=a,c+=l,l&&n&&(d=d.append(n[s-2>>1])),!(i||s==e.sections.length||e.sections[s+1]<0);)a=e.sections[s++],l=e.sections[s++];t(o,h,r,c,d),o=h,r=c;}}}function mapSet(e,t,i,n=!1){let o=[],r=n?[]:null,s=new SectionIter(e),a=new SectionIter(t);for(let e=-1;;)if(-1==s.ins&&-1==a.ins){let e=Math.min(s.len,a.len);addSection(o,e,-1),s.forward(e),a.forward(e);}else if(a.ins>=0&&(s.ins<0||e==s.i||0==s.off&&(a.len<s.len||a.len==s.len&&!i))){let t=a.len;for(addSection(o,a.ins,-1);t;){let i=Math.min(s.len,t);s.ins>=0&&e<s.i&&s.len<=i&&(addSection(o,0,s.ins),r&&addInsert(r,o,s.text),e=s.i),s.forward(i),t-=i;}a.next();}else {if(!(s.ins>=0)){if(s.done&&a.done)return r?ChangeSet.createSet(o,r):ChangeDesc.create(o);throw new Error("Mismatched change set lengths")}{let t=0,i=s.len;for(;i;)if(-1==a.ins){let e=Math.min(i,a.len);t+=e,i-=e,a.forward(e);}else {if(!(0==a.ins&&a.len<i))break;i-=a.len,a.next();}addSection(o,t,e<s.i?s.ins:0),r&&e<s.i&&addInsert(r,o,s.text),e=s.i,s.forward(s.len-i);}}}function composeSets(e,t,i=!1){let n=[],o=i?[]:null,r=new SectionIter(e),s=new SectionIter(t);for(let e=!1;;){if(r.done&&s.done)return o?ChangeSet.createSet(n,o):ChangeDesc.create(n);if(0==r.ins)addSection(n,r.len,0,e),r.next();else if(0!=s.len||s.done){if(r.done||s.done)throw new Error("Mismatched change set lengths");{let t=Math.min(r.len2,s.len),i=n.length;if(-1==r.ins){let i=-1==s.ins?-1:s.off?0:s.ins;addSection(n,t,i,e),o&&i&&addInsert(o,n,s.text);}else -1==s.ins?(addSection(n,r.off?0:r.len,t,e),o&&addInsert(o,n,r.textBit(t))):(addSection(n,r.off?0:r.len,s.off?0:s.ins,e),o&&!s.off&&addInsert(o,n,s.text));e=(r.ins>t||s.ins>=0&&s.len>t)&&(e||n.length>i),r.forward2(t),s.forward(t);}}else addSection(n,0,s.ins,e),o&&addInsert(o,n,s.text),s.next();}}class SectionIter{constructor(e){this.set=e,this.i=0,this.next();}next(){let{sections:e}=this.set;this.i<e.length?(this.len=e[this.i++],this.ins=e[this.i++]):(this.len=0,this.ins=-2),this.off=0;}get done(){return -2==this.ins}get len2(){return this.ins<0?this.len:this.ins}get text(){let{inserted:e}=this.set,t=this.i-2>>1;return t>=e.length?Text.empty:e[t]}textBit(e){let{inserted:t}=this.set,i=this.i-2>>1;return i>=t.length&&!e?Text.empty:t[i].slice(this.off,null==e?void 0:this.off+e)}forward(e){e==this.len?this.next():(this.len-=e,this.off+=e);}forward2(e){-1==this.ins?this.forward(e):e==this.ins?this.next():(this.ins-=e,this.off+=e);}}class SelectionRange{constructor(e,t,i){this.from=e,this.to=t,this.flags=i;}get anchor(){return 16&this.flags?this.to:this.from}get head(){return 16&this.flags?this.from:this.to}get empty(){return this.from==this.to}get assoc(){return 4&this.flags?-1:8&this.flags?1:0}get bidiLevel(){let e=3&this.flags;return 3==e?null:e}get goalColumn(){let e=this.flags>>5;return 33554431==e?void 0:e}map(e,t=-1){let i,n;return this.empty?i=n=e.mapPos(this.from,t):(i=e.mapPos(this.from,1),n=e.mapPos(this.to,-1)),i==this.from&&n==this.to?this:new SelectionRange(i,n,this.flags)}extend(e,t=e){if(e<=this.anchor&&t>=this.anchor)return EditorSelection.range(e,t);let i=Math.abs(e-this.anchor)>Math.abs(t-this.anchor)?e:t;return EditorSelection.range(this.anchor,i)}eq(e){return this.anchor==e.anchor&&this.head==e.head}toJSON(){return {anchor:this.anchor,head:this.head}}static fromJSON(e){if(!e||"number"!=typeof e.anchor||"number"!=typeof e.head)throw new RangeError("Invalid JSON representation for SelectionRange");return EditorSelection.range(e.anchor,e.head)}static create(e,t,i){return new SelectionRange(e,t,i)}}class EditorSelection{constructor(e,t){this.ranges=e,this.mainIndex=t;}map(e,t=-1){return e.empty?this:EditorSelection.create(this.ranges.map(i=>i.map(e,t)),this.mainIndex)}eq(e){if(this.ranges.length!=e.ranges.length||this.mainIndex!=e.mainIndex)return !1;for(let t=0;t<this.ranges.length;t++)if(!this.ranges[t].eq(e.ranges[t]))return !1;return !0}get main(){return this.ranges[this.mainIndex]}asSingle(){return 1==this.ranges.length?this:new EditorSelection([this.main],0)}addRange(e,t=!0){return EditorSelection.create([e].concat(this.ranges),t?0:this.mainIndex+1)}replaceRange(e,t=this.mainIndex){let i=this.ranges.slice();return i[t]=e,EditorSelection.create(i,this.mainIndex)}toJSON(){return {ranges:this.ranges.map(e=>e.toJSON()),main:this.mainIndex}}static fromJSON(e){if(!e||!Array.isArray(e.ranges)||"number"!=typeof e.main||e.main>=e.ranges.length)throw new RangeError("Invalid JSON representation for EditorSelection");return new EditorSelection(e.ranges.map(e=>SelectionRange.fromJSON(e)),e.main)}static single(e,t=e){return new EditorSelection([EditorSelection.range(e,t)],0)}static create(e,t=0){if(0==e.length)throw new RangeError("A selection needs at least one range");for(let i=0,n=0;n<e.length;n++){let o=e[n];if(o.empty?o.from<=i:o.from<i)return EditorSelection.normalized(e.slice(),t);i=o.to;}return new EditorSelection(e,t)}static cursor(e,t=0,i,n){return SelectionRange.create(e,e,(0==t?0:t<0?4:8)|(null==i?3:Math.min(2,i))|(null!==n&&void 0!==n?n:33554431)<<5)}static range(e,t,i){let n=(null!==i&&void 0!==i?i:33554431)<<5;return t<e?SelectionRange.create(t,e,24|n):SelectionRange.create(e,t,n|(t>e?4:0))}static normalized(e,t=0){let i=e[t];e.sort((e,t)=>e.from-t.from),t=e.indexOf(i);for(let i=1;i<e.length;i++){let n=e[i],o=e[i-1];if(n.empty?n.from<=o.to:n.from<o.to){let r=o.from,s=Math.max(n.to,o.to);i<=t&&t--,e.splice(--i,2,n.anchor>n.head?EditorSelection.range(s,r):EditorSelection.range(r,s));}}return new EditorSelection(e,t)}}function checkSelection(e,t){for(let i of e.ranges)if(i.to>t)throw new RangeError("Selection points outside of document")}let nextID=0;class Facet{constructor(e,t,i,n,o){this.combine=e,this.compareInput=t,this.compare=i,this.isStatic=n,this.id=nextID++,this.default=e([]),this.extensions="function"==typeof o?o(this):o;}static define(e={}){return new Facet(e.combine||(e=>e),e.compareInput||((e,t)=>e===t),e.compare||(e.combine?(e,t)=>e===t:sameArray),!!e.static,e.enables)}of(e){return new FacetProvider([],this,0,e)}compute(e,t){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(e,this,1,t)}computeN(e,t){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(e,this,2,t)}from(e,t){return t||(t=(e=>e)),this.compute([e],i=>t(i.field(e)))}}function sameArray(e,t){return e==t||e.length==t.length&&e.every((e,i)=>e===t[i])}class FacetProvider{constructor(e,t,i,n){this.dependencies=e,this.facet=t,this.type=i,this.value=n,this.id=nextID++;}dynamicSlot(e){var t;let i=this.value,n=this.facet.compareInput,o=this.id,r=e[o]>>1,s=2==this.type,a=!1,l=!1,h=[];for(let i of this.dependencies)"doc"==i?a=!0:"selection"==i?l=!0:0==(1&(null!==(t=e[i.id])&&void 0!==t?t:1))&&h.push(e[i.id]);return {create:e=>(e.values[r]=i(e),1),update(e,t){if(a&&t.docChanged||l&&(t.docChanged||t.selection)||ensureAll(e,h)){let t=i(e);if(s?!compareArray(t,e.values[r],n):!n(t,e.values[r]))return e.values[r]=t,1}return 0},reconfigure:(e,t)=>{let a,l=t.config.address[o];if(null!=l){let o=getAddr(t,l);if(this.dependencies.every(i=>i instanceof Facet?t.facet(i)===e.facet(i):!(i instanceof StateField)||t.field(i,!1)==e.field(i,!1))||(s?compareArray(a=i(e),o,n):n(a=i(e),o)))return e.values[r]=o,0}else a=i(e);return e.values[r]=a,1}}}}function compareArray(e,t,i){if(e.length!=t.length)return !1;for(let n=0;n<e.length;n++)if(!i(e[n],t[n]))return !1;return !0}function ensureAll(e,t){let i=!1;for(let n of t)1&ensureAddr(e,n)&&(i=!0);return i}function dynamicFacetSlot(e,t,i){let n=i.map(t=>e[t.id]),o=i.map(e=>e.type),r=n.filter(e=>!(1&e)),s=e[t.id]>>1;function a(e){let i=[];for(let t=0;t<n.length;t++){let r=getAddr(e,n[t]);if(2==o[t])for(let e of r)i.push(e);else i.push(r);}return t.combine(i)}return {create(e){for(let t of n)ensureAddr(e,t);return e.values[s]=a(e),1},update(e,i){if(!ensureAll(e,r))return 0;let n=a(e);return t.compare(n,e.values[s])?0:(e.values[s]=n,1)},reconfigure(e,o){let r=ensureAll(e,n),l=o.config.facets[t.id],h=o.facet(t);if(l&&!r&&sameArray(i,l))return e.values[s]=h,0;let c=a(e);return t.compare(c,h)?(e.values[s]=h,0):(e.values[s]=c,1)}}}const initField=Facet.define({static:!0});class StateField{constructor(e,t,i,n,o){this.id=e,this.createF=t,this.updateF=i,this.compareF=n,this.spec=o,this.provides=void 0;}static define(e){let t=new StateField(nextID++,e.create,e.update,e.compare||((e,t)=>e===t),e);return e.provide&&(t.provides=e.provide(t)),t}create(e){let t=e.facet(initField).find(e=>e.field==this);return ((null===t||void 0===t?void 0:t.create)||this.createF)(e)}slot(e){let t=e[this.id]>>1;return {create:e=>(e.values[t]=this.create(e),1),update:(e,i)=>{let n=e.values[t],o=this.updateF(n,i);return this.compareF(n,o)?0:(e.values[t]=o,1)},reconfigure:(e,i)=>null!=i.config.address[this.id]?(e.values[t]=i.field(this),0):(e.values[t]=this.create(e),1)}}init(e){return [this,initField.of({field:this,create:e})]}get extension(){return this}}const Prec_={lowest:4,low:3,default:2,high:1,highest:0};function prec(e){return t=>new PrecExtension(t,e)}const Prec={highest:prec(Prec_.highest),high:prec(Prec_.high),default:prec(Prec_.default),low:prec(Prec_.low),lowest:prec(Prec_.lowest)};class PrecExtension{constructor(e,t){this.inner=e,this.prec=t;}}class Compartment{of(e){return new CompartmentInstance(this,e)}reconfigure(e){return Compartment.reconfigure.of({compartment:this,extension:e})}get(e){return e.config.compartments.get(this)}}class CompartmentInstance{constructor(e,t){this.compartment=e,this.inner=t;}}class Configuration{constructor(e,t,i,n,o,r){for(this.base=e,this.compartments=t,this.dynamicSlots=i,this.address=n,this.staticValues=o,this.facets=r,this.statusTemplate=[];this.statusTemplate.length<i.length;)this.statusTemplate.push(0);}staticFacet(e){let t=this.address[e.id];return null==t?e.default:this.staticValues[t>>1]}static resolve(e,t,i){let n=[],o=Object.create(null),r=new Map;for(let i of flatten(e,t,r))i instanceof StateField?n.push(i):(o[i.facet.id]||(o[i.facet.id]=[])).push(i);let s=Object.create(null),a=[],l=[];for(let e of n)s[e.id]=l.length<<1,l.push(t=>e.slot(t));let h=null===i||void 0===i?void 0:i.config.facets;for(let e in o){let t=o[e],n=t[0].facet,r=h&&h[e]||[];if(t.every(e=>0==e.type))if(s[n.id]=a.length<<1|1,sameArray(r,t))a.push(i.facet(n));else {let e=n.combine(t.map(e=>e.value));a.push(i&&n.compare(e,i.facet(n))?i.facet(n):e);}else {for(let e of t)0==e.type?(s[e.id]=a.length<<1|1,a.push(e.value)):(s[e.id]=l.length<<1,l.push(t=>e.dynamicSlot(t)));s[n.id]=l.length<<1,l.push(e=>dynamicFacetSlot(e,n,t));}}let c=l.map(e=>e(s));return new Configuration(e,r,c,s,a,o)}}function flatten(e,t,i){let n=[[],[],[],[],[]],o=new Map;return function e(r,s){let a=o.get(r);if(null!=a){if(a<=s)return;let e=n[a].indexOf(r);e>-1&&n[a].splice(e,1),r instanceof CompartmentInstance&&i.delete(r.compartment);}if(o.set(r,s),Array.isArray(r))for(let t of r)e(t,s);else if(r instanceof CompartmentInstance){if(i.has(r.compartment))throw new RangeError("Duplicate use of compartment in extensions");let n=t.get(r.compartment)||r.inner;i.set(r.compartment,n),e(n,s);}else if(r instanceof PrecExtension)e(r.inner,r.prec);else if(r instanceof StateField)n[s].push(r),r.provides&&e(r.provides,s);else if(r instanceof FacetProvider)n[s].push(r),r.facet.extensions&&e(r.facet.extensions,Prec_.default);else {let t=r.extension;if(!t)throw new Error(`Unrecognized extension value in extension set (${r}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);e(t,s);}}(e,Prec_.default),n.reduce((e,t)=>e.concat(t))}function ensureAddr(e,t){if(1&t)return 2;let i=t>>1,n=e.status[i];if(4==n)throw new Error("Cyclic dependency between fields and/or facets");if(2&n)return n;e.status[i]=4;let o=e.computeSlot(e,e.config.dynamicSlots[i]);return e.status[i]=2|o}function getAddr(e,t){return 1&t?e.config.staticValues[t>>1]:e.values[t>>1]}const languageData=Facet.define(),allowMultipleSelections=Facet.define({combine:e=>e.some(e=>e),static:!0}),lineSeparator=Facet.define({combine:e=>e.length?e[0]:void 0,static:!0}),changeFilter=Facet.define(),transactionFilter=Facet.define(),transactionExtender=Facet.define(),readOnly=Facet.define({combine:e=>!!e.length&&e[0]});class Annotation{constructor(e,t){this.type=e,this.value=t;}static define(){return new AnnotationType}}class AnnotationType{of(e){return new Annotation(this,e)}}class StateEffectType{constructor(e){this.map=e;}of(e){return new StateEffect(this,e)}}class StateEffect{constructor(e,t){this.type=e,this.value=t;}map(e){let t=this.type.map(this.value,e);return void 0===t?void 0:t==this.value?this:new StateEffect(this.type,t)}is(e){return this.type==e}static define(e={}){return new StateEffectType(e.map||(e=>e))}static mapEffects(e,t){if(!e.length)return e;let i=[];for(let n of e){let e=n.map(t);e&&i.push(e);}return i}}StateEffect.reconfigure=StateEffect.define(),StateEffect.appendConfig=StateEffect.define();class Transaction{constructor(e,t,i,n,o,r){this.startState=e,this.changes=t,this.selection=i,this.effects=n,this.annotations=o,this.scrollIntoView=r,this._doc=null,this._state=null,i&&checkSelection(i,t.newLength),o.some(e=>e.type==Transaction.time)||(this.annotations=o.concat(Transaction.time.of(Date.now())));}static create(e,t,i,n,o,r){return new Transaction(e,t,i,n,o,r)}get newDoc(){return this._doc||(this._doc=this.changes.apply(this.startState.doc))}get newSelection(){return this.selection||this.startState.selection.map(this.changes)}get state(){return this._state||this.startState.applyTransaction(this),this._state}annotation(e){for(let t of this.annotations)if(t.type==e)return t.value}get docChanged(){return !this.changes.empty}get reconfigured(){return this.startState.config!=this.state.config}isUserEvent(e){let t=this.annotation(Transaction.userEvent);return !(!t||!(t==e||t.length>e.length&&t.slice(0,e.length)==e&&"."==t[e.length]))}}function joinRanges(e,t){let i=[];for(let n=0,o=0;;){let r,s;if(n<e.length&&(o==t.length||t[o]>=e[n]))r=e[n++],s=e[n++];else {if(!(o<t.length))return i;r=t[o++],s=t[o++];}!i.length||i[i.length-1]<r?i.push(r,s):i[i.length-1]<s&&(i[i.length-1]=s);}}function mergeTransaction(e,t,i){var n;let o,r,s;return i?(o=t.changes,r=ChangeSet.empty(t.changes.length),s=e.changes.compose(t.changes)):(o=t.changes.map(e.changes),r=e.changes.mapDesc(t.changes,!0),s=e.changes.compose(o)),{changes:s,selection:t.selection?t.selection.map(r):null===(n=e.selection)||void 0===n?void 0:n.map(o),effects:StateEffect.mapEffects(e.effects,o).concat(StateEffect.mapEffects(t.effects,r)),annotations:e.annotations.length?e.annotations.concat(t.annotations):t.annotations,scrollIntoView:e.scrollIntoView||t.scrollIntoView}}function resolveTransactionInner(e,t,i){let n=t.selection,o=asArray(t.annotations);return t.userEvent&&(o=o.concat(Transaction.userEvent.of(t.userEvent))),{changes:t.changes instanceof ChangeSet?t.changes:ChangeSet.of(t.changes||[],i,e.facet(lineSeparator)),selection:n&&(n instanceof EditorSelection?n:EditorSelection.single(n.anchor,n.head)),effects:asArray(t.effects),annotations:o,scrollIntoView:!!t.scrollIntoView}}function resolveTransaction(e,t,i){let n=resolveTransactionInner(e,t.length?t[0]:{},e.doc.length);t.length&&!1===t[0].filter&&(i=!1);for(let o=1;o<t.length;o++){!1===t[o].filter&&(i=!1);let r=!!t[o].sequential;n=mergeTransaction(n,resolveTransactionInner(e,t[o],r?n.changes.newLength:e.doc.length),r);}let o=Transaction.create(e,n.changes,n.selection,n.effects,n.annotations,n.scrollIntoView);return extendTransaction(i?filterTransaction(o):o)}function filterTransaction(e){let t=e.startState,i=!0;for(let n of t.facet(changeFilter)){let t=n(e);if(!1===t){i=!1;break}Array.isArray(t)&&(i=!0===i?t:joinRanges(i,t));}if(!0!==i){let n,o;if(!1===i)o=e.changes.invertedDesc,n=ChangeSet.empty(t.doc.length);else {let t=e.changes.filter(i);n=t.changes,o=t.filtered.mapDesc(t.changes).invertedDesc;}e=Transaction.create(t,n,e.selection&&e.selection.map(o),StateEffect.mapEffects(e.effects,o),e.annotations,e.scrollIntoView);}let n=t.facet(transactionFilter);for(let i=n.length-1;i>=0;i--){let o=n[i](e);e=o instanceof Transaction?o:Array.isArray(o)&&1==o.length&&o[0]instanceof Transaction?o[0]:resolveTransaction(t,asArray(o),!1);}return e}function extendTransaction(e){let t=e.startState,i=t.facet(transactionExtender),n=e;for(let o=i.length-1;o>=0;o--){let r=i[o](e);r&&Object.keys(r).length&&(n=mergeTransaction(n,resolveTransactionInner(t,r,e.changes.newLength),!0));}return n==e?e:Transaction.create(t,e.changes,e.selection,n.effects,n.annotations,n.scrollIntoView)}Transaction.time=Annotation.define(),Transaction.userEvent=Annotation.define(),Transaction.addToHistory=Annotation.define(),Transaction.remote=Annotation.define();const none=[];function asArray(e){return null==e?none:Array.isArray(e)?e:[e]}var CharCategory=function(e){return e[e.Word=0]="Word",e[e.Space=1]="Space",e[e.Other=2]="Other",e}(CharCategory||(CharCategory={}));const nonASCIISingleCaseWordChar=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;let wordChar;try{wordChar=new RegExp("[\\p{Alphabetic}\\p{Number}_]","u");}catch(e){}function hasWordChar(e){if(wordChar)return wordChar.test(e);for(let t=0;t<e.length;t++){let i=e[t];if(/\w/.test(i)||i>""&&(i.toUpperCase()!=i.toLowerCase()||nonASCIISingleCaseWordChar.test(i)))return !0}return !1}function makeCategorizer(e){return t=>{if(!/\S/.test(t))return CharCategory.Space;if(hasWordChar(t))return CharCategory.Word;for(let i=0;i<e.length;i++)if(t.indexOf(e[i])>-1)return CharCategory.Word;return CharCategory.Other}}class EditorState{constructor(e,t,i,n,o,r){this.config=e,this.doc=t,this.selection=i,this.values=n,this.status=e.statusTemplate.slice(),this.computeSlot=o,r&&(r._state=this);for(let e=0;e<this.config.dynamicSlots.length;e++)ensureAddr(this,e<<1);this.computeSlot=null;}field(e,t=!0){let i=this.config.address[e.id];if(null!=i)return ensureAddr(this,i),getAddr(this,i);if(t)throw new RangeError("Field is not present in this state")}update(...e){return resolveTransaction(this,e,!0)}applyTransaction(e){let t,i=this.config,{base:n,compartments:o}=i;for(let t of e.effects)t.is(Compartment.reconfigure)?(i&&(o=new Map,i.compartments.forEach((e,t)=>o.set(t,e)),i=null),o.set(t.value.compartment,t.value.extension)):t.is(StateEffect.reconfigure)?(i=null,n=t.value):t.is(StateEffect.appendConfig)&&(i=null,n=asArray(n).concat(t.value));if(i)t=e.startState.values.slice();else {i=Configuration.resolve(n,o,this),t=new EditorState(i,this.doc,this.selection,i.dynamicSlots.map(()=>null),(e,t)=>t.reconfigure(e,this),null).values;}new EditorState(i,e.newDoc,e.newSelection,t,(t,i)=>i.update(t,e),e);}replaceSelection(e){return "string"==typeof e&&(e=this.toText(e)),this.changeByRange(t=>({changes:{from:t.from,to:t.to,insert:e},range:EditorSelection.cursor(t.from+e.length)}))}changeByRange(e){let t=this.selection,i=e(t.ranges[0]),n=this.changes(i.changes),o=[i.range],r=asArray(i.effects);for(let i=1;i<t.ranges.length;i++){let s=e(t.ranges[i]),a=this.changes(s.changes),l=a.map(n);for(let e=0;e<i;e++)o[e]=o[e].map(l);let h=n.mapDesc(a,!0);o.push(s.range.map(h)),n=n.compose(l),r=StateEffect.mapEffects(r,l).concat(StateEffect.mapEffects(asArray(s.effects),h));}return {changes:n,selection:EditorSelection.create(o,t.mainIndex),effects:r}}changes(e=[]){return e instanceof ChangeSet?e:ChangeSet.of(e,this.doc.length,this.facet(EditorState.lineSeparator))}toText(e){return Text.of(e.split(this.facet(EditorState.lineSeparator)||DefaultSplit))}sliceDoc(e=0,t=this.doc.length){return this.doc.sliceString(e,t,this.lineBreak)}facet(e){let t=this.config.address[e.id];return null==t?e.default:(ensureAddr(this,t),getAddr(this,t))}toJSON(e){let t={doc:this.sliceDoc(),selection:this.selection.toJSON()};if(e)for(let i in e){let n=e[i];n instanceof StateField&&null!=this.config.address[n.id]&&(t[i]=n.spec.toJSON(this.field(e[i]),this));}return t}static fromJSON(e,t={},i){if(!e||"string"!=typeof e.doc)throw new RangeError("Invalid JSON representation for EditorState");let n=[];if(i)for(let t in i)if(Object.prototype.hasOwnProperty.call(e,t)){let o=i[t],r=e[t];n.push(o.init(e=>o.spec.fromJSON(r,e)));}return EditorState.create({doc:e.doc,selection:EditorSelection.fromJSON(e.selection),extensions:t.extensions?n.concat([t.extensions]):n})}static create(e={}){let t=Configuration.resolve(e.extensions||[],new Map),i=e.doc instanceof Text?e.doc:Text.of((e.doc||"").split(t.staticFacet(EditorState.lineSeparator)||DefaultSplit)),n=e.selection?e.selection instanceof EditorSelection?e.selection:EditorSelection.single(e.selection.anchor,e.selection.head):EditorSelection.single(0);return checkSelection(n,i.length),t.staticFacet(allowMultipleSelections)||(n=n.asSingle()),new EditorState(t,i,n,t.dynamicSlots.map(()=>null),(e,t)=>t.create(e),null)}get tabSize(){return this.facet(EditorState.tabSize)}get lineBreak(){return this.facet(EditorState.lineSeparator)||"\n"}get readOnly(){return this.facet(readOnly)}phrase(e,...t){for(let t of this.facet(EditorState.phrases))if(Object.prototype.hasOwnProperty.call(t,e)){e=t[e];break}return t.length&&(e=e.replace(/\$(\$|\d*)/g,(e,i)=>{if("$"==i)return "$";let n=+(i||1);return !n||n>t.length?e:t[n-1]})),e}languageDataAt(e,t,i=-1){let n=[];for(let o of this.facet(languageData))for(let r of o(this,t,i))Object.prototype.hasOwnProperty.call(r,e)&&n.push(r[e]);return n}charCategorizer(e){return makeCategorizer(this.languageDataAt("wordChars",e).join(""))}wordAt(e){let{text:t,from:i,length:n}=this.doc.lineAt(e),o=this.charCategorizer(e),r=e-i,s=e-i;for(;r>0;){let e=findClusterBreak(t,r,!1);if(o(t.slice(e,r))!=CharCategory.Word)break;r=e;}for(;s<n;){let e=findClusterBreak(t,s);if(o(t.slice(s,e))!=CharCategory.Word)break;s=e;}return r==s?null:EditorSelection.range(r+i,s+i)}}function combineConfig(e,t,i={}){let n={};for(let t of e)for(let e of Object.keys(t)){let o=t[e],r=n[e];if(void 0===r)n[e]=o;else if(r===o||void 0===o);else {if(!Object.hasOwnProperty.call(i,e))throw new Error("Config merge conflict for field "+e);n[e]=i[e](r,o);}}for(let e in t)void 0===n[e]&&(n[e]=t[e]);return n}EditorState.allowMultipleSelections=allowMultipleSelections,EditorState.tabSize=Facet.define({combine:e=>e.length?e[0]:4}),EditorState.lineSeparator=lineSeparator,EditorState.readOnly=readOnly,EditorState.phrases=Facet.define({compare(e,t){let i=Object.keys(e),n=Object.keys(t);return i.length==n.length&&i.every(i=>e[i]==t[i])}}),EditorState.languageData=languageData,EditorState.changeFilter=changeFilter,EditorState.transactionFilter=transactionFilter,EditorState.transactionExtender=transactionExtender,Compartment.reconfigure=StateEffect.define();class RangeValue{eq(e){return this==e}range(e,t=e){return Range.create(e,t,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0,RangeValue.prototype.point=!1,RangeValue.prototype.mapMode=MapMode.TrackDel;class Range{constructor(e,t,i){this.from=e,this.to=t,this.value=i;}static create(e,t,i){return new Range(e,t,i)}}function cmpRange(e,t){return e.from-t.from||e.value.startSide-t.value.startSide}class Chunk{constructor(e,t,i,n){this.from=e,this.to=t,this.value=i,this.maxPoint=n;}get length(){return this.to[this.to.length-1]}findIndex(e,t,i,n=0){let o=i?this.to:this.from;for(let r=n,s=o.length;;){if(r==s)return r;let n=r+s>>1,a=o[n]-e||(i?this.value[n].endSide:this.value[n].startSide)-t;if(n==r)return a>=0?r:s;a>=0?s=n:r=n+1;}}between(e,t,i,n){for(let o=this.findIndex(t,-1e9,!0),r=this.findIndex(i,1e9,!1,o);o<r;o++)if(!1===n(this.from[o]+e,this.to[o]+e,this.value[o]))return !1}map(e,t){let i=[],n=[],o=[],r=-1,s=-1;for(let a=0;a<this.value.length;a++){let l,h,c=this.value[a],d=this.from[a]+e,u=this.to[a]+e;if(d==u){let e=t.mapPos(d,c.startSide,c.mapMode);if(null==e)continue;if(l=h=e,c.startSide!=c.endSide&&(h=t.mapPos(d,c.endSide))<l)continue}else if((l=t.mapPos(d,c.startSide))>(h=t.mapPos(u,c.endSide))||l==h&&c.startSide>0&&c.endSide<=0)continue;(h-l||c.endSide-c.startSide)<0||(r<0&&(r=l),c.point&&(s=Math.max(s,h-l)),i.push(c),n.push(l-r),o.push(h-r));}return {mapped:i.length?new Chunk(n,o,i,s):null,pos:r}}}class RangeSet{constructor(e,t,i,n){this.chunkPos=e,this.chunk=t,this.nextLayer=i,this.maxPoint=n;}static create(e,t,i,n){return new RangeSet(e,t,i,n)}get length(){let e=this.chunk.length-1;return e<0?0:Math.max(this.chunkEnd(e),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let e=this.nextLayer.size;for(let t of this.chunk)e+=t.value.length;return e}chunkEnd(e){return this.chunkPos[e]+this.chunk[e].length}update(e){let{add:t=[],sort:i=!1,filterFrom:n=0,filterTo:o=this.length}=e,r=e.filter;if(0==t.length&&!r)return this;if(i&&(t=t.slice().sort(cmpRange)),this.isEmpty)return t.length?RangeSet.of(t):this;let s=new LayerCursor(this,null,-1).goto(0),a=0,l=[],h=new RangeSetBuilder;for(;s.value||a<t.length;)if(a<t.length&&(s.from-t[a].from||s.startSide-t[a].value.startSide)>=0){let e=t[a++];h.addInner(e.from,e.to,e.value)||l.push(e);}else 1==s.rangeIndex&&s.chunkIndex<this.chunk.length&&(a==t.length||this.chunkEnd(s.chunkIndex)<t[a].from)&&(!r||n>this.chunkEnd(s.chunkIndex)||o<this.chunkPos[s.chunkIndex])&&h.addChunk(this.chunkPos[s.chunkIndex],this.chunk[s.chunkIndex])?s.nextChunk():((!r||n>s.to||o<s.from||r(s.from,s.to,s.value))&&(h.addInner(s.from,s.to,s.value)||l.push(Range.create(s.from,s.to,s.value))),s.next());return h.finishInner(this.nextLayer.isEmpty&&!l.length?RangeSet.empty:this.nextLayer.update({add:l,filter:r,filterFrom:n,filterTo:o}))}map(e){if(e.empty||this.isEmpty)return this;let t=[],i=[],n=-1;for(let o=0;o<this.chunk.length;o++){let r=this.chunkPos[o],s=this.chunk[o],a=e.touchesRange(r,r+s.length);if(!1===a)n=Math.max(n,s.maxPoint),t.push(s),i.push(e.mapPos(r));else if(!0===a){let{mapped:o,pos:a}=s.map(r,e);o&&(n=Math.max(n,o.maxPoint),t.push(o),i.push(a));}}let o=this.nextLayer.map(e);return 0==t.length?o:new RangeSet(i,t,o||RangeSet.empty,n)}between(e,t,i){if(!this.isEmpty){for(let n=0;n<this.chunk.length;n++){let o=this.chunkPos[n],r=this.chunk[n];if(t>=o&&e<=o+r.length&&!1===r.between(o,e-o,t-o,i))return}this.nextLayer.between(e,t,i);}}iter(e=0){return HeapCursor.from([this]).goto(e)}get isEmpty(){return this.nextLayer==this}static iter(e,t=0){return HeapCursor.from(e).goto(t)}static compare(e,t,i,n,o=-1){let r=e.filter(e=>e.maxPoint>0||!e.isEmpty&&e.maxPoint>=o),s=t.filter(e=>e.maxPoint>0||!e.isEmpty&&e.maxPoint>=o),a=findSharedChunks(r,s,i),l=new SpanCursor(r,a,o),h=new SpanCursor(s,a,o);i.iterGaps((e,t,i)=>compare(l,e,h,t,i,n)),i.empty&&0==i.length&&compare(l,0,h,0,0,n);}static eq(e,t,i=0,n){null==n&&(n=1e9-1);let o=e.filter(e=>!e.isEmpty&&t.indexOf(e)<0),r=t.filter(t=>!t.isEmpty&&e.indexOf(t)<0);if(o.length!=r.length)return !1;if(!o.length)return !0;let s=findSharedChunks(o,r),a=new SpanCursor(o,s,0).goto(i),l=new SpanCursor(r,s,0).goto(i);for(;;){if(a.to!=l.to||!sameValues(a.active,l.active)||a.point&&(!l.point||!a.point.eq(l.point)))return !1;if(a.to>n)return !0;a.next(),l.next();}}static spans(e,t,i,n,o=-1){let r=new SpanCursor(e,null,o).goto(t),s=t,a=r.openStart;for(;;){let e=Math.min(r.to,i);if(r.point){let i=r.activeForPoint(r.to),o=r.pointFrom<t?i.length+1:Math.min(i.length,a);n.point(s,e,r.point,i,o,r.pointRank),a=Math.min(r.openEnd(e),i.length);}else e>s&&(n.span(s,e,r.active,a),a=r.openEnd(e));if(r.to>i)return a+(r.point&&r.to>i?1:0);s=r.to,r.next();}}static of(e,t=!1){let i=new RangeSetBuilder;for(let n of e instanceof Range?[e]:t?lazySort(e):e)i.add(n.from,n.to,n.value);return i.finish()}}function lazySort(e){if(e.length>1)for(let t=e[0],i=1;i<e.length;i++){let n=e[i];if(cmpRange(t,n)>0)return e.slice().sort(cmpRange);t=n;}return e}RangeSet.empty=new RangeSet([],[],null,-1),RangeSet.empty.nextLayer=RangeSet.empty;class RangeSetBuilder{constructor(){this.chunks=[],this.chunkPos=[],this.chunkStart=-1,this.last=null,this.lastFrom=-1e9,this.lastTo=-1e9,this.from=[],this.to=[],this.value=[],this.maxPoint=-1,this.setMaxPoint=-1,this.nextLayer=null;}finishChunk(e){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint)),this.chunkPos.push(this.chunkStart),this.chunkStart=-1,this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint),this.maxPoint=-1,e&&(this.from=[],this.to=[],this.value=[]);}add(e,t,i){this.addInner(e,t,i)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(e,t,i);}addInner(e,t,i){let n=e-this.lastTo||i.startSide-this.last.endSide;if(n<=0&&(e-this.lastFrom||i.startSide-this.last.startSide)<0)throw new Error("Ranges must be added sorted by `from` position and `startSide`");return !(n<0)&&(250==this.from.length&&this.finishChunk(!0),this.chunkStart<0&&(this.chunkStart=e),this.from.push(e-this.chunkStart),this.to.push(t-this.chunkStart),this.last=i,this.lastFrom=e,this.lastTo=t,this.value.push(i),i.point&&(this.maxPoint=Math.max(this.maxPoint,t-e)),!0)}addChunk(e,t){if((e-this.lastTo||t.value[0].startSide-this.last.endSide)<0)return !1;this.from.length&&this.finishChunk(!0),this.setMaxPoint=Math.max(this.setMaxPoint,t.maxPoint),this.chunks.push(t),this.chunkPos.push(e);let i=t.value.length-1;return this.last=t.value[i],this.lastFrom=t.from[i]+e,this.lastTo=t.to[i]+e,!0}finish(){return this.finishInner(RangeSet.empty)}finishInner(e){if(this.from.length&&this.finishChunk(!1),0==this.chunks.length)return e;let t=RangeSet.create(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(e):e,this.setMaxPoint);return this.from=null,t}}function findSharedChunks(e,t,i){let n=new Map;for(let t of e)for(let e=0;e<t.chunk.length;e++)t.chunk[e].maxPoint<=0&&n.set(t.chunk[e],t.chunkPos[e]);let o=new Set;for(let e of t)for(let t=0;t<e.chunk.length;t++){let r=n.get(e.chunk[t]);null==r||(i?i.mapPos(r):r)!=e.chunkPos[t]||(null===i||void 0===i?void 0:i.touchesRange(r,r+e.chunk[t].length))||o.add(e.chunk[t]);}return o}class LayerCursor{constructor(e,t,i,n=0){this.layer=e,this.skip=t,this.minPoint=i,this.rank=n;}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(e,t=-1e9){return this.chunkIndex=this.rangeIndex=0,this.gotoInner(e,t,!1),this}gotoInner(e,t,i){for(;this.chunkIndex<this.layer.chunk.length;){let t=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(t)||this.layer.chunkEnd(this.chunkIndex)<e||t.maxPoint<this.minPoint))break;this.chunkIndex++,i=!1;}if(this.chunkIndex<this.layer.chunk.length){let n=this.layer.chunk[this.chunkIndex].findIndex(e-this.layer.chunkPos[this.chunkIndex],t,!0);(!i||this.rangeIndex<n)&&this.setRangeIndex(n);}this.next();}forward(e,t){(this.to-e||this.endSide-t)<0&&this.gotoInner(e,t,!0);}next(){for(;;){if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9,this.value=null;break}{let e=this.layer.chunkPos[this.chunkIndex],t=this.layer.chunk[this.chunkIndex],i=e+t.from[this.rangeIndex];if(this.from=i,this.to=e+t.to[this.rangeIndex],this.value=t.value[this.rangeIndex],this.setRangeIndex(this.rangeIndex+1),this.minPoint<0||this.value.point&&this.to-this.from>=this.minPoint)break}}}setRangeIndex(e){if(e==this.layer.chunk[this.chunkIndex].value.length){if(this.chunkIndex++,this.skip)for(;this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++;this.rangeIndex=0;}else this.rangeIndex=e;}nextChunk(){this.chunkIndex++,this.rangeIndex=0,this.next();}compare(e){return this.from-e.from||this.startSide-e.startSide||this.rank-e.rank||this.to-e.to||this.endSide-e.endSide}}class HeapCursor{constructor(e){this.heap=e;}static from(e,t=null,i=-1){let n=[];for(let o=0;o<e.length;o++)for(let r=e[o];!r.isEmpty;r=r.nextLayer)r.maxPoint>=i&&n.push(new LayerCursor(r,t,i,o));return 1==n.length?n[0]:new HeapCursor(n)}get startSide(){return this.value?this.value.startSide:0}goto(e,t=-1e9){for(let i of this.heap)i.goto(e,t);for(let e=this.heap.length>>1;e>=0;e--)heapBubble(this.heap,e);return this.next(),this}forward(e,t){for(let i of this.heap)i.forward(e,t);for(let e=this.heap.length>>1;e>=0;e--)heapBubble(this.heap,e);(this.to-e||this.value.endSide-t)<0&&this.next();}next(){if(0==this.heap.length)this.from=this.to=1e9,this.value=null,this.rank=-1;else {let e=this.heap[0];this.from=e.from,this.to=e.to,this.value=e.value,this.rank=e.rank,e.value&&e.next(),heapBubble(this.heap,0);}}}function heapBubble(e,t){for(let i=e[t];;){let n=1+(t<<1);if(n>=e.length)break;let o=e[n];if(n+1<e.length&&o.compare(e[n+1])>=0&&(o=e[n+1],n++),i.compare(o)<0)break;e[n]=i,e[t]=o,t=n;}}class SpanCursor{constructor(e,t,i){this.minPoint=i,this.active=[],this.activeTo=[],this.activeRank=[],this.minActive=-1,this.point=null,this.pointFrom=0,this.pointRank=0,this.to=-1e9,this.endSide=0,this.openStart=-1,this.cursor=HeapCursor.from(e,t,i);}goto(e,t=-1e9){return this.cursor.goto(e,t),this.active.length=this.activeTo.length=this.activeRank.length=0,this.minActive=-1,this.to=e,this.endSide=t,this.openStart=-1,this.next(),this}forward(e,t){for(;this.minActive>-1&&(this.activeTo[this.minActive]-e||this.active[this.minActive].endSide-t)<0;)this.removeActive(this.minActive);this.cursor.forward(e,t);}removeActive(e){remove(this.active,e),remove(this.activeTo,e),remove(this.activeRank,e),this.minActive=findMinIndex(this.active,this.activeTo);}addActive(e){let t=0,{value:i,to:n,rank:o}=this.cursor;for(;t<this.activeRank.length&&this.activeRank[t]<=o;)t++;insert(this.active,t,i),insert(this.activeTo,t,n),insert(this.activeRank,t,o),e&&insert(e,t,this.cursor.from),this.minActive=findMinIndex(this.active,this.activeTo);}next(){let e=this.to,t=this.point;this.point=null;let i=this.openStart<0?[]:null;for(;;){let n=this.minActive;if(n>-1&&(this.activeTo[n]-this.cursor.from||this.active[n].endSide-this.cursor.startSide)<0){if(this.activeTo[n]>e){this.to=this.activeTo[n],this.endSide=this.active[n].endSide;break}this.removeActive(n),i&&remove(i,n);}else {if(!this.cursor.value){this.to=this.endSide=1e9;break}if(this.cursor.from>e){this.to=this.cursor.from,this.endSide=this.cursor.startSide;break}{let e=this.cursor.value;if(e.point){if(!(t&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)){this.point=e,this.pointFrom=this.cursor.from,this.pointRank=this.cursor.rank,this.to=this.cursor.to,this.endSide=e.endSide,this.cursor.next(),this.forward(this.to,this.endSide);break}this.cursor.next();}else this.addActive(i),this.cursor.next();}}}if(i){this.openStart=0;for(let t=i.length-1;t>=0&&i[t]<e;t--)this.openStart++;}}activeForPoint(e){if(!this.active.length)return this.active;let t=[];for(let i=this.active.length-1;i>=0&&!(this.activeRank[i]<this.pointRank);i--)(this.activeTo[i]>e||this.activeTo[i]==e&&this.active[i].endSide>=this.point.endSide)&&t.push(this.active[i]);return t.reverse()}openEnd(e){let t=0;for(let i=this.activeTo.length-1;i>=0&&this.activeTo[i]>e;i--)t++;return t}}function compare(e,t,i,n,o,r){e.goto(t),i.goto(n);let s=n+o,a=n,l=n-t;for(;;){let t=e.to+l-i.to||e.endSide-i.endSide,n=t<0?e.to+l:i.to,o=Math.min(n,s);if(e.point||i.point?e.point&&i.point&&(e.point==i.point||e.point.eq(i.point))&&sameValues(e.activeForPoint(e.to+l),i.activeForPoint(i.to))||r.comparePoint(a,o,e.point,i.point):o>a&&!sameValues(e.active,i.active)&&r.compareRange(a,o,e.active,i.active),n>s)break;a=n,t<=0&&e.next(),t>=0&&i.next();}}function sameValues(e,t){if(e.length!=t.length)return !1;for(let i=0;i<e.length;i++)if(e[i]!=t[i]&&!e[i].eq(t[i]))return !1;return !0}function remove(e,t){for(let i=t,n=e.length-1;i<n;i++)e[i]=e[i+1];e.pop();}function insert(e,t,i){for(let i=e.length-1;i>=t;i--)e[i+1]=e[i];e[t]=i;}function findMinIndex(e,t){let i=-1,n=1e9;for(let o=0;o<t.length;o++)(t[o]-n||e[o].endSide-e[i].endSide)<0&&(i=o,n=t[o]);return i}function countColumn(e,t,i=e.length){let n=0;for(let o=0;o<i;)9==e.charCodeAt(o)?(n+=t-n%t,o++):(n++,o=findClusterBreak(e,o));return n}function findColumn(e,t,i,n){for(let n=0,o=0;;){if(o>=t)return n;if(n==e.length)break;o+=9==e.charCodeAt(n)?i-o%i:1,n=findClusterBreak(e,n);}return !0===n?-1:e.length}const C$1="ͼ",COUNT="undefined"==typeof Symbol?"__"+C$1:Symbol.for(C$1),SET="undefined"==typeof Symbol?"__styleSet"+Math.floor(1e8*Math.random()):Symbol("styleSet"),top="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:{};class StyleModule{constructor(e,t){this.rules=[];let{finish:i}=t||{};function n(e){return /^@/.test(e)?[e]:e.split(/,\s*/)}function o(e,t,r,s){let a=[],l=/^@(\w+)\b/.exec(e[0]),h=l&&"keyframes"==l[1];if(l&&null==t)return r.push(e[0]+";");for(let i in t){let s=t[i];if(/&/.test(i))o(i.split(/,\s*/).map(t=>e.map(e=>t.replace(/&/,e))).reduce((e,t)=>e.concat(t)),s,r);else if(s&&"object"==typeof s){if(!l)throw new RangeError("The value of a property ("+i+") should be a primitive value.");o(n(i),s,a,h);}else null!=s&&a.push(i.replace(/_.*/,"").replace(/[A-Z]/g,e=>"-"+e.toLowerCase())+": "+s+";");}(a.length||h)&&r.push((!i||l||s?e:e.map(i)).join(", ")+" {"+a.join(" ")+"}");}for(let t in e)o(n(t),e[t],this.rules);}getRules(){return this.rules.join("\n")}static newName(){let e=top[COUNT]||1;return top[COUNT]=e+1,C$1+e.toString(36)}static mount(e,t){(e[SET]||new StyleSet(e)).mount(Array.isArray(t)?t:[t]);}}let adoptedSet=null;class StyleSet{constructor(e){if(!e.head&&e.adoptedStyleSheets&&"undefined"!=typeof CSSStyleSheet){if(adoptedSet)return e.adoptedStyleSheets=[adoptedSet.sheet].concat(e.adoptedStyleSheets),e[SET]=adoptedSet;this.sheet=new CSSStyleSheet,e.adoptedStyleSheets=[this.sheet].concat(e.adoptedStyleSheets),adoptedSet=this;}else {this.styleTag=(e.ownerDocument||e).createElement("style");let t=e.head||e;t.insertBefore(this.styleTag,t.firstChild);}this.modules=[],e[SET]=this;}mount(e){let t=this.sheet,i=0,n=0;for(let o=0;o<e.length;o++){let r=e[o],s=this.modules.indexOf(r);if(s<n&&s>-1&&(this.modules.splice(s,1),n--,s=-1),-1==s){if(this.modules.splice(n++,0,r),t)for(let e=0;e<r.rules.length;e++)t.insertRule(r.rules[e],i++);}else {for(;n<s;)i+=this.modules[n++].rules.length;i+=r.rules.length,n++;}}if(!t){let e="";for(let t=0;t<this.modules.length;t++)e+=this.modules[t].getRules()+"\n";this.styleTag.textContent=e;}}}for(var base={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},shift={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},chrome="undefined"!=typeof navigator&&/Chrome\/(\d+)/.exec(navigator.userAgent),gecko="undefined"!=typeof navigator&&/Gecko\/\d+/.test(navigator.userAgent),mac="undefined"!=typeof navigator&&/Mac/.test(navigator.platform),ie="undefined"!=typeof navigator&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),brokenModifierNames=mac||chrome&&+chrome[1]<57,i=0;i<10;i++)base[48+i]=base[96+i]=String(i);for(i=1;i<=24;i++)base[i+111]="F"+i;for(i=65;i<=90;i++)base[i]=String.fromCharCode(i+32),shift[i]=String.fromCharCode(i);for(var code$1 in base)shift.hasOwnProperty(code$1)||(shift[code$1]=base[code$1]);function keyName(e){var t=!(brokenModifierNames&&(e.ctrlKey||e.altKey||e.metaKey)||ie&&e.shiftKey&&e.key&&1==e.key.length||"Unidentified"==e.key)&&e.key||(e.shiftKey?shift:base)[e.keyCode]||e.key||"Unidentified";return "Esc"==t&&(t="Escape"),"Del"==t&&(t="Delete"),"Left"==t&&(t="ArrowLeft"),"Up"==t&&(t="ArrowUp"),"Right"==t&&(t="ArrowRight"),"Down"==t&&(t="ArrowDown"),t}function getSelection(e){return (11==e.nodeType?e.getSelection?e:e.ownerDocument:e).getSelection()}function contains(e,t){return !!t&&(e==t||e.contains(1!=t.nodeType?t.parentNode:t))}function deepActiveElement(e){let t=e.activeElement;for(;t&&t.shadowRoot;)t=t.shadowRoot.activeElement;return t}function hasSelection(e,t){if(!t.anchorNode)return !1;try{return contains(e,t.anchorNode)}catch(e){return !1}}function clientRectsFor(e){return 3==e.nodeType?textRange(e,0,e.nodeValue.length).getClientRects():1==e.nodeType?e.getClientRects():[]}function isEquivalentPosition(e,t,i,n){return !!i&&(scanFor(e,t,i,n,-1)||scanFor(e,t,i,n,1))}function domIndex(e){for(var t=0;;t++)if(!(e=e.previousSibling))return t}function scanFor(e,t,i,n,o){for(;;){if(e==i&&t==n)return !0;if(t==(o<0?0:maxOffset(e))){if("DIV"==e.nodeName)return !1;let i=e.parentNode;if(!i||1!=i.nodeType)return !1;t=domIndex(e)+(o<0?0:1),e=i;}else {if(1!=e.nodeType)return !1;if(1==(e=e.childNodes[t+(o<0?-1:0)]).nodeType&&"false"==e.contentEditable)return !1;t=o<0?maxOffset(e):0;}}}function maxOffset(e){return 3==e.nodeType?e.nodeValue.length:e.childNodes.length}const Rect0={left:0,right:0,top:0,bottom:0};function flattenRect(e,t){let i=t?e.left:e.right;return {left:i,right:i,top:e.top,bottom:e.bottom}}function windowRect(e){return {left:0,right:e.innerWidth,top:0,bottom:e.innerHeight}}function scrollRectIntoView(e,t,i,n,o,r,s,a){let l=e.ownerDocument,h=l.defaultView||window;for(let c=e;c;)if(1==c.nodeType){let e,d=c==l.body;if(d)e=windowRect(h);else {if(c.scrollHeight<=c.clientHeight&&c.scrollWidth<=c.clientWidth){c=c.assignedSlot||c.parentNode;continue}let t=c.getBoundingClientRect();e={left:t.left,right:t.left+c.clientWidth,top:t.top,bottom:t.top+c.clientHeight};}let u=0,f=0;if("nearest"==o)t.top<e.top?(f=-(e.top-t.top+s),i>0&&t.bottom>e.bottom+f&&(f=t.bottom-e.bottom+f+s)):t.bottom>e.bottom&&(f=t.bottom-e.bottom+s,i<0&&t.top-f<e.top&&(f=-(e.top+f-t.top+s)));else {let n=t.bottom-t.top,r=e.bottom-e.top;f=("center"==o&&n<=r?t.top+n/2-r/2:"start"==o||"center"==o&&i<0?t.top-s:t.bottom-r+s)-e.top;}if("nearest"==n)t.left<e.left?(u=-(e.left-t.left+r),i>0&&t.right>e.right+u&&(u=t.right-e.right+u+r)):t.right>e.right&&(u=t.right-e.right+r,i<0&&t.left<e.left+u&&(u=-(e.left+u-t.left+r)));else {u=("center"==n?t.left+(t.right-t.left)/2-(e.right-e.left)/2:"start"==n==a?t.left-r:t.right-(e.right-e.left)+r)-e.left;}if(u||f)if(d)h.scrollBy(u,f);else {let e=0,i=0;if(f){let e=c.scrollTop;c.scrollTop+=f,i=c.scrollTop-e;}if(u){let t=c.scrollLeft;c.scrollLeft+=u,e=c.scrollLeft-t;}t={left:t.left-e,top:t.top-i,right:t.right-e,bottom:t.bottom-i},e&&Math.abs(e-u)<1&&(n="nearest"),i&&Math.abs(i-f)<1&&(o="nearest");}if(d)break;c=c.assignedSlot||c.parentNode;}else {if(11!=c.nodeType)break;c=c.host;}}class DOMSelectionState{constructor(){this.anchorNode=null,this.anchorOffset=0,this.focusNode=null,this.focusOffset=0;}eq(e){return this.anchorNode==e.anchorNode&&this.anchorOffset==e.anchorOffset&&this.focusNode==e.focusNode&&this.focusOffset==e.focusOffset}setRange(e){this.set(e.anchorNode,e.anchorOffset,e.focusNode,e.focusOffset);}set(e,t,i,n){this.anchorNode=e,this.anchorOffset=t,this.focusNode=i,this.focusOffset=n;}}let scratchRange,preventScrollSupported=null;function focusPreventScroll(e){if(e.setActive)return e.setActive();if(preventScrollSupported)return e.focus(preventScrollSupported);let t=[];for(let i=e;i&&(t.push(i,i.scrollTop,i.scrollLeft),i!=i.ownerDocument);i=i.parentNode);if(e.focus(null==preventScrollSupported?{get preventScroll(){return preventScrollSupported={preventScroll:!0},!0}}:void 0),!preventScrollSupported){preventScrollSupported=!1;for(let e=0;e<t.length;){let i=t[e++],n=t[e++],o=t[e++];i.scrollTop!=n&&(i.scrollTop=n),i.scrollLeft!=o&&(i.scrollLeft=o);}}}function textRange(e,t,i=t){let n=scratchRange||(scratchRange=document.createRange());return n.setEnd(e,i),n.setStart(e,t),n}function dispatchKey(e,t,i){let n={key:t,code:t,keyCode:i,which:i,cancelable:!0},o=new KeyboardEvent("keydown",n);o.synthetic=!0,e.dispatchEvent(o);let r=new KeyboardEvent("keyup",n);return r.synthetic=!0,e.dispatchEvent(r),o.defaultPrevented||r.defaultPrevented}function getRoot(e){for(;e;){if(e&&(9==e.nodeType||11==e.nodeType&&e.host))return e;e=e.assignedSlot||e.parentNode;}return null}function clearAttributes(e){for(;e.attributes.length;)e.removeAttributeNode(e.attributes[0]);}function atElementStart(e,t){let i=t.focusNode,n=t.focusOffset;if(!i||t.anchorNode!=i||t.anchorOffset!=n)return !1;for(;;)if(n){if(1!=i.nodeType)return !1;let e=i.childNodes[n-1];"false"==e.contentEditable?n--:n=maxOffset(i=e);}else {if(i==e)return !0;n=domIndex(i),i=i.parentNode;}}class DOMPos{constructor(e,t,i=!0){this.node=e,this.offset=t,this.precise=i;}static before(e,t){return new DOMPos(e.parentNode,domIndex(e),t)}static after(e,t){return new DOMPos(e.parentNode,domIndex(e)+1,t)}}const noChildren=[];class ContentView{constructor(){this.parent=null,this.dom=null,this.dirty=2;}get editorView(){if(!this.parent)throw new Error("Accessing view in orphan content view");return this.parent.editorView}get overrideDOMText(){return null}get posAtStart(){return this.parent?this.parent.posBefore(this):0}get posAtEnd(){return this.posAtStart+this.length}posBefore(e){let t=this.posAtStart;for(let i of this.children){if(i==e)return t;t+=i.length+i.breakAfter;}throw new RangeError("Invalid child in posBefore")}posAfter(e){return this.posBefore(e)+e.length}coordsAt(e,t){return null}sync(e){if(2&this.dirty){let t,i=this.dom,n=null;for(let o of this.children){if(o.dirty){if(!o.dom&&(t=n?n.nextSibling:i.firstChild)){let e=ContentView.get(t);(!e||!e.parent&&e.canReuseDOM(o))&&o.reuseDOM(t);}o.sync(e),o.dirty=0;}if(t=n?n.nextSibling:i.firstChild,e&&!e.written&&e.node==i&&t!=o.dom&&(e.written=!0),o.dom.parentNode==i)for(;t&&t!=o.dom;)t=rm$1(t);else i.insertBefore(o.dom,t);n=o.dom;}for((t=n?n.nextSibling:i.firstChild)&&e&&e.node==i&&(e.written=!0);t;)t=rm$1(t);}else if(1&this.dirty)for(let t of this.children)t.dirty&&(t.sync(e),t.dirty=0);}reuseDOM(e){}localPosFromDOM(e,t){let i;if(e==this.dom)i=this.dom.childNodes[t];else {let n=0==maxOffset(e)?0:0==t?-1:1;for(;;){let t=e.parentNode;if(t==this.dom)break;0==n&&t.firstChild!=t.lastChild&&(n=e==t.firstChild?-1:1),e=t;}i=n<0?e:e.nextSibling;}if(i==this.dom.firstChild)return 0;for(;i&&!ContentView.get(i);)i=i.nextSibling;if(!i)return this.length;for(let e=0,t=0;;e++){let n=this.children[e];if(n.dom==i)return t;t+=n.length+n.breakAfter;}}domBoundsAround(e,t,i=0){let n=-1,o=-1,r=-1,s=-1;for(let a=0,l=i,h=i;a<this.children.length;a++){let i=this.children[a],c=l+i.length;if(l<e&&c>t)return i.domBoundsAround(e,t,l);if(c>=e&&-1==n&&(n=a,o=l),l>t&&i.dom.parentNode==this.dom){r=a,s=h;break}h=c,l=c+i.breakAfter;}return {from:o,to:s<0?i+this.length:s,startDOM:(n?this.children[n-1].dom.nextSibling:null)||this.dom.firstChild,endDOM:r<this.children.length&&r>=0?this.children[r].dom:null}}markDirty(e=!1){this.dirty|=2,this.markParentsDirty(e);}markParentsDirty(e){for(let t=this.parent;t;t=t.parent){if(e&&(t.dirty|=2),1&t.dirty)return;t.dirty|=1,e=!1;}}setParent(e){this.parent!=e&&(this.parent=e,this.dirty&&this.markParentsDirty(!0));}setDOM(e){this.dom&&(this.dom.cmView=null),this.dom=e,e.cmView=this;}get rootView(){for(let e=this;;){let t=e.parent;if(!t)return e;e=t;}}replaceChildren(e,t,i=noChildren){this.markDirty();for(let i=e;i<t;i++){let e=this.children[i];e.parent==this&&e.destroy();}this.children.splice(e,t-e,...i);for(let e=0;e<i.length;e++)i[e].setParent(this);}ignoreMutation(e){return !1}ignoreEvent(e){return !1}childCursor(e=this.length){return new ChildCursor(this.children,e,this.children.length)}childPos(e,t=1){return this.childCursor().findPos(e,t)}toString(){let e=this.constructor.name.replace("View","");return e+(this.children.length?"("+this.children.join()+")":this.length?"["+("Text"==e?this.text:this.length)+"]":"")+(this.breakAfter?"#":"")}static get(e){return e.cmView}get isEditable(){return !0}merge(e,t,i,n,o,r){return !1}become(e){return !1}canReuseDOM(e){return e.constructor==this.constructor}getSide(){return 0}destroy(){this.parent=null;}}function rm$1(e){let t=e.nextSibling;return e.parentNode.removeChild(e),t}ContentView.prototype.breakAfter=0;class ChildCursor{constructor(e,t,i){this.children=e,this.pos=t,this.i=i,this.off=0;}findPos(e,t=1){for(;;){if(e>this.pos||e==this.pos&&(t>0||0==this.i||this.children[this.i-1].breakAfter))return this.off=e-this.pos,this;let i=this.children[--this.i];this.pos-=i.length+i.breakAfter;}}}function replaceRange(e,t,i,n,o,r,s,a,l){let{children:h}=e,c=h.length?h[t]:null,d=r.length?r[r.length-1]:null,u=d?d.breakAfter:s;if(!(t==n&&c&&!s&&!u&&r.length<2&&c.merge(i,o,r.length?d:null,0==i,a,l))){if(n<h.length){let e=h[n];e&&o<e.length?(t==n&&(e=e.split(o),o=0),!u&&d&&e.merge(0,o,d,!0,0,l)?r[r.length-1]=e:(o&&e.merge(0,o,null,!1,0,l),r.push(e))):(null===e||void 0===e?void 0:e.breakAfter)&&(d?d.breakAfter=1:s=1),n++;}for(c&&(c.breakAfter=s,i>0&&(!s&&r.length&&c.merge(i,c.length,r[0],!1,a,0)?c.breakAfter=r.shift().breakAfter:(i<c.length||c.children.length&&0==c.children[c.children.length-1].length)&&c.merge(i,c.length,null,!1,a,0),t++));t<n&&r.length;)if(h[n-1].become(r[r.length-1]))n--,r.pop(),l=r.length?0:a;else {if(!h[t].become(r[0]))break;t++,r.shift(),a=r.length?0:l;}!r.length&&t&&n<h.length&&!h[t-1].breakAfter&&h[n].merge(0,0,h[t-1],!1,a,l)&&t--,(t<n||r.length)&&e.replaceChildren(t,n,r);}}function mergeChildrenInto(e,t,i,n,o,r){let s=e.childCursor(),{i:a,off:l}=s.findPos(i,1),{i:h,off:c}=s.findPos(t,-1),d=t-i;for(let e of n)d+=e.length;e.length+=d,replaceRange(e,h,c,a,l,n,0,o,r);}let nav="undefined"!=typeof navigator?navigator:{userAgent:"",vendor:"",platform:""},doc="undefined"!=typeof document?document:{documentElement:{style:{}}};const ie_edge=/Edge\/(\d+)/.exec(nav.userAgent),ie_upto10=/MSIE \d/.test(nav.userAgent),ie_11up=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent),ie$1=!!(ie_upto10||ie_11up||ie_edge),gecko$1=!ie$1&&/gecko\/(\d+)/i.test(nav.userAgent),chrome$1=!ie$1&&/Chrome\/(\d+)/.exec(nav.userAgent),webkit="webkitFontSmoothing"in doc.documentElement.style,safari=!ie$1&&/Apple Computer/.test(nav.vendor),ios=safari&&(/Mobile\/\w+/.test(nav.userAgent)||nav.maxTouchPoints>2);var browser={mac:ios||/Mac/.test(nav.platform),windows:/Win/.test(nav.platform),linux:/Linux|X11/.test(nav.platform),ie:ie$1,ie_version:ie_upto10?doc.documentMode||6:ie_11up?+ie_11up[1]:ie_edge?+ie_edge[1]:0,gecko:gecko$1,gecko_version:gecko$1?+(/Firefox\/(\d+)/.exec(nav.userAgent)||[0,0])[1]:0,chrome:!!chrome$1,chrome_version:chrome$1?+chrome$1[1]:0,ios:ios,android:/Android\b/.test(nav.userAgent),webkit:webkit,safari:safari,webkit_version:webkit?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0,tabSize:null!=doc.documentElement.style.tabSize?"tab-size":"-moz-tab-size"};const MaxJoinLen=256;class TextView extends ContentView{constructor(e){super(),this.text=e;}get length(){return this.text.length}createDOM(e){this.setDOM(e||document.createTextNode(this.text));}sync(e){this.dom||this.createDOM(),this.dom.nodeValue!=this.text&&(e&&e.node==this.dom&&(e.written=!0),this.dom.nodeValue=this.text);}reuseDOM(e){3==e.nodeType&&this.createDOM(e);}merge(e,t,i){return (!i||i instanceof TextView&&!(this.length-(t-e)+i.length>MaxJoinLen))&&(this.text=this.text.slice(0,e)+(i?i.text:"")+this.text.slice(t),this.markDirty(),!0)}split(e){let t=new TextView(this.text.slice(e));return this.text=this.text.slice(0,e),this.markDirty(),t}localPosFromDOM(e,t){return e==this.dom?t:t?this.text.length:0}domAtPos(e){return new DOMPos(this.dom,e)}domBoundsAround(e,t,i){return {from:i,to:i+this.length,startDOM:this.dom,endDOM:this.dom.nextSibling}}coordsAt(e,t){return textCoords(this.dom,e,t)}}class MarkView extends ContentView{constructor(e,t=[],i=0){super(),this.mark=e,this.children=t,this.length=i;for(let e of t)e.setParent(this);}setAttrs(e){if(clearAttributes(e),this.mark.class&&(e.className=this.mark.class),this.mark.attrs)for(let t in this.mark.attrs)e.setAttribute(t,this.mark.attrs[t]);return e}reuseDOM(e){e.nodeName==this.mark.tagName.toUpperCase()&&(this.setDOM(e),this.dirty|=6);}sync(e){this.dom?4&this.dirty&&this.setAttrs(this.dom):this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),super.sync(e);}merge(e,t,i,n,o,r){return (!i||!(!(i instanceof MarkView&&i.mark.eq(this.mark))||e&&o<=0||t<this.length&&r<=0))&&(mergeChildrenInto(this,e,t,i?i.children:[],o-1,r-1),this.markDirty(),!0)}split(e){let t=[],i=0,n=-1,o=0;for(let r of this.children){let s=i+r.length;s>e&&t.push(i<e?r.split(e-i):r),n<0&&i>=e&&(n=o),i=s,o++;}let r=this.length-e;return this.length=e,n>-1&&(this.children.length=n,this.markDirty()),new MarkView(this.mark,t,r)}domAtPos(e){return inlineDOMAtPos(this,e)}coordsAt(e,t){return coordsInChildren(this,e,t)}}function textCoords(e,t,i){let n=e.nodeValue.length;t>n&&(t=n);let o=t,r=t,s=0;0==t&&i<0||t==n&&i>=0?browser.chrome||browser.gecko||(t?(o--,s=1):r<n&&(r++,s=-1)):i<0?o--:r<n&&r++;let a=textRange(e,o,r).getClientRects();if(!a.length)return Rect0;let l=a[(s?s<0:i>=0)?0:a.length-1];return browser.safari&&!s&&0==l.width&&(l=Array.prototype.find.call(a,e=>e.width)||l),s?flattenRect(l,s<0):l||null}class WidgetView extends ContentView{constructor(e,t,i){super(),this.widget=e,this.length=t,this.side=i,this.prevWidget=null;}static create(e,t,i){return new(e.customView||WidgetView)(e,t,i)}split(e){let t=WidgetView.create(this.widget,this.length-e,this.side);return this.length-=e,t}sync(){this.dom&&this.widget.updateDOM(this.dom)||(this.dom&&this.prevWidget&&this.prevWidget.destroy(this.dom),this.prevWidget=null,this.setDOM(this.widget.toDOM(this.editorView)),this.dom.contentEditable="false");}getSide(){return this.side}merge(e,t,i,n,o,r){return !(i&&(!(i instanceof WidgetView&&this.widget.compare(i.widget))||e>0&&o<=0||t<this.length&&r<=0))&&(this.length=e+(i?i.length:0)+(this.length-t),!0)}become(e){return e.length==this.length&&e instanceof WidgetView&&e.side==this.side&&this.widget.constructor==e.widget.constructor&&(this.widget.eq(e.widget)||this.markDirty(!0),this.dom&&!this.prevWidget&&(this.prevWidget=this.widget),this.widget=e.widget,!0)}ignoreMutation(){return !0}ignoreEvent(e){return this.widget.ignoreEvent(e)}get overrideDOMText(){if(0==this.length)return Text.empty;let e=this;for(;e.parent;)e=e.parent;let t=e.editorView,i=t&&t.state.doc,n=this.posAtStart;return i?i.slice(n,n+this.length):Text.empty}domAtPos(e){return 0==e?DOMPos.before(this.dom):DOMPos.after(this.dom,e==this.length)}domBoundsAround(){return null}coordsAt(e,t){let i=this.dom.getClientRects(),n=null;if(!i.length)return Rect0;for(let t=e>0?i.length-1:0;n=i[t],!(e>0?0==t:t==i.length-1||n.top<n.bottom);t+=e>0?-1:1);return this.length?n:flattenRect(n,this.side>0)}get isEditable(){return !1}destroy(){super.destroy(),this.dom&&this.widget.destroy(this.dom);}}class CompositionView extends WidgetView{domAtPos(e){let{topView:t,text:i}=this.widget;return t?scanCompositionTree(e,0,t,i,(e,t)=>e.domAtPos(t),e=>new DOMPos(i,Math.min(e,i.nodeValue.length))):new DOMPos(i,Math.min(e,i.nodeValue.length))}sync(){this.setDOM(this.widget.toDOM());}localPosFromDOM(e,t){let{topView:i,text:n}=this.widget;return i?posFromDOMInCompositionTree(e,t,i,n):Math.min(t,this.length)}ignoreMutation(){return !1}get overrideDOMText(){return null}coordsAt(e,t){let{topView:i,text:n}=this.widget;return i?scanCompositionTree(e,t,i,n,(e,t,i)=>e.coordsAt(t,i),(e,t)=>textCoords(n,e,t)):textCoords(n,e,t)}destroy(){var e;super.destroy(),null===(e=this.widget.topView)||void 0===e||e.destroy();}get isEditable(){return !0}canReuseDOM(){return !0}}function scanCompositionTree(e,t,i,n,o,r){if(i instanceof MarkView){for(let s=i.dom.firstChild;s;s=s.nextSibling){let i=ContentView.get(s);if(!i)return r(e,t);let a=contains(s,n),l=i.length+(a?n.nodeValue.length:0);if(e<l||e==l&&i.getSide()<=0)return a?scanCompositionTree(e,t,i,n,o,r):o(i,e,t);e-=l;}return o(i,i.length,-1)}return i.dom==n?r(e,t):o(i,e,t)}function posFromDOMInCompositionTree(e,t,i,n){if(i instanceof MarkView)for(let o of i.children){let i=0,r=contains(o.dom,n);if(contains(o.dom,e))return i+(r?posFromDOMInCompositionTree(e,t,o,n):o.localPosFromDOM(e,t));i+=r?n.nodeValue.length:o.length;}else if(i.dom==n)return Math.min(t,n.nodeValue.length);return i.localPosFromDOM(e,t)}class WidgetBufferView extends ContentView{constructor(e){super(),this.side=e;}get length(){return 0}merge(){return !1}become(e){return e instanceof WidgetBufferView&&e.side==this.side}split(){return new WidgetBufferView(this.side)}sync(){if(!this.dom){let e=document.createElement("img");e.className="cm-widgetBuffer",e.setAttribute("aria-hidden","true"),this.setDOM(e);}}getSide(){return this.side}domAtPos(e){return DOMPos.before(this.dom)}localPosFromDOM(){return 0}domBoundsAround(){return null}coordsAt(e){let t=this.dom.getBoundingClientRect(),i=inlineSiblingRect(this,this.side>0?-1:1);return i&&i.top<t.bottom&&i.bottom>t.top?{left:t.left,right:t.right,top:i.top,bottom:i.bottom}:t}get overrideDOMText(){return Text.empty}}function inlineSiblingRect(e,t){let i=e.parent,n=i?i.children.indexOf(e):-1;for(;i&&n>=0;)if(t<0?n>0:n<i.children.length){let e=i.children[n+t];if(e instanceof TextView){let i=e.coordsAt(t<0?e.length:0,t);if(i)return i}n+=t;}else {if(!(i instanceof MarkView&&i.parent)){let e=i.dom.lastChild;if(e&&"BR"==e.nodeName)return e.getClientRects()[0];break}n=i.parent.children.indexOf(i)+(t<0?0:1),i=i.parent;}}function inlineDOMAtPos(e,t){let i=e.dom,{children:n}=e,o=0;for(let e=0;o<n.length;o++){let r=n[o],s=e+r.length;if(!(s==e&&r.getSide()<=0)){if(t>e&&t<s&&r.dom.parentNode==i)return r.domAtPos(t-e);if(t<=e)break;e=s;}}for(let e=o;e>0;e--){let t=n[e-1];if(t.dom.parentNode==i)return t.domAtPos(t.length)}for(let e=o;e<n.length;e++){let t=n[e];if(t.dom.parentNode==i)return t.domAtPos(0)}return new DOMPos(i,0)}function joinInlineInto(e,t,i){let n,{children:o}=e;i>0&&t instanceof MarkView&&o.length&&(n=o[o.length-1])instanceof MarkView&&n.mark.eq(t.mark)?joinInlineInto(n,t.children[0],i-1):(o.push(t),t.setParent(e)),e.length+=t.length;}function coordsInChildren(e,t,i){let n=null,o=-1,r=null,s=-1;!function e(t,i){for(let a=0,l=0;a<t.children.length&&l<=i;a++){let h=t.children[a],c=l+h.length;c>=i&&(h.children.length?e(h,i-l):!r&&(c>i||l==c&&h.getSide()>0)?(r=h,s=i-l):(l<i||l==c&&h.getSide()<0)&&(n=h,o=i-l)),l=c;}}(e,t);let a=(i<0?n:r)||n||r;return a?a.coordsAt(Math.max(0,a==n?o:s),i):fallbackRect(e)}function fallbackRect(e){let t=e.dom.lastChild;if(!t)return e.dom.getBoundingClientRect();let i=clientRectsFor(t);return i[i.length-1]||null}function combineAttrs(e,t){for(let i in e)"class"==i&&t.class?t.class+=" "+e.class:"style"==i&&t.style?t.style+=";"+e.style:t[i]=e[i];return t}function attrsEq(e,t){if(e==t)return !0;if(!e||!t)return !1;let i=Object.keys(e),n=Object.keys(t);if(i.length!=n.length)return !1;for(let o of i)if(-1==n.indexOf(o)||e[o]!==t[o])return !1;return !0}function updateAttrs(e,t,i){let n=null;if(t)for(let o in t)i&&o in i||e.removeAttribute(n=o);if(i)for(let o in i)t&&t[o]==i[o]||e.setAttribute(n=o,i[o]);return !!n}TextView.prototype.children=WidgetView.prototype.children=WidgetBufferView.prototype.children=noChildren;class WidgetType{eq(e){return !1}updateDOM(e){return !1}compare(e){return this==e||this.constructor==e.constructor&&this.eq(e)}get estimatedHeight(){return -1}ignoreEvent(e){return !0}get customView(){return null}destroy(e){}}var BlockType=function(e){return e[e.Text=0]="Text",e[e.WidgetBefore=1]="WidgetBefore",e[e.WidgetAfter=2]="WidgetAfter",e[e.WidgetRange=3]="WidgetRange",e}(BlockType||(BlockType={}));class Decoration extends RangeValue{constructor(e,t,i,n){super(),this.startSide=e,this.endSide=t,this.widget=i,this.spec=n;}get heightRelevant(){return !1}static mark(e){return new MarkDecoration(e)}static widget(e){let t=e.side||0,i=!!e.block;return new PointDecoration(e,t+=i?t>0?3e8:-4e8:t>0?1e8:-1e8,t,i,e.widget||null,!1)}static replace(e){let t,i,n=!!e.block;if(e.isBlockGap)t=-5e8,i=4e8;else {let{start:o,end:r}=getInclusive(e,n);t=(o?n?-3e8:-1:5e8)-1,i=1+(r?n?2e8:1:-6e8);}return new PointDecoration(e,t,i,n,e.widget||null,!0)}static line(e){return new LineDecoration(e)}static set(e,t=!1){return RangeSet.of(e,t)}hasHeight(){return !!this.widget&&this.widget.estimatedHeight>-1}}Decoration.none=RangeSet.empty;class MarkDecoration extends Decoration{constructor(e){let{start:t,end:i}=getInclusive(e);super(t?-1:5e8,i?1:-6e8,null,e),this.tagName=e.tagName||"span",this.class=e.class||"",this.attrs=e.attributes||null;}eq(e){return this==e||e instanceof MarkDecoration&&this.tagName==e.tagName&&this.class==e.class&&attrsEq(this.attrs,e.attrs)}range(e,t=e){if(e>=t)throw new RangeError("Mark decorations may not be empty");return super.range(e,t)}}MarkDecoration.prototype.point=!1;class LineDecoration extends Decoration{constructor(e){super(-2e8,-2e8,null,e);}eq(e){return e instanceof LineDecoration&&attrsEq(this.spec.attributes,e.spec.attributes)}range(e,t=e){if(t!=e)throw new RangeError("Line decoration ranges must be zero-length");return super.range(e,t)}}LineDecoration.prototype.mapMode=MapMode.TrackBefore,LineDecoration.prototype.point=!0;class PointDecoration extends Decoration{constructor(e,t,i,n,o,r){super(t,i,o,e),this.block=n,this.isReplace=r,this.mapMode=n?t<=0?MapMode.TrackBefore:MapMode.TrackAfter:MapMode.TrackDel;}get type(){return this.startSide<this.endSide?BlockType.WidgetRange:this.startSide<=0?BlockType.WidgetBefore:BlockType.WidgetAfter}get heightRelevant(){return this.block||!!this.widget&&this.widget.estimatedHeight>=5}eq(e){return e instanceof PointDecoration&&widgetsEq(this.widget,e.widget)&&this.block==e.block&&this.startSide==e.startSide&&this.endSide==e.endSide}range(e,t=e){if(this.isReplace&&(e>t||e==t&&this.startSide>0&&this.endSide<=0))throw new RangeError("Invalid range for replacement decoration");if(!this.isReplace&&t!=e)throw new RangeError("Widget decorations can only have zero-length ranges");return super.range(e,t)}}function getInclusive(e,t=!1){let{inclusiveStart:i,inclusiveEnd:n}=e;return null==i&&(i=e.inclusive),null==n&&(n=e.inclusive),{start:null!==i&&void 0!==i?i:t,end:null!==n&&void 0!==n?n:t}}function widgetsEq(e,t){return e==t||!!(e&&t&&e.compare(t))}function addRange(e,t,i,n=0){let o=i.length-1;o>=0&&i[o]+n>=e?i[o]=Math.max(i[o],t):i.push(e,t);}PointDecoration.prototype.point=!0;class LineView extends ContentView{constructor(){super(...arguments),this.children=[],this.length=0,this.prevAttrs=void 0,this.attrs=null,this.breakAfter=0;}merge(e,t,i,n,o,r){if(i){if(!(i instanceof LineView))return !1;this.dom||i.transferDOM(this);}return n&&this.setDeco(i?i.attrs:null),mergeChildrenInto(this,e,t,i?i.children:[],o,r),!0}split(e){let t=new LineView;if(t.breakAfter=this.breakAfter,0==this.length)return t;let{i:i,off:n}=this.childPos(e);n&&(t.append(this.children[i].split(n),0),this.children[i].merge(n,this.children[i].length,null,!1,0,0),i++);for(let e=i;e<this.children.length;e++)t.append(this.children[e],0);for(;i>0&&0==this.children[i-1].length;)this.children[--i].destroy();return this.children.length=i,this.markDirty(),this.length=e,t}transferDOM(e){this.dom&&(this.markDirty(),e.setDOM(this.dom),e.prevAttrs=void 0===this.prevAttrs?this.attrs:this.prevAttrs,this.prevAttrs=void 0,this.dom=null);}setDeco(e){attrsEq(this.attrs,e)||(this.dom&&(this.prevAttrs=this.attrs,this.markDirty()),this.attrs=e);}append(e,t){joinInlineInto(this,e,t);}addLineDeco(e){let t=e.spec.attributes,i=e.spec.class;t&&(this.attrs=combineAttrs(t,this.attrs||{})),i&&(this.attrs=combineAttrs({class:i},this.attrs||{}));}domAtPos(e){return inlineDOMAtPos(this,e)}reuseDOM(e){"DIV"==e.nodeName&&(this.setDOM(e),this.dirty|=6);}sync(e){var t;this.dom?4&this.dirty&&(clearAttributes(this.dom),this.dom.className="cm-line",this.prevAttrs=this.attrs?null:void 0):(this.setDOM(document.createElement("div")),this.dom.className="cm-line",this.prevAttrs=this.attrs?null:void 0),void 0!==this.prevAttrs&&(updateAttrs(this.dom,this.prevAttrs,this.attrs),this.dom.classList.add("cm-line"),this.prevAttrs=void 0),super.sync(e);let i=this.dom.lastChild;for(;i&&ContentView.get(i)instanceof MarkView;)i=i.lastChild;if(!(i&&this.length&&("BR"==i.nodeName||0!=(null===(t=ContentView.get(i))||void 0===t?void 0:t.isEditable)||browser.ios&&this.children.some(e=>e instanceof TextView)))){let e=document.createElement("BR");e.cmIgnore=!0,this.dom.appendChild(e);}}measureTextSize(){if(0==this.children.length||this.length>20)return null;let e=0;for(let t of this.children){if(!(t instanceof TextView)||/[^ -~]/.test(t.text))return null;let i=clientRectsFor(t.dom);if(1!=i.length)return null;e+=i[0].width;}return e?{lineHeight:this.dom.getBoundingClientRect().height,charWidth:e/this.length}:null}coordsAt(e,t){return coordsInChildren(this,e,t)}become(e){return !1}get type(){return BlockType.Text}static find(e,t){for(let i=0,n=0;i<e.children.length;i++){let o=e.children[i],r=n+o.length;if(r>=t){if(o instanceof LineView)return o;if(r>t)break}n=r+o.breakAfter;}return null}}class BlockWidgetView extends ContentView{constructor(e,t,i){super(),this.widget=e,this.length=t,this.type=i,this.breakAfter=0,this.prevWidget=null;}merge(e,t,i,n,o,r){return !(i&&(!(i instanceof BlockWidgetView&&this.widget.compare(i.widget))||e>0&&o<=0||t<this.length&&r<=0))&&(this.length=e+(i?i.length:0)+(this.length-t),!0)}domAtPos(e){return 0==e?DOMPos.before(this.dom):DOMPos.after(this.dom,e==this.length)}split(e){let t=this.length-e;this.length=e;let i=new BlockWidgetView(this.widget,t,this.type);return i.breakAfter=this.breakAfter,i}get children(){return noChildren}sync(){this.dom&&this.widget.updateDOM(this.dom)||(this.dom&&this.prevWidget&&this.prevWidget.destroy(this.dom),this.prevWidget=null,this.setDOM(this.widget.toDOM(this.editorView)),this.dom.contentEditable="false");}get overrideDOMText(){return this.parent?this.parent.view.state.doc.slice(this.posAtStart,this.posAtEnd):Text.empty}domBoundsAround(){return null}become(e){return e instanceof BlockWidgetView&&e.type==this.type&&e.widget.constructor==this.widget.constructor&&(e.widget.eq(this.widget)||this.markDirty(!0),this.dom&&!this.prevWidget&&(this.prevWidget=this.widget),this.widget=e.widget,this.length=e.length,this.breakAfter=e.breakAfter,!0)}ignoreMutation(){return !0}ignoreEvent(e){return this.widget.ignoreEvent(e)}destroy(){super.destroy(),this.dom&&this.widget.destroy(this.dom);}}class ContentBuilder{constructor(e,t,i,n){this.doc=e,this.pos=t,this.end=i,this.disallowBlockEffectsFor=n,this.content=[],this.curLine=null,this.breakAtStart=0,this.pendingBuffer=0,this.atCursorPos=!0,this.openStart=-1,this.openEnd=-1,this.text="",this.textOff=0,this.cursor=e.iter(),this.skip=t;}posCovered(){if(0==this.content.length)return !this.breakAtStart&&this.doc.lineAt(this.pos).from!=this.pos;let e=this.content[this.content.length-1];return !(e.breakAfter||e instanceof BlockWidgetView&&e.type==BlockType.WidgetBefore)}getLine(){return this.curLine||(this.content.push(this.curLine=new LineView),this.atCursorPos=!0),this.curLine}flushBuffer(e){this.pendingBuffer&&(this.curLine.append(wrapMarks(new WidgetBufferView(-1),e),e.length),this.pendingBuffer=0);}addBlockWidget(e){this.flushBuffer([]),this.curLine=null,this.content.push(e);}finish(e){e?this.pendingBuffer=0:this.flushBuffer([]),this.posCovered()||this.getLine();}buildText(e,t,i){for(;e>0;){if(this.textOff==this.text.length){let{value:t,lineBreak:i,done:n}=this.cursor.next(this.skip);if(this.skip=0,n)throw new Error("Ran out of text content when drawing inline views");if(i){this.posCovered()||this.getLine(),this.content.length?this.content[this.content.length-1].breakAfter=1:this.breakAtStart=1,this.flushBuffer([]),this.curLine=null,e--;continue}this.text=t,this.textOff=0;}let n=Math.min(this.text.length-this.textOff,e,512);this.flushBuffer(t.slice(t.length-i)),this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff,this.textOff+n)),t),i),this.atCursorPos=!0,this.textOff+=n,e-=n,i=0;}}span(e,t,i,n){this.buildText(t-e,i,n),this.pos=t,this.openStart<0&&(this.openStart=n);}point(e,t,i,n,o,r){if(this.disallowBlockEffectsFor[r]&&i instanceof PointDecoration){if(i.block)throw new RangeError("Block decorations may not be specified via plugins");if(t>this.doc.lineAt(this.pos).to)throw new RangeError("Decorations that replace line breaks may not be specified via plugins")}let s=t-e;if(i instanceof PointDecoration)if(i.block){let{type:e}=i;e!=BlockType.WidgetAfter||this.posCovered()||this.getLine(),this.addBlockWidget(new BlockWidgetView(i.widget||new NullWidget("div"),s,e));}else {let r=WidgetView.create(i.widget||new NullWidget("span"),s,s?0:i.startSide),a=this.atCursorPos&&!r.isEditable&&o<=n.length&&(e<t||i.startSide>0),l=!r.isEditable&&(e<t||i.startSide<=0),h=this.getLine();2!=this.pendingBuffer||a||(this.pendingBuffer=0),this.flushBuffer(n),a&&(h.append(wrapMarks(new WidgetBufferView(1),n),o),o=n.length+Math.max(0,o-n.length)),h.append(wrapMarks(r,n),o),this.atCursorPos=l,this.pendingBuffer=l?e<t?1:2:0;}else this.doc.lineAt(this.pos).from==this.pos&&this.getLine().addLineDeco(i);s&&(this.textOff+s<=this.text.length?this.textOff+=s:(this.skip+=s-(this.text.length-this.textOff),this.text="",this.textOff=0),this.pos=t),this.openStart<0&&(this.openStart=o);}static build(e,t,i,n,o){let r=new ContentBuilder(e,t,i,o);return r.openEnd=RangeSet.spans(n,t,i,r),r.openStart<0&&(r.openStart=r.openEnd),r.finish(r.openEnd),r}}function wrapMarks(e,t){for(let i of t)e=new MarkView(i,[e],e.length);return e}class NullWidget extends WidgetType{constructor(e){super(),this.tag=e;}eq(e){return e.tag==this.tag}toDOM(){return document.createElement(this.tag)}updateDOM(e){return e.nodeName.toLowerCase()==this.tag}}const clickAddsSelectionRange=Facet.define(),dragMovesSelection$1=Facet.define(),mouseSelectionStyle=Facet.define(),exceptionSink=Facet.define(),updateListener=Facet.define(),inputHandler=Facet.define(),perLineTextDirection=Facet.define({combine:e=>e.some(e=>e)}),nativeSelectionHidden=Facet.define({combine:e=>e.some(e=>e)});class ScrollTarget{constructor(e,t="nearest",i="nearest",n=5,o=5){this.range=e,this.y=t,this.x=i,this.yMargin=n,this.xMargin=o;}map(e){return e.empty?this:new ScrollTarget(this.range.map(e),this.y,this.x,this.yMargin,this.xMargin)}}const scrollIntoView=StateEffect.define({map:(e,t)=>e.map(t)});function logException(e,t,i){let n=e.facet(exceptionSink);n.length?n[0](t):window.onerror?window.onerror(String(t),i,void 0,void 0,t):i?console.error(i+":",t):console.error(t);}const editable=Facet.define({combine:e=>!e.length||e[0]});let nextPluginID=0;const viewPlugin=Facet.define();class ViewPlugin{constructor(e,t,i,n){this.id=e,this.create=t,this.domEventHandlers=i,this.extension=n(this);}static define(e,t){const{eventHandlers:i,provide:n,decorations:o}=t||{};return new ViewPlugin(nextPluginID++,e,i,e=>{let t=[viewPlugin.of(e)];return o&&t.push(decorations.of(t=>{let i=t.plugin(e);return i?o(i):Decoration.none})),n&&t.push(n(e)),t})}static fromClass(e,t){return ViewPlugin.define(t=>new e(t),t)}}class PluginInstance{constructor(e){this.spec=e,this.mustUpdate=null,this.value=null;}update(e){if(this.value){if(this.mustUpdate){let e=this.mustUpdate;if(this.mustUpdate=null,this.value.update)try{this.value.update(e);}catch(t){if(logException(e.state,t,"CodeMirror plugin crashed"),this.value.destroy)try{this.value.destroy();}catch(e){}this.deactivate();}}}else if(this.spec)try{this.value=this.spec.create(e);}catch(t){logException(e.state,t,"CodeMirror plugin crashed"),this.deactivate();}return this}destroy(e){var t;if(null===(t=this.value)||void 0===t?void 0:t.destroy)try{this.value.destroy();}catch(t){logException(e.state,t,"CodeMirror plugin crashed");}}deactivate(){this.spec=this.value=null;}}const editorAttributes=Facet.define(),contentAttributes=Facet.define(),decorations=Facet.define(),atomicRanges=Facet.define(),scrollMargins=Facet.define(),styleModule=Facet.define();class ChangedRange{constructor(e,t,i,n){this.fromA=e,this.toA=t,this.fromB=i,this.toB=n;}join(e){return new ChangedRange(Math.min(this.fromA,e.fromA),Math.max(this.toA,e.toA),Math.min(this.fromB,e.fromB),Math.max(this.toB,e.toB))}addToSet(e){let t=e.length,i=this;for(;t>0;t--){let n=e[t-1];if(!(n.fromA>i.toA)){if(n.toA<i.fromA)break;i=i.join(n),e.splice(t-1,1);}}return e.splice(t,0,i),e}static extendWithRanges(e,t){if(0==t.length)return e;let i=[];for(let n=0,o=0,r=0,s=0;;n++){let a=n==e.length?null:e[n],l=r-s,h=a?a.fromB:1e9;for(;o<t.length&&t[o]<h;){let e=t[o],n=t[o+1],r=Math.max(s,e),a=Math.min(h,n);if(r<=a&&new ChangedRange(r+l,a+l,r,a).addToSet(i),n>h)break;o+=2;}if(!a)return i;new ChangedRange(a.fromA,a.toA,a.fromB,a.toB).addToSet(i),r=a.toA,s=a.toB;}}}class ViewUpdate{constructor(e,t,i){this.view=e,this.state=t,this.transactions=i,this.flags=0,this.startState=e.state,this.changes=ChangeSet.empty(this.startState.doc.length);for(let e of i)this.changes=this.changes.compose(e.changes);let n=[];this.changes.iterChangedRanges((e,t,i,o)=>n.push(new ChangedRange(e,t,i,o))),this.changedRanges=n;let o=e.hasFocus;o!=e.inputState.notifiedFocused&&(e.inputState.notifiedFocused=o,this.flags|=1);}static create(e,t,i){return new ViewUpdate(e,t,i)}get viewportChanged(){return (4&this.flags)>0}get heightChanged(){return (2&this.flags)>0}get geometryChanged(){return this.docChanged||(10&this.flags)>0}get focusChanged(){return (1&this.flags)>0}get docChanged(){return !this.changes.empty}get selectionSet(){return this.transactions.some(e=>e.selection)}get empty(){return 0==this.flags&&0==this.transactions.length}}var Direction=function(e){return e[e.LTR=0]="LTR",e[e.RTL=1]="RTL",e}(Direction||(Direction={}));const LTR=Direction.LTR,RTL=Direction.RTL;function dec(e){let t=[];for(let i=0;i<e.length;i++)t.push(1<<+e[i]);return t}const LowTypes=dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"),ArabicTypes=dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"),Brackets=Object.create(null),BracketStack=[];for(let e of ["()","[]","{}"]){let t=e.charCodeAt(0),i=e.charCodeAt(1);Brackets[t]=i,Brackets[i]=-t;}function charType(e){return e<=247?LowTypes[e]:1424<=e&&e<=1524?2:1536<=e&&e<=1785?ArabicTypes[e-1536]:1774<=e&&e<=2220?4:8192<=e&&e<=8203?256:64336<=e&&e<=65023?4:8204==e?256:1}const BidiRE=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;class BidiSpan{constructor(e,t,i){this.from=e,this.to=t,this.level=i;}get dir(){return this.level%2?RTL:LTR}side(e,t){return this.dir==t==e?this.to:this.from}static find(e,t,i,n){let o=-1;for(let r=0;r<e.length;r++){let s=e[r];if(s.from<=t&&s.to>=t){if(s.level==i)return r;(o<0||(0!=n?n<0?s.from<t:s.to>t:e[o].level>s.level))&&(o=r);}}if(o<0)throw new RangeError("Index out of range");return o}}const types=[];function computeOrder(e,t){let i=e.length,n=t==LTR?1:2,o=t==LTR?2:1;if(!e||1==n&&!BidiRE.test(e))return trivialOrder(i);for(let t=0,o=n,r=n;t<i;t++){let i=charType(e.charCodeAt(t));512==i?i=o:8==i&&4==r&&(i=16),types[t]=4==i?2:i,7&i&&(r=i),o=i;}for(let e=0,t=n,o=n;e<i;e++){let n=types[e];if(128==n)e<i-1&&t==types[e+1]&&24&t?n=types[e]=t:types[e]=256;else if(64==n){let n=e+1;for(;n<i&&64==types[n];)n++;let r=e&&8==t||n<i&&8==types[n]?1==o?1:8:256;for(let t=e;t<n;t++)types[t]=r;e=n-1;}else 8==n&&1==o&&(types[e]=1);t=n,7&n&&(o=n);}for(let t,r,s,a=0,l=0,h=0;a<i;a++)if(r=Brackets[t=e.charCodeAt(a)])if(r<0){for(let e=l-3;e>=0;e-=3)if(BracketStack[e+1]==-r){let t=BracketStack[e+2],i=2&t?n:4&t?1&t?o:n:0;i&&(types[a]=types[BracketStack[e]]=i),l=e;break}}else {if(189==BracketStack.length)break;BracketStack[l++]=a,BracketStack[l++]=t,BracketStack[l++]=h;}else if(2==(s=types[a])||1==s){let e=s==n;h=e?0:1;for(let t=l-3;t>=0;t-=3){let i=BracketStack[t+2];if(2&i)break;if(e)BracketStack[t+2]|=2;else {if(4&i)break;BracketStack[t+2]|=4;}}}for(let e=0;e<i;e++)if(256==types[e]){let t=e+1;for(;t<i&&256==types[t];)t++;let o=1==(e?types[e-1]:n),r=o==(1==(t<i?types[t]:n))?o?1:2:n;for(let i=e;i<t;i++)types[i]=r;e=t-1;}let r=[];if(1==n)for(let e=0;e<i;){let t=e,n=1!=types[e++];for(;e<i&&n==(1!=types[e]);)e++;if(n)for(let i=e;i>t;){let e=i,n=2!=types[--i];for(;i>t&&n==(2!=types[i-1]);)i--;r.push(new BidiSpan(i,e,n?2:1));}else r.push(new BidiSpan(t,e,0));}else for(let e=0;e<i;){let t=e,n=2==types[e++];for(;e<i&&n==(2==types[e]);)e++;r.push(new BidiSpan(t,e,n?1:2));}return r}function trivialOrder(e){return [new BidiSpan(0,e,0)]}let movedOver="";function moveVisually(e,t,i,n,o){var r;let s=n.head-e.from,a=-1;if(0==s){if(!o||!e.length)return null;t[0].level!=i&&(s=t[0].side(!1,i),a=0);}else if(s==e.length){if(o)return null;let e=t[t.length-1];e.level!=i&&(s=e.side(!0,i),a=t.length-1);}a<0&&(a=BidiSpan.find(t,s,null!==(r=n.bidiLevel)&&void 0!==r?r:-1,n.assoc));let l=t[a];s==l.side(o,i)&&(s=(l=t[a+=o?1:-1]).side(!o,i));let h=o==(l.dir==i),c=findClusterBreak(e.text,s,h);if(movedOver=e.text.slice(Math.min(s,c),Math.max(s,c)),c!=l.side(o,i))return EditorSelection.cursor(c+e.from,h?-1:1,l.level);let d=a==(o?t.length-1:0)?null:t[a+(o?1:-1)];return d||l.level==i?d&&d.level<l.level?EditorSelection.cursor(d.side(!o,i)+e.from,o?1:-1,d.level):EditorSelection.cursor(c+e.from,o?-1:1,l.level):EditorSelection.cursor(o?e.to:e.from,o?-1:1,i)}const LineBreakPlaceholder="￿";class DOMReader{constructor(e,t){this.points=e,this.text="",this.lineSeparator=t.facet(EditorState.lineSeparator);}append(e){this.text+=e;}lineBreak(){this.text+=LineBreakPlaceholder;}readRange(e,t){if(!e)return this;let i=e.parentNode;for(let n=e;;){this.findPointBefore(i,n),this.readNode(n);let e=n.nextSibling;if(e==t)break;let o=ContentView.get(n),r=ContentView.get(e);(o&&r?o.breakAfter:(o?o.breakAfter:isBlockElement(n))||isBlockElement(e)&&("BR"!=n.nodeName||n.cmIgnore))&&this.lineBreak(),n=e;}return this.findPointBefore(i,t),this}readTextNode(e){let t=e.nodeValue;for(let i of this.points)i.node==e&&(i.pos=this.text.length+Math.min(i.offset,t.length));for(let i=0,n=this.lineSeparator?null:/\r\n?|\n/g;;){let o,r=-1,s=1;if(this.lineSeparator?(r=t.indexOf(this.lineSeparator,i),s=this.lineSeparator.length):(o=n.exec(t))&&(r=o.index,s=o[0].length),this.append(t.slice(i,r<0?t.length:r)),r<0)break;if(this.lineBreak(),s>1)for(let t of this.points)t.node==e&&t.pos>this.text.length&&(t.pos-=s-1);i=r+s;}}readNode(e){if(e.cmIgnore)return;let t=ContentView.get(e),i=t&&t.overrideDOMText;if(null!=i){this.findPointInside(e,i.length);for(let e=i.iter();!e.next().done;)e.lineBreak?this.lineBreak():this.append(e.value);}else 3==e.nodeType?this.readTextNode(e):"BR"==e.nodeName?e.nextSibling&&this.lineBreak():1==e.nodeType&&this.readRange(e.firstChild,null);}findPointBefore(e,t){for(let i of this.points)i.node==e&&e.childNodes[i.offset]==t&&(i.pos=this.text.length);}findPointInside(e,t){for(let i of this.points)(3==e.nodeType?i.node==e:e.contains(i.node))&&(i.pos=this.text.length+Math.min(t,i.offset));}}function isBlockElement(e){return 1==e.nodeType&&/^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(e.nodeName)}class DOMPoint{constructor(e,t){this.node=e,this.offset=t,this.pos=-1;}}class DocView extends ContentView{constructor(e){super(),this.view=e,this.compositionDeco=Decoration.none,this.decorations=[],this.dynamicDecorationMap=[],this.minWidth=0,this.minWidthFrom=0,this.minWidthTo=0,this.impreciseAnchor=null,this.impreciseHead=null,this.forceSelection=!1,this.lastUpdate=Date.now(),this.setDOM(e.contentDOM),this.children=[new LineView],this.children[0].setParent(this),this.updateDeco(),this.updateInner([new ChangedRange(0,0,0,e.state.doc.length)],0);}get editorView(){return this.view}get length(){return this.view.state.doc.length}update(e){let t=e.changedRanges;this.minWidth>0&&t.length&&(t.every(({fromA:e,toA:t})=>t<this.minWidthFrom||e>this.minWidthTo)?(this.minWidthFrom=e.changes.mapPos(this.minWidthFrom,1),this.minWidthTo=e.changes.mapPos(this.minWidthTo,1)):this.minWidth=this.minWidthFrom=this.minWidthTo=0),this.view.inputState.composing<0?this.compositionDeco=Decoration.none:(e.transactions.length||this.dirty)&&(this.compositionDeco=computeCompositionDeco(this.view,e.changes)),(browser.ie||browser.chrome)&&!this.compositionDeco.size&&e&&e.state.doc.lines!=e.startState.doc.lines&&(this.forceSelection=!0);let i=findChangedDeco(this.decorations,this.updateDeco(),e.changes);return t=ChangedRange.extendWithRanges(t,i),(0!=this.dirty||0!=t.length)&&(this.updateInner(t,e.startState.doc.length),e.transactions.length&&(this.lastUpdate=Date.now()),!0)}updateInner(e,t){this.view.viewState.mustMeasureContent=!0,this.updateChildren(e,t);let{observer:i}=this.view;i.ignore(()=>{this.dom.style.height=this.view.viewState.contentHeight+"px",this.dom.style.flexBasis=this.minWidth?this.minWidth+"px":"";let e=browser.chrome||browser.ios?{node:i.selectionRange.focusNode,written:!1}:void 0;this.sync(e),this.dirty=0,e&&(e.written||i.selectionRange.focusNode!=e.node)&&(this.forceSelection=!0),this.dom.style.height="";});let n=[];if(this.view.viewport.from||this.view.viewport.to<this.view.state.doc.length)for(let e of this.children)e instanceof BlockWidgetView&&e.widget instanceof BlockGapWidget&&n.push(e.dom);i.updateGaps(n);}updateChildren(e,t){let i=this.childCursor(t);for(let t=e.length-1;;t--){let n=t>=0?e[t]:null;if(!n)break;let{fromA:o,toA:r,fromB:s,toB:a}=n,{content:l,breakAtStart:h,openStart:c,openEnd:d}=ContentBuilder.build(this.view.state.doc,s,a,this.decorations,this.dynamicDecorationMap),{i:u,off:f}=i.findPos(r,1),{i:p,off:O}=i.findPos(o,-1);replaceRange(this,p,O,u,f,l,h,c,d);}}updateSelection(e=!1,t=!1){if(!e&&this.view.observer.selectionRange.focusNode||this.view.observer.readSelectionRange(),!t&&!this.mayControlSelection())return;let i=this.forceSelection;this.forceSelection=!1;let n=this.view.state.selection.main,o=this.domAtPos(n.anchor),r=n.empty?o:this.domAtPos(n.head);if(browser.gecko&&n.empty&&betweenUneditable(o)){let e=document.createTextNode("");this.view.observer.ignore(()=>o.node.insertBefore(e,o.node.childNodes[o.offset]||null)),o=r=new DOMPos(e,0),i=!0;}let s=this.view.observer.selectionRange;!i&&s.focusNode&&isEquivalentPosition(o.node,o.offset,s.anchorNode,s.anchorOffset)&&isEquivalentPosition(r.node,r.offset,s.focusNode,s.focusOffset)||(this.view.observer.ignore(()=>{browser.android&&browser.chrome&&this.dom.contains(s.focusNode)&&inUneditable(s.focusNode,this.dom)&&(this.dom.blur(),this.dom.focus({preventScroll:!0}));let e=getSelection(this.view.root);if(e)if(n.empty){if(browser.gecko){let e=nextToUneditable(o.node,o.offset);if(e&&3!=e){let t=nearbyTextNode(o.node,o.offset,1==e?1:-1);t&&(o=new DOMPos(t,1==e?0:t.nodeValue.length));}}e.collapse(o.node,o.offset),null!=n.bidiLevel&&null!=s.cursorBidiLevel&&(s.cursorBidiLevel=n.bidiLevel);}else if(e.extend){e.collapse(o.node,o.offset);try{e.extend(r.node,r.offset);}catch(e){}}else {let t=document.createRange();n.anchor>n.head&&([o,r]=[r,o]),t.setEnd(r.node,r.offset),t.setStart(o.node,o.offset),e.removeAllRanges(),e.addRange(t);}}),this.view.observer.setSelectionRange(o,r)),this.impreciseAnchor=o.precise?null:new DOMPos(s.anchorNode,s.anchorOffset),this.impreciseHead=r.precise?null:new DOMPos(s.focusNode,s.focusOffset);}enforceCursorAssoc(){if(this.compositionDeco.size)return;let{view:e}=this,t=e.state.selection.main,i=getSelection(e.root),{anchorNode:n,anchorOffset:o}=e.observer.selectionRange;if(!(i&&t.empty&&t.assoc&&i.modify))return;let r=LineView.find(this,t.head);if(!r)return;let s=r.posAtStart;if(t.head==s||t.head==s+r.length)return;let a=this.coordsAt(t.head,-1),l=this.coordsAt(t.head,1);if(!a||!l||a.bottom>l.top)return;let h=this.domAtPos(t.head+t.assoc);i.collapse(h.node,h.offset),i.modify("move",t.assoc<0?"forward":"backward","lineboundary"),e.observer.readSelectionRange();let c=e.observer.selectionRange;e.docView.posFromDOM(c.anchorNode,c.anchorOffset)!=t.from&&i.collapse(n,o);}mayControlSelection(){let e=this.view.root.activeElement;return e==this.dom||hasSelection(this.dom,this.view.observer.selectionRange)&&!(e&&this.dom.contains(e))}nearest(e){for(let t=e;t;){let e=ContentView.get(t);if(e&&e.rootView==this)return e;t=t.parentNode;}return null}posFromDOM(e,t){let i=this.nearest(e);if(!i)throw new RangeError("Trying to find position for a DOM position outside of the document");return i.localPosFromDOM(e,t)+i.posAtStart}domAtPos(e){let{i:t,off:i}=this.childCursor().findPos(e,-1);for(;t<this.children.length-1;){let e=this.children[t];if(i<e.length||e instanceof LineView)break;t++,i=0;}return this.children[t].domAtPos(i)}coordsAt(e,t){for(let i=this.length,n=this.children.length-1;;n--){let o=this.children[n],r=i-o.breakAfter-o.length;if(e>r||e==r&&o.type!=BlockType.WidgetBefore&&o.type!=BlockType.WidgetAfter&&(!n||2==t||this.children[n-1].breakAfter||this.children[n-1].type==BlockType.WidgetBefore&&t>-2))return o.coordsAt(e-r,t);i=r;}}measureVisibleLineHeights(e){let t=[],{from:i,to:n}=e,o=this.view.contentDOM.clientWidth,r=o>Math.max(this.view.scrollDOM.clientWidth,this.minWidth)+1,s=-1,a=this.view.textDirection==Direction.LTR;for(let e=0,l=0;l<this.children.length;l++){let h=this.children[l],c=e+h.length;if(c>n)break;if(e>=i){let i=h.dom.getBoundingClientRect();if(t.push(i.height),r){let t=h.dom.lastChild,n=t?clientRectsFor(t):[];if(n.length){let t=n[n.length-1],r=a?t.right-i.left:i.right-t.left;r>s&&(s=r,this.minWidth=o,this.minWidthFrom=e,this.minWidthTo=c);}}}e=c+h.breakAfter;}return t}textDirectionAt(e){let{i:t}=this.childPos(e,1);return "rtl"==getComputedStyle(this.children[t].dom).direction?Direction.RTL:Direction.LTR}measureTextSize(){for(let e of this.children)if(e instanceof LineView){let t=e.measureTextSize();if(t)return t}let e,t,i=document.createElement("div");return i.className="cm-line",i.style.width="99999px",i.textContent="abc def ghi jkl mno pqr stu",this.view.observer.ignore(()=>{this.dom.appendChild(i);let n=clientRectsFor(i.firstChild)[0];e=i.getBoundingClientRect().height,t=n?n.width/27:7,i.remove();}),{lineHeight:e,charWidth:t}}childCursor(e=this.length){let t=this.children.length;return t&&(e-=this.children[--t].length),new ChildCursor(this.children,e,t)}computeBlockGapDeco(){let e=[],t=this.view.viewState;for(let i=0,n=0;;n++){let o=n==t.viewports.length?null:t.viewports[n],r=o?o.from-1:this.length;if(r>i){let n=t.lineBlockAt(r).bottom-t.lineBlockAt(i).top;e.push(Decoration.replace({widget:new BlockGapWidget(n),block:!0,inclusive:!0,isBlockGap:!0}).range(i,r));}if(!o)break;i=o.to+1;}return Decoration.set(e)}updateDeco(){let e=this.view.state.facet(decorations).map((e,t)=>{return (this.dynamicDecorationMap[t]="function"==typeof e)?e(this.view):e});for(let t=e.length;t<e.length+3;t++)this.dynamicDecorationMap[t]=!1;return this.decorations=[...e,this.compositionDeco,this.computeBlockGapDeco(),this.view.viewState.lineGapDeco]}scrollIntoView(e){let t,{range:i}=e,n=this.coordsAt(i.head,i.empty?i.assoc:i.head>i.anchor?-1:1);if(!n)return;!i.empty&&(t=this.coordsAt(i.anchor,i.anchor>i.head?-1:1))&&(n={left:Math.min(n.left,t.left),top:Math.min(n.top,t.top),right:Math.max(n.right,t.right),bottom:Math.max(n.bottom,t.bottom)});let o=0,r=0,s=0,a=0;for(let e of this.view.state.facet(scrollMargins).map(e=>e(this.view)))if(e){let{left:t,right:i,top:n,bottom:l}=e;null!=t&&(o=Math.max(o,t)),null!=i&&(r=Math.max(r,i)),null!=n&&(s=Math.max(s,n)),null!=l&&(a=Math.max(a,l));}let l={left:n.left-o,top:n.top-s,right:n.right+r,bottom:n.bottom+a};scrollRectIntoView(this.view.scrollDOM,l,i.head<i.anchor?-1:1,e.x,e.y,e.xMargin,e.yMargin,this.view.textDirection==Direction.LTR);}}function betweenUneditable(e){return 1==e.node.nodeType&&e.node.firstChild&&(0==e.offset||"false"==e.node.childNodes[e.offset-1].contentEditable)&&(e.offset==e.node.childNodes.length||"false"==e.node.childNodes[e.offset].contentEditable)}class BlockGapWidget extends WidgetType{constructor(e){super(),this.height=e;}toDOM(){let e=document.createElement("div");return this.updateDOM(e),e}eq(e){return e.height==this.height}updateDOM(e){return e.style.height=this.height+"px",!0}get estimatedHeight(){return this.height}}function compositionSurroundingNode(e){let t=e.observer.selectionRange,i=t.focusNode&&nearbyTextNode(t.focusNode,t.focusOffset,0);if(!i)return null;let n=e.docView.nearest(i);if(!n)return null;if(n instanceof LineView){let e=i;for(;e.parentNode!=n.dom;)e=e.parentNode;let t=e.previousSibling;for(;t&&!ContentView.get(t);)t=t.previousSibling;let o=t?ContentView.get(t).posAtEnd:n.posAtStart;return {from:o,to:o,node:e,text:i}}{for(;;){let{parent:e}=n;if(!e)return null;if(e instanceof LineView)break;n=e;}let e=n.posAtStart;return {from:e,to:e+n.length,node:n.dom,text:i}}}function computeCompositionDeco(e,t){let i=compositionSurroundingNode(e);if(!i)return Decoration.none;let{from:n,to:o,node:r,text:s}=i,a=t.mapPos(n,1),l=Math.max(a,t.mapPos(o,-1)),{state:h}=e,c=3==r.nodeType?r.nodeValue:new DOMReader([],h).readRange(r.firstChild,null).text;if(l-a<c.length)if(h.doc.sliceString(a,Math.min(h.doc.length,a+c.length),LineBreakPlaceholder)==c)l=a+c.length;else {if(h.doc.sliceString(Math.max(0,l-c.length),l,LineBreakPlaceholder)!=c)return Decoration.none;a=l-c.length;}else if(h.doc.sliceString(a,l,LineBreakPlaceholder)!=c)return Decoration.none;let d=ContentView.get(r);return d instanceof CompositionView?d=d.widget.topView:d&&(d.parent=null),Decoration.set(Decoration.replace({widget:new CompositionWidget(r,s,d),inclusive:!0}).range(a,l))}class CompositionWidget extends WidgetType{constructor(e,t,i){super(),this.top=e,this.text=t,this.topView=i;}eq(e){return this.top==e.top&&this.text==e.text}toDOM(){return this.top}ignoreEvent(){return !1}get customView(){return CompositionView}}function nearbyTextNode(e,t,i){for(;;){if(3==e.nodeType)return e;if(1==e.nodeType&&t>0&&i<=0)t=maxOffset(e=e.childNodes[t-1]);else {if(!(1==e.nodeType&&t<e.childNodes.length&&i>=0))return null;e=e.childNodes[t],t=0;}}}function nextToUneditable(e,t){return 1!=e.nodeType?0:(t&&"false"==e.childNodes[t-1].contentEditable?1:0)|(t<e.childNodes.length&&"false"==e.childNodes[t].contentEditable?2:0)}class DecorationComparator$1{constructor(){this.changes=[];}compareRange(e,t){addRange(e,t,this.changes);}comparePoint(e,t){addRange(e,t,this.changes);}}function findChangedDeco(e,t,i){let n=new DecorationComparator$1;return RangeSet.compare(e,t,i,n),n.changes}function inUneditable(e,t){for(let i=e;i&&i!=t;i=i.assignedSlot||i.parentNode)if(1==i.nodeType&&"false"==i.contentEditable)return !0;return !1}function groupAt(e,t,i=1){let n=e.charCategorizer(t),o=e.doc.lineAt(t),r=t-o.from;if(0==o.length)return EditorSelection.cursor(t);0==r?i=1:r==o.length&&(i=-1);let s=r,a=r;i<0?s=findClusterBreak(o.text,r,!1):a=findClusterBreak(o.text,r);let l=n(o.text.slice(s,a));for(;s>0;){let e=findClusterBreak(o.text,s,!1);if(n(o.text.slice(e,s))!=l)break;s=e;}for(;a<o.length;){let e=findClusterBreak(o.text,a);if(n(o.text.slice(a,e))!=l)break;a=e;}return EditorSelection.range(s+o.from,a+o.from)}function getdx(e,t){return t.left>e?t.left-e:Math.max(0,e-t.right)}function getdy(e,t){return t.top>e?t.top-e:Math.max(0,e-t.bottom)}function yOverlap(e,t){return e.top<t.bottom-1&&e.bottom>t.top+1}function upTop(e,t){return t<e.top?{top:t,left:e.left,right:e.right,bottom:e.bottom}:e}function upBot(e,t){return t>e.bottom?{top:e.top,left:e.left,right:e.right,bottom:t}:e}function domPosAtCoords(e,t,i){let n,o,r,s,a,l,h,c,d=!1;for(let u=e.firstChild;u;u=u.nextSibling){let e=clientRectsFor(u);for(let f=0;f<e.length;f++){let p=e[f];o&&yOverlap(o,p)&&(p=upTop(upBot(p,o.bottom),o.top));let O=getdx(t,p),g=getdy(i,p);if(0==O&&0==g)return 3==u.nodeType?domPosInText(u,t,i):domPosAtCoords(u,t,i);(!n||s>g||s==g&&r>O)&&(n=u,o=p,r=O,s=g,d=!O||(O>0?f<e.length-1:f>0)),0==O?i>p.bottom&&(!h||h.bottom<p.bottom)?(a=u,h=p):i<p.top&&(!c||c.top>p.top)&&(l=u,c=p):h&&yOverlap(h,p)?h=upBot(h,p.bottom):c&&yOverlap(c,p)&&(c=upTop(c,p.top));}}if(h&&h.bottom>=i?(n=a,o=h):c&&c.top<=i&&(n=l,o=c),!n)return {node:e,offset:0};let u=Math.max(o.left,Math.min(o.right,t));return 3==n.nodeType?domPosInText(n,u,i):d&&"false"!=n.contentEditable?domPosAtCoords(n,u,i):{node:e,offset:Array.prototype.indexOf.call(e.childNodes,n)+(t>=(o.left+o.right)/2?1:0)}}function domPosInText(e,t,i){let n=e.nodeValue.length,o=-1,r=1e9,s=0;for(let a=0;a<n;a++){let n=textRange(e,a,a+1).getClientRects();for(let l=0;l<n.length;l++){let h=n[l];if(h.top==h.bottom)continue;s||(s=t-h.left);let c=(h.top>i?h.top-i:i-h.bottom)-1;if(h.left-1<=t&&h.right+1>=t&&c<r){let i=t>=(h.left+h.right)/2,n=i;if(browser.chrome||browser.gecko){textRange(e,a).getBoundingClientRect().left==h.right&&(n=!i);}if(c<=0)return {node:e,offset:a+(n?1:0)};o=a+(n?1:0),r=c;}}}return {node:e,offset:o>-1?o:s>0?e.nodeValue.length:0}}function posAtCoords(e,{x:t,y:i},n,o=-1){var r;let s,a=e.contentDOM.getBoundingClientRect(),l=a.top+e.viewState.paddingTop,{docHeight:h}=e.viewState,c=i-l;if(c<0)return 0;if(c>h)return e.state.doc.length;for(let t=e.defaultLineHeight/2,i=!1;(s=e.elementAtHeight(c)).type!=BlockType.Text;)for(;!((c=o>0?s.bottom+t:s.top-t)>=0&&c<=h);){if(i)return n?null:0;i=!0,o=-o;}i=l+c;let d=s.from;if(d<e.viewport.from)return 0==e.viewport.from?0:n?null:posAtCoordsImprecise(e,a,s,t,i);if(d>e.viewport.to)return e.viewport.to==e.state.doc.length?e.state.doc.length:n?null:posAtCoordsImprecise(e,a,s,t,i);let u=e.dom.ownerDocument,f=e.root.elementFromPoint?e.root:u,p=f.elementFromPoint(t,i);p&&!e.contentDOM.contains(p)&&(p=null),p||(t=Math.max(a.left+1,Math.min(a.right-1,t)),(p=f.elementFromPoint(t,i))&&!e.contentDOM.contains(p)&&(p=null));let O,g=-1;if(p&&0!=(null===(r=e.docView.nearest(p))||void 0===r?void 0:r.isEditable))if(u.caretPositionFromPoint){let e=u.caretPositionFromPoint(t,i);e&&({offsetNode:O,offset:g}=e);}else if(u.caretRangeFromPoint){let n=u.caretRangeFromPoint(t,i);n&&(({startContainer:O,startOffset:g}=n),(!e.contentDOM.contains(O)||browser.safari&&isSuspiciousSafariCaretResult(O,g,t)||browser.chrome&&isSuspiciousChromeCaretResult(O,g,t))&&(O=void 0));}if(!O||!e.docView.dom.contains(O)){let n=LineView.find(e.docView,d);if(!n)return c>s.top+s.height/2?s.to:s.from;({node:O,offset:g}=domPosAtCoords(n.dom,t,i));}return e.docView.posFromDOM(O,g)}function posAtCoordsImprecise(e,t,i,n,o){let r=Math.round((n-t.left)*e.defaultCharacterWidth);if(e.lineWrapping&&i.height>1.5*e.defaultLineHeight){r+=Math.floor((o-i.top)/e.defaultLineHeight)*e.viewState.heightOracle.lineLength;}let s=e.state.sliceDoc(i.from,i.to);return i.from+findColumn(s,r,e.state.tabSize)}function isSuspiciousSafariCaretResult(e,t,i){let n;if(3!=e.nodeType||t!=(n=e.nodeValue.length))return !1;for(let t=e.nextSibling;t;t=t.nextSibling)if(1!=t.nodeType||"BR"!=t.nodeName)return !1;return textRange(e,n-1,n).getBoundingClientRect().left>i}function isSuspiciousChromeCaretResult(e,t,i){if(0!=t)return !1;for(let t=e;;){let e=t.parentNode;if(!e||1!=e.nodeType||e.firstChild!=t)return !1;if(e.classList.contains("cm-line"))break;t=e;}return i-(1==e.nodeType?e.getBoundingClientRect():textRange(e,0,Math.max(e.nodeValue.length,1)).getBoundingClientRect()).left>5}function moveToLineBoundary(e,t,i,n){let o=e.state.doc.lineAt(t.head),r=n&&e.lineWrapping?e.coordsAtPos(t.assoc<0&&t.head>o.from?t.head-1:t.head):null;if(r){let t=e.dom.getBoundingClientRect(),n=e.textDirectionAt(o.from),s=e.posAtCoords({x:i==(n==Direction.LTR)?t.right-1:t.left+1,y:(r.top+r.bottom)/2});if(null!=s)return EditorSelection.cursor(s,i?-1:1)}let s=LineView.find(e.docView,t.head),a=s?i?s.posAtEnd:s.posAtStart:i?o.to:o.from;return EditorSelection.cursor(a,i?-1:1)}function moveByChar(e,t,i,n){let o=e.state.doc.lineAt(t.head),r=e.bidiSpans(o),s=e.textDirectionAt(o.from);for(let a=t,l=null;;){let t=moveVisually(o,r,s,a,i),h=movedOver;if(!t){if(o.number==(i?e.state.doc.lines:1))return a;h="\n",o=e.state.doc.line(o.number+(i?1:-1)),r=e.bidiSpans(o),t=EditorSelection.cursor(i?o.from:o.to);}if(l){if(!l(h))return a}else {if(!n)return t;l=n(h);}a=t;}}function byGroup(e,t,i){let n=e.state.charCategorizer(t),o=n(i);return e=>{let t=n(e);return o==CharCategory.Space&&(o=t),o==t}}function moveVertically(e,t,i,n){let o=t.head,r=i?1:-1;if(o==(i?e.state.doc.length:0))return EditorSelection.cursor(o,t.assoc);let s,a=t.goalColumn,l=e.contentDOM.getBoundingClientRect(),h=e.coordsAtPos(o),c=e.documentTop;if(h)null==a&&(a=h.left-l.left),s=r<0?h.top:h.bottom;else {let t=e.viewState.lineBlockAt(o);null==a&&(a=Math.min(l.right-l.left,e.defaultCharacterWidth*(o-t.from))),s=(r<0?t.top:t.bottom)+c;}let d=l.left+a,u=null!==n&&void 0!==n?n:e.defaultLineHeight>>1;for(let i=0;;i+=10){let n=s+(u+i)*r,h=posAtCoords(e,{x:d,y:n},!1,r);if(n<l.top||n>l.bottom||(r<0?h<o:h>o))return EditorSelection.cursor(h,t.assoc,void 0,a)}}function skipAtoms(e,t,i){let n=e.state.facet(atomicRanges).map(t=>t(e));for(;;){let e=!1;for(let o of n)o.between(i.from-1,i.from+1,(n,o,r)=>{i.from>n&&i.from<o&&(i=t.head>i.from?EditorSelection.cursor(n,1):EditorSelection.cursor(o,-1),e=!0);});if(!e)return i}}class InputState{constructor(e){this.lastKeyCode=0,this.lastKeyTime=0,this.lastTouchTime=0,this.lastFocusTime=0,this.lastScrollTop=0,this.lastScrollLeft=0,this.chromeScrollHack=-1,this.pendingIOSKey=void 0,this.lastSelectionOrigin=null,this.lastSelectionTime=0,this.lastEscPress=0,this.lastContextMenu=0,this.scrollHandlers=[],this.registeredEvents=[],this.customHandlers=[],this.composing=-1,this.compositionFirstChange=null,this.compositionEndedAt=0,this.mouseSelection=null;for(let t in handlers){let i=handlers[t];e.contentDOM.addEventListener(t,n=>{eventBelongsToEditor(e,n)&&!this.ignoreDuringComposition(n)&&("keydown"==t&&this.keydown(e,n)||(this.mustFlushObserver(n)&&e.observer.forceFlush(),this.runCustomHandlers(t,e,n)?n.preventDefault():i(e,n)));},handlerOptions[t]),this.registeredEvents.push(t);}browser.chrome&&102==browser.chrome_version&&e.scrollDOM.addEventListener("wheel",()=>{this.chromeScrollHack<0?e.contentDOM.style.pointerEvents="none":window.clearTimeout(this.chromeScrollHack),this.chromeScrollHack=setTimeout(()=>{this.chromeScrollHack=-1,e.contentDOM.style.pointerEvents="";},100);},{passive:!0}),this.notifiedFocused=e.hasFocus,browser.safari&&e.contentDOM.addEventListener("input",()=>null);}setSelectionOrigin(e){this.lastSelectionOrigin=e,this.lastSelectionTime=Date.now();}ensureHandlers(e,t){var i;let n;this.customHandlers=[];for(let o of t)if(n=null===(i=o.update(e).spec)||void 0===i?void 0:i.domEventHandlers){this.customHandlers.push({plugin:o.value,handlers:n});for(let t in n)this.registeredEvents.indexOf(t)<0&&"scroll"!=t&&(this.registeredEvents.push(t),e.contentDOM.addEventListener(t,i=>{eventBelongsToEditor(e,i)&&this.runCustomHandlers(t,e,i)&&i.preventDefault();}));}}runCustomHandlers(e,t,i){for(let n of this.customHandlers){let o=n.handlers[e];if(o)try{if(o.call(n.plugin,i,t)||i.defaultPrevented)return !0}catch(e){logException(t.state,e);}}return !1}runScrollHandlers(e,t){this.lastScrollTop=e.scrollDOM.scrollTop,this.lastScrollLeft=e.scrollDOM.scrollLeft;for(let i of this.customHandlers){let n=i.handlers.scroll;if(n)try{n.call(i.plugin,t,e);}catch(t){logException(e.state,t);}}}keydown(e,t){if(this.lastKeyCode=t.keyCode,this.lastKeyTime=Date.now(),9==t.keyCode&&Date.now()<this.lastEscPress+2e3)return !0;if(browser.android&&browser.chrome&&!t.synthetic&&(13==t.keyCode||8==t.keyCode))return e.observer.delayAndroidKey(t.key,t.keyCode),!0;let i;return !(!browser.ios||t.synthetic||t.altKey||t.metaKey||!((i=PendingKeys.find(e=>e.keyCode==t.keyCode))&&!t.ctrlKey||EmacsyPendingKeys.indexOf(t.key)>-1&&t.ctrlKey&&!t.shiftKey))&&(this.pendingIOSKey=i||t,setTimeout(()=>this.flushIOSKey(e),250),!0)}flushIOSKey(e){let t=this.pendingIOSKey;return !!t&&(this.pendingIOSKey=void 0,dispatchKey(e.contentDOM,t.key,t.keyCode))}ignoreDuringComposition(e){return !!/^key/.test(e.type)&&(this.composing>0||!!(browser.safari&&!browser.ios&&Date.now()-this.compositionEndedAt<100)&&(this.compositionEndedAt=0,!0))}mustFlushObserver(e){return "keydown"==e.type&&229!=e.keyCode}startMouseSelection(e){this.mouseSelection&&this.mouseSelection.destroy(),this.mouseSelection=e;}update(e){this.mouseSelection&&this.mouseSelection.update(e),e.transactions.length&&(this.lastKeyCode=this.lastSelectionTime=0);}destroy(){this.mouseSelection&&this.mouseSelection.destroy();}}const PendingKeys=[{key:"Backspace",keyCode:8,inputType:"deleteContentBackward"},{key:"Enter",keyCode:13,inputType:"insertParagraph"},{key:"Delete",keyCode:46,inputType:"deleteContentForward"}],EmacsyPendingKeys="dthko",modifierCodes=[16,17,18,20,91,92,224,225];class MouseSelection{constructor(e,t,i,n){this.view=e,this.style=i,this.mustSelect=n,this.lastEvent=t;let o=e.contentDOM.ownerDocument;o.addEventListener("mousemove",this.move=this.move.bind(this)),o.addEventListener("mouseup",this.up=this.up.bind(this)),this.extend=t.shiftKey,this.multiple=e.state.facet(EditorState.allowMultipleSelections)&&addsSelectionRange(e,t),this.dragMove=dragMovesSelection(e,t),this.dragging=!(!isInPrimarySelection(e,t)||1!=getClickType(t))&&null,!1===this.dragging&&(t.preventDefault(),this.select(t));}move(e){if(0==e.buttons)return this.destroy();!1===this.dragging&&this.select(this.lastEvent=e);}up(e){null==this.dragging&&this.select(this.lastEvent),this.dragging||e.preventDefault(),this.destroy();}destroy(){let e=this.view.contentDOM.ownerDocument;e.removeEventListener("mousemove",this.move),e.removeEventListener("mouseup",this.up),this.view.inputState.mouseSelection=null;}select(e){let t=this.style.get(e,this.extend,this.multiple);!this.mustSelect&&t.eq(this.view.state.selection)&&t.main.assoc==this.view.state.selection.main.assoc||this.view.dispatch({selection:t,userEvent:"select.pointer",scrollIntoView:!0}),this.mustSelect=!1;}update(e){e.docChanged&&this.dragging&&(this.dragging=this.dragging.map(e.changes)),this.style.update(e)&&setTimeout(()=>this.select(this.lastEvent),20);}}function addsSelectionRange(e,t){let i=e.state.facet(clickAddsSelectionRange);return i.length?i[0](t):browser.mac?t.metaKey:t.ctrlKey}function dragMovesSelection(e,t){let i=e.state.facet(dragMovesSelection$1);return i.length?i[0](t):browser.mac?!t.altKey:!t.ctrlKey}function isInPrimarySelection(e,t){let{main:i}=e.state.selection;if(i.empty)return !1;let n=getSelection(e.root);if(!n||0==n.rangeCount)return !0;let o=n.getRangeAt(0).getClientRects();for(let e=0;e<o.length;e++){let i=o[e];if(i.left<=t.clientX&&i.right>=t.clientX&&i.top<=t.clientY&&i.bottom>=t.clientY)return !0}return !1}function eventBelongsToEditor(e,t){if(!t.bubbles)return !0;if(t.defaultPrevented)return !1;for(let i,n=t.target;n!=e.contentDOM;n=n.parentNode)if(!n||11==n.nodeType||(i=ContentView.get(n))&&i.ignoreEvent(t))return !1;return !0}const handlers=Object.create(null),handlerOptions=Object.create(null),brokenClipboardAPI=browser.ie&&browser.ie_version<15||browser.ios&&browser.webkit_version<604;function capturePaste(e){let t=e.dom.parentNode;if(!t)return;let i=t.appendChild(document.createElement("textarea"));i.style.cssText="position: fixed; left: -10000px; top: 10px",i.focus(),setTimeout(()=>{e.focus(),i.remove(),doPaste(e,i.value);},50);}function doPaste(e,t){let i,{state:n}=e,o=1,r=n.toText(t),s=r.lines==n.selection.ranges.length;if(null!=lastLinewiseCopy&&n.selection.ranges.every(e=>e.empty)&&lastLinewiseCopy==r.toString()){let e=-1;i=n.changeByRange(i=>{let a=n.doc.lineAt(i.from);if(a.from==e)return {range:i};e=a.from;let l=n.toText((s?r.line(o++).text:t)+n.lineBreak);return {changes:{from:a.from,insert:l},range:EditorSelection.cursor(i.from+l.length)}});}else i=s?n.changeByRange(e=>{let t=r.line(o++);return {changes:{from:e.from,to:e.to,insert:t.text},range:EditorSelection.cursor(e.from+t.length)}}):n.replaceSelection(r);e.dispatch(i,{userEvent:"input.paste",scrollIntoView:!0});}function rangeForClick(e,t,i,n){if(1==n)return EditorSelection.cursor(t,i);if(2==n)return groupAt(e.state,t,i);{let i=LineView.find(e.docView,t),n=e.state.doc.lineAt(i?i.posAtEnd:t),o=i?i.posAtStart:n.from,r=i?i.posAtEnd:n.to;return r<e.state.doc.length&&r==n.to&&r++,EditorSelection.range(o,r)}}handlers.keydown=((e,t)=>{e.inputState.setSelectionOrigin("select"),27==t.keyCode?e.inputState.lastEscPress=Date.now():modifierCodes.indexOf(t.keyCode)<0&&(e.inputState.lastEscPress=0);}),handlers.touchstart=((e,t)=>{e.inputState.lastTouchTime=Date.now(),e.inputState.setSelectionOrigin("select.pointer");}),handlers.touchmove=(e=>{e.inputState.setSelectionOrigin("select.pointer");}),handlerOptions.touchstart=handlerOptions.touchmove={passive:!0},handlers.mousedown=((e,t)=>{if(e.observer.flush(),e.inputState.lastTouchTime>Date.now()-2e3)return;let i=null;for(let n of e.state.facet(mouseSelectionStyle))if(i=n(e,t))break;if(i||0!=t.button||(i=basicMouseSelection(e,t)),i){let n=e.root.activeElement!=e.contentDOM;n&&e.observer.ignore(()=>focusPreventScroll(e.contentDOM)),e.inputState.startMouseSelection(new MouseSelection(e,t,i,n));}});let insideY=(e,t)=>e>=t.top&&e<=t.bottom,inside=(e,t,i)=>insideY(t,i)&&e>=i.left&&e<=i.right;function findPositionSide(e,t,i,n){let o=LineView.find(e.docView,t);if(!o)return 1;let r=t-o.posAtStart;if(0==r)return 1;if(r==o.length)return -1;let s=o.coordsAt(r,-1);if(s&&inside(i,n,s))return -1;let a=o.coordsAt(r,1);return a&&inside(i,n,a)?1:s&&insideY(n,s)?-1:1}function queryPos(e,t){let i=e.posAtCoords({x:t.clientX,y:t.clientY},!1);return {pos:i,bias:findPositionSide(e,i,t.clientX,t.clientY)}}const BadMouseDetail=browser.ie&&browser.ie_version<=11;let lastMouseDown=null,lastMouseDownCount=0,lastMouseDownTime=0;function getClickType(e){if(!BadMouseDetail)return e.detail;let t=lastMouseDown,i=lastMouseDownTime;return lastMouseDown=e,lastMouseDownTime=Date.now(),lastMouseDownCount=!t||i>Date.now()-400&&Math.abs(t.clientX-e.clientX)<2&&Math.abs(t.clientY-e.clientY)<2?(lastMouseDownCount+1)%3:1}function basicMouseSelection(e,t){let i=queryPos(e,t),n=getClickType(t),o=e.state.selection,r=i,s=t;return {update(e){e.docChanged&&(i.pos=e.changes.mapPos(i.pos),o=o.map(e.changes),s=null);},get(t,a,l){let h;s&&t.clientX==s.clientX&&t.clientY==s.clientY?h=r:(h=r=queryPos(e,t),s=t);let c=rangeForClick(e,h.pos,h.bias,n);if(i.pos!=h.pos&&!a){let t=rangeForClick(e,i.pos,i.bias,n),o=Math.min(t.from,c.from),r=Math.max(t.to,c.to);c=o<c.from?EditorSelection.range(o,r):EditorSelection.range(r,o);}return a?o.replaceRange(o.main.extend(c.from,c.to)):l&&o.ranges.length>1&&o.ranges.some(e=>e.eq(c))?removeRange(o,c):l?o.addRange(c):EditorSelection.create([c])}}}function removeRange(e,t){for(let i=0;;i++)if(e.ranges[i].eq(t))return EditorSelection.create(e.ranges.slice(0,i).concat(e.ranges.slice(i+1)),e.mainIndex==i?0:e.mainIndex-(e.mainIndex>i?1:0))}function dropText(e,t,i,n){if(!i)return;let o=e.posAtCoords({x:t.clientX,y:t.clientY},!1);t.preventDefault();let{mouseSelection:r}=e.inputState,s=n&&r&&r.dragging&&r.dragMove?{from:r.dragging.from,to:r.dragging.to}:null,a={from:o,insert:i},l=e.state.changes(s?[s,a]:a);e.focus(),e.dispatch({changes:l,selection:{anchor:l.mapPos(o,-1),head:l.mapPos(o,1)},userEvent:s?"move.drop":"input.drop"});}function captureCopy(e,t){let i=e.dom.parentNode;if(!i)return;let n=i.appendChild(document.createElement("textarea"));n.style.cssText="position: fixed; left: -10000px; top: 10px",n.value=t,n.focus(),n.selectionEnd=t.length,n.selectionStart=0,setTimeout(()=>{n.remove(),e.focus();},50);}function copiedRange(e){let t=[],i=[],n=!1;for(let n of e.selection.ranges)n.empty||(t.push(e.sliceDoc(n.from,n.to)),i.push(n));if(!t.length){let o=-1;for(let{from:n}of e.selection.ranges){let r=e.doc.lineAt(n);r.number>o&&(t.push(r.text),i.push({from:r.from,to:Math.min(e.doc.length,r.to+1)})),o=r.number;}n=!0;}return {text:t.join(e.lineBreak),ranges:i,linewise:n}}handlers.dragstart=((e,t)=>{let{selection:{main:i}}=e.state,{mouseSelection:n}=e.inputState;n&&(n.dragging=i),t.dataTransfer&&(t.dataTransfer.setData("Text",e.state.sliceDoc(i.from,i.to)),t.dataTransfer.effectAllowed="copyMove");}),handlers.drop=((e,t)=>{if(!t.dataTransfer)return;if(e.state.readOnly)return t.preventDefault();let i=t.dataTransfer.files;if(i&&i.length){t.preventDefault();let n=Array(i.length),o=0,r=()=>{++o==i.length&&dropText(e,t,n.filter(e=>null!=e).join(e.state.lineBreak),!1);};for(let e=0;e<i.length;e++){let t=new FileReader;t.onerror=r,t.onload=(()=>{/[\x00-\x08\x0e-\x1f]{2}/.test(t.result)||(n[e]=t.result),r();}),t.readAsText(i[e]);}}else dropText(e,t,t.dataTransfer.getData("Text"),!0);}),handlers.paste=((e,t)=>{if(e.state.readOnly)return t.preventDefault();e.observer.flush();let i=brokenClipboardAPI?null:t.clipboardData;i?(doPaste(e,i.getData("text/plain")),t.preventDefault()):capturePaste(e);});let lastLinewiseCopy=null;function updateForFocusChange(e){setTimeout(()=>{e.hasFocus!=e.inputState.notifiedFocused&&e.update([]);},10);}handlers.copy=handlers.cut=((e,t)=>{let{text:i,ranges:n,linewise:o}=copiedRange(e.state);if(!i&&!o)return;lastLinewiseCopy=o?i:null;let r=brokenClipboardAPI?null:t.clipboardData;r?(t.preventDefault(),r.clearData(),r.setData("text/plain",i)):captureCopy(e,i),"cut"!=t.type||e.state.readOnly||e.dispatch({changes:n,scrollIntoView:!0,userEvent:"delete.cut"});}),handlers.focus=(e=>{e.inputState.lastFocusTime=Date.now(),e.scrollDOM.scrollTop||!e.inputState.lastScrollTop&&!e.inputState.lastScrollLeft||(e.scrollDOM.scrollTop=e.inputState.lastScrollTop,e.scrollDOM.scrollLeft=e.inputState.lastScrollLeft),updateForFocusChange(e);}),handlers.blur=(e=>{e.observer.clearSelectionRange(),updateForFocusChange(e);}),handlers.compositionstart=handlers.compositionupdate=(e=>{null==e.inputState.compositionFirstChange&&(e.inputState.compositionFirstChange=!0),e.inputState.composing<0&&(e.inputState.composing=0);}),handlers.compositionend=(e=>{e.inputState.composing=-1,e.inputState.compositionEndedAt=Date.now(),e.inputState.compositionFirstChange=null,browser.chrome&&browser.android&&e.observer.flushSoon(),setTimeout(()=>{e.inputState.composing<0&&e.docView.compositionDeco.size&&e.update([]);},50);}),handlers.contextmenu=(e=>{e.inputState.lastContextMenu=Date.now();}),handlers.beforeinput=((e,t)=>{var i;let n;if(browser.chrome&&browser.android&&(n=PendingKeys.find(e=>e.inputType==t.inputType))&&(e.observer.delayAndroidKey(n.key,n.keyCode),"Backspace"==n.key||"Delete"==n.key)){let t=(null===(i=window.visualViewport)||void 0===i?void 0:i.height)||0;setTimeout(()=>{var i;((null===(i=window.visualViewport)||void 0===i?void 0:i.height)||0)>t+10&&e.hasFocus&&(e.contentDOM.blur(),e.focus());},100);}});const wrappingWhiteSpace=["pre-wrap","normal","pre-line","break-spaces"];class HeightOracle{constructor(e){this.lineWrapping=e,this.doc=Text.empty,this.heightSamples={},this.lineHeight=14,this.charWidth=7,this.lineLength=30,this.heightChanged=!1;}heightForGap(e,t){let i=this.doc.lineAt(t).number-this.doc.lineAt(e).number+1;return this.lineWrapping&&(i+=Math.ceil((t-e-i*this.lineLength*.5)/this.lineLength)),this.lineHeight*i}heightForLine(e){if(!this.lineWrapping)return this.lineHeight;return (1+Math.max(0,Math.ceil((e-this.lineLength)/(this.lineLength-5))))*this.lineHeight}setDoc(e){return this.doc=e,this}mustRefreshForWrapping(e){return wrappingWhiteSpace.indexOf(e)>-1!=this.lineWrapping}mustRefreshForHeights(e){let t=!1;for(let i=0;i<e.length;i++){let n=e[i];n<0?i++:this.heightSamples[Math.floor(10*n)]||(t=!0,this.heightSamples[Math.floor(10*n)]=!0);}return t}refresh(e,t,i,n,o){let r=wrappingWhiteSpace.indexOf(e)>-1,s=Math.round(t)!=Math.round(this.lineHeight)||this.lineWrapping!=r;if(this.lineWrapping=r,this.lineHeight=t,this.charWidth=i,this.lineLength=n,s){this.heightSamples={};for(let e=0;e<o.length;e++){let t=o[e];t<0?e++:this.heightSamples[Math.floor(10*t)]=!0;}}return s}}class MeasuredHeights{constructor(e,t){this.from=e,this.heights=t,this.index=0;}get more(){return this.index<this.heights.length}}class BlockInfo{constructor(e,t,i,n,o){this.from=e,this.length=t,this.top=i,this.height=n,this.type=o;}get to(){return this.from+this.length}get bottom(){return this.top+this.height}join(e){let t=(Array.isArray(this.type)?this.type:[this]).concat(Array.isArray(e.type)?e.type:[e]);return new BlockInfo(this.from,this.length+e.length,this.top,this.height+e.height,t)}}var QueryType=function(e){return e[e.ByPos=0]="ByPos",e[e.ByHeight=1]="ByHeight",e[e.ByPosNoHeight=2]="ByPosNoHeight",e}(QueryType||(QueryType={}));const Epsilon=.001;class HeightMap{constructor(e,t,i=2){this.length=e,this.height=t,this.flags=i;}get outdated(){return (2&this.flags)>0}set outdated(e){this.flags=(e?2:0)|-3&this.flags;}setHeight(e,t){this.height!=t&&(Math.abs(this.height-t)>Epsilon&&(e.heightChanged=!0),this.height=t);}replace(e,t,i){return HeightMap.of(i)}decomposeLeft(e,t){t.push(this);}decomposeRight(e,t){t.push(this);}applyChanges(e,t,i,n){let o=this;for(let r=n.length-1;r>=0;r--){let{fromA:s,toA:a,fromB:l,toB:h}=n[r],c=o.lineAt(s,QueryType.ByPosNoHeight,t,0,0),d=c.to>=a?c:o.lineAt(a,QueryType.ByPosNoHeight,t,0,0);for(h+=d.to-a,a=d.to;r>0&&c.from<=n[r-1].toA;)s=n[r-1].fromA,l=n[r-1].fromB,r--,s<c.from&&(c=o.lineAt(s,QueryType.ByPosNoHeight,t,0,0));l+=c.from-s,s=c.from;let u=NodeBuilder.build(i,e,l,h);o=o.replace(s,a,u);}return o.updateHeight(i,0)}static empty(){return new HeightMapText(0,0)}static of(e){if(1==e.length)return e[0];let t=0,i=e.length,n=0,o=0;for(;;)if(t==i)if(n>2*o){let o=e[t-1];o.break?e.splice(--t,1,o.left,null,o.right):e.splice(--t,1,o.left,o.right),i+=1+o.break,n-=o.size;}else {if(!(o>2*n))break;{let t=e[i];t.break?e.splice(i,1,t.left,null,t.right):e.splice(i,1,t.left,t.right),i+=2+t.break,o-=t.size;}}else if(n<o){let i=e[t++];i&&(n+=i.size);}else {let t=e[--i];t&&(o+=t.size);}let r=0;return null==e[t-1]?(r=1,t--):null==e[t]&&(r=1,i++),new HeightMapBranch(HeightMap.of(e.slice(0,t)),r,HeightMap.of(e.slice(i)))}}HeightMap.prototype.size=1;class HeightMapBlock extends HeightMap{constructor(e,t,i){super(e,t),this.type=i;}blockAt(e,t,i,n){return new BlockInfo(n,this.length,i,this.height,this.type)}lineAt(e,t,i,n,o){return this.blockAt(0,i,n,o)}forEachLine(e,t,i,n,o,r){e<=o+this.length&&t>=o&&r(this.blockAt(0,i,n,o));}updateHeight(e,t=0,i=!1,n){return n&&n.from<=t&&n.more&&this.setHeight(e,n.heights[n.index++]),this.outdated=!1,this}toString(){return `block(${this.length})`}}class HeightMapText extends HeightMapBlock{constructor(e,t){super(e,t,BlockType.Text),this.collapsed=0,this.widgetHeight=0;}replace(e,t,i){let n=i[0];return 1==i.length&&(n instanceof HeightMapText||n instanceof HeightMapGap&&4&n.flags)&&Math.abs(this.length-n.length)<10?(n instanceof HeightMapGap?n=new HeightMapText(n.length,this.height):n.height=this.height,this.outdated||(n.outdated=!1),n):HeightMap.of(i)}updateHeight(e,t=0,i=!1,n){return n&&n.from<=t&&n.more?this.setHeight(e,n.heights[n.index++]):(i||this.outdated)&&this.setHeight(e,Math.max(this.widgetHeight,e.heightForLine(this.length-this.collapsed))),this.outdated=!1,this}toString(){return `line(${this.length}${this.collapsed?-this.collapsed:""}${this.widgetHeight?":"+this.widgetHeight:""})`}}class HeightMapGap extends HeightMap{constructor(e){super(e,0);}lines(e,t){let i=e.lineAt(t).number,n=e.lineAt(t+this.length).number;return {firstLine:i,lastLine:n,lineHeight:this.height/(n-i+1)}}blockAt(e,t,i,n){let{firstLine:o,lastLine:r,lineHeight:s}=this.lines(t,n),a=Math.max(0,Math.min(r-o,Math.floor((e-i)/s))),{from:l,length:h}=t.line(o+a);return new BlockInfo(l,h,i+s*a,s,BlockType.Text)}lineAt(e,t,i,n,o){if(t==QueryType.ByHeight)return this.blockAt(e,i,n,o);if(t==QueryType.ByPosNoHeight){let{from:t,to:n}=i.lineAt(e);return new BlockInfo(t,n-t,0,0,BlockType.Text)}let{firstLine:r,lineHeight:s}=this.lines(i,o),{from:a,length:l,number:h}=i.lineAt(e);return new BlockInfo(a,l,n+s*(h-r),s,BlockType.Text)}forEachLine(e,t,i,n,o,r){let{firstLine:s,lineHeight:a}=this.lines(i,o);for(let l=Math.max(e,o),h=Math.min(o+this.length,t);l<=h;){let t=i.lineAt(l);l==e&&(n+=a*(t.number-s)),r(new BlockInfo(t.from,t.length,n,a,BlockType.Text)),n+=a,l=t.to+1;}}replace(e,t,i){let n=this.length-t;if(n>0){let e=i[i.length-1];e instanceof HeightMapGap?i[i.length-1]=new HeightMapGap(e.length+n):i.push(null,new HeightMapGap(n-1));}if(e>0){let t=i[0];t instanceof HeightMapGap?i[0]=new HeightMapGap(e+t.length):i.unshift(new HeightMapGap(e-1),null);}return HeightMap.of(i)}decomposeLeft(e,t){t.push(new HeightMapGap(e-1),null);}decomposeRight(e,t){t.push(null,new HeightMapGap(this.length-e-1));}updateHeight(e,t=0,i=!1,n){let o=t+this.length;if(n&&n.from<=t+this.length&&n.more){let i=[],r=Math.max(t,n.from),s=-1,a=e.heightChanged;for(n.from>t&&i.push(new HeightMapGap(n.from-t-1).updateHeight(e,t));r<=o&&n.more;){let t=e.doc.lineAt(r).length;i.length&&i.push(null);let o=n.heights[n.index++];-1==s?s=o:Math.abs(o-s)>=Epsilon&&(s=-2);let a=new HeightMapText(t,o);a.outdated=!1,i.push(a),r+=t+1;}r<=o&&i.push(null,new HeightMapGap(o-r).updateHeight(e,r));let l=HeightMap.of(i);return e.heightChanged=a||s<0||Math.abs(l.height-this.height)>=Epsilon||Math.abs(s-this.lines(e.doc,t).lineHeight)>=Epsilon,l}return (i||this.outdated)&&(this.setHeight(e,e.heightForGap(t,t+this.length)),this.outdated=!1),this}toString(){return `gap(${this.length})`}}class HeightMapBranch extends HeightMap{constructor(e,t,i){super(e.length+t+i.length,e.height+i.height,t|(e.outdated||i.outdated?2:0)),this.left=e,this.right=i,this.size=e.size+i.size;}get break(){return 1&this.flags}blockAt(e,t,i,n){let o=i+this.left.height;return e<o?this.left.blockAt(e,t,i,n):this.right.blockAt(e,t,o,n+this.left.length+this.break)}lineAt(e,t,i,n,o){let r=n+this.left.height,s=o+this.left.length+this.break,a=t==QueryType.ByHeight?e<r:e<s,l=a?this.left.lineAt(e,t,i,n,o):this.right.lineAt(e,t,i,r,s);if(this.break||(a?l.to<s:l.from>s))return l;let h=t==QueryType.ByPosNoHeight?QueryType.ByPosNoHeight:QueryType.ByPos;return a?l.join(this.right.lineAt(s,h,i,r,s)):this.left.lineAt(s,h,i,n,o).join(l)}forEachLine(e,t,i,n,o,r){let s=n+this.left.height,a=o+this.left.length+this.break;if(this.break)e<a&&this.left.forEachLine(e,t,i,n,o,r),t>=a&&this.right.forEachLine(e,t,i,s,a,r);else {let l=this.lineAt(a,QueryType.ByPos,i,n,o);e<l.from&&this.left.forEachLine(e,l.from-1,i,n,o,r),l.to>=e&&l.from<=t&&r(l),t>l.to&&this.right.forEachLine(l.to+1,t,i,s,a,r);}}replace(e,t,i){let n=this.left.length+this.break;if(t<n)return this.balanced(this.left.replace(e,t,i),this.right);if(e>this.left.length)return this.balanced(this.left,this.right.replace(e-n,t-n,i));let o=[];e>0&&this.decomposeLeft(e,o);let r=o.length;for(let e of i)o.push(e);if(e>0&&mergeGaps(o,r-1),t<this.length){let e=o.length;this.decomposeRight(t,o),mergeGaps(o,e);}return HeightMap.of(o)}decomposeLeft(e,t){let i=this.left.length;if(e<=i)return this.left.decomposeLeft(e,t);t.push(this.left),this.break&&e>=++i&&t.push(null),e>i&&this.right.decomposeLeft(e-i,t);}decomposeRight(e,t){let i=this.left.length,n=i+this.break;if(e>=n)return this.right.decomposeRight(e-n,t);e<i&&this.left.decomposeRight(e,t),this.break&&e<n&&t.push(null),t.push(this.right);}balanced(e,t){return e.size>2*t.size||t.size>2*e.size?HeightMap.of(this.break?[e,null,t]:[e,t]):(this.left=e,this.right=t,this.height=e.height+t.height,this.outdated=e.outdated||t.outdated,this.size=e.size+t.size,this.length=e.length+this.break+t.length,this)}updateHeight(e,t=0,i=!1,n){let{left:o,right:r}=this,s=t+o.length+this.break,a=null;return n&&n.from<=t+o.length&&n.more?a=o=o.updateHeight(e,t,i,n):o.updateHeight(e,t,i),n&&n.from<=s+r.length&&n.more?a=r=r.updateHeight(e,s,i,n):r.updateHeight(e,s,i),a?this.balanced(o,r):(this.height=this.left.height+this.right.height,this.outdated=!1,this)}toString(){return this.left+(this.break?" ":"-")+this.right}}function mergeGaps(e,t){let i,n;null==e[t]&&(i=e[t-1])instanceof HeightMapGap&&(n=e[t+1])instanceof HeightMapGap&&e.splice(t-1,3,new HeightMapGap(i.length+1+n.length));}const relevantWidgetHeight=5;class NodeBuilder{constructor(e,t){this.pos=e,this.oracle=t,this.nodes=[],this.lineStart=-1,this.lineEnd=-1,this.covering=null,this.writtenTo=e;}get isCovered(){return this.covering&&this.nodes[this.nodes.length-1]==this.covering}span(e,t){if(this.lineStart>-1){let e=Math.min(t,this.lineEnd),i=this.nodes[this.nodes.length-1];i instanceof HeightMapText?i.length+=e-this.pos:(e>this.pos||!this.isCovered)&&this.nodes.push(new HeightMapText(e-this.pos,-1)),this.writtenTo=e,t>e&&(this.nodes.push(null),this.writtenTo++,this.lineStart=-1);}this.pos=t;}point(e,t,i){if(e<t||i.heightRelevant){let n=i.widget?i.widget.estimatedHeight:0;n<0&&(n=this.oracle.lineHeight);let o=t-e;i.block?this.addBlock(new HeightMapBlock(o,n,i.type)):(o||n>=relevantWidgetHeight)&&this.addLineDeco(n,o);}else t>e&&this.span(e,t);this.lineEnd>-1&&this.lineEnd<this.pos&&(this.lineEnd=this.oracle.doc.lineAt(this.pos).to);}enterLine(){if(this.lineStart>-1)return;let{from:e,to:t}=this.oracle.doc.lineAt(this.pos);this.lineStart=e,this.lineEnd=t,this.writtenTo<e&&((this.writtenTo<e-1||null==this.nodes[this.nodes.length-1])&&this.nodes.push(this.blankContent(this.writtenTo,e-1)),this.nodes.push(null)),this.pos>e&&this.nodes.push(new HeightMapText(this.pos-e,-1)),this.writtenTo=this.pos;}blankContent(e,t){let i=new HeightMapGap(t-e);return this.oracle.doc.lineAt(e).to==t&&(i.flags|=4),i}ensureLine(){this.enterLine();let e=this.nodes.length?this.nodes[this.nodes.length-1]:null;if(e instanceof HeightMapText)return e;let t=new HeightMapText(0,-1);return this.nodes.push(t),t}addBlock(e){this.enterLine(),e.type!=BlockType.WidgetAfter||this.isCovered||this.ensureLine(),this.nodes.push(e),this.writtenTo=this.pos=this.pos+e.length,e.type!=BlockType.WidgetBefore&&(this.covering=e);}addLineDeco(e,t){let i=this.ensureLine();i.length+=t,i.collapsed+=t,i.widgetHeight=Math.max(i.widgetHeight,e),this.writtenTo=this.pos=this.pos+t;}finish(e){let t=0==this.nodes.length?null:this.nodes[this.nodes.length-1];!(this.lineStart>-1)||t instanceof HeightMapText||this.isCovered?(this.writtenTo<this.pos||null==t)&&this.nodes.push(this.blankContent(this.writtenTo,this.pos)):this.nodes.push(new HeightMapText(0,-1));let i=e;for(let e of this.nodes)e instanceof HeightMapText&&e.updateHeight(this.oracle,i),i+=e?e.length:1;return this.nodes}static build(e,t,i,n){let o=new NodeBuilder(i,e);return RangeSet.spans(t,i,n,o,0),o.finish(i)}}function heightRelevantDecoChanges(e,t,i){let n=new DecorationComparator;return RangeSet.compare(e,t,i,n,0),n.changes}class DecorationComparator{constructor(){this.changes=[];}compareRange(){}comparePoint(e,t,i,n){(e<t||i&&i.heightRelevant||n&&n.heightRelevant)&&addRange(e,t,this.changes,5);}}function visiblePixelRange(e,t){let i=e.getBoundingClientRect(),n=e.ownerDocument,o=n.defaultView||window,r=Math.max(0,i.left),s=Math.min(o.innerWidth,i.right),a=Math.max(0,i.top),l=Math.min(o.innerHeight,i.bottom);for(let t=e.parentNode;t&&t!=n.body;)if(1==t.nodeType){let i=t,n=window.getComputedStyle(i);if((i.scrollHeight>i.clientHeight||i.scrollWidth>i.clientWidth)&&"visible"!=n.overflow){let n=i.getBoundingClientRect();r=Math.max(r,n.left),s=Math.min(s,n.right),a=Math.max(a,n.top),l=t==e.parentNode?n.bottom:Math.min(l,n.bottom);}t="absolute"==n.position||"fixed"==n.position?i.offsetParent:i.parentNode;}else {if(11!=t.nodeType)break;t=t.host;}return {left:r-i.left,right:Math.max(r,s)-i.left,top:a-(i.top+t),bottom:Math.max(a,l)-(i.top+t)}}function fullPixelRange(e,t){let i=e.getBoundingClientRect();return {left:0,right:i.right-i.left,top:t,bottom:i.bottom-(i.top+t)}}class LineGap{constructor(e,t,i){this.from=e,this.to=t,this.size=i;}static same(e,t){if(e.length!=t.length)return !1;for(let i=0;i<e.length;i++){let n=e[i],o=t[i];if(n.from!=o.from||n.to!=o.to||n.size!=o.size)return !1}return !0}draw(e){return Decoration.replace({widget:new LineGapWidget(this.size,e)}).range(this.from,this.to)}}class LineGapWidget extends WidgetType{constructor(e,t){super(),this.size=e,this.vertical=t;}eq(e){return e.size==this.size&&e.vertical==this.vertical}toDOM(){let e=document.createElement("div");return this.vertical?e.style.height=this.size+"px":(e.style.width=this.size+"px",e.style.height="2px",e.style.display="inline-block"),e}get estimatedHeight(){return this.vertical?this.size:-1}}class ViewState{constructor(e){this.state=e,this.pixelViewport={left:0,right:window.innerWidth,top:0,bottom:0},this.inView=!0,this.paddingTop=0,this.paddingBottom=0,this.contentDOMWidth=0,this.contentDOMHeight=0,this.editorHeight=0,this.editorWidth=0,this.scaler=IdScaler,this.scrollTarget=null,this.printing=!1,this.mustMeasureContent=!0,this.defaultTextDirection=Direction.LTR,this.visibleRanges=[],this.mustEnforceCursorAssoc=!1;let t=e.facet(contentAttributes).some(e=>"function"!=typeof e&&"cm-lineWrapping"==e.class);this.heightOracle=new HeightOracle(t),this.stateDeco=e.facet(decorations).filter(e=>"function"!=typeof e),this.heightMap=HeightMap.empty().applyChanges(this.stateDeco,Text.empty,this.heightOracle.setDoc(e.doc),[new ChangedRange(0,0,0,e.doc.length)]),this.viewport=this.getViewport(0,null),this.updateViewportLines(),this.updateForViewport(),this.lineGaps=this.ensureLineGaps([]),this.lineGapDeco=Decoration.set(this.lineGaps.map(e=>e.draw(!1))),this.computeVisibleRanges();}updateForViewport(){let e=[this.viewport],{main:t}=this.state.selection;for(let i=0;i<=1;i++){let n=i?t.head:t.anchor;if(!e.some(({from:e,to:t})=>n>=e&&n<=t)){let{from:t,to:i}=this.lineBlockAt(n);e.push(new Viewport(t,i));}}this.viewports=e.sort((e,t)=>e.from-t.from),this.scaler=this.heightMap.height<=7e6?IdScaler:new BigScaler(this.heightOracle.doc,this.heightMap,this.viewports);}updateViewportLines(){this.viewportLines=[],this.heightMap.forEachLine(this.viewport.from,this.viewport.to,this.state.doc,0,0,e=>{this.viewportLines.push(1==this.scaler.scale?e:scaleBlock(e,this.scaler));});}update(e,t=null){this.state=e.state;let i=this.stateDeco;this.stateDeco=this.state.facet(decorations).filter(e=>"function"!=typeof e);let n=e.changedRanges,o=ChangedRange.extendWithRanges(n,heightRelevantDecoChanges(i,this.stateDeco,e?e.changes:ChangeSet.empty(this.state.doc.length))),r=this.heightMap.height;this.heightMap=this.heightMap.applyChanges(this.stateDeco,e.startState.doc,this.heightOracle.setDoc(this.state.doc),o),this.heightMap.height!=r&&(e.flags|=2);let s=o.length?this.mapViewport(this.viewport,e.changes):this.viewport;(t&&(t.range.head<s.from||t.range.head>s.to)||!this.viewportIsAppropriate(s))&&(s=this.getViewport(0,t));let a=!e.changes.empty||2&e.flags||s.from!=this.viewport.from||s.to!=this.viewport.to;this.viewport=s,this.updateForViewport(),a&&this.updateViewportLines(),(this.lineGaps.length||this.viewport.to-this.viewport.from>4e3)&&this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps,e.changes))),e.flags|=this.computeVisibleRanges(),t&&(this.scrollTarget=t),!this.mustEnforceCursorAssoc&&e.selectionSet&&e.view.lineWrapping&&e.state.selection.main.empty&&e.state.selection.main.assoc&&!e.state.facet(nativeSelectionHidden)&&(this.mustEnforceCursorAssoc=!0);}measure(e){let t=e.contentDOM,i=window.getComputedStyle(t),n=this.heightOracle,o=i.whiteSpace;this.defaultTextDirection="rtl"==i.direction?Direction.RTL:Direction.LTR;let r=this.heightOracle.mustRefreshForWrapping(o),s=r||this.mustMeasureContent||this.contentDOMHeight!=t.clientHeight;this.contentDOMHeight=t.clientHeight,this.mustMeasureContent=!1;let a=0,l=0,h=parseInt(i.paddingTop)||0,c=parseInt(i.paddingBottom)||0;this.paddingTop==h&&this.paddingBottom==c||(this.paddingTop=h,this.paddingBottom=c,a|=10),this.editorWidth!=e.scrollDOM.clientWidth&&(n.lineWrapping&&(s=!0),this.editorWidth=e.scrollDOM.clientWidth,a|=8);let d=(this.printing?fullPixelRange:visiblePixelRange)(t,this.paddingTop),u=d.top-this.pixelViewport.top,f=d.bottom-this.pixelViewport.bottom;this.pixelViewport=d;let p=this.pixelViewport.bottom>this.pixelViewport.top&&this.pixelViewport.right>this.pixelViewport.left;if(p!=this.inView&&(this.inView=p,p&&(s=!0)),!this.inView&&!this.scrollTarget)return 0;let O=t.clientWidth;if(this.contentDOMWidth==O&&this.editorHeight==e.scrollDOM.clientHeight||(this.contentDOMWidth=O,this.editorHeight=e.scrollDOM.clientHeight,a|=8),s){let t=e.docView.measureVisibleLineHeights(this.viewport);if(n.mustRefreshForHeights(t)&&(r=!0),r||n.lineWrapping&&Math.abs(O-this.contentDOMWidth)>n.charWidth){let{lineHeight:i,charWidth:s}=e.docView.measureTextSize();(r=i>0&&n.refresh(o,i,s,O/s,t))&&(e.docView.minWidth=0,a|=8);}u>0&&f>0?l=Math.max(u,f):u<0&&f<0&&(l=Math.min(u,f)),n.heightChanged=!1;for(let i of this.viewports){let o=i.from==this.viewport.from?t:e.docView.measureVisibleLineHeights(i);this.heightMap=(r?HeightMap.empty().applyChanges(this.stateDeco,Text.empty,this.heightOracle,[new ChangedRange(0,0,0,e.state.doc.length)]):this.heightMap).updateHeight(n,0,r,new MeasuredHeights(i.from,o));}n.heightChanged&&(a|=2);}let g=!this.viewportIsAppropriate(this.viewport,l)||this.scrollTarget&&(this.scrollTarget.range.head<this.viewport.from||this.scrollTarget.range.head>this.viewport.to);return g&&(this.viewport=this.getViewport(l,this.scrollTarget)),this.updateForViewport(),(2&a||g)&&this.updateViewportLines(),(this.lineGaps.length||this.viewport.to-this.viewport.from>4e3)&&this.updateLineGaps(this.ensureLineGaps(r?[]:this.lineGaps,e)),a|=this.computeVisibleRanges(),this.mustEnforceCursorAssoc&&(this.mustEnforceCursorAssoc=!1,e.docView.enforceCursorAssoc()),a}get visibleTop(){return this.scaler.fromDOM(this.pixelViewport.top)}get visibleBottom(){return this.scaler.fromDOM(this.pixelViewport.bottom)}getViewport(e,t){let i=.5-Math.max(-.5,Math.min(.5,e/1e3/2)),n=this.heightMap,o=this.state.doc,{visibleTop:r,visibleBottom:s}=this,a=new Viewport(n.lineAt(r-1e3*i,QueryType.ByHeight,o,0,0).from,n.lineAt(s+1e3*(1-i),QueryType.ByHeight,o,0,0).to);if(t){let{head:e}=t.range;if(e<a.from||e>a.to){let i,r=Math.min(this.editorHeight,this.pixelViewport.bottom-this.pixelViewport.top),s=n.lineAt(e,QueryType.ByPos,o,0,0);i="center"==t.y?(s.top+s.bottom)/2-r/2:"start"==t.y||"nearest"==t.y&&e<a.from?s.top:s.bottom-r,a=new Viewport(n.lineAt(i-500,QueryType.ByHeight,o,0,0).from,n.lineAt(i+r+500,QueryType.ByHeight,o,0,0).to);}}return a}mapViewport(e,t){let i=t.mapPos(e.from,-1),n=t.mapPos(e.to,1);return new Viewport(this.heightMap.lineAt(i,QueryType.ByPos,this.state.doc,0,0).from,this.heightMap.lineAt(n,QueryType.ByPos,this.state.doc,0,0).to)}viewportIsAppropriate({from:e,to:t},i=0){if(!this.inView)return !0;let{top:n}=this.heightMap.lineAt(e,QueryType.ByPos,this.state.doc,0,0),{bottom:o}=this.heightMap.lineAt(t,QueryType.ByPos,this.state.doc,0,0),{visibleTop:r,visibleBottom:s}=this;return (0==e||n<=r-Math.max(10,Math.min(-i,250)))&&(t==this.state.doc.length||o>=s+Math.max(10,Math.min(i,250)))&&n>r-2e3&&o<s+2e3}mapLineGaps(e,t){if(!e.length||t.empty)return e;let i=[];for(let n of e)t.touchesRange(n.from,n.to)||i.push(new LineGap(t.mapPos(n.from),t.mapPos(n.to),n.size));return i}ensureLineGaps(e,t){let i=this.heightOracle.lineWrapping,n=i?1e4:2e3,o=n>>1,r=n<<1;if(this.defaultTextDirection!=Direction.LTR&&!i)return [];let s=[],a=(n,r,l,h)=>{if(r-n<o)return;let c=this.state.selection.main,d=[c.from];c.empty||d.push(c.to);for(let e of d)if(e>n&&e<r)return a(n,e-10,l,h),void a(e+10,r,l,h);let u=find(e,e=>e.from>=l.from&&e.to<=l.to&&Math.abs(e.from-n)<o&&Math.abs(e.to-r)<o&&!d.some(t=>e.from<t&&e.to>t));if(!u){if(r<l.to&&t&&i&&t.visibleRanges.some(e=>e.from<=r&&e.to>=r)){let e=t.moveToLineBoundary(EditorSelection.cursor(r),!1,!0).head;e>n&&(r=e);}u=new LineGap(n,r,this.gapSize(l,n,r,h));}s.push(u);};for(let e of this.viewportLines){if(e.length<r)continue;let t=lineStructure(e.from,e.to,this.stateDeco);if(t.total<r)continue;let o,s,l=this.scrollTarget?this.scrollTarget.range.head:null;if(i){let i,r,a=n/this.heightOracle.lineLength*this.heightOracle.lineHeight;if(null!=l){let n=findFraction(t,l),o=((this.visibleBottom-this.visibleTop)/2+a)/e.height;i=n-o,r=n+o;}else i=(this.visibleTop-e.top-a)/e.height,r=(this.visibleBottom-e.top+a)/e.height;o=findPosition(t,i),s=findPosition(t,r);}else {let e,i,r=t.total*this.heightOracle.charWidth,a=n*this.heightOracle.charWidth;if(null!=l){let n=findFraction(t,l),o=((this.pixelViewport.right-this.pixelViewport.left)/2+a)/r;e=n-o,i=n+o;}else e=(this.pixelViewport.left-a)/r,i=(this.pixelViewport.right+a)/r;o=findPosition(t,e),s=findPosition(t,i);}o>e.from&&a(e.from,o,e,t),s<e.to&&a(s,e.to,e,t);}return s}gapSize(e,t,i,n){let o=findFraction(n,i)-findFraction(n,t);return this.heightOracle.lineWrapping?e.height*o:n.total*this.heightOracle.charWidth*o}updateLineGaps(e){LineGap.same(e,this.lineGaps)||(this.lineGaps=e,this.lineGapDeco=Decoration.set(e.map(e=>e.draw(this.heightOracle.lineWrapping))));}computeVisibleRanges(){let e=this.stateDeco;this.lineGaps.length&&(e=e.concat(this.lineGapDeco));let t=[];RangeSet.spans(e,this.viewport.from,this.viewport.to,{span(e,i){t.push({from:e,to:i});},point(){}},20);let i=t.length!=this.visibleRanges.length||this.visibleRanges.some((e,i)=>e.from!=t[i].from||e.to!=t[i].to);return this.visibleRanges=t,i?4:0}lineBlockAt(e){return e>=this.viewport.from&&e<=this.viewport.to&&this.viewportLines.find(t=>t.from<=e&&t.to>=e)||scaleBlock(this.heightMap.lineAt(e,QueryType.ByPos,this.state.doc,0,0),this.scaler)}lineBlockAtHeight(e){return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(e),QueryType.ByHeight,this.state.doc,0,0),this.scaler)}elementAtHeight(e){return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(e),this.state.doc,0,0),this.scaler)}get docHeight(){return this.scaler.toDOM(this.heightMap.height)}get contentHeight(){return this.docHeight+this.paddingTop+this.paddingBottom}}class Viewport{constructor(e,t){this.from=e,this.to=t;}}function lineStructure(e,t,i){let n=[],o=e,r=0;return RangeSet.spans(i,e,t,{span(){},point(e,t){e>o&&(n.push({from:o,to:e}),r+=e-o),o=t;}},20),o<t&&(n.push({from:o,to:t}),r+=t-o),{total:r,ranges:n}}function findPosition({total:e,ranges:t},i){if(i<=0)return t[0].from;if(i>=1)return t[t.length-1].to;let n=Math.floor(e*i);for(let e=0;;e++){let{from:i,to:o}=t[e],r=o-i;if(n<=r)return i+n;n-=r;}}function findFraction(e,t){let i=0;for(let{from:n,to:o}of e.ranges){if(t<=o){i+=t-n;break}i+=o-n;}return i/e.total}function find(e,t){for(let i of e)if(t(i))return i}const IdScaler={toDOM:e=>e,fromDOM:e=>e,scale:1};class BigScaler{constructor(e,t,i){let n=0,o=0,r=0;this.viewports=i.map(({from:i,to:o})=>{let r=t.lineAt(i,QueryType.ByPos,e,0,0).top,s=t.lineAt(o,QueryType.ByPos,e,0,0).bottom;return n+=s-r,{from:i,to:o,top:r,bottom:s,domTop:0,domBottom:0}}),this.scale=(7e6-n)/(t.height-n);for(let e of this.viewports)e.domTop=r+(e.top-o)*this.scale,r=e.domBottom=e.domTop+(e.bottom-e.top),o=e.bottom;}toDOM(e){for(let t=0,i=0,n=0;;t++){let o=t<this.viewports.length?this.viewports[t]:null;if(!o||e<o.top)return n+(e-i)*this.scale;if(e<=o.bottom)return o.domTop+(e-o.top);i=o.bottom,n=o.domBottom;}}fromDOM(e){for(let t=0,i=0,n=0;;t++){let o=t<this.viewports.length?this.viewports[t]:null;if(!o||e<o.domTop)return i+(e-n)/this.scale;if(e<=o.domBottom)return o.top+(e-o.domTop);i=o.bottom,n=o.domBottom;}}}function scaleBlock(e,t){if(1==t.scale)return e;let i=t.toDOM(e.top),n=t.toDOM(e.bottom);return new BlockInfo(e.from,e.length,i,n-i,Array.isArray(e.type)?e.type.map(e=>scaleBlock(e,t)):e.type)}const theme=Facet.define({combine:e=>e.join(" ")}),darkTheme=Facet.define({combine:e=>e.indexOf(!0)>-1}),baseThemeID=StyleModule.newName(),baseLightID=StyleModule.newName(),baseDarkID=StyleModule.newName(),lightDarkIDs={"&light":"."+baseLightID,"&dark":"."+baseDarkID};function buildTheme(e,t,i){return new StyleModule(t,{finish:t=>/&/.test(t)?t.replace(/&\w*/,t=>{if("&"==t)return e;if(!i||!i[t])throw new RangeError(`Unsupported selector: ${t}`);return i[t]}):e+" "+t})}const baseTheme$1=buildTheme("."+baseThemeID,{"&.cm-editor":{position:"relative !important",boxSizing:"border-box","&.cm-focused":{outline:"1px dotted #212121"},display:"flex !important",flexDirection:"column"},".cm-scroller":{display:"flex !important",alignItems:"flex-start !important",fontFamily:"monospace",lineHeight:1.4,height:"100%",overflowX:"auto",position:"relative",zIndex:0},".cm-content":{margin:0,flexGrow:2,flexShrink:0,minHeight:"100%",display:"block",whiteSpace:"pre",wordWrap:"normal",boxSizing:"border-box",padding:"4px 0",outline:"none","&[contenteditable=true]":{WebkitUserModify:"read-write-plaintext-only"}},".cm-lineWrapping":{whiteSpace_fallback:"pre-wrap",whiteSpace:"break-spaces",wordBreak:"break-word",overflowWrap:"anywhere",flexShrink:1},"&light .cm-content":{caretColor:"black"},"&dark .cm-content":{caretColor:"white"},".cm-line":{display:"block",padding:"0 2px 0 6px"},".cm-layer":{contain:"size style","& > *":{position:"absolute"}},"&light .cm-selectionBackground":{background:"#d9d9d9"},"&dark .cm-selectionBackground":{background:"#222"},"&light.cm-focused .cm-selectionBackground":{background:"#d7d4f0"},"&dark.cm-focused .cm-selectionBackground":{background:"#233"},".cm-cursorLayer":{pointerEvents:"none"},"&.cm-focused .cm-cursorLayer":{animation:"steps(1) cm-blink 1.2s infinite"},"@keyframes cm-blink":{"0%":{},"50%":{opacity:0},"100%":{}},"@keyframes cm-blink2":{"0%":{},"50%":{opacity:0},"100%":{}},".cm-cursor, .cm-dropCursor":{borderLeft:"1.2px solid black",marginLeft:"-0.6px",pointerEvents:"none"},".cm-cursor":{display:"none"},"&dark .cm-cursor":{borderLeftColor:"#444"},"&.cm-focused .cm-cursor":{display:"block"},"&light .cm-activeLine":{backgroundColor:"#cceeff44"},"&dark .cm-activeLine":{backgroundColor:"#99eeff33"},"&light .cm-specialChar":{color:"red"},"&dark .cm-specialChar":{color:"#f78"},".cm-gutters":{flexShrink:0,display:"flex",height:"100%",boxSizing:"border-box",left:0,zIndex:200},"&light .cm-gutters":{backgroundColor:"#f5f5f5",color:"#6c6c6c",borderRight:"1px solid #ddd"},"&dark .cm-gutters":{backgroundColor:"#333338",color:"#ccc"},".cm-gutter":{display:"flex !important",flexDirection:"column",flexShrink:0,boxSizing:"border-box",minHeight:"100%",overflow:"hidden"},".cm-gutterElement":{boxSizing:"border-box"},".cm-lineNumbers .cm-gutterElement":{padding:"0 3px 0 5px",minWidth:"20px",textAlign:"right",whiteSpace:"nowrap"},"&light .cm-activeLineGutter":{backgroundColor:"#e2f2ff"},"&dark .cm-activeLineGutter":{backgroundColor:"#222227"},".cm-panels":{boxSizing:"border-box",position:"sticky",left:0,right:0},"&light .cm-panels":{backgroundColor:"#f5f5f5",color:"black"},"&light .cm-panels-top":{borderBottom:"1px solid #ddd"},"&light .cm-panels-bottom":{borderTop:"1px solid #ddd"},"&dark .cm-panels":{backgroundColor:"#333338",color:"white"},".cm-tab":{display:"inline-block",overflow:"hidden",verticalAlign:"bottom"},".cm-widgetBuffer":{verticalAlign:"text-top",height:"1em",width:0,display:"inline"},".cm-placeholder":{color:"#888",display:"inline-block",verticalAlign:"top"},".cm-button":{verticalAlign:"middle",color:"inherit",fontSize:"70%",padding:".2em 1em",borderRadius:"1px"},"&light .cm-button":{backgroundImage:"linear-gradient(#eff1f5, #d9d9df)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#b4b4b4, #d0d3d6)"}},"&dark .cm-button":{backgroundImage:"linear-gradient(#393939, #111)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#111, #333)"}},".cm-textfield":{verticalAlign:"middle",color:"inherit",fontSize:"70%",border:"1px solid silver",padding:".2em .5em"},"&light .cm-textfield":{backgroundColor:"white"},"&dark .cm-textfield":{border:"1px solid #555",backgroundColor:"inherit"}},lightDarkIDs);class DOMChange{constructor(e,t,i,n){this.typeOver=n,this.bounds=null,this.text="";let{impreciseHead:o,impreciseAnchor:r}=e.docView;if(e.state.readOnly&&t>-1)this.newSel=null;else if(t>-1&&(this.bounds=e.docView.domBoundsAround(t,i,0))){let t=o||r?[]:selectionPoints(e),i=new DOMReader(t,e.state);i.readRange(this.bounds.startDOM,this.bounds.endDOM),this.text=i.text,this.newSel=selectionFromPoints(t,this.bounds.from);}else {let t=e.observer.selectionRange,i=o&&o.node==t.focusNode&&o.offset==t.focusOffset||!contains(e.contentDOM,t.focusNode)?e.state.selection.main.head:e.docView.posFromDOM(t.focusNode,t.focusOffset),n=r&&r.node==t.anchorNode&&r.offset==t.anchorOffset||!contains(e.contentDOM,t.anchorNode)?e.state.selection.main.anchor:e.docView.posFromDOM(t.anchorNode,t.anchorOffset);this.newSel=EditorSelection.single(n,i);}}}function applyDOMChange(e,t){let i,{newSel:n}=t,o=e.state.selection.main;if(t.bounds){let{from:n,to:r}=t.bounds,s=o.from,a=null;(8===e.inputState.lastKeyCode&&e.inputState.lastKeyTime>Date.now()-100||browser.android&&t.text.length<r-n)&&(s=o.to,a="end");let l=findDiff(e.state.doc.sliceString(n,r,LineBreakPlaceholder),t.text,s-n,a);l&&(browser.chrome&&13==e.inputState.lastKeyCode&&l.toB==l.from+2&&t.text.slice(l.from,l.toB)==LineBreakPlaceholder+LineBreakPlaceholder&&l.toB--,i={from:n+l.from,to:n+l.toA,insert:Text.of(t.text.slice(l.from,l.toB).split(LineBreakPlaceholder))});}else !n||e.hasFocus&&e.state.facet(editable)&&!n.main.eq(o)||(n=null);if(!i&&!n)return !1;if(!i&&t.typeOver&&!o.empty&&n&&n.main.empty?i={from:o.from,to:o.to,insert:e.state.doc.slice(o.from,o.to)}:i&&i.from>=o.from&&i.to<=o.to&&(i.from!=o.from||i.to!=o.to)&&o.to-o.from-(i.to-i.from)<=4?i={from:o.from,to:o.to,insert:e.state.doc.slice(o.from,i.from).append(i.insert).append(e.state.doc.slice(i.to,o.to))}:(browser.mac||browser.android)&&i&&i.from==i.to&&i.from==o.head-1&&/^\. ?$/.test(i.insert.toString())?(n&&2==i.insert.length&&(n=EditorSelection.single(n.main.anchor-1,n.main.head-1)),i={from:o.from,to:o.to,insert:Text.of([" "])}):browser.chrome&&i&&i.from==i.to&&i.from==o.head&&"\n "==i.insert.toString()&&e.lineWrapping&&(n&&(n=EditorSelection.single(n.main.anchor-1,n.main.head-1)),i={from:o.from,to:o.to,insert:Text.of([" "])}),i){let t=e.state;if(browser.ios&&e.inputState.flushIOSKey(e))return !0;if(browser.android&&(i.from==o.from&&i.to==o.to&&1==i.insert.length&&2==i.insert.lines&&dispatchKey(e.contentDOM,"Enter",13)||i.from==o.from-1&&i.to==o.to&&0==i.insert.length&&dispatchKey(e.contentDOM,"Backspace",8)||i.from==o.from&&i.to==o.to+1&&0==i.insert.length&&dispatchKey(e.contentDOM,"Delete",46)))return !0;let r,s=i.insert.toString();if(e.state.facet(inputHandler).some(t=>t(e,i.from,i.to,s)))return !0;if(e.inputState.composing>=0&&e.inputState.composing++,i.from>=o.from&&i.to<=o.to&&i.to-i.from>=(o.to-o.from)/3&&(!n||n.main.empty&&n.main.from==i.from+i.insert.length)&&e.inputState.composing<0){let n=o.from<i.from?t.sliceDoc(o.from,i.from):"",s=o.to>i.to?t.sliceDoc(i.to,o.to):"";r=t.replaceSelection(e.state.toText(n+i.insert.sliceString(0,void 0,e.state.lineBreak)+s));}else {let s=t.changes(i),a=n&&!t.selection.main.eq(n.main)&&n.main.to<=s.newLength?n.main:void 0;if(t.selection.ranges.length>1&&e.inputState.composing>=0&&i.to<=o.to&&i.to>=o.to-10){let n=e.state.sliceDoc(i.from,i.to),l=compositionSurroundingNode(e)||e.state.doc.lineAt(o.head),h=o.to-i.to,c=o.to-o.from;r=t.changeByRange(r=>{if(r.from==o.from&&r.to==o.to)return {changes:s,range:a||r.map(s)};let d=r.to-h,u=d-n.length;if(r.to-r.from!=c||e.state.sliceDoc(u,d)!=n||l&&r.to>=l.from&&r.from<=l.to)return {range:r};let f=t.changes({from:u,to:d,insert:i.insert}),p=r.to-o.to;return {changes:f,range:a?EditorSelection.range(Math.max(0,a.anchor+p),Math.max(0,a.head+p)):r.map(f)}});}else r={changes:s,selection:a&&t.selection.replaceRange(a)};}let a="input.type";return e.composing&&(a+=".compose",e.inputState.compositionFirstChange&&(a+=".start",e.inputState.compositionFirstChange=!1)),e.dispatch(r,{scrollIntoView:!0,userEvent:a}),!0}if(n&&!n.main.eq(o)){let t=!1,i="select";return e.inputState.lastSelectionTime>Date.now()-50&&("select"==e.inputState.lastSelectionOrigin&&(t=!0),i=e.inputState.lastSelectionOrigin),e.dispatch({selection:n,scrollIntoView:t,userEvent:i}),!0}return !1}function findDiff(e,t,i,n){let o=Math.min(e.length,t.length),r=0;for(;r<o&&e.charCodeAt(r)==t.charCodeAt(r);)r++;if(r==o&&e.length==t.length)return null;let s=e.length,a=t.length;for(;s>0&&a>0&&e.charCodeAt(s-1)==t.charCodeAt(a-1);)s--,a--;if("end"==n){i-=s+Math.max(0,r-Math.min(s,a))-r;}if(s<r&&e.length<t.length){a=(r-=i<=r&&i>=s?r-i:0)+(a-s),s=r;}else if(a<r){s=(r-=i<=r&&i>=a?r-i:0)+(s-a),a=r;}return {from:r,toA:s,toB:a}}function selectionPoints(e){let t=[];if(e.root.activeElement!=e.contentDOM)return t;let{anchorNode:i,anchorOffset:n,focusNode:o,focusOffset:r}=e.observer.selectionRange;return i&&(t.push(new DOMPoint(i,n)),o==i&&r==n||t.push(new DOMPoint(o,r))),t}function selectionFromPoints(e,t){if(0==e.length)return null;let i=e[0].pos,n=2==e.length?e[1].pos:i;return i>-1&&n>-1?EditorSelection.single(i+t,n+t):null}const observeOptions={childList:!0,characterData:!0,subtree:!0,attributes:!0,characterDataOldValue:!0},useCharData=browser.ie&&browser.ie_version<=11;class DOMObserver{constructor(e){this.view=e,this.active=!1,this.selectionRange=new DOMSelectionState,this.selectionChanged=!1,this.delayedFlush=-1,this.resizeTimeout=-1,this.queue=[],this.delayedAndroidKey=null,this.flushingAndroidKey=-1,this.lastChange=0,this.scrollTargets=[],this.intersection=null,this.resize=null,this.intersecting=!1,this.gapIntersection=null,this.gaps=[],this.parentCheck=-1,this.dom=e.contentDOM,this.observer=new MutationObserver(t=>{for(let e of t)this.queue.push(e);(browser.ie&&browser.ie_version<=11||browser.ios&&e.composing)&&t.some(e=>"childList"==e.type&&e.removedNodes.length||"characterData"==e.type&&e.oldValue.length>e.target.nodeValue.length)?this.flushSoon():this.flush();}),useCharData&&(this.onCharData=(e=>{this.queue.push({target:e.target,type:"characterData",oldValue:e.prevValue}),this.flushSoon();})),this.onSelectionChange=this.onSelectionChange.bind(this),this.onResize=this.onResize.bind(this),this.onPrint=this.onPrint.bind(this),this.onScroll=this.onScroll.bind(this),"function"==typeof ResizeObserver&&(this.resize=new ResizeObserver(()=>{var e;(null===(e=this.view.docView)||void 0===e?void 0:e.lastUpdate)<Date.now()-75&&this.onResize();}),this.resize.observe(e.scrollDOM)),this.addWindowListeners(this.win=e.win),this.start(),"function"==typeof IntersectionObserver&&(this.intersection=new IntersectionObserver(e=>{this.parentCheck<0&&(this.parentCheck=setTimeout(this.listenForScroll.bind(this),1e3)),e.length>0&&e[e.length-1].intersectionRatio>0!=this.intersecting&&(this.intersecting=!this.intersecting,this.intersecting!=this.view.inView&&this.onScrollChanged(document.createEvent("Event")));},{}),this.intersection.observe(this.dom),this.gapIntersection=new IntersectionObserver(e=>{e.length>0&&e[e.length-1].intersectionRatio>0&&this.onScrollChanged(document.createEvent("Event"));},{})),this.listenForScroll(),this.readSelectionRange();}onScrollChanged(e){this.view.inputState.runScrollHandlers(this.view,e),this.intersecting&&this.view.measure();}onScroll(e){this.intersecting&&this.flush(!1),this.onScrollChanged(e);}onResize(){this.resizeTimeout<0&&(this.resizeTimeout=setTimeout(()=>{this.resizeTimeout=-1,this.view.requestMeasure();},50));}onPrint(){this.view.viewState.printing=!0,this.view.measure(),setTimeout(()=>{this.view.viewState.printing=!1,this.view.requestMeasure();},500);}updateGaps(e){if(this.gapIntersection&&(e.length!=this.gaps.length||this.gaps.some((t,i)=>t!=e[i]))){this.gapIntersection.disconnect();for(let t of e)this.gapIntersection.observe(t);this.gaps=e;}}onSelectionChange(e){let t=this.selectionChanged;if(!this.readSelectionRange()||this.delayedAndroidKey)return;let{view:i}=this,n=this.selectionRange;if(i.state.facet(editable)?i.root.activeElement!=this.dom:!hasSelection(i.dom,n))return;let o=n.anchorNode&&i.docView.nearest(n.anchorNode);o&&o.ignoreEvent(e)?t||(this.selectionChanged=!1):(browser.ie&&browser.ie_version<=11||browser.android&&browser.chrome)&&!i.state.selection.main.empty&&n.focusNode&&isEquivalentPosition(n.focusNode,n.focusOffset,n.anchorNode,n.anchorOffset)?this.flushSoon():this.flush(!1);}readSelectionRange(){let{view:e}=this,t=browser.safari&&11==e.root.nodeType&&deepActiveElement(this.dom.ownerDocument)==this.dom&&safariSelectionRangeHack(this.view)||getSelection(e.root);if(!t||this.selectionRange.eq(t))return !1;let i=hasSelection(this.dom,t);return i&&!this.selectionChanged&&e.inputState.lastFocusTime>Date.now()-200&&e.inputState.lastTouchTime<Date.now()-300&&atElementStart(this.dom,t)?(this.view.inputState.lastFocusTime=0,e.docView.updateSelection(),!1):(this.selectionRange.setRange(t),i&&(this.selectionChanged=!0),!0)}setSelectionRange(e,t){this.selectionRange.set(e.node,e.offset,t.node,t.offset),this.selectionChanged=!1;}clearSelectionRange(){this.selectionRange.set(null,0,null,0);}listenForScroll(){this.parentCheck=-1;let e=0,t=null;for(let i=this.dom;i;)if(1==i.nodeType)!t&&e<this.scrollTargets.length&&this.scrollTargets[e]==i?e++:t||(t=this.scrollTargets.slice(0,e)),t&&t.push(i),i=i.assignedSlot||i.parentNode;else {if(11!=i.nodeType)break;i=i.host;}if(e<this.scrollTargets.length&&!t&&(t=this.scrollTargets.slice(0,e)),t){for(let e of this.scrollTargets)e.removeEventListener("scroll",this.onScroll);for(let e of this.scrollTargets=t)e.addEventListener("scroll",this.onScroll);}}ignore(e){if(!this.active)return e();try{return this.stop(),e()}finally{this.start(),this.clear();}}start(){this.active||(this.observer.observe(this.dom,observeOptions),useCharData&&this.dom.addEventListener("DOMCharacterDataModified",this.onCharData),this.active=!0);}stop(){this.active&&(this.active=!1,this.observer.disconnect(),useCharData&&this.dom.removeEventListener("DOMCharacterDataModified",this.onCharData));}clear(){this.processRecords(),this.queue.length=0,this.selectionChanged=!1;}delayAndroidKey(e,t){var i;if(!this.delayedAndroidKey){let e=()=>{let e=this.delayedAndroidKey;e&&(this.clearDelayedAndroidKey(),!this.flush()&&e.force&&dispatchKey(this.dom,e.key,e.keyCode));};this.flushingAndroidKey=this.view.win.requestAnimationFrame(e);}this.delayedAndroidKey&&"Enter"!=e||(this.delayedAndroidKey={key:e,keyCode:t,force:this.lastChange<Date.now()-50||!!(null===(i=this.delayedAndroidKey)||void 0===i?void 0:i.force)});}clearDelayedAndroidKey(){this.win.cancelAnimationFrame(this.flushingAndroidKey),this.delayedAndroidKey=null,this.flushingAndroidKey=-1;}flushSoon(){this.delayedFlush<0&&(this.delayedFlush=this.view.win.requestAnimationFrame(()=>{this.delayedFlush=-1,this.flush();}));}forceFlush(){this.delayedFlush>=0&&(this.view.win.cancelAnimationFrame(this.delayedFlush),this.delayedFlush=-1),this.flush();}processRecords(){let e=this.queue;for(let t of this.observer.takeRecords())e.push(t);e.length&&(this.queue=[]);let t=-1,i=-1,n=!1;for(let o of e){let e=this.readMutation(o);e&&(e.typeOver&&(n=!0),-1==t?({from:t,to:i}=e):(t=Math.min(e.from,t),i=Math.max(e.to,i)));}return {from:t,to:i,typeOver:n}}readChange(){let{from:e,to:t,typeOver:i}=this.processRecords(),n=this.selectionChanged&&hasSelection(this.dom,this.selectionRange);return e<0&&!n?null:(e>-1&&(this.lastChange=Date.now()),this.view.inputState.lastFocusTime=0,this.selectionChanged=!1,new DOMChange(this.view,e,t,i))}flush(e=!0){if(this.delayedFlush>=0||this.delayedAndroidKey)return !1;e&&this.readSelectionRange();let t=this.readChange();if(!t)return !1;let i=this.view.state,n=applyDOMChange(this.view,t);return this.view.state==i&&this.view.update([]),n}readMutation(e){let t=this.view.docView.nearest(e.target);if(!t||t.ignoreMutation(e))return null;if(t.markDirty("attributes"==e.type),"attributes"==e.type&&(t.dirty|=4),"childList"==e.type){let i=findChild(t,e.previousSibling||e.target.previousSibling,-1),n=findChild(t,e.nextSibling||e.target.nextSibling,1);return {from:i?t.posAfter(i):t.posAtStart,to:n?t.posBefore(n):t.posAtEnd,typeOver:!1}}return "characterData"==e.type?{from:t.posAtStart,to:t.posAtEnd,typeOver:e.target.nodeValue==e.oldValue}:null}setWindow(e){e!=this.win&&(this.removeWindowListeners(this.win),this.win=e,this.addWindowListeners(this.win));}addWindowListeners(e){e.addEventListener("resize",this.onResize),e.addEventListener("beforeprint",this.onPrint),e.addEventListener("scroll",this.onScroll),e.document.addEventListener("selectionchange",this.onSelectionChange);}removeWindowListeners(e){e.removeEventListener("scroll",this.onScroll),e.removeEventListener("resize",this.onResize),e.removeEventListener("beforeprint",this.onPrint),e.document.removeEventListener("selectionchange",this.onSelectionChange);}destroy(){var e,t,i;this.stop(),null===(e=this.intersection)||void 0===e||e.disconnect(),null===(t=this.gapIntersection)||void 0===t||t.disconnect(),null===(i=this.resize)||void 0===i||i.disconnect();for(let e of this.scrollTargets)e.removeEventListener("scroll",this.onScroll);this.removeWindowListeners(this.win),clearTimeout(this.parentCheck),clearTimeout(this.resizeTimeout),this.win.cancelAnimationFrame(this.delayedFlush),this.win.cancelAnimationFrame(this.flushingAndroidKey);}}function findChild(e,t,i){for(;t;){let n=ContentView.get(t);if(n&&n.parent==e)return n;let o=t.parentNode;t=o!=e.dom?o:i>0?t.nextSibling:t.previousSibling;}return null}function safariSelectionRangeHack(e){let t=null;function i(e){e.preventDefault(),e.stopImmediatePropagation(),t=e.getTargetRanges()[0];}if(e.contentDOM.addEventListener("beforeinput",i,!0),e.dom.ownerDocument.execCommand("indent"),e.contentDOM.removeEventListener("beforeinput",i,!0),!t)return null;let n=t.startContainer,o=t.startOffset,r=t.endContainer,s=t.endOffset,a=e.docView.domAtPos(e.state.selection.main.anchor);return isEquivalentPosition(a.node,a.offset,r,s)&&([n,o,r,s]=[r,s,n,o]),{anchorNode:n,anchorOffset:o,focusNode:r,focusOffset:s}}class EditorView{constructor(e={}){this.plugins=[],this.pluginMap=new Map,this.editorAttrs={},this.contentAttrs={},this.bidiCache=[],this.destroyed=!1,this.updateState=2,this.measureScheduled=-1,this.measureRequests=[],this.contentDOM=document.createElement("div"),this.scrollDOM=document.createElement("div"),this.scrollDOM.tabIndex=-1,this.scrollDOM.className="cm-scroller",this.scrollDOM.appendChild(this.contentDOM),this.announceDOM=document.createElement("div"),this.announceDOM.style.cssText="position: absolute; top: -10000px",this.announceDOM.setAttribute("aria-live","polite"),this.dom=document.createElement("div"),this.dom.appendChild(this.announceDOM),this.dom.appendChild(this.scrollDOM),this._dispatch=e.dispatch||(e=>this.update([e])),this.dispatch=this.dispatch.bind(this),this._root=e.root||getRoot(e.parent)||document,this.viewState=new ViewState(e.state||EditorState.create(e)),this.plugins=this.state.facet(viewPlugin).map(e=>new PluginInstance(e));for(let e of this.plugins)e.update(this);this.observer=new DOMObserver(this),this.inputState=new InputState(this),this.inputState.ensureHandlers(this,this.plugins),this.docView=new DocView(this),this.mountStyles(),this.updateAttrs(),this.updateState=0,this.requestMeasure(),e.parent&&e.parent.appendChild(this.dom);}get state(){return this.viewState.state}get viewport(){return this.viewState.viewport}get visibleRanges(){return this.viewState.visibleRanges}get inView(){return this.viewState.inView}get composing(){return this.inputState.composing>0}get compositionStarted(){return this.inputState.composing>=0}get root(){return this._root}get win(){return this.dom.ownerDocument.defaultView||window}dispatch(...e){this._dispatch(1==e.length&&e[0]instanceof Transaction?e[0]:this.state.update(...e));}update(e){if(0!=this.updateState)throw new Error("Calls to EditorView.update are not allowed while an update is in progress");let t,i=!1,n=!1,o=this.state;for(let t of e){if(t.startState!=o)throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");o=t.state;}if(this.destroyed)return void(this.viewState.state=o);let r=this.observer.delayedAndroidKey,s=null;if(r?(this.observer.clearDelayedAndroidKey(),((s=this.observer.readChange())&&!this.state.doc.eq(o.doc)||!this.state.selection.eq(o.selection))&&(s=null)):this.observer.clear(),o.facet(EditorState.phrases)!=this.state.facet(EditorState.phrases))return this.setState(o);t=ViewUpdate.create(this,o,e);let a=this.viewState.scrollTarget;try{this.updateState=2;for(let t of e){if(a&&(a=a.map(t.changes)),t.scrollIntoView){let{main:e}=t.state.selection;a=new ScrollTarget(e.empty?e:EditorSelection.cursor(e.head,e.head>e.anchor?-1:1));}for(let e of t.effects)e.is(scrollIntoView)&&(a=e.value);}this.viewState.update(t,a),this.bidiCache=CachedOrder.update(this.bidiCache,t.changes),t.empty||(this.updatePlugins(t),this.inputState.update(t)),i=this.docView.update(t),this.state.facet(styleModule)!=this.styleModules&&this.mountStyles(),n=this.updateAttrs(),this.showAnnouncements(e),this.docView.updateSelection(i,e.some(e=>e.isUserEvent("select.pointer")));}finally{this.updateState=0;}if(t.startState.facet(theme)!=t.state.facet(theme)&&(this.viewState.mustMeasureContent=!0),(i||n||a||this.viewState.mustEnforceCursorAssoc||this.viewState.mustMeasureContent)&&this.requestMeasure(),!t.empty)for(let e of this.state.facet(updateListener))e(t);s&&!applyDOMChange(this,s)&&r.force&&dispatchKey(this.contentDOM,r.key,r.keyCode);}setState(e){if(0!=this.updateState)throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");if(this.destroyed)return void(this.viewState.state=e);this.updateState=2;let t=this.hasFocus;try{for(let e of this.plugins)e.destroy(this);this.viewState=new ViewState(e),this.plugins=e.facet(viewPlugin).map(e=>new PluginInstance(e)),this.pluginMap.clear();for(let e of this.plugins)e.update(this);this.docView=new DocView(this),this.inputState.ensureHandlers(this,this.plugins),this.mountStyles(),this.updateAttrs(),this.bidiCache=[];}finally{this.updateState=0;}t&&this.focus(),this.requestMeasure();}updatePlugins(e){let t=e.startState.facet(viewPlugin),i=e.state.facet(viewPlugin);if(t!=i){let n=[];for(let o of i){let i=t.indexOf(o);if(i<0)n.push(new PluginInstance(o));else {let t=this.plugins[i];t.mustUpdate=e,n.push(t);}}for(let t of this.plugins)t.mustUpdate!=e&&t.destroy(this);this.plugins=n,this.pluginMap.clear(),this.inputState.ensureHandlers(this,this.plugins);}else for(let t of this.plugins)t.mustUpdate=e;for(let e=0;e<this.plugins.length;e++)this.plugins[e].update(this);}measure(e=!0){if(this.destroyed)return;this.measureScheduled>-1&&cancelAnimationFrame(this.measureScheduled),this.measureScheduled=0,e&&this.observer.forceFlush();let t=null,{scrollHeight:i,scrollTop:n,clientHeight:o}=this.scrollDOM,r=n>i-o-4?i:n;try{for(let e=0;;e++){this.updateState=1;let i=this.viewport,n=this.viewState.lineBlockAtHeight(r),o=this.viewState.measure(this);if(!o&&!this.measureRequests.length&&null==this.viewState.scrollTarget)break;if(e>5){console.warn(this.measureRequests.length?"Measure loop restarted more than 5 times":"Viewport failed to stabilize");break}let s=[];4&o||([this.measureRequests,s]=[s,this.measureRequests]);let a=s.map(e=>{try{return e.read(this)}catch(e){return logException(this.state,e),BadMeasure}}),l=ViewUpdate.create(this,this.state,[]),h=!1,c=!1;l.flags|=o,t?t.flags|=o:t=l,this.updateState=2,l.empty||(this.updatePlugins(l),this.inputState.update(l),this.updateAttrs(),h=this.docView.update(l));for(let e=0;e<s.length;e++)if(a[e]!=BadMeasure)try{let t=s[e];t.write&&t.write(a[e],this);}catch(e){logException(this.state,e);}if(this.viewState.editorHeight)if(this.viewState.scrollTarget)this.docView.scrollIntoView(this.viewState.scrollTarget),this.viewState.scrollTarget=null,c=!0;else {let e=this.viewState.lineBlockAt(n.from).top-n.top;(e>1||e<-1)&&(this.scrollDOM.scrollTop+=e,c=!0);}if(h&&this.docView.updateSelection(!0),this.viewport.from==i.from&&this.viewport.to==i.to&&!c&&0==this.measureRequests.length)break}}finally{this.updateState=0,this.measureScheduled=-1;}if(t&&!t.empty)for(let e of this.state.facet(updateListener))e(t);}get themeClasses(){return baseThemeID+" "+(this.state.facet(darkTheme)?baseDarkID:baseLightID)+" "+this.state.facet(theme)}updateAttrs(){let e=attrsFromFacet(this,editorAttributes,{class:"cm-editor"+(this.hasFocus?" cm-focused ":" ")+this.themeClasses}),t={spellcheck:"false",autocorrect:"off",autocapitalize:"off",translate:"no",contenteditable:this.state.facet(editable)?"true":"false",class:"cm-content",style:`${browser.tabSize}: ${this.state.tabSize}`,role:"textbox","aria-multiline":"true"};this.state.readOnly&&(t["aria-readonly"]="true"),attrsFromFacet(this,contentAttributes,t);let i=this.observer.ignore(()=>{let i=updateAttrs(this.contentDOM,this.contentAttrs,t),n=updateAttrs(this.dom,this.editorAttrs,e);return i||n});return this.editorAttrs=e,this.contentAttrs=t,i}showAnnouncements(e){let t=!0;for(let i of e)for(let e of i.effects)if(e.is(EditorView.announce)){t&&(this.announceDOM.textContent=""),t=!1,this.announceDOM.appendChild(document.createElement("div")).textContent=e.value;}}mountStyles(){this.styleModules=this.state.facet(styleModule),StyleModule.mount(this.root,this.styleModules.concat(baseTheme$1).reverse());}readMeasured(){if(2==this.updateState)throw new Error("Reading the editor layout isn't allowed during an update");0==this.updateState&&this.measureScheduled>-1&&this.measure(!1);}requestMeasure(e){if(this.measureScheduled<0&&(this.measureScheduled=this.win.requestAnimationFrame(()=>this.measure())),e){if(null!=e.key)for(let t=0;t<this.measureRequests.length;t++)if(this.measureRequests[t].key===e.key)return void(this.measureRequests[t]=e);this.measureRequests.push(e);}}plugin(e){let t=this.pluginMap.get(e);return (void 0===t||t&&t.spec!=e)&&this.pluginMap.set(e,t=this.plugins.find(t=>t.spec==e)||null),t&&t.update(this).value}get documentTop(){return this.contentDOM.getBoundingClientRect().top+this.viewState.paddingTop}get documentPadding(){return {top:this.viewState.paddingTop,bottom:this.viewState.paddingBottom}}elementAtHeight(e){return this.readMeasured(),this.viewState.elementAtHeight(e)}lineBlockAtHeight(e){return this.readMeasured(),this.viewState.lineBlockAtHeight(e)}get viewportLineBlocks(){return this.viewState.viewportLines}lineBlockAt(e){return this.viewState.lineBlockAt(e)}get contentHeight(){return this.viewState.contentHeight}moveByChar(e,t,i){return skipAtoms(this,e,moveByChar(this,e,t,i))}moveByGroup(e,t){return skipAtoms(this,e,moveByChar(this,e,t,t=>byGroup(this,e.head,t)))}moveToLineBoundary(e,t,i=!0){return moveToLineBoundary(this,e,t,i)}moveVertically(e,t,i){return skipAtoms(this,e,moveVertically(this,e,t,i))}domAtPos(e){return this.docView.domAtPos(e)}posAtDOM(e,t=0){return this.docView.posFromDOM(e,t)}posAtCoords(e,t=!0){return this.readMeasured(),posAtCoords(this,e,t)}coordsAtPos(e,t=1){this.readMeasured();let i=this.docView.coordsAt(e,t);if(!i||i.left==i.right)return i;let n=this.state.doc.lineAt(e),o=this.bidiSpans(n);return flattenRect(i,o[BidiSpan.find(o,e-n.from,-1,t)].dir==Direction.LTR==t>0)}get defaultCharacterWidth(){return this.viewState.heightOracle.charWidth}get defaultLineHeight(){return this.viewState.heightOracle.lineHeight}get textDirection(){return this.viewState.defaultTextDirection}textDirectionAt(e){return !this.state.facet(perLineTextDirection)||e<this.viewport.from||e>this.viewport.to?this.textDirection:(this.readMeasured(),this.docView.textDirectionAt(e))}get lineWrapping(){return this.viewState.heightOracle.lineWrapping}bidiSpans(e){if(e.length>MaxBidiLine)return trivialOrder(e.length);let t=this.textDirectionAt(e.from);for(let i of this.bidiCache)if(i.from==e.from&&i.dir==t)return i.order;let i=computeOrder(e.text,t);return this.bidiCache.push(new CachedOrder(e.from,e.to,t,i)),i}get hasFocus(){var e;return (this.dom.ownerDocument.hasFocus()||browser.safari&&(null===(e=this.inputState)||void 0===e?void 0:e.lastContextMenu)>Date.now()-3e4)&&this.root.activeElement==this.contentDOM}focus(){this.observer.ignore(()=>{focusPreventScroll(this.contentDOM),this.docView.updateSelection();});}setRoot(e){this._root!=e&&(this._root=e,this.observer.setWindow((9==e.nodeType?e:e.ownerDocument).defaultView||window),this.mountStyles());}destroy(){for(let e of this.plugins)e.destroy(this);this.plugins=[],this.inputState.destroy(),this.dom.remove(),this.observer.destroy(),this.measureScheduled>-1&&cancelAnimationFrame(this.measureScheduled),this.destroyed=!0;}static scrollIntoView(e,t={}){return scrollIntoView.of(new ScrollTarget("number"==typeof e?EditorSelection.cursor(e):e,t.y,t.x,t.yMargin,t.xMargin))}static domEventHandlers(e){return ViewPlugin.define(()=>({}),{eventHandlers:e})}static theme(e,t){let i=StyleModule.newName(),n=[theme.of(i),styleModule.of(buildTheme(`.${i}`,e))];return t&&t.dark&&n.push(darkTheme.of(!0)),n}static baseTheme(e){return Prec.lowest(styleModule.of(buildTheme("."+baseThemeID,e,lightDarkIDs)))}static findFromDOM(e){var t;let i=e.querySelector(".cm-content"),n=i&&ContentView.get(i)||ContentView.get(e);return (null===(t=null===n||void 0===n?void 0:n.rootView)||void 0===t?void 0:t.view)||null}}EditorView.styleModule=styleModule,EditorView.inputHandler=inputHandler,EditorView.perLineTextDirection=perLineTextDirection,EditorView.exceptionSink=exceptionSink,EditorView.updateListener=updateListener,EditorView.editable=editable,EditorView.mouseSelectionStyle=mouseSelectionStyle,EditorView.dragMovesSelection=dragMovesSelection$1,EditorView.clickAddsSelectionRange=clickAddsSelectionRange,EditorView.decorations=decorations,EditorView.atomicRanges=atomicRanges,EditorView.scrollMargins=scrollMargins,EditorView.darkTheme=darkTheme,EditorView.contentAttributes=contentAttributes,EditorView.editorAttributes=editorAttributes,EditorView.lineWrapping=EditorView.contentAttributes.of({class:"cm-lineWrapping"}),EditorView.announce=StateEffect.define();const MaxBidiLine=4096,BadMeasure={};class CachedOrder{constructor(e,t,i,n){this.from=e,this.to=t,this.dir=i,this.order=n;}static update(e,t){if(t.empty)return e;let i=[],n=e.length?e[e.length-1].dir:Direction.LTR;for(let o=Math.max(0,e.length-10);o<e.length;o++){let r=e[o];r.dir!=n||t.touchesRange(r.from,r.to)||i.push(new CachedOrder(t.mapPos(r.from,1),t.mapPos(r.to,-1),r.dir,r.order));}return i}}function attrsFromFacet(e,t,i){for(let n=e.state.facet(t),o=n.length-1;o>=0;o--){let t=n[o],r="function"==typeof t?t(e):t;r&&combineAttrs(r,i);}return i}const currentPlatform=browser.mac?"mac":browser.windows?"win":browser.linux?"linux":"key";function normalizeKeyName(e,t){const i=e.split(/-(?!$)/);let n,o,r,s,a=i[i.length-1];"Space"==a&&(a=" ");for(let e=0;e<i.length-1;++e){const a=i[e];if(/^(cmd|meta|m)$/i.test(a))s=!0;else if(/^a(lt)?$/i.test(a))n=!0;else if(/^(c|ctrl|control)$/i.test(a))o=!0;else if(/^s(hift)?$/i.test(a))r=!0;else {if(!/^mod$/i.test(a))throw new Error("Unrecognized modifier name: "+a);"mac"==t?s=!0:o=!0;}}return n&&(a="Alt-"+a),o&&(a="Ctrl-"+a),s&&(a="Meta-"+a),r&&(a="Shift-"+a),a}function modifiers(e,t,i){return t.altKey&&(e="Alt-"+e),t.ctrlKey&&(e="Ctrl-"+e),t.metaKey&&(e="Meta-"+e),!1!==i&&t.shiftKey&&(e="Shift-"+e),e}const handleKeyEvents=Prec.default(EditorView.domEventHandlers({keydown:(e,t)=>runHandlers(getKeymap(t.state),e,t,"editor")})),keymap=Facet.define({enables:handleKeyEvents}),Keymaps=new WeakMap;function getKeymap(e){let t=e.facet(keymap),i=Keymaps.get(t);return i||Keymaps.set(t,i=buildKeymap(t.reduce((e,t)=>e.concat(t),[]))),i}let storedPrefix=null;const PrefixTimeout=4e3;function buildKeymap(e,t=currentPlatform){let i=Object.create(null),n=Object.create(null),o=(e,t)=>{let i=n[e];if(null==i)n[e]=t;else if(i!=t)throw new Error("Key binding "+e+" is used both as a regular binding and as a multi-stroke prefix")},r=(e,n,r,s)=>{var a,l;let h=i[e]||(i[e]=Object.create(null)),c=n.split(/ (?!$)/).map(e=>normalizeKeyName(e,t));for(let t=1;t<c.length;t++){let i=c.slice(0,t).join(" ");o(i,!0),h[i]||(h[i]={preventDefault:!0,run:[t=>{let n=storedPrefix={view:t,prefix:i,scope:e};return setTimeout(()=>{storedPrefix==n&&(storedPrefix=null);},PrefixTimeout),!0}]});}let d=c.join(" ");o(d,!1);let u=h[d]||(h[d]={preventDefault:!1,run:(null===(l=null===(a=h._any)||void 0===a?void 0:a.run)||void 0===l?void 0:l.slice())||[]});r&&u.run.push(r),s&&(u.preventDefault=!0);};for(let n of e){let e=n.scope?n.scope.split(" "):["editor"];if(n.any)for(let t of e){let e=i[t]||(i[t]=Object.create(null));e._any||(e._any={preventDefault:!1,run:[]});for(let t in e)e[t].run.push(n.any);}let o=n[t]||n.key;if(o)for(let t of e)r(t,o,n.run,n.preventDefault),n.shift&&r(t,"Shift-"+o,n.shift,n.preventDefault);}return i}function runHandlers(e,t,i,n){let o=keyName(t),r=codePointSize(codePointAt(o,0))==o.length&&" "!=o,s="",a=!1;storedPrefix&&storedPrefix.view==i&&storedPrefix.scope==n&&(s=storedPrefix.prefix+" ",(a=modifierCodes.indexOf(t.keyCode)<0)&&(storedPrefix=null));let l,h,c=new Set,d=e=>{if(e){for(let n of e.run)if(!c.has(n)&&(c.add(n),n(i,t)))return !0;e.preventDefault&&(a=!0);}return !1},u=e[n];if(u){if(d(u[s+modifiers(o,t,!r)]))return !0;if(r&&(t.altKey||t.metaKey||t.ctrlKey)&&(l=base[t.keyCode])&&l!=o){if(d(u[s+modifiers(l,t,!0)]))return !0;if(t.shiftKey&&(h=shift[t.keyCode])!=o&&h!=l&&d(u[s+modifiers(h,t,!1)]))return !0}else if(r&&t.shiftKey&&d(u[s+modifiers(o,t,!0)]))return !0;if(d(u._any))return !0}return a}class RectangleMarker{constructor(e,t,i,n,o){this.className=e,this.left=t,this.top=i,this.width=n,this.height=o;}draw(){let e=document.createElement("div");return e.className=this.className,this.adjust(e),e}update(e,t){return t.className==this.className&&(this.adjust(e),!0)}adjust(e){e.style.left=this.left+"px",e.style.top=this.top+"px",this.width>=0&&(e.style.width=this.width+"px"),e.style.height=this.height+"px";}eq(e){return this.left==e.left&&this.top==e.top&&this.width==e.width&&this.height==e.height&&this.className==e.className}}function sameMarker(e,t){return e.constructor==t.constructor&&e.eq(t)}class LayerView{constructor(e,t){this.view=e,this.layer=t,this.drawn=[],this.measureReq={read:this.measure.bind(this),write:this.draw.bind(this)},this.dom=e.scrollDOM.appendChild(document.createElement("div")),this.dom.classList.add("cm-layer"),t.above&&this.dom.classList.add("cm-layer-above"),t.class&&this.dom.classList.add(t.class),this.dom.setAttribute("aria-hidden","true"),this.setOrder(e.state),e.requestMeasure(this.measureReq),t.mount&&t.mount(this.dom,e);}update(e){e.startState.facet(layerOrder)!=e.state.facet(layerOrder)&&this.setOrder(e.state),(this.layer.update(e,this.dom)||e.geometryChanged)&&e.view.requestMeasure(this.measureReq);}setOrder(e){let t=0,i=e.facet(layerOrder);for(;t<i.length&&i[t]!=this.layer;)t++;this.dom.style.zIndex=String((this.layer.above?150:-1)-t);}measure(){return this.layer.markers(this.view)}draw(e){if(e.length!=this.drawn.length||e.some((e,t)=>!sameMarker(e,this.drawn[t]))){let t=this.dom.firstChild,i=0;for(let n of e)n.update&&t&&n.constructor&&this.drawn[i].constructor&&n.update(t,this.drawn[i])?(t=t.nextSibling,i++):this.dom.insertBefore(n.draw(),t);for(;t;){let e=t.nextSibling;t.remove(),t=e;}this.drawn=e;}}destroy(){this.dom.remove();}}const layerOrder=Facet.define();function layer(e){return [ViewPlugin.define(t=>new LayerView(t,e)),layerOrder.of(e)]}const CanHidePrimary=!browser.ios,selectionConfig=Facet.define({combine:e=>combineConfig(e,{cursorBlinkRate:1200,drawRangeCursor:!0},{cursorBlinkRate:(e,t)=>Math.min(e,t),drawRangeCursor:(e,t)=>e||t})});function drawSelection(e={}){return [selectionConfig.of(e),cursorLayer,selectionLayer,hideNativeSelection,nativeSelectionHidden.of(!0)]}function configChanged(e){return e.startState.facet(selectionConfig)!=e.startState.facet(selectionConfig)}const cursorLayer=layer({above:!0,markers(e){let{state:t}=e,i=t.facet(selectionConfig),n=[];for(let o of t.selection.ranges){let r=o==t.selection.main;if(o.empty?!r||CanHidePrimary:i.drawRangeCursor){let t=measureCursor(e,o,r);t&&n.push(t);}}return n},update(e,t){e.transactions.some(e=>e.scrollIntoView)&&(t.style.animationName="cm-blink"==t.style.animationName?"cm-blink2":"cm-blink");let i=configChanged(e);return i&&setBlinkRate(e.state,t),e.docChanged||e.selectionSet||i},mount(e,t){setBlinkRate(t.state,e);},class:"cm-cursorLayer"});function setBlinkRate(e,t){t.style.animationDuration=e.facet(selectionConfig).cursorBlinkRate+"ms";}const selectionLayer=layer({above:!1,markers:e=>e.state.selection.ranges.map(t=>t.empty?[]:measureRange(e,t)).reduce((e,t)=>e.concat(t)),update:(e,t)=>e.docChanged||e.selectionSet||e.viewportChanged||configChanged(e),class:"cm-selectionLayer"}),themeSpec={".cm-line":{"& ::selection":{backgroundColor:"transparent !important"},"&::selection":{backgroundColor:"transparent !important"}}};CanHidePrimary&&(themeSpec[".cm-line"].caretColor="transparent !important");const hideNativeSelection=Prec.highest(EditorView.theme(themeSpec));function getBase(e){let t=e.scrollDOM.getBoundingClientRect();return {left:(e.textDirection==Direction.LTR?t.left:t.right-e.scrollDOM.clientWidth)-e.scrollDOM.scrollLeft,top:t.top-e.scrollDOM.scrollTop}}function wrappedLine(e,t,i){let n=EditorSelection.cursor(t);return {from:Math.max(i.from,e.moveToLineBoundary(n,!1,!0).from),to:Math.min(i.to,e.moveToLineBoundary(n,!0,!0).from),type:BlockType.Text}}function blockAt(e,t){let i=e.lineBlockAt(t);if(Array.isArray(i.type))for(let e of i.type)if(e.to>t||e.to==t&&(e.to==i.to||e.type==BlockType.Text))return e;return i}function measureRange(e,t){if(t.to<=e.viewport.from||t.from>=e.viewport.to)return [];let i=Math.max(t.from,e.viewport.from),n=Math.min(t.to,e.viewport.to),o=e.textDirection==Direction.LTR,r=e.contentDOM,s=r.getBoundingClientRect(),a=getBase(e),l=window.getComputedStyle(r.firstChild),h=s.left+parseInt(l.paddingLeft)+Math.min(0,parseInt(l.textIndent)),c=s.right-parseInt(l.paddingRight),d=blockAt(e,i),u=blockAt(e,n),f=d.type==BlockType.Text?d:null,p=u.type==BlockType.Text?u:null;if(e.lineWrapping&&(f&&(f=wrappedLine(e,i,f)),p&&(p=wrappedLine(e,n,p))),f&&p&&f.from==p.from)return g(m(t.from,t.to,f));{let i=f?m(t.from,null,f):S(d,!1),n=p?m(null,t.to,p):S(u,!0),o=[];return (f||d).to<(p||u).from-1?o.push(O(h,i.bottom,c,n.top)):i.bottom<n.top&&e.elementAtHeight((i.bottom+n.top)/2).type==BlockType.Text&&(i.bottom=n.top=(i.bottom+n.top)/2),g(i).concat(o).concat(g(n))}function O(e,t,i,n){return new RectangleMarker("cm-selectionBackground",e-a.left,t-a.top-.01,i-e,n-t+.01)}function g({top:e,bottom:t,horizontal:i}){let n=[];for(let o=0;o<i.length;o+=2)n.push(O(i[o],e,i[o+1],t));return n}function m(t,i,n){let r=1e9,s=-1e9,a=[];function l(t,i,l,d,u){let f=e.coordsAtPos(t,t==n.to?-2:2),p=e.coordsAtPos(l,l==n.from?2:-2);r=Math.min(f.top,p.top,r),s=Math.max(f.bottom,p.bottom,s),u==Direction.LTR?a.push(o&&i?h:f.left,o&&d?c:p.right):a.push(!o&&d?h:p.left,!o&&i?c:f.right);}let d=null!==t&&void 0!==t?t:n.from,u=null!==i&&void 0!==i?i:n.to;for(let n of e.visibleRanges)if(n.to>d&&n.from<u)for(let o=Math.max(n.from,d),r=Math.min(n.to,u);;){let n=e.state.doc.lineAt(o);for(let s of e.bidiSpans(n)){let e=s.from+n.from,a=s.to+n.from;if(e>=r)break;a>o&&l(Math.max(e,o),null==t&&e<=d,Math.min(a,r),null==i&&a>=u,s.dir);}if((o=n.to+1)>=r)break}return 0==a.length&&l(d,null==t,u,null==i,e.textDirection),{top:r,bottom:s,horizontal:a}}function S(e,t){let i=s.top+(t?e.top:e.bottom);return {top:i,bottom:i,horizontal:[]}}}function measureCursor(e,t,i){let n=e.coordsAtPos(t.head,t.assoc||1);if(!n)return null;let o=getBase(e);return new RectangleMarker(i?"cm-cursor cm-cursor-primary":"cm-cursor cm-cursor-secondary",n.left-o.left,n.top-o.top,-1,n.bottom-n.top)}const setDropCursorPos=StateEffect.define({map:(e,t)=>null==e?null:t.mapPos(e)}),dropCursorPos=StateField.define({create:()=>null,update:(e,t)=>(null!=e&&(e=t.changes.mapPos(e)),t.effects.reduce((e,t)=>t.is(setDropCursorPos)?t.value:e,e))});ViewPlugin.fromClass(class{constructor(e){this.view=e,this.cursor=null,this.measureReq={read:this.readPos.bind(this),write:this.drawCursor.bind(this)};}update(e){var t;let i=e.state.field(dropCursorPos);null==i?null!=this.cursor&&(null===(t=this.cursor)||void 0===t||t.remove(),this.cursor=null):(this.cursor||(this.cursor=this.view.scrollDOM.appendChild(document.createElement("div")),this.cursor.className="cm-dropCursor"),(e.startState.field(dropCursorPos)!=i||e.docChanged||e.geometryChanged)&&this.view.requestMeasure(this.measureReq));}readPos(){let e=this.view.state.field(dropCursorPos),t=null!=e&&this.view.coordsAtPos(e);if(!t)return null;let i=this.view.scrollDOM.getBoundingClientRect();return {left:t.left-i.left+this.view.scrollDOM.scrollLeft,top:t.top-i.top+this.view.scrollDOM.scrollTop,height:t.bottom-t.top}}drawCursor(e){this.cursor&&(e?(this.cursor.style.left=e.left+"px",this.cursor.style.top=e.top+"px",this.cursor.style.height=e.height+"px"):this.cursor.style.left="-100000px");}destroy(){this.cursor&&this.cursor.remove();}setDropPos(e){this.view.state.field(dropCursorPos)!=e&&this.view.dispatch({effects:setDropCursorPos.of(e)});}},{eventHandlers:{dragover(e){this.setDropPos(this.view.posAtCoords({x:e.clientX,y:e.clientY}));},dragleave(e){e.target!=this.view.contentDOM&&this.view.contentDOM.contains(e.relatedTarget)||this.setDropPos(null);},dragend(){this.setDropPos(null);},drop(){this.setDropPos(null);}}});function iterMatches(e,t,i,n,o){t.lastIndex=0;for(let r,s=e.iterRange(i,n),a=i;!s.next().done;a+=s.value.length)if(!s.lineBreak)for(;r=t.exec(s.value);)o(a+r.index,r);}function matchRanges(e,t){let i=e.visibleRanges;if(1==i.length&&i[0].from==e.viewport.from&&i[0].to==e.viewport.to)return i;let n=[];for(let{from:o,to:r}of i)o=Math.max(e.state.doc.lineAt(o).from,o-t),r=Math.min(e.state.doc.lineAt(r).to,r+t),n.length&&n[n.length-1].to>=o?n[n.length-1].to=r:n.push({from:o,to:r});return n}class MatchDecorator{constructor(e){const{regexp:t,decoration:i,decorate:n,boundary:o,maxLength:r=1e3}=e;if(!t.global)throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");if(this.regexp=t,n)this.addMatch=((e,t,i,o)=>n(o,i,i+e[0].length,e,t));else if("function"==typeof i)this.addMatch=((e,t,n,o)=>{let r=i(e,t,n);r&&o(n,n+e[0].length,r);});else {if(!i)throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");this.addMatch=((e,t,n,o)=>o(n,n+e[0].length,i));}this.boundary=o,this.maxLength=r;}createDeco(e){let t=new RangeSetBuilder,i=t.add.bind(t);for(let{from:t,to:n}of matchRanges(e,this.maxLength))iterMatches(e.state.doc,this.regexp,t,n,(t,n)=>this.addMatch(n,e,t,i));return t.finish()}updateDeco(e,t){let i=1e9,n=-1;return e.docChanged&&e.changes.iterChanges((t,o,r,s)=>{s>e.view.viewport.from&&r<e.view.viewport.to&&(i=Math.min(r,i),n=Math.max(s,n));}),e.viewportChanged||n-i>1e3?this.createDeco(e.view):n>-1?this.updateRange(e.view,t.map(e.changes),i,n):t}updateRange(e,t,i,n){for(let o of e.visibleRanges){let r=Math.max(o.from,i),s=Math.min(o.to,n);if(s>r){let i=e.state.doc.lineAt(r),n=i.to<s?e.state.doc.lineAt(s):i,a=Math.max(o.from,i.from),l=Math.min(o.to,n.to);if(this.boundary){for(;r>i.from;r--)if(this.boundary.test(i.text[r-1-i.from])){a=r;break}for(;s<n.to;s++)if(this.boundary.test(n.text[s-n.from])){l=s;break}}let h,c=[],d=(e,t,i)=>c.push(i.range(e,t));if(i==n)for(this.regexp.lastIndex=a-i.from;(h=this.regexp.exec(i.text))&&h.index<l-i.from;)this.addMatch(h,e,h.index+i.from,d);else iterMatches(e.state.doc,this.regexp,a,l,(t,i)=>this.addMatch(i,e,t,d));t=t.update({filterFrom:a,filterTo:l,filter:(e,t)=>e<a||t>l,add:c});}}return t}}const UnicodeRegexpSupport=null!=/x/.unicode?"gu":"g",Specials=new RegExp("[\0-\b\n--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\ufeff￹-￼]",UnicodeRegexpSupport),Names={0:"null",7:"bell",8:"backspace",10:"newline",11:"vertical tab",13:"carriage return",27:"escape",8203:"zero width space",8204:"zero width non-joiner",8205:"zero width joiner",8206:"left-to-right mark",8207:"right-to-left mark",8232:"line separator",8237:"left-to-right override",8238:"right-to-left override",8294:"left-to-right isolate",8295:"right-to-left isolate",8297:"pop directional isolate",8233:"paragraph separator",65279:"zero width no-break space",65532:"object replacement"};let _supportsTabSize=null;function supportsTabSize(){var e;if(null==_supportsTabSize&&"undefined"!=typeof document&&document.body){let t=document.body.style;_supportsTabSize=null!=(null!==(e=t.tabSize)&&void 0!==e?e:t.MozTabSize);}return _supportsTabSize||!1}const specialCharConfig=Facet.define({combine(e){let t=combineConfig(e,{render:null,specialChars:Specials,addSpecialChars:null});return (t.replaceTabs=!supportsTabSize())&&(t.specialChars=new RegExp("\t|"+t.specialChars.source,UnicodeRegexpSupport)),t.addSpecialChars&&(t.specialChars=new RegExp(t.specialChars.source+"|"+t.addSpecialChars.source,UnicodeRegexpSupport)),t}});function highlightSpecialChars(e={}){return [specialCharConfig.of(e),specialCharPlugin()]}let _plugin=null;function specialCharPlugin(){return _plugin||(_plugin=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.decorations=Decoration.none,this.decorationCache=Object.create(null),this.decorator=this.makeDecorator(e.state.facet(specialCharConfig)),this.decorations=this.decorator.createDeco(e);}makeDecorator(e){return new MatchDecorator({regexp:e.specialChars,decoration:(t,i,n)=>{let{doc:o}=i.state,r=codePointAt(t[0],0);if(9==r){let e=o.lineAt(n),t=i.state.tabSize,r=countColumn(e.text,t,n-e.from);return Decoration.replace({widget:new TabWidget((t-r%t)*this.view.defaultCharacterWidth)})}return this.decorationCache[r]||(this.decorationCache[r]=Decoration.replace({widget:new SpecialCharWidget(e,r)}))},boundary:e.replaceTabs?void 0:/[^]/})}update(e){let t=e.state.facet(specialCharConfig);e.startState.facet(specialCharConfig)!=t?(this.decorator=this.makeDecorator(t),this.decorations=this.decorator.createDeco(e.view)):this.decorations=this.decorator.updateDeco(e,this.decorations);}},{decorations:e=>e.decorations}))}const DefaultPlaceholder="•";function placeholder$1(e){return e>=32?DefaultPlaceholder:10==e?"␤":String.fromCharCode(9216+e)}class SpecialCharWidget extends WidgetType{constructor(e,t){super(),this.options=e,this.code=t;}eq(e){return e.code==this.code}toDOM(e){let t=placeholder$1(this.code),i=e.state.phrase("Control character")+" "+(Names[this.code]||"0x"+this.code.toString(16)),n=this.options.render&&this.options.render(this.code,i,t);if(n)return n;let o=document.createElement("span");return o.textContent=t,o.title=i,o.setAttribute("aria-label",i),o.className="cm-specialChar",o}ignoreEvent(){return !1}}class TabWidget extends WidgetType{constructor(e){super(),this.width=e;}eq(e){return e.width==this.width}toDOM(){let e=document.createElement("span");return e.textContent="\t",e.className="cm-tab",e.style.width=this.width+"px",e}ignoreEvent(){return !1}}ViewPlugin.fromClass(class{constructor(){this.height=1e3,this.attrs={style:"padding-bottom: 1000px"};}update(e){let{view:t}=e,i=t.viewState.editorHeight-t.defaultLineHeight-t.documentPadding.top-.5;i!=this.height&&(this.height=i,this.attrs={style:`padding-bottom: ${i}px`});}});const lineDeco=Decoration.line({class:"cm-activeLine"});ViewPlugin.fromClass(class{constructor(e){this.decorations=this.getDeco(e);}update(e){(e.docChanged||e.selectionSet)&&(this.decorations=this.getDeco(e.view));}getDeco(e){let t=-1,i=[];for(let n of e.state.selection.ranges){let o=e.lineBlockAt(n.head);o.from>t&&(i.push(lineDeco.range(o.from)),t=o.from);}return Decoration.set(i)}},{decorations:e=>e.decorations});const Outside="-10000px";class TooltipViewManager{constructor(e,t,i){this.facet=t,this.createTooltipView=i,this.input=e.state.facet(t),this.tooltips=this.input.filter(e=>e),this.tooltipViews=this.tooltips.map(i);}update(e){var t;let i=e.state.facet(this.facet),n=i.filter(e=>e);if(i===this.input){for(let t of this.tooltipViews)t.update&&t.update(e);return !1}let o=[];for(let t=0;t<n.length;t++){let i=n[t],r=-1;if(i){for(let e=0;e<this.tooltips.length;e++){let t=this.tooltips[e];t&&t.create==i.create&&(r=e);}if(r<0)o[t]=this.createTooltipView(i);else {let i=o[t]=this.tooltipViews[r];i.update&&i.update(e);}}}for(let e of this.tooltipViews)o.indexOf(e)<0&&(e.dom.remove(),null===(t=e.destroy)||void 0===t||t.call(e));return this.input=i,this.tooltips=n,this.tooltipViews=o,!0}}function windowSpace(e){let{win:t}=e;return {top:0,left:0,bottom:t.innerHeight,right:t.innerWidth}}const tooltipConfig=Facet.define({combine:e=>{var t,i,n;return {position:browser.ios?"absolute":(null===(t=e.find(e=>e.position))||void 0===t?void 0:t.position)||"fixed",parent:(null===(i=e.find(e=>e.parent))||void 0===i?void 0:i.parent)||null,tooltipSpace:(null===(n=e.find(e=>e.tooltipSpace))||void 0===n?void 0:n.tooltipSpace)||windowSpace}}}),tooltipPlugin=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.inView=!0,this.lastTransaction=0,this.measureTimeout=-1;let t=e.state.facet(tooltipConfig);this.position=t.position,this.parent=t.parent,this.classes=e.themeClasses,this.createContainer(),this.measureReq={read:this.readMeasure.bind(this),write:this.writeMeasure.bind(this),key:this},this.manager=new TooltipViewManager(e,showTooltip,e=>this.createTooltip(e)),this.intersectionObserver="function"==typeof IntersectionObserver?new IntersectionObserver(e=>{Date.now()>this.lastTransaction-50&&e.length>0&&e[e.length-1].intersectionRatio<1&&this.measureSoon();},{threshold:[1]}):null,this.observeIntersection(),e.win.addEventListener("resize",this.measureSoon=this.measureSoon.bind(this)),this.maybeMeasure();}createContainer(){this.parent?(this.container=document.createElement("div"),this.container.style.position="relative",this.container.className=this.view.themeClasses,this.parent.appendChild(this.container)):this.container=this.view.dom;}observeIntersection(){if(this.intersectionObserver){this.intersectionObserver.disconnect();for(let e of this.manager.tooltipViews)this.intersectionObserver.observe(e.dom);}}measureSoon(){this.measureTimeout<0&&(this.measureTimeout=setTimeout(()=>{this.measureTimeout=-1,this.maybeMeasure();},50));}update(e){e.transactions.length&&(this.lastTransaction=Date.now());let t=this.manager.update(e);t&&this.observeIntersection();let i=t||e.geometryChanged,n=e.state.facet(tooltipConfig);if(n.position!=this.position){this.position=n.position;for(let e of this.manager.tooltipViews)e.dom.style.position=this.position;i=!0;}if(n.parent!=this.parent){this.parent&&this.container.remove(),this.parent=n.parent,this.createContainer();for(let e of this.manager.tooltipViews)this.container.appendChild(e.dom);i=!0;}else this.parent&&this.view.themeClasses!=this.classes&&(this.classes=this.container.className=this.view.themeClasses);i&&this.maybeMeasure();}createTooltip(e){let t=e.create(this.view);if(t.dom.classList.add("cm-tooltip"),e.arrow&&!t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")){let e=document.createElement("div");e.className="cm-tooltip-arrow",t.dom.appendChild(e);}return t.dom.style.position=this.position,t.dom.style.top=Outside,this.container.appendChild(t.dom),t.mount&&t.mount(this.view),t}destroy(){var e,t;this.view.win.removeEventListener("resize",this.measureSoon);for(let t of this.manager.tooltipViews)t.dom.remove(),null===(e=t.destroy)||void 0===e||e.call(t);null===(t=this.intersectionObserver)||void 0===t||t.disconnect(),clearTimeout(this.measureTimeout);}readMeasure(){let e=this.view.dom.getBoundingClientRect();return {editor:e,parent:this.parent?this.container.getBoundingClientRect():e,pos:this.manager.tooltips.map((e,t)=>{let i=this.manager.tooltipViews[t];return i.getCoords?i.getCoords(e.pos):this.view.coordsAtPos(e.pos)}),size:this.manager.tooltipViews.map(({dom:e})=>e.getBoundingClientRect()),space:this.view.state.facet(tooltipConfig).tooltipSpace(this.view)}}writeMeasure(e){let{editor:t,space:i}=e,n=[];for(let o=0;o<this.manager.tooltips.length;o++){let r=this.manager.tooltips[o],s=this.manager.tooltipViews[o],{dom:a}=s,l=e.pos[o],h=e.size[o];if(!l||l.bottom<=Math.max(t.top,i.top)||l.top>=Math.min(t.bottom,i.bottom)||l.right<Math.max(t.left,i.left)-.1||l.left>Math.min(t.right,i.right)+.1){a.style.top=Outside;continue}let c=r.arrow?s.dom.querySelector(".cm-tooltip-arrow"):null,d=c?7:0,u=h.right-h.left,f=h.bottom-h.top,p=s.offset||noOffset,O=this.view.textDirection==Direction.LTR,g=h.width>i.right-i.left?O?i.left:i.right-h.width:O?Math.min(l.left-(c?14:0)+p.x,i.right-u):Math.max(i.left,l.left-u+(c?14:0)-p.x),m=!!r.above;!r.strictSide&&(m?l.top-(h.bottom-h.top)-p.y<i.top:l.bottom+(h.bottom-h.top)+p.y>i.bottom)&&m==i.bottom-l.bottom>l.top-i.top&&(m=!m);let S=(m?l.top-i.top:i.bottom-l.bottom)-d;if(S<f&&!1!==s.resize){if(S<this.view.defaultLineHeight){a.style.top=Outside;continue}a.style.height=(f=S)+"px";}else a.style.height&&(a.style.height="");let b=m?l.top-f-d-p.y:l.bottom+d+p.y,y=g+u;if(!0!==s.overlap)for(let e of n)e.left<y&&e.right>g&&e.top<b+f&&e.bottom>b&&(b=m?e.top-f-2-d:e.bottom+d+2);"absolute"==this.position?(a.style.top=b-e.parent.top+"px",a.style.left=g-e.parent.left+"px"):(a.style.top=b+"px",a.style.left=g+"px"),c&&(c.style.left=`${l.left+(O?p.x:-p.x)-(g+14-7)}px`),!0!==s.overlap&&n.push({left:g,top:b,right:y,bottom:b+f}),a.classList.toggle("cm-tooltip-above",m),a.classList.toggle("cm-tooltip-below",!m),s.positioned&&s.positioned(e.space);}}maybeMeasure(){if(this.manager.tooltips.length&&(this.view.inView&&this.view.requestMeasure(this.measureReq),this.inView!=this.view.inView&&(this.inView=this.view.inView,!this.inView)))for(let e of this.manager.tooltipViews)e.dom.style.top=Outside;}},{eventHandlers:{scroll(){this.maybeMeasure();}}}),baseTheme=EditorView.baseTheme({".cm-tooltip":{zIndex:100,boxSizing:"border-box"},"&light .cm-tooltip":{border:"1px solid #bbb",backgroundColor:"#f5f5f5"},"&light .cm-tooltip-section:not(:first-child)":{borderTop:"1px solid #bbb"},"&dark .cm-tooltip":{backgroundColor:"#333338",color:"white"},".cm-tooltip-arrow":{height:"7px",width:"14px",position:"absolute",zIndex:-1,overflow:"hidden","&:before, &:after":{content:"''",position:"absolute",width:0,height:0,borderLeft:"7px solid transparent",borderRight:"7px solid transparent"},".cm-tooltip-above &":{bottom:"-7px","&:before":{borderTop:"7px solid #bbb"},"&:after":{borderTop:"7px solid #f5f5f5",bottom:"1px"}},".cm-tooltip-below &":{top:"-7px","&:before":{borderBottom:"7px solid #bbb"},"&:after":{borderBottom:"7px solid #f5f5f5",top:"1px"}}},"&dark .cm-tooltip .cm-tooltip-arrow":{"&:before":{borderTopColor:"#333338",borderBottomColor:"#333338"},"&:after":{borderTopColor:"transparent",borderBottomColor:"transparent"}}}),noOffset={x:0,y:0},showTooltip=Facet.define({enables:[tooltipPlugin,baseTheme]}),showHoverTooltip=Facet.define();class HoverTooltipHost{constructor(e){this.view=e,this.mounted=!1,this.dom=document.createElement("div"),this.dom.classList.add("cm-tooltip-hover"),this.manager=new TooltipViewManager(e,showHoverTooltip,e=>this.createHostedView(e));}static create(e){return new HoverTooltipHost(e)}createHostedView(e){let t=e.create(this.view);return t.dom.classList.add("cm-tooltip-section"),this.dom.appendChild(t.dom),this.mounted&&t.mount&&t.mount(this.view),t}mount(e){for(let t of this.manager.tooltipViews)t.mount&&t.mount(e);this.mounted=!0;}positioned(e){for(let t of this.manager.tooltipViews)t.positioned&&t.positioned(e);}update(e){this.manager.update(e);}}const showHoverTooltipHost=showTooltip.compute([showHoverTooltip],e=>{let t=e.facet(showHoverTooltip).filter(e=>e);return 0===t.length?null:{pos:Math.min(...t.map(e=>e.pos)),end:Math.max(...t.filter(e=>null!=e.end).map(e=>e.end)),create:HoverTooltipHost.create,above:t[0].above,arrow:t.some(e=>e.arrow)}});class HoverPlugin{constructor(e,t,i,n,o){this.view=e,this.source=t,this.field=i,this.setHover=n,this.hoverTime=o,this.hoverTimeout=-1,this.restartTimeout=-1,this.pending=null,this.lastMove={x:0,y:0,target:e.dom,time:0},this.checkHover=this.checkHover.bind(this),e.dom.addEventListener("mouseleave",this.mouseleave=this.mouseleave.bind(this)),e.dom.addEventListener("mousemove",this.mousemove=this.mousemove.bind(this));}update(){this.pending&&(this.pending=null,clearTimeout(this.restartTimeout),this.restartTimeout=setTimeout(()=>this.startHover(),20));}get active(){return this.view.state.field(this.field)}checkHover(){if(this.hoverTimeout=-1,this.active)return;let e=Date.now()-this.lastMove.time;e<this.hoverTime?this.hoverTimeout=setTimeout(this.checkHover,this.hoverTime-e):this.startHover();}startHover(){clearTimeout(this.restartTimeout);let{lastMove:e}=this,t=this.view.contentDOM.contains(e.target)?this.view.posAtCoords(e):null;if(null==t)return;let i=this.view.coordsAtPos(t);if(null==i||e.y<i.top||e.y>i.bottom||e.x<i.left-this.view.defaultCharacterWidth||e.x>i.right+this.view.defaultCharacterWidth)return;let n=this.view.bidiSpans(this.view.state.doc.lineAt(t)).find(e=>e.from<=t&&e.to>=t),o=n&&n.dir==Direction.RTL?-1:1,r=this.source(this.view,t,e.x<i.left?-o:o);if(null===r||void 0===r?void 0:r.then){let e=this.pending={pos:t};r.then(t=>{this.pending==e&&(this.pending=null,t&&this.view.dispatch({effects:this.setHover.of(t)}));},e=>logException(this.view.state,e,"hover tooltip"));}else r&&this.view.dispatch({effects:this.setHover.of(r)});}mousemove(e){var t;this.lastMove={x:e.clientX,y:e.clientY,target:e.target,time:Date.now()},this.hoverTimeout<0&&(this.hoverTimeout=setTimeout(this.checkHover,this.hoverTime));let i=this.active;if(i&&!isInTooltip(this.lastMove.target)||this.pending){let{pos:n}=i||this.pending,o=null!==(t=null===i||void 0===i?void 0:i.end)&&void 0!==t?t:n;(n==o?this.view.posAtCoords(this.lastMove)==n:isOverRange(this.view,n,o,e.clientX,e.clientY,6))||(this.view.dispatch({effects:this.setHover.of(null)}),this.pending=null);}}mouseleave(e){clearTimeout(this.hoverTimeout),this.hoverTimeout=-1,this.active&&!isInTooltip(e.relatedTarget)&&this.view.dispatch({effects:this.setHover.of(null)});}destroy(){clearTimeout(this.hoverTimeout),this.view.dom.removeEventListener("mouseleave",this.mouseleave),this.view.dom.removeEventListener("mousemove",this.mousemove);}}function isInTooltip(e){for(let t=e;t;t=t.parentNode)if(1==t.nodeType&&t.classList.contains("cm-tooltip"))return !0;return !1}function isOverRange(e,t,i,n,o,r){let s=document.createRange(),a=e.domAtPos(t),l=e.domAtPos(i);s.setEnd(l.node,l.offset),s.setStart(a.node,a.offset);let h=s.getClientRects();s.detach();for(let e=0;e<h.length;e++){let t=h[e];if(Math.max(t.top-o,o-t.bottom,t.left-n,n-t.right)<=r)return !0}return !1}function hoverTooltip(e,t={}){let i=StateEffect.define(),n=StateField.define({create:()=>null,update(e,n){if(e&&(t.hideOnChange&&(n.docChanged||n.selection)||t.hideOn&&t.hideOn(n,e)))return null;if(e&&n.docChanged){let t=n.changes.mapPos(e.pos,-1,MapMode.TrackDel);if(null==t)return null;let i=Object.assign(Object.create(null),e);i.pos=t,null!=e.end&&(i.end=n.changes.mapPos(e.end)),e=i;}for(let t of n.effects)t.is(i)&&(e=t.value),t.is(closeHoverTooltipEffect)&&(e=null);return e},provide:e=>showHoverTooltip.from(e)});return [n,ViewPlugin.define(o=>new HoverPlugin(o,e,n,i,t.hoverTime||300)),showHoverTooltipHost]}function getTooltip(e,t){let i=e.plugin(tooltipPlugin);if(!i)return null;let n=i.manager.tooltips.indexOf(t);return n<0?null:i.manager.tooltipViews[n]}const closeHoverTooltipEffect=StateEffect.define();closeHoverTooltipEffect.of(null);const panelConfig=Facet.define({combine(e){let t,i;for(let n of e)t=t||n.topContainer,i=i||n.bottomContainer;return {topContainer:t,bottomContainer:i}}}),panelPlugin=ViewPlugin.fromClass(class{constructor(e){this.input=e.state.facet(showPanel),this.specs=this.input.filter(e=>e),this.panels=this.specs.map(t=>t(e));let t=e.state.facet(panelConfig);this.top=new PanelGroup(e,!0,t.topContainer),this.bottom=new PanelGroup(e,!1,t.bottomContainer),this.top.sync(this.panels.filter(e=>e.top)),this.bottom.sync(this.panels.filter(e=>!e.top));for(let e of this.panels)e.dom.classList.add("cm-panel"),e.mount&&e.mount();}update(e){let t=e.state.facet(panelConfig);this.top.container!=t.topContainer&&(this.top.sync([]),this.top=new PanelGroup(e.view,!0,t.topContainer)),this.bottom.container!=t.bottomContainer&&(this.bottom.sync([]),this.bottom=new PanelGroup(e.view,!1,t.bottomContainer)),this.top.syncClasses(),this.bottom.syncClasses();let i=e.state.facet(showPanel);if(i!=this.input){let t=i.filter(e=>e),n=[],o=[],r=[],s=[];for(let i of t){let t,a=this.specs.indexOf(i);a<0?(t=i(e.view),s.push(t)):(t=this.panels[a]).update&&t.update(e),n.push(t),(t.top?o:r).push(t);}this.specs=t,this.panels=n,this.top.sync(o),this.bottom.sync(r);for(let e of s)e.dom.classList.add("cm-panel"),e.mount&&e.mount();}else for(let t of this.panels)t.update&&t.update(e);}destroy(){this.top.sync([]),this.bottom.sync([]);}},{provide:e=>EditorView.scrollMargins.of(t=>{let i=t.plugin(e);return i&&{top:i.top.scrollMargin(),bottom:i.bottom.scrollMargin()}})});class PanelGroup{constructor(e,t,i){this.view=e,this.top=t,this.container=i,this.dom=void 0,this.classes="",this.panels=[],this.syncClasses();}sync(e){for(let t of this.panels)t.destroy&&e.indexOf(t)<0&&t.destroy();this.panels=e,this.syncDOM();}syncDOM(){if(0==this.panels.length)return void(this.dom&&(this.dom.remove(),this.dom=void 0));if(!this.dom){this.dom=document.createElement("div"),this.dom.className=this.top?"cm-panels cm-panels-top":"cm-panels cm-panels-bottom",this.dom.style[this.top?"top":"bottom"]="0";let e=this.container||this.view.dom;e.insertBefore(this.dom,this.top?e.firstChild:null);}let e=this.dom.firstChild;for(let t of this.panels)if(t.dom.parentNode==this.dom){for(;e!=t.dom;)e=rm(e);e=e.nextSibling;}else this.dom.insertBefore(t.dom,e);for(;e;)e=rm(e);}scrollMargin(){return !this.dom||this.container?0:Math.max(0,this.top?this.dom.getBoundingClientRect().bottom-Math.max(0,this.view.scrollDOM.getBoundingClientRect().top):Math.min(innerHeight,this.view.scrollDOM.getBoundingClientRect().bottom)-this.dom.getBoundingClientRect().top)}syncClasses(){if(this.container&&this.classes!=this.view.themeClasses){for(let e of this.classes.split(" "))e&&this.container.classList.remove(e);for(let e of (this.classes=this.view.themeClasses).split(" "))e&&this.container.classList.add(e);}}}function rm(e){let t=e.nextSibling;return e.remove(),t}const showPanel=Facet.define({enables:panelPlugin});class GutterMarker extends RangeValue{compare(e){return this==e||this.constructor==e.constructor&&this.eq(e)}eq(e){return !1}destroy(e){}}GutterMarker.prototype.elementClass="",GutterMarker.prototype.toDOM=void 0,GutterMarker.prototype.mapMode=MapMode.TrackBefore,GutterMarker.prototype.startSide=GutterMarker.prototype.endSide=-1,GutterMarker.prototype.point=!0;const gutterLineClass=Facet.define(),defaults={class:"",renderEmptyElements:!1,elementStyle:"",markers:()=>RangeSet.empty,lineMarker:()=>null,lineMarkerChange:null,initialSpacer:null,updateSpacer:null,domEventHandlers:{}},activeGutters=Facet.define();function gutter(e){return [gutters(),activeGutters.of(Object.assign(Object.assign({},defaults),e))]}const unfixGutters=Facet.define({combine:e=>e.some(e=>e)});function gutters(e){let t=[gutterView];return e&&!1===e.fixed&&t.push(unfixGutters.of(!0)),t}const gutterView=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.prevViewport=e.viewport,this.dom=document.createElement("div"),this.dom.className="cm-gutters",this.dom.setAttribute("aria-hidden","true"),this.dom.style.minHeight=this.view.contentHeight+"px",this.gutters=e.state.facet(activeGutters).map(t=>new SingleGutterView(e,t));for(let e of this.gutters)this.dom.appendChild(e.dom);this.fixed=!e.state.facet(unfixGutters),this.fixed&&(this.dom.style.position="sticky"),this.syncGutters(!1),e.scrollDOM.insertBefore(this.dom,e.contentDOM);}update(e){if(this.updateGutters(e)){let t=this.prevViewport,i=e.view.viewport,n=Math.min(t.to,i.to)-Math.max(t.from,i.from);this.syncGutters(n<.8*(i.to-i.from));}e.geometryChanged&&(this.dom.style.minHeight=this.view.contentHeight+"px"),this.view.state.facet(unfixGutters)!=!this.fixed&&(this.fixed=!this.fixed,this.dom.style.position=this.fixed?"sticky":""),this.prevViewport=e.view.viewport;}syncGutters(e){let t=this.dom.nextSibling;e&&this.dom.remove();let i=RangeSet.iter(this.view.state.facet(gutterLineClass),this.view.viewport.from),n=[],o=this.gutters.map(e=>new UpdateContext(e,this.view.viewport,-this.view.documentPadding.top));for(let e of this.view.viewportLineBlocks){let t;if(Array.isArray(e.type)){for(let i of e.type)if(i.type==BlockType.Text){t=i;break}}else t=e.type==BlockType.Text?e:void 0;if(t){n.length&&(n=[]),advanceCursor(i,n,e.from);for(let e of o)e.line(this.view,t,n);}}for(let e of o)e.finish();e&&this.view.scrollDOM.insertBefore(this.dom,t);}updateGutters(e){let t=e.startState.facet(activeGutters),i=e.state.facet(activeGutters),n=e.docChanged||e.heightChanged||e.viewportChanged||!RangeSet.eq(e.startState.facet(gutterLineClass),e.state.facet(gutterLineClass),e.view.viewport.from,e.view.viewport.to);if(t==i)for(let t of this.gutters)t.update(e)&&(n=!0);else {n=!0;let o=[];for(let n of i){let i=t.indexOf(n);i<0?o.push(new SingleGutterView(this.view,n)):(this.gutters[i].update(e),o.push(this.gutters[i]));}for(let e of this.gutters)e.dom.remove(),o.indexOf(e)<0&&e.destroy();for(let e of o)this.dom.appendChild(e.dom);this.gutters=o;}return n}destroy(){for(let e of this.gutters)e.destroy();this.dom.remove();}},{provide:e=>EditorView.scrollMargins.of(t=>{let i=t.plugin(e);return i&&0!=i.gutters.length&&i.fixed?t.textDirection==Direction.LTR?{left:i.dom.offsetWidth}:{right:i.dom.offsetWidth}:null})});function asArray$1(e){return Array.isArray(e)?e:[e]}function advanceCursor(e,t,i){for(;e.value&&e.from<=i;)e.from==i&&t.push(e.value),e.next();}class UpdateContext{constructor(e,t,i){this.gutter=e,this.height=i,this.localMarkers=[],this.i=0,this.cursor=RangeSet.iter(e.markers,t.from);}line(e,t,i){this.localMarkers.length&&(this.localMarkers=[]),advanceCursor(this.cursor,this.localMarkers,t.from);let n=i.length?this.localMarkers.concat(i):this.localMarkers,o=this.gutter.config.lineMarker(e,t,n);o&&n.unshift(o);let r=this.gutter;if(0==n.length&&!r.config.renderEmptyElements)return;let s=t.top-this.height;if(this.i==r.elements.length){let i=new GutterElement(e,t.height,s,n);r.elements.push(i),r.dom.appendChild(i.dom);}else r.elements[this.i].update(e,t.height,s,n);this.height=t.bottom,this.i++;}finish(){let e=this.gutter;for(;e.elements.length>this.i;){let t=e.elements.pop();e.dom.removeChild(t.dom),t.destroy();}}}class SingleGutterView{constructor(e,t){this.view=e,this.config=t,this.elements=[],this.spacer=null,this.dom=document.createElement("div"),this.dom.className="cm-gutter"+(this.config.class?" "+this.config.class:"");for(let i in t.domEventHandlers)this.dom.addEventListener(i,n=>{let o=e.lineBlockAtHeight(n.clientY-e.documentTop);t.domEventHandlers[i](e,o,n)&&n.preventDefault();});this.markers=asArray$1(t.markers(e)),t.initialSpacer&&(this.spacer=new GutterElement(e,0,0,[t.initialSpacer(e)]),this.dom.appendChild(this.spacer.dom),this.spacer.dom.style.cssText+="visibility: hidden; pointer-events: none");}update(e){let t=this.markers;if(this.markers=asArray$1(this.config.markers(e.view)),this.spacer&&this.config.updateSpacer){let t=this.config.updateSpacer(this.spacer.markers[0],e);t!=this.spacer.markers[0]&&this.spacer.update(e.view,0,0,[t]);}let i=e.view.viewport;return !RangeSet.eq(this.markers,t,i.from,i.to)||!!this.config.lineMarkerChange&&this.config.lineMarkerChange(e)}destroy(){for(let e of this.elements)e.destroy();}}class GutterElement{constructor(e,t,i,n){this.height=-1,this.above=0,this.markers=[],this.dom=document.createElement("div"),this.dom.className="cm-gutterElement",this.update(e,t,i,n);}update(e,t,i,n){this.height!=t&&(this.dom.style.height=(this.height=t)+"px"),this.above!=i&&(this.dom.style.marginTop=(this.above=i)?i+"px":""),sameMarkers(this.markers,n)||this.setMarkers(e,n);}setMarkers(e,t){let i="cm-gutterElement",n=this.dom.firstChild;for(let o=0,r=0;;){let s=r,a=o<t.length?t[o++]:null,l=!1;if(a){let e=a.elementClass;e&&(i+=" "+e);for(let e=r;e<this.markers.length;e++)if(this.markers[e].compare(a)){s=e,l=!0;break}}else s=this.markers.length;for(;r<s;){let e=this.markers[r++];if(e.toDOM){e.destroy(n);let t=n.nextSibling;n.remove(),n=t;}}if(!a)break;a.toDOM&&(l?n=n.nextSibling:this.dom.insertBefore(a.toDOM(e),n)),l&&r++;}this.dom.className=i,this.markers=t;}destroy(){this.setMarkers(null,[]);}}function sameMarkers(e,t){if(e.length!=t.length)return !1;for(let i=0;i<e.length;i++)if(!e[i].compare(t[i]))return !1;return !0}const lineNumberMarkers=Facet.define(),lineNumberConfig=Facet.define({combine:e=>combineConfig(e,{formatNumber:String,domEventHandlers:{}},{domEventHandlers(e,t){let i=Object.assign({},e);for(let e in t){let n=i[e],o=t[e];i[e]=n?(e,t,i)=>n(e,t,i)||o(e,t,i):o;}return i}})});class NumberMarker extends GutterMarker{constructor(e){super(),this.number=e;}eq(e){return this.number==e.number}toDOM(){return document.createTextNode(this.number)}}function formatNumber(e,t){return e.state.facet(lineNumberConfig).formatNumber(t,e.state)}const lineNumberGutter=activeGutters.compute([lineNumberConfig],e=>({class:"cm-lineNumbers",renderEmptyElements:!1,markers:e=>e.state.facet(lineNumberMarkers),lineMarker:(e,t,i)=>i.some(e=>e.toDOM)?null:new NumberMarker(formatNumber(e,e.state.doc.lineAt(t.from).number)),lineMarkerChange:e=>e.startState.facet(lineNumberConfig)!=e.state.facet(lineNumberConfig),initialSpacer:e=>new NumberMarker(formatNumber(e,maxLineNumber(e.state.doc.lines))),updateSpacer(e,t){let i=formatNumber(t.view,maxLineNumber(t.view.state.doc.lines));return i==e.number?e:new NumberMarker(i)},domEventHandlers:e.facet(lineNumberConfig).domEventHandlers}));function lineNumbers(e={}){return [lineNumberConfig.of(e),gutters(),lineNumberGutter]}function maxLineNumber(e){let t=9;for(;t<e;)t=10*t+9;return t}const activeLineGutterMarker=new class extends GutterMarker{constructor(){super(...arguments),this.elementClass="cm-activeLineGutter";}},activeLineGutterHighlighter=gutterLineClass.compute(["selection"],e=>{let t=[],i=-1;for(let n of e.selection.ranges){let o=e.doc.lineAt(n.head).from;o>i&&(i=o,t.push(activeLineGutterMarker.range(o)));}return RangeSet.of(t)});function highlightActiveLineGutter(){return activeLineGutterHighlighter}const DefaultBufferLength=1024;let nextPropID=0;class Range$1{constructor(e,t){this.from=e,this.to=t;}}class NodeProp{constructor(e={}){this.id=nextPropID++,this.perNode=!!e.perNode,this.deserialize=e.deserialize||(()=>{throw new Error("This node type doesn't define a deserialize function")});}add(e){if(this.perNode)throw new RangeError("Can't add per-node props to node types");return "function"!=typeof e&&(e=NodeType.match(e)),t=>{let i=e(t);return void 0===i?null:[this,i]}}}NodeProp.closedBy=new NodeProp({deserialize:e=>e.split(" ")}),NodeProp.openedBy=new NodeProp({deserialize:e=>e.split(" ")}),NodeProp.group=new NodeProp({deserialize:e=>e.split(" ")}),NodeProp.contextHash=new NodeProp({perNode:!0}),NodeProp.lookAhead=new NodeProp({perNode:!0}),NodeProp.mounted=new NodeProp({perNode:!0});const noProps=Object.create(null);class NodeType{constructor(e,t,i,n=0){this.name=e,this.props=t,this.id=i,this.flags=n;}static define(e){let t=e.props&&e.props.length?Object.create(null):noProps,i=(e.top?1:0)|(e.skipped?2:0)|(e.error?4:0)|(null==e.name?8:0),n=new NodeType(e.name||"",t,e.id,i);if(e.props)for(let i of e.props)if(Array.isArray(i)||(i=i(n)),i){if(i[0].perNode)throw new RangeError("Can't store a per-node prop on a node type");t[i[0].id]=i[1];}return n}prop(e){return this.props[e.id]}get isTop(){return (1&this.flags)>0}get isSkipped(){return (2&this.flags)>0}get isError(){return (4&this.flags)>0}get isAnonymous(){return (8&this.flags)>0}is(e){if("string"==typeof e){if(this.name==e)return !0;let t=this.prop(NodeProp.group);return !!t&&t.indexOf(e)>-1}return this.id==e}static match(e){let t=Object.create(null);for(let i in e)for(let n of i.split(" "))t[n]=e[i];return e=>{for(let i=e.prop(NodeProp.group),n=-1;n<(i?i.length:0);n++){let o=t[n<0?e.name:i[n]];if(o)return o}}}}NodeType.none=new NodeType("",Object.create(null),0,8);class NodeSet{constructor(e){this.types=e;for(let t=0;t<e.length;t++)if(e[t].id!=t)throw new RangeError("Node type ids should correspond to array positions when creating a node set")}extend(...e){let t=[];for(let i of this.types){let n=null;for(let t of e){let e=t(i);e&&(n||(n=Object.assign({},i.props)),n[e[0].id]=e[1]);}t.push(n?new NodeType(i.name,n,i.id,i.flags):i);}return new NodeSet(t)}}const CachedNode=new WeakMap,CachedInnerNode=new WeakMap;var IterMode;!function(e){e[e.ExcludeBuffers=1]="ExcludeBuffers",e[e.IncludeAnonymous=2]="IncludeAnonymous",e[e.IgnoreMounts=4]="IgnoreMounts",e[e.IgnoreOverlays=8]="IgnoreOverlays";}(IterMode||(IterMode={}));class Tree{constructor(e,t,i,n,o){if(this.type=e,this.children=t,this.positions=i,this.length=n,this.props=null,o&&o.length){this.props=Object.create(null);for(let[e,t]of o)this.props["number"==typeof e?e:e.id]=t;}}toString(){let e=this.prop(NodeProp.mounted);if(e&&!e.overlay)return e.tree.toString();let t="";for(let e of this.children){let i=e.toString();i&&(t&&(t+=","),t+=i);}return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+(t.length?"("+t+")":""):t}cursor(e=0){return new TreeCursor(this.topNode,e)}cursorAt(e,t=0,i=0){let n=CachedNode.get(this)||this.topNode,o=new TreeCursor(n);return o.moveTo(e,t),CachedNode.set(this,o._tree),o}get topNode(){return new TreeNode(this,0,0,null)}resolve(e,t=0){let i=resolveNode(CachedNode.get(this)||this.topNode,e,t,!1);return CachedNode.set(this,i),i}resolveInner(e,t=0){let i=resolveNode(CachedInnerNode.get(this)||this.topNode,e,t,!0);return CachedInnerNode.set(this,i),i}iterate(e){let{enter:t,leave:i,from:n=0,to:o=this.length}=e;for(let r=this.cursor((e.mode||0)|IterMode.IncludeAnonymous);;){let e=!1;if(r.from<=o&&r.to>=n&&(r.type.isAnonymous||!1!==t(r))){if(r.firstChild())continue;e=!0;}for(;e&&i&&!r.type.isAnonymous&&i(r),!r.nextSibling();){if(!r.parent())return;e=!0;}}}prop(e){return e.perNode?this.props?this.props[e.id]:void 0:this.type.prop(e)}get propValues(){let e=[];if(this.props)for(let t in this.props)e.push([+t,this.props[t]]);return e}balance(e={}){return this.children.length<=8?this:balanceRange(NodeType.none,this.children,this.positions,0,this.children.length,0,this.length,(e,t,i)=>new Tree(this.type,e,t,i,this.propValues),e.makeTree||((e,t,i)=>new Tree(NodeType.none,e,t,i)))}static build(e){return buildTree(e)}}Tree.empty=new Tree(NodeType.none,[],[],0);class FlatBufferCursor{constructor(e,t){this.buffer=e,this.index=t;}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4;}fork(){return new FlatBufferCursor(this.buffer,this.index)}}class TreeBuffer{constructor(e,t,i){this.buffer=e,this.length=t,this.set=i;}get type(){return NodeType.none}toString(){let e=[];for(let t=0;t<this.buffer.length;)e.push(this.childString(t)),t=this.buffer[t+3];return e.join(",")}childString(e){let t=this.buffer[e],i=this.buffer[e+3],n=this.set.types[t],o=n.name;if(/\W/.test(o)&&!n.isError&&(o=JSON.stringify(o)),i==(e+=4))return o;let r=[];for(;e<i;)r.push(this.childString(e)),e=this.buffer[e+3];return o+"("+r.join(",")+")"}findChild(e,t,i,n,o){let{buffer:r}=this,s=-1;for(let a=e;a!=t&&!(checkSide(o,n,r[a+1],r[a+2])&&(s=a,i>0));a=r[a+3]);return s}slice(e,t,i){let n=this.buffer,o=new Uint16Array(t-e),r=0;for(let s=e,a=0;s<t;){o[a++]=n[s++],o[a++]=n[s++]-i;let t=o[a++]=n[s++]-i;o[a++]=n[s++]-e,r=Math.max(r,t);}return new TreeBuffer(o,r,this.set)}}function checkSide(e,t,i,n){switch(e){case-2:return i<t;case-1:return n>=t&&i<t;case 0:return i<t&&n>t;case 1:return i<=t&&n>t;case 2:return n>t;case 4:return !0}}function enterUnfinishedNodesBefore(e,t){let i=e.childBefore(t);for(;i;){let t=i.lastChild;if(!t||t.to!=i.to)break;t.type.isError&&t.from==t.to?(e=i,i=t.prevSibling):i=t;}return e}function resolveNode(e,t,i,n){for(var o;e.from==e.to||(i<1?e.from>=t:e.from>t)||(i>-1?e.to<=t:e.to<t);){let t=!n&&e instanceof TreeNode&&e.index<0?null:e.parent;if(!t)return e;e=t;}let r=n?0:IterMode.IgnoreOverlays;if(n)for(let n=e,s=n.parent;s;s=(n=s).parent)n instanceof TreeNode&&n.index<0&&(null===(o=s.enter(t,i,r))||void 0===o?void 0:o.from)!=n.from&&(e=s);for(;;){let n=e.enter(t,i,r);if(!n)return e;e=n;}}class TreeNode{constructor(e,t,i,n){this._tree=e,this.from=t,this.index=i,this._parent=n;}get type(){return this._tree.type}get name(){return this._tree.type.name}get to(){return this.from+this._tree.length}nextChild(e,t,i,n,o=0){for(let r=this;;){for(let{children:s,positions:a}=r._tree,l=t>0?s.length:-1;e!=l;e+=t){let l=s[e],h=a[e]+r.from;if(checkSide(n,i,h,h+l.length))if(l instanceof TreeBuffer){if(o&IterMode.ExcludeBuffers)continue;let s=l.findChild(0,l.buffer.length,t,i-h,n);if(s>-1)return new BufferNode(new BufferContext(r,l,e,h),null,s)}else if(o&IterMode.IncludeAnonymous||!l.type.isAnonymous||hasChild(l)){let s;if(!(o&IterMode.IgnoreMounts)&&l.props&&(s=l.prop(NodeProp.mounted))&&!s.overlay)return new TreeNode(s.tree,h,e,r);let a=new TreeNode(l,h,e,r);return o&IterMode.IncludeAnonymous||!a.type.isAnonymous?a:a.nextChild(t<0?l.children.length-1:0,t,i,n)}}if(o&IterMode.IncludeAnonymous||!r.type.isAnonymous)return null;if(e=r.index>=0?r.index+t:t<0?-1:r._parent._tree.children.length,!(r=r._parent))return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this._tree.children.length-1,-1,0,4)}childAfter(e){return this.nextChild(0,1,e,2)}childBefore(e){return this.nextChild(this._tree.children.length-1,-1,e,-2)}enter(e,t,i=0){let n;if(!(i&IterMode.IgnoreOverlays)&&(n=this._tree.prop(NodeProp.mounted))&&n.overlay){let i=e-this.from;for(let{from:e,to:o}of n.overlay)if((t>0?e<=i:e<i)&&(t<0?o>=i:o>i))return new TreeNode(n.tree,n.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,e,t,i)}nextSignificantParent(){let e=this;for(;e.type.isAnonymous&&e._parent;)e=e._parent;return e}get parent(){return this._parent?this._parent.nextSignificantParent():null}get nextSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index-1,-1,0,4):null}cursor(e=0){return new TreeCursor(this,e)}get tree(){return this._tree}toTree(){return this._tree}resolve(e,t=0){return resolveNode(this,e,t,!1)}resolveInner(e,t=0){return resolveNode(this,e,t,!0)}enterUnfinishedNodesBefore(e){return enterUnfinishedNodesBefore(this,e)}getChild(e,t=null,i=null){let n=getChildren(this,e,t,i);return n.length?n[0]:null}getChildren(e,t=null,i=null){return getChildren(this,e,t,i)}toString(){return this._tree.toString()}get node(){return this}matchContext(e){return matchNodeContext(this,e)}}function getChildren(e,t,i,n){let o=e.cursor(),r=[];if(!o.firstChild())return r;if(null!=i)for(;!o.type.is(i);)if(!o.nextSibling())return r;for(;;){if(null!=n&&o.type.is(n))return r;if(o.type.is(t)&&r.push(o.node),!o.nextSibling())return null==n?r:[]}}function matchNodeContext(e,t,i=t.length-1){for(let n=e.parent;i>=0;n=n.parent){if(!n)return !1;if(!n.type.isAnonymous){if(t[i]&&t[i]!=n.name)return !1;i--;}}return !0}class BufferContext{constructor(e,t,i,n){this.parent=e,this.buffer=t,this.index=i,this.start=n;}}class BufferNode{get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}constructor(e,t,i){this.context=e,this._parent=t,this.index=i,this.type=e.buffer.set.types[e.buffer.buffer[i]];}child(e,t,i){let{buffer:n}=this.context,o=n.findChild(this.index+4,n.buffer[this.index+3],e,t-this.context.start,i);return o<0?null:new BufferNode(this.context,this,o)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(e){return this.child(1,e,2)}childBefore(e){return this.child(-1,e,-2)}enter(e,t,i=0){if(i&IterMode.ExcludeBuffers)return null;let{buffer:n}=this.context,o=n.findChild(this.index+4,n.buffer[this.index+3],t>0?1:-1,e-this.context.start,t);return o<0?null:new BufferNode(this.context,this,o)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(e){return this._parent?null:this.context.parent.nextChild(this.context.index+e,e,0,4)}get nextSibling(){let{buffer:e}=this.context,t=e.buffer[this.index+3];return t<(this._parent?e.buffer[this._parent.index+3]:e.buffer.length)?new BufferNode(this.context,this._parent,t):this.externalSibling(1)}get prevSibling(){let{buffer:e}=this.context,t=this._parent?this._parent.index+4:0;return this.index==t?this.externalSibling(-1):new BufferNode(this.context,this._parent,e.findChild(t,this.index,-1,0,4))}cursor(e=0){return new TreeCursor(this,e)}get tree(){return null}toTree(){let e=[],t=[],{buffer:i}=this.context,n=this.index+4,o=i.buffer[this.index+3];if(o>n){let r=i.buffer[this.index+1];e.push(i.slice(n,o,r)),t.push(0);}return new Tree(this.type,e,t,this.to-this.from)}resolve(e,t=0){return resolveNode(this,e,t,!1)}resolveInner(e,t=0){return resolveNode(this,e,t,!0)}enterUnfinishedNodesBefore(e){return enterUnfinishedNodesBefore(this,e)}toString(){return this.context.buffer.childString(this.index)}getChild(e,t=null,i=null){let n=getChildren(this,e,t,i);return n.length?n[0]:null}getChildren(e,t=null,i=null){return getChildren(this,e,t,i)}get node(){return this}matchContext(e){return matchNodeContext(this,e)}}class TreeCursor{get name(){return this.type.name}constructor(e,t=0){if(this.mode=t,this.buffer=null,this.stack=[],this.index=0,this.bufferNode=null,e instanceof TreeNode)this.yieldNode(e);else {this._tree=e.context.parent,this.buffer=e.context;for(let t=e._parent;t;t=t._parent)this.stack.unshift(t.index);this.bufferNode=e,this.yieldBuf(e.index);}}yieldNode(e){return !!e&&(this._tree=e,this.type=e.type,this.from=e.from,this.to=e.to,!0)}yieldBuf(e,t){this.index=e;let{start:i,buffer:n}=this.buffer;return this.type=t||n.set.types[n.buffer[e]],this.from=i+n.buffer[e+1],this.to=i+n.buffer[e+2],!0}yield(e){return !!e&&(e instanceof TreeNode?(this.buffer=null,this.yieldNode(e)):(this.buffer=e.context,this.yieldBuf(e.index,e.type)))}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this._tree.toString()}enterChild(e,t,i){if(!this.buffer)return this.yield(this._tree.nextChild(e<0?this._tree._tree.children.length-1:0,e,t,i,this.mode));let{buffer:n}=this.buffer,o=n.findChild(this.index+4,n.buffer[this.index+3],e,t-this.buffer.start,i);return !(o<0)&&(this.stack.push(this.index),this.yieldBuf(o))}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(e){return this.enterChild(1,e,2)}childBefore(e){return this.enterChild(-1,e,-2)}enter(e,t,i=this.mode){return this.buffer?!(i&IterMode.ExcludeBuffers)&&this.enterChild(1,e,t):this.yield(this._tree.enter(e,t,i))}parent(){if(!this.buffer)return this.yieldNode(this.mode&IterMode.IncludeAnonymous?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let e=this.mode&IterMode.IncludeAnonymous?this.buffer.parent:this.buffer.parent.nextSignificantParent();return this.buffer=null,this.yieldNode(e)}sibling(e){if(!this.buffer)return !!this._tree._parent&&this.yield(this._tree.index<0?null:this._tree._parent.nextChild(this._tree.index+e,e,0,4,this.mode));let{buffer:t}=this.buffer,i=this.stack.length-1;if(e<0){let e=i<0?0:this.stack[i]+4;if(this.index!=e)return this.yieldBuf(t.findChild(e,this.index,-1,0,4))}else {let e=t.buffer[this.index+3];if(e<(i<0?t.buffer.length:t.buffer[this.stack[i]+3]))return this.yieldBuf(e)}return i<0&&this.yield(this.buffer.parent.nextChild(this.buffer.index+e,e,0,4,this.mode))}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(e){let t,i,{buffer:n}=this;if(n){if(e>0){if(this.index<n.buffer.buffer.length)return !1}else for(let e=0;e<this.index;e++)if(n.buffer.buffer[e+3]<this.index)return !1;({index:t,parent:i}=n);}else ({index:t,_parent:i}=this._tree);for(;i;({index:t,_parent:i}=i))if(t>-1)for(let n=t+e,o=e<0?-1:i._tree.children.length;n!=o;n+=e){let e=i._tree.children[n];if(this.mode&IterMode.IncludeAnonymous||e instanceof TreeBuffer||!e.type.isAnonymous||hasChild(e))return !1}return !0}move(e,t){if(t&&this.enterChild(e,0,4))return !0;for(;;){if(this.sibling(e))return !0;if(this.atLastNode(e)||!this.parent())return !1}}next(e=!0){return this.move(1,e)}prev(e=!0){return this.move(-1,e)}moveTo(e,t=0){for(;(this.from==this.to||(t<1?this.from>=e:this.from>e)||(t>-1?this.to<=e:this.to<e))&&this.parent(););for(;this.enterChild(1,e,t););return this}get node(){if(!this.buffer)return this._tree;let e=this.bufferNode,t=null,i=0;if(e&&e.context==this.buffer)e:for(let n=this.index,o=this.stack.length;o>=0;){for(let r=e;r;r=r._parent)if(r.index==n){if(n==this.index)return r;t=r,i=o+1;break e}n=this.stack[--o];}for(let e=i;e<this.stack.length;e++)t=new BufferNode(this.buffer,t,this.stack[e]);return this.bufferNode=new BufferNode(this.buffer,t,this.index)}get tree(){return this.buffer?null:this._tree._tree}iterate(e,t){for(let i=0;;){let n=!1;if(this.type.isAnonymous||!1!==e(this)){if(this.firstChild()){i++;continue}this.type.isAnonymous||(n=!0);}for(;n&&t&&t(this),n=this.type.isAnonymous,!this.nextSibling();){if(!i)return;this.parent(),i--,n=!0;}}}matchContext(e){if(!this.buffer)return matchNodeContext(this.node,e);let{buffer:t}=this.buffer,{types:i}=t.set;for(let n=e.length-1,o=this.stack.length-1;n>=0;o--){if(o<0)return matchNodeContext(this.node,e,n);let r=i[t.buffer[this.stack[o]]];if(!r.isAnonymous){if(e[n]&&e[n]!=r.name)return !1;n--;}}return !0}}function hasChild(e){return e.children.some(e=>e instanceof TreeBuffer||!e.type.isAnonymous||hasChild(e))}function buildTree(e){var t;let{buffer:i,nodeSet:n,maxBufferLength:o=DefaultBufferLength,reused:r=[],minRepeatType:s=n.types.length}=e,a=Array.isArray(i)?new FlatBufferCursor(i,i.length):i,l=n.types,h=0,c=0;function d(e,t,i,O,g){let{id:m,start:S,end:b,size:y}=a,w=c;for(;y<0;){if(a.next(),-1==y){let t=r[m];return i.push(t),void O.push(S-e)}if(-3==y)return void(h=m);if(-4==y)return void(c=m);throw new RangeError(`Unrecognized record size: ${y}`)}let v,Q,k=l[m],x=S-e;if(b-S<=o&&(Q=function(e,t){let i=a.fork(),n=0,r=0,l=0,h=i.end-o,c={size:0,start:0,skip:0};e:for(let o=i.pos-e;i.pos>o;){let e=i.size;if(i.id==t&&e>=0){c.size=n,c.start=r,c.skip=l,l+=4,n+=4,i.next();continue}let a=i.pos-e;if(e<0||a<o||i.start<h)break;let d=i.id>=s?4:0,u=i.start;for(i.next();i.pos>a;){if(i.size<0){if(-3!=i.size)break e;d+=4;}else i.id>=s&&(d+=4);i.next();}r=u,n+=e,l+=d;}(t<0||n==e)&&(c.size=n,c.start=r,c.skip=l);return c.size>4?c:void 0}(a.pos-t,g))){let t=new Uint16Array(Q.size-Q.skip),i=a.pos-Q.size,o=t.length;for(;a.pos>i;)o=p(Q.start,t,o);v=new TreeBuffer(t,b-Q.start,n),x=Q.start-e;}else {let e=a.pos-y;a.next();let t=[],i=[],n=m>=s?m:-1,r=0,l=b;for(;a.pos>e;)n>=0&&a.id==n&&a.size>=0?(a.end<=l-o&&(u(t,i,S,r,a.end,l,n,w),r=t.length,l=a.end),a.next()):d(S,e,t,i,n);if(n>=0&&r>0&&r<t.length&&u(t,i,S,r,S,l,n,w),t.reverse(),i.reverse(),n>-1&&r>0){let e=function(e){return (t,i,n)=>{let o,r,s=0,a=t.length-1;if(a>=0&&(o=t[a])instanceof Tree){if(!a&&o.type==e&&o.length==n)return o;(r=o.prop(NodeProp.lookAhead))&&(s=i[a]+o.length+r);}return f(e,t,i,n,s)}}(k);v=balanceRange(k,t,i,0,t.length,0,b-S,e,e);}else v=f(k,t,i,b-S,w-b);}i.push(v),O.push(x);}function u(e,t,i,o,r,s,a,l){let h=[],c=[];for(;e.length>o;)h.push(e.pop()),c.push(t.pop()+i-r);e.push(f(n.types[a],h,c,s-r,l-s)),t.push(r-i);}function f(e,t,i,n,o=0,r){if(h){let e=[NodeProp.contextHash,h];r=r?[e].concat(r):[e];}if(o>25){let e=[NodeProp.lookAhead,o];r=r?[e].concat(r):[e];}return new Tree(e,t,i,n,r)}function p(e,t,i){let{id:n,start:o,end:r,size:l}=a;if(a.next(),l>=0&&n<s){let s=i;if(l>4){let n=a.pos-(l-4);for(;a.pos>n;)i=p(e,t,i);}t[--i]=s,t[--i]=r-e,t[--i]=o-e,t[--i]=n;}else -3==l?h=n:-4==l&&(c=n);return i}let O=[],g=[];for(;a.pos>0;)d(e.start||0,e.bufferStart||0,O,g,-1);let m=null!==(t=e.length)&&void 0!==t?t:O.length?g[0]+O[0].length:0;return new Tree(l[e.topID],O.reverse(),g.reverse(),m)}const nodeSizeCache=new WeakMap;function nodeSize(e,t){if(!e.isAnonymous||t instanceof TreeBuffer||t.type!=e)return 1;let i=nodeSizeCache.get(t);if(null==i){i=1;for(let n of t.children){if(n.type!=e||!(n instanceof Tree)){i=1;break}i+=nodeSize(e,n);}nodeSizeCache.set(t,i);}return i}function balanceRange(e,t,i,n,o,r,s,a,l){let h=0;for(let i=n;i<o;i++)h+=nodeSize(e,t[i]);let c=Math.ceil(1.5*h/8),d=[],u=[];return function t(i,n,o,s,a){for(let h=o;h<s;){let o=h,f=n[h],p=nodeSize(e,i[h]);for(h++;h<s;h++){let t=nodeSize(e,i[h]);if(p+t>=c)break;p+=t;}if(h==o+1){if(p>c){let e=i[o];t(e.children,e.positions,0,e.children.length,n[o]+a);continue}d.push(i[o]);}else {let t=n[h-1]+i[h-1].length-f;d.push(balanceRange(e,i,n,o,h,f,t,null,l));}u.push(f+a-r);}}(t,i,n,o,0),(a||l)(d,u,s)}class TreeFragment{constructor(e,t,i,n,o=!1,r=!1){this.from=e,this.to=t,this.tree=i,this.offset=n,this.open=(o?1:0)|(r?2:0);}get openStart(){return (1&this.open)>0}get openEnd(){return (2&this.open)>0}static addTree(e,t=[],i=!1){let n=[new TreeFragment(0,e.length,e,0,!1,i)];for(let i of t)i.to>e.length&&n.push(i);return n}static applyChanges(e,t,i=128){if(!t.length)return e;let n=[],o=1,r=e.length?e[0]:null;for(let s=0,a=0,l=0;;s++){let h=s<t.length?t[s]:null,c=h?h.fromA:1e9;if(c-a>=i)for(;r&&r.from<c;){let t=r;if(a>=t.from||c<=t.to||l){let e=Math.max(t.from,a)-l,i=Math.min(t.to,c)-l;t=e>=i?null:new TreeFragment(e,i,t.tree,t.offset+l,s>0,!!h);}if(t&&n.push(t),r.to>c)break;r=o<e.length?e[o++]:null;}if(!h)break;a=h.toA,l=h.toA-h.toB;}return n}}class Parser{startParse(e,t,i){return "string"==typeof e&&(e=new StringInput(e)),i=i?i.length?i.map(e=>new Range$1(e.from,e.to)):[new Range$1(0,0)]:[new Range$1(0,e.length)],this.createParse(e,t||[],i)}parse(e,t,i){let n=this.startParse(e,t,i);for(;;){let e=n.advance();if(e)return e}}}class StringInput{constructor(e){this.string=e;}get length(){return this.string.length}chunk(e){return this.string.slice(e)}get lineChunks(){return !1}read(e,t){return this.string.slice(e,t)}}new NodeProp({perNode:!0});let nextTagID=0;class Tag{constructor(e,t,i){this.set=e,this.base=t,this.modified=i,this.id=nextTagID++;}static define(e){if(null===e||void 0===e?void 0:e.base)throw new Error("Can not derive from a modified tag");let t=new Tag([],null,[]);if(t.set.push(t),e)for(let i of e.set)t.set.push(i);return t}static defineModifier(){let e=new Modifier;return t=>t.modified.indexOf(e)>-1?t:Modifier.get(t.base||t,t.modified.concat(e).sort((e,t)=>e.id-t.id))}}let nextModifierID=0;class Modifier{constructor(){this.instances=[],this.id=nextModifierID++;}static get(e,t){if(!t.length)return e;let i=t[0].instances.find(i=>i.base==e&&sameArray$1(t,i.modified));if(i)return i;let n=[],o=new Tag(n,e,t);for(let e of t)e.instances.push(o);let r=powerSet(t);for(let t of e.set)if(!t.modified.length)for(let e of r)n.push(Modifier.get(t,e));return o}}function sameArray$1(e,t){return e.length==t.length&&e.every((e,i)=>e==t[i])}function powerSet(e){let t=[[]];for(let i=0;i<e.length;i++)for(let n=0,o=t.length;n<o;n++)t.push(t[n].concat(e[i]));return t.sort((e,t)=>t.length-e.length)}function styleTags(e){let t=Object.create(null);for(let i in e){let n=e[i];Array.isArray(n)||(n=[n]);for(let e of i.split(" "))if(e){let i=[],o=2,r=e;for(let t=0;;){if("..."==r&&t>0&&t+3==e.length){o=1;break}let n=/^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(r);if(!n)throw new RangeError("Invalid path: "+e);if(i.push("*"==n[0]?"":'"'==n[0][0]?JSON.parse(n[0]):n[0]),(t+=n[0].length)==e.length)break;let s=e[t++];if(t==e.length&&"!"==s){o=0;break}if("/"!=s)throw new RangeError("Invalid path: "+e);r=e.slice(t);}let s=i.length-1,a=i[s];if(!a)throw new RangeError("Invalid path: "+e);let l=new Rule(n,o,s>0?i.slice(0,s):null);t[a]=l.sort(t[a]);}}return ruleNodeProp.add(t)}const ruleNodeProp=new NodeProp;class Rule{constructor(e,t,i,n){this.tags=e,this.mode=t,this.context=i,this.next=n;}get opaque(){return 0==this.mode}get inherit(){return 1==this.mode}sort(e){return !e||e.depth<this.depth?(this.next=e,this):(e.next=this.sort(e.next),e)}get depth(){return this.context?this.context.length:0}}function tagHighlighter(e,t){let i=Object.create(null);for(let t of e)if(Array.isArray(t.tag))for(let e of t.tag)i[e.id]=t.class;else i[t.tag.id]=t.class;let{scope:n,all:o=null}=t||{};return {style:e=>{let t=o;for(let n of e)for(let e of n.set){let n=i[e.id];if(n){t=t?t+" "+n:n;break}}return t},scope:n}}function highlightTags(e,t){let i=null;for(let n of e){let e=n.style(t);e&&(i=i?i+" "+e:e);}return i}function highlightTree(e,t,i,n=0,o=e.length){let r=new HighlightBuilder(n,Array.isArray(t)?t:[t],i);r.highlightRange(e.cursor(),n,o,"",r.highlighters),r.flush(o);}Rule.empty=new Rule([],2,null);class HighlightBuilder{constructor(e,t,i){this.at=e,this.highlighters=t,this.span=i,this.class="";}startSpan(e,t){t!=this.class&&(this.flush(e),e>this.at&&(this.at=e),this.class=t);}flush(e){e>this.at&&this.class&&this.span(this.at,e,this.class);}highlightRange(e,t,i,n,o){let{type:r,from:s,to:a}=e;if(s>=i||a<=t)return;r.isTop&&(o=this.highlighters.filter(e=>!e.scope||e.scope(r)));let l=n,h=getStyleTags(e)||Rule.empty,c=highlightTags(o,h.tags);if(c&&(l&&(l+=" "),l+=c,1==h.mode&&(n+=(n?" ":"")+c)),this.startSpan(e.from,l),h.opaque)return;let d=e.tree&&e.tree.prop(NodeProp.mounted);if(d&&d.overlay){let r=e.node.enter(d.overlay[0].from+s,1),h=this.highlighters.filter(e=>!e.scope||e.scope(d.tree.type)),c=e.firstChild();for(let u=0,f=s;;u++){let p=u<d.overlay.length?d.overlay[u]:null,O=p?p.from+s:a,g=Math.max(t,f),m=Math.min(i,O);if(g<m&&c)for(;e.from<m&&(this.highlightRange(e,g,m,n,o),this.startSpan(Math.min(m,e.to),l),!(e.to>=O)&&e.nextSibling()););if(!p||O>i)break;(f=p.to+s)>t&&(this.highlightRange(r.cursor(),Math.max(t,p.from+s),Math.min(i,f),n,h),this.startSpan(f,l));}c&&e.parent();}else if(e.firstChild()){do{if(!(e.to<=t)){if(e.from>=i)break;this.highlightRange(e,t,i,n,o),this.startSpan(Math.min(i,e.to),l);}}while(e.nextSibling());e.parent();}}}function getStyleTags(e){let t=e.type.prop(ruleNodeProp);for(;t&&t.context&&!e.matchContext(t.context);)t=t.next;return t||null}const t=Tag.define,comment=t(),name$1=t(),typeName=t(name$1),propertyName=t(name$1),literal=t(),string=t(literal),number=t(literal),content=t(),heading=t(content),keyword=t(),operator=t(),punctuation=t(),bracket=t(punctuation),meta=t(),tags={comment:comment,lineComment:t(comment),blockComment:t(comment),docComment:t(comment),name:name$1,variableName:t(name$1),typeName:typeName,tagName:t(typeName),propertyName:propertyName,attributeName:t(propertyName),className:t(name$1),labelName:t(name$1),namespace:t(name$1),macroName:t(name$1),literal:literal,string:string,docString:t(string),character:t(string),attributeValue:t(string),number:number,integer:t(number),float:t(number),bool:t(literal),regexp:t(literal),escape:t(literal),color:t(literal),url:t(literal),keyword:keyword,self:t(keyword),null:t(keyword),atom:t(keyword),unit:t(keyword),modifier:t(keyword),operatorKeyword:t(keyword),controlKeyword:t(keyword),definitionKeyword:t(keyword),moduleKeyword:t(keyword),operator:operator,derefOperator:t(operator),arithmeticOperator:t(operator),logicOperator:t(operator),bitwiseOperator:t(operator),compareOperator:t(operator),updateOperator:t(operator),definitionOperator:t(operator),typeOperator:t(operator),controlOperator:t(operator),punctuation:punctuation,separator:t(punctuation),bracket:bracket,angleBracket:t(bracket),squareBracket:t(bracket),paren:t(bracket),brace:t(bracket),content:content,heading:heading,heading1:t(heading),heading2:t(heading),heading3:t(heading),heading4:t(heading),heading5:t(heading),heading6:t(heading),contentSeparator:t(content),list:t(content),quote:t(content),emphasis:t(content),strong:t(content),link:t(content),monospace:t(content),strikethrough:t(content),inserted:t(),deleted:t(),changed:t(),invalid:t(),meta:meta,documentMeta:t(meta),annotation:t(meta),processingInstruction:t(meta),definition:Tag.defineModifier(),constant:Tag.defineModifier(),function:Tag.defineModifier(),standard:Tag.defineModifier(),local:Tag.defineModifier(),special:Tag.defineModifier()};tagHighlighter([{tag:tags.link,class:"tok-link"},{tag:tags.heading,class:"tok-heading"},{tag:tags.emphasis,class:"tok-emphasis"},{tag:tags.strong,class:"tok-strong"},{tag:tags.keyword,class:"tok-keyword"},{tag:tags.atom,class:"tok-atom"},{tag:tags.bool,class:"tok-bool"},{tag:tags.url,class:"tok-url"},{tag:tags.labelName,class:"tok-labelName"},{tag:tags.inserted,class:"tok-inserted"},{tag:tags.deleted,class:"tok-deleted"},{tag:tags.literal,class:"tok-literal"},{tag:tags.string,class:"tok-string"},{tag:tags.number,class:"tok-number"},{tag:[tags.regexp,tags.escape,tags.special(tags.string)],class:"tok-string2"},{tag:tags.variableName,class:"tok-variableName"},{tag:tags.local(tags.variableName),class:"tok-variableName tok-local"},{tag:tags.definition(tags.variableName),class:"tok-variableName tok-definition"},{tag:tags.special(tags.variableName),class:"tok-variableName2"},{tag:tags.definition(tags.propertyName),class:"tok-propertyName tok-definition"},{tag:tags.typeName,class:"tok-typeName"},{tag:tags.namespace,class:"tok-namespace"},{tag:tags.className,class:"tok-className"},{tag:tags.macroName,class:"tok-macroName"},{tag:tags.propertyName,class:"tok-propertyName"},{tag:tags.operator,class:"tok-operator"},{tag:tags.comment,class:"tok-comment"},{tag:tags.meta,class:"tok-meta"},{tag:tags.invalid,class:"tok-invalid"},{tag:tags.punctuation,class:"tok-punctuation"}]);var _a;const languageDataProp=new NodeProp;function defineLanguageFacet(e){return Facet.define({combine:e?t=>t.concat(e):void 0})}class Language{constructor(e,t,i=[],n=""){this.data=e,this.name=n,EditorState.prototype.hasOwnProperty("tree")||Object.defineProperty(EditorState.prototype,"tree",{get(){return syntaxTree(this)}}),this.parser=t,this.extension=[language.of(this),EditorState.languageData.of((e,t,i)=>e.facet(languageDataFacetAt(e,t,i)))].concat(i);}isActiveAt(e,t,i=-1){return languageDataFacetAt(e,t,i)==this.data}findRegions(e){let t=e.facet(language);if((null===t||void 0===t?void 0:t.data)==this.data)return [{from:0,to:e.doc.length}];if(!t||!t.allowsNesting)return [];let i=[],n=(e,t)=>{if(e.prop(languageDataProp)==this.data)return void i.push({from:t,to:t+e.length});let o=e.prop(NodeProp.mounted);if(o){if(o.tree.prop(languageDataProp)==this.data){if(o.overlay)for(let e of o.overlay)i.push({from:e.from+t,to:e.to+t});else i.push({from:t,to:t+e.length});return}if(o.overlay){let e=i.length;if(n(o.tree,o.overlay[0].from+t),i.length>e)return}}for(let i=0;i<e.children.length;i++){let o=e.children[i];o instanceof Tree&&n(o,e.positions[i]+t);}};return n(syntaxTree(e),0),i}get allowsNesting(){return !0}}function languageDataFacetAt(e,t,i){let n=e.facet(language);if(!n)return null;let o=n.data;if(n.allowsNesting)for(let n=syntaxTree(e).topNode;n;n=n.enter(t,i,IterMode.ExcludeBuffers))o=n.type.prop(languageDataProp)||o;return o}Language.setState=StateEffect.define();class LRLanguage extends Language{constructor(e,t,i){super(e,t,[],i),this.parser=t;}static define(e){let t=defineLanguageFacet(e.languageData);return new LRLanguage(t,e.parser.configure({props:[languageDataProp.add(e=>e.isTop?t:void 0)]}),e.name)}configure(e,t){return new LRLanguage(this.data,this.parser.configure(e),t||this.name)}get allowsNesting(){return this.parser.hasWrappers()}}function syntaxTree(e){let t=e.field(Language.state,!1);return t?t.tree:Tree.empty}class DocInput{constructor(e,t=e.length){this.doc=e,this.length=t,this.cursorPos=0,this.string="",this.cursor=e.iter();}syncTo(e){return this.string=this.cursor.next(e-this.cursorPos).value,this.cursorPos=e+this.string.length,this.cursorPos-this.string.length}chunk(e){return this.syncTo(e),this.string}get lineChunks(){return !0}read(e,t){let i=this.cursorPos-this.string.length;return e<i||t>=this.cursorPos?this.doc.sliceString(e,t):this.string.slice(e-i,t-i)}}let currentContext=null;class ParseContext{constructor(e,t,i=[],n,o,r,s,a){this.parser=e,this.state=t,this.fragments=i,this.tree=n,this.treeLen=o,this.viewport=r,this.skipped=s,this.scheduleOn=a,this.parse=null,this.tempSkipped=[];}static create(e,t,i){return new ParseContext(e,t,[],Tree.empty,0,i,[],null)}startParse(){return this.parser.startParse(new DocInput(this.state.doc),this.fragments)}work(e,t){return null!=t&&t>=this.state.doc.length&&(t=void 0),this.tree!=Tree.empty&&this.isDone(null!==t&&void 0!==t?t:this.state.doc.length)?(this.takeTree(),!0):this.withContext(()=>{var i;if("number"==typeof e){let t=Date.now()+e;e=(()=>Date.now()>t);}for(this.parse||(this.parse=this.startParse()),null!=t&&(null==this.parse.stoppedAt||this.parse.stoppedAt>t)&&t<this.state.doc.length&&this.parse.stopAt(t);;){let n=this.parse.advance();if(n){if(this.fragments=this.withoutTempSkipped(TreeFragment.addTree(n,this.fragments,null!=this.parse.stoppedAt)),this.treeLen=null!==(i=this.parse.stoppedAt)&&void 0!==i?i:this.state.doc.length,this.tree=n,this.parse=null,!(this.treeLen<(null!==t&&void 0!==t?t:this.state.doc.length)))return !0;this.parse=this.startParse();}if(e())return !1}})}takeTree(){let e,t;this.parse&&(e=this.parse.parsedPos)>=this.treeLen&&((null==this.parse.stoppedAt||this.parse.stoppedAt>e)&&this.parse.stopAt(e),this.withContext(()=>{for(;!(t=this.parse.advance()););}),this.treeLen=e,this.tree=t,this.fragments=this.withoutTempSkipped(TreeFragment.addTree(this.tree,this.fragments,!0)),this.parse=null);}withContext(e){let t=currentContext;currentContext=this;try{return e()}finally{currentContext=t;}}withoutTempSkipped(e){for(let t;t=this.tempSkipped.pop();)e=cutFragments(e,t.from,t.to);return e}changes(e,t){let{fragments:i,tree:n,treeLen:o,viewport:r,skipped:s}=this;if(this.takeTree(),!e.empty){let t=[];if(e.iterChangedRanges((e,i,n,o)=>t.push({fromA:e,toA:i,fromB:n,toB:o})),i=TreeFragment.applyChanges(i,t),n=Tree.empty,o=0,r={from:e.mapPos(r.from,-1),to:e.mapPos(r.to,1)},this.skipped.length){s=[];for(let t of this.skipped){let i=e.mapPos(t.from,1),n=e.mapPos(t.to,-1);i<n&&s.push({from:i,to:n});}}}return new ParseContext(this.parser,t,i,n,o,r,s,this.scheduleOn)}updateViewport(e){if(this.viewport.from==e.from&&this.viewport.to==e.to)return !1;this.viewport=e;let t=this.skipped.length;for(let t=0;t<this.skipped.length;t++){let{from:i,to:n}=this.skipped[t];i<e.to&&n>e.from&&(this.fragments=cutFragments(this.fragments,i,n),this.skipped.splice(t--,1));}return !(this.skipped.length>=t)&&(this.reset(),!0)}reset(){this.parse&&(this.takeTree(),this.parse=null);}skipUntilInView(e,t){this.skipped.push({from:e,to:t});}static getSkippingParser(e){return new class extends Parser{createParse(t,i,n){let o=n[0].from,r=n[n.length-1].to;return {parsedPos:o,advance(){let t=currentContext;if(t){for(let e of n)t.tempSkipped.push(e);e&&(t.scheduleOn=t.scheduleOn?Promise.all([t.scheduleOn,e]):e);}return this.parsedPos=r,new Tree(NodeType.none,[],[],r-o)},stoppedAt:null,stopAt(){}}}}}isDone(e){e=Math.min(e,this.state.doc.length);let t=this.fragments;return this.treeLen>=e&&t.length&&0==t[0].from&&t[0].to>=e}static get(){return currentContext}}function cutFragments(e,t,i){return TreeFragment.applyChanges(e,[{fromA:t,toA:i,fromB:t,toB:i}])}class LanguageState{constructor(e){this.context=e,this.tree=e.tree;}apply(e){if(!e.docChanged&&this.tree==this.context.tree)return this;let t=this.context.changes(e.changes,e.state),i=this.context.treeLen==e.startState.doc.length?void 0:Math.max(e.changes.mapPos(this.context.treeLen),t.viewport.to);return t.work(20,i)||t.takeTree(),new LanguageState(t)}static init(e){let t=Math.min(3e3,e.doc.length),i=ParseContext.create(e.facet(language).parser,e,{from:0,to:t});return i.work(20,t)||i.takeTree(),new LanguageState(i)}}Language.state=StateField.define({create:LanguageState.init,update(e,t){for(let e of t.effects)if(e.is(Language.setState))return e.value;return t.startState.facet(language)!=t.state.facet(language)?LanguageState.init(t.state):e.apply(t)}});let requestIdle=e=>{let t=setTimeout(()=>e(),500);return ()=>clearTimeout(t)};"undefined"!=typeof requestIdleCallback&&(requestIdle=(e=>{let t=-1,i=setTimeout(()=>{t=requestIdleCallback(e,{timeout:400});},100);return ()=>t<0?clearTimeout(i):cancelIdleCallback(t)}));const isInputPending="undefined"!=typeof navigator&&(null===(_a=navigator.scheduling)||void 0===_a?void 0:_a.isInputPending)?()=>navigator.scheduling.isInputPending():null,parseWorker=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.working=null,this.workScheduled=0,this.chunkEnd=-1,this.chunkBudget=-1,this.work=this.work.bind(this),this.scheduleWork();}update(e){let t=this.view.state.field(Language.state).context;(t.updateViewport(e.view.viewport)||this.view.viewport.to>t.treeLen)&&this.scheduleWork(),e.docChanged&&(this.view.hasFocus&&(this.chunkBudget+=50),this.scheduleWork()),this.checkAsyncSchedule(t);}scheduleWork(){if(this.working)return;let{state:e}=this.view,t=e.field(Language.state);t.tree==t.context.tree&&t.context.isDone(e.doc.length)||(this.working=requestIdle(this.work));}work(e){this.working=null;let t=Date.now();if(this.chunkEnd<t&&(this.chunkEnd<0||this.view.hasFocus)&&(this.chunkEnd=t+3e4,this.chunkBudget=3e3),this.chunkBudget<=0)return;let{state:i,viewport:{to:n}}=this.view,o=i.field(Language.state);if(o.tree==o.context.tree&&o.context.isDone(n+1e5))return;let r=Date.now()+Math.min(this.chunkBudget,100,e&&!isInputPending?Math.max(25,e.timeRemaining()-5):1e9),s=o.context.treeLen<n&&i.doc.length>n+1e3,a=o.context.work(()=>isInputPending&&isInputPending()||Date.now()>r,n+(s?0:1e5));this.chunkBudget-=Date.now()-t,(a||this.chunkBudget<=0)&&(o.context.takeTree(),this.view.dispatch({effects:Language.setState.of(new LanguageState(o.context))})),this.chunkBudget>0&&(!a||s)&&this.scheduleWork(),this.checkAsyncSchedule(o.context);}checkAsyncSchedule(e){e.scheduleOn&&(this.workScheduled++,e.scheduleOn.then(()=>this.scheduleWork()).catch(e=>logException(this.view.state,e)).then(()=>this.workScheduled--),e.scheduleOn=null);}destroy(){this.working&&this.working();}isWorking(){return !!(this.working||this.workScheduled>0)}},{eventHandlers:{focus(){this.scheduleWork();}}}),language=Facet.define({combine:e=>e.length?e[0]:null,enables:e=>[Language.state,parseWorker,EditorView.contentAttributes.compute([e],t=>{let i=t.facet(e);return i&&i.name?{"data-language":i.name}:{}})]}),indentService=Facet.define(),indentUnit=Facet.define({combine:e=>{if(!e.length)return "  ";if(!/^(?: +|\t+)$/.test(e[0]))throw new Error("Invalid indent unit: "+JSON.stringify(e[0]));return e[0]}});function getIndentUnit(e){let t=e.facet(indentUnit);return 9==t.charCodeAt(0)?e.tabSize*t.length:t.length}function indentString(e,t){let i="",n=e.tabSize;if(9==e.facet(indentUnit).charCodeAt(0))for(;t>=n;)i+="\t",t-=n;for(let e=0;e<t;e++)i+=" ";return i}function getIndentation(e,t){e instanceof EditorState&&(e=new IndentContext(e));for(let i of e.state.facet(indentService)){let n=i(e,t);if(void 0!==n)return n}let i=syntaxTree(e.state);return i?syntaxIndentation(e,i,t):null}class IndentContext{constructor(e,t={}){this.state=e,this.options=t,this.unit=getIndentUnit(e);}lineAt(e,t=1){let i=this.state.doc.lineAt(e),{simulateBreak:n,simulateDoubleBreak:o}=this.options;return null!=n&&n>=i.from&&n<=i.to?o&&n==e?{text:"",from:e}:(t<0?n<e:n<=e)?{text:i.text.slice(n-i.from),from:n}:{text:i.text.slice(0,n-i.from),from:i.from}:i}textAfterPos(e,t=1){if(this.options.simulateDoubleBreak&&e==this.options.simulateBreak)return "";let{text:i,from:n}=this.lineAt(e,t);return i.slice(e-n,Math.min(i.length,e+100-n))}column(e,t=1){let{text:i,from:n}=this.lineAt(e,t),o=this.countColumn(i,e-n),r=this.options.overrideIndentation?this.options.overrideIndentation(n):-1;return r>-1&&(o+=r-this.countColumn(i,i.search(/\S|$/))),o}countColumn(e,t=e.length){return countColumn(e,this.state.tabSize,t)}lineIndent(e,t=1){let{text:i,from:n}=this.lineAt(e,t),o=this.options.overrideIndentation;if(o){let e=o(n);if(e>-1)return e}return this.countColumn(i,i.search(/\S|$/))}get simulatedBreak(){return this.options.simulateBreak||null}}const indentNodeProp=new NodeProp;function syntaxIndentation(e,t,i){return indentFrom(t.resolveInner(i).enterUnfinishedNodesBefore(i),i,e)}function ignoreClosed(e){return e.pos==e.options.simulateBreak&&e.options.simulateDoubleBreak}function indentStrategy(e){let t=e.type.prop(indentNodeProp);if(t)return t;let i,n=e.firstChild;if(n&&(i=n.type.prop(NodeProp.closedBy))){let t=e.lastChild,n=t&&i.indexOf(t.name)>-1;return e=>delimitedStrategy(e,!0,1,void 0,n&&!ignoreClosed(e)?t.from:void 0)}return null==e.parent?topIndent:null}function indentFrom(e,t,i){for(;e;e=e.parent){let n=indentStrategy(e);if(n)return n(TreeIndentContext.create(i,t,e))}return null}function topIndent(){return 0}class TreeIndentContext extends IndentContext{constructor(e,t,i){super(e.state,e.options),this.base=e,this.pos=t,this.node=i;}static create(e,t,i){return new TreeIndentContext(e,t,i)}get textAfter(){return this.textAfterPos(this.pos)}get baseIndent(){let e=this.state.doc.lineAt(this.node.from);for(;;){let t=this.node.resolve(e.from);for(;t.parent&&t.parent.from==t.from;)t=t.parent;if(isParent(t,this.node))break;e=this.state.doc.lineAt(t.from);}return this.lineIndent(e.from)}continue(){let e=this.node.parent;return e?indentFrom(e,this.pos,this.base):0}}function isParent(e,t){for(let i=t;i;i=i.parent)if(e==i)return !0;return !1}function bracketedAligned(e){let t=e.node,i=t.childAfter(t.from),n=t.lastChild;if(!i)return null;let o=e.options.simulateBreak,r=e.state.doc.lineAt(i.from),s=null==o||o<=r.from?r.to:Math.min(r.to,o);for(let e=i.to;;){let o=t.childAfter(e);if(!o||o==n)return null;if(!o.type.isSkipped)return o.from<s?i:null;e=o.to;}}function delimitedIndent({closing:e,align:t=!0,units:i=1}){return n=>delimitedStrategy(n,t,i,e)}function delimitedStrategy(e,t,i,n,o){let r=e.textAfter,s=r.match(/^\s*/)[0].length,a=n&&r.slice(s,s+n.length)==n||o==e.pos+s,l=t?bracketedAligned(e):null;return l?a?e.column(l.from):e.column(l.to):e.baseIndent+(a?0:e.unit*i)}const flatIndent=e=>e.baseIndent;function continuedIndent({except:e,units:t=1}={}){return i=>{let n=e&&e.test(i.textAfter);return i.baseIndent+(n?0:t*i.unit)}}const DontIndentBeyond=200;function indentOnInput(){return EditorState.transactionFilter.of(e=>{if(!e.docChanged||!e.isUserEvent("input.type")&&!e.isUserEvent("input.complete"))return e;let t=e.startState.languageDataAt("indentOnInput",e.startState.selection.main.head);if(!t.length)return e;let i=e.newDoc,{head:n}=e.newSelection.main,o=i.lineAt(n);if(n>o.from+DontIndentBeyond)return e;let r=i.sliceString(o.from,n);if(!t.some(e=>e.test(r)))return e;let{state:s}=e,a=-1,l=[];for(let{head:e}of s.selection.ranges){let t=s.doc.lineAt(e);if(t.from==a)continue;a=t.from;let i=getIndentation(s,t.from);if(null==i)continue;let n=/^\s*/.exec(t.text)[0],o=indentString(s,i);n!=o&&l.push({from:t.from,to:t.from+n.length,insert:o});}return l.length?[e,{changes:l,sequential:!0}]:e})}const foldService=Facet.define(),foldNodeProp=new NodeProp;function foldInside(e){let t=e.firstChild,i=e.lastChild;return t&&t.to<i.from?{from:t.to,to:i.type.isError?e.to:i.from}:null}function syntaxFolding(e,t,i){let n=syntaxTree(e);if(n.length<i)return null;let o=null;for(let r=n.resolveInner(i,1);r;r=r.parent){if(r.to<=i||r.from>i)continue;if(o&&r.from<t)break;let s=r.type.prop(foldNodeProp);if(s&&(r.to<n.length-50||n.length==e.doc.length||!isUnfinished(r))){let n=s(r,e);n&&n.from<=i&&n.from>=t&&n.to>i&&(o=n);}}return o}function isUnfinished(e){let t=e.lastChild;return t&&t.to==e.to&&t.type.isError}function foldable(e,t,i){for(let n of e.facet(foldService)){let o=n(e,t,i);if(o)return o}return syntaxFolding(e,t,i)}function mapRange(e,t){let i=t.mapPos(e.from,1),n=t.mapPos(e.to,-1);return i>=n?void 0:{from:i,to:n}}const foldEffect=StateEffect.define({map:mapRange}),unfoldEffect=StateEffect.define({map:mapRange});function selectedLines(e){let t=[];for(let{head:i}of e.state.selection.ranges)t.some(e=>e.from<=i&&e.to>=i)||t.push(e.lineBlockAt(i));return t}const foldState=StateField.define({create:()=>Decoration.none,update(e,t){e=e.map(t.changes);for(let i of t.effects)i.is(foldEffect)&&!foldExists(e,i.value.from,i.value.to)?e=e.update({add:[foldWidget.range(i.value.from,i.value.to)]}):i.is(unfoldEffect)&&(e=e.update({filter:(e,t)=>i.value.from!=e||i.value.to!=t,filterFrom:i.value.from,filterTo:i.value.to}));if(t.selection){let i=!1,{head:n}=t.selection.main;e.between(n,n,(e,t)=>{e<n&&t>n&&(i=!0);}),i&&(e=e.update({filterFrom:n,filterTo:n,filter:(e,t)=>t<=n||e>=n}));}return e},provide:e=>EditorView.decorations.from(e),toJSON(e,t){let i=[];return e.between(0,t.doc.length,(e,t)=>{i.push(e,t);}),i},fromJSON(e){if(!Array.isArray(e)||e.length%2)throw new RangeError("Invalid JSON for fold state");let t=[];for(let i=0;i<e.length;){let n=e[i++],o=e[i++];if("number"!=typeof n||"number"!=typeof o)throw new RangeError("Invalid JSON for fold state");t.push(foldWidget.range(n,o));}return Decoration.set(t,!0)}});function findFold(e,t,i){var n;let o=null;return null===(n=e.field(foldState,!1))||void 0===n||n.between(t,i,(e,t)=>{(!o||o.from>e)&&(o={from:e,to:t});}),o}function foldExists(e,t,i){let n=!1;return e.between(t,t,(e,o)=>{e==t&&o==i&&(n=!0);}),n}function maybeEnable(e,t){return e.field(foldState,!1)?t:t.concat(StateEffect.appendConfig.of(codeFolding()))}const foldCode=e=>{for(let t of selectedLines(e)){let i=foldable(e.state,t.from,t.to);if(i)return e.dispatch({effects:maybeEnable(e.state,[foldEffect.of(i),announceFold(e,i)])}),!0}return !1},unfoldCode=e=>{if(!e.state.field(foldState,!1))return !1;let t=[];for(let i of selectedLines(e)){let n=findFold(e.state,i.from,i.to);n&&t.push(unfoldEffect.of(n),announceFold(e,n,!1));}return t.length&&e.dispatch({effects:t}),t.length>0};function announceFold(e,t,i=!0){let n=e.state.doc.lineAt(t.from).number,o=e.state.doc.lineAt(t.to).number;return EditorView.announce.of(`${e.state.phrase(i?"Folded lines":"Unfolded lines")} ${n} ${e.state.phrase("to")} ${o}.`)}const foldAll=e=>{let{state:t}=e,i=[];for(let n=0;n<t.doc.length;){let o=e.lineBlockAt(n),r=foldable(t,o.from,o.to);r&&i.push(foldEffect.of(r)),n=(r?e.lineBlockAt(r.to):o).to+1;}return i.length&&e.dispatch({effects:maybeEnable(e.state,i)}),!!i.length},unfoldAll=e=>{let t=e.state.field(foldState,!1);if(!t||!t.size)return !1;let i=[];return t.between(0,e.state.doc.length,(e,t)=>{i.push(unfoldEffect.of({from:e,to:t}));}),e.dispatch({effects:i}),!0},foldKeymap=[{key:"Ctrl-Shift-[",mac:"Cmd-Alt-[",run:foldCode},{key:"Ctrl-Shift-]",mac:"Cmd-Alt-]",run:unfoldCode},{key:"Ctrl-Alt-[",run:foldAll},{key:"Ctrl-Alt-]",run:unfoldAll}],defaultConfig={placeholderDOM:null,placeholderText:"…"},foldConfig=Facet.define({combine:e=>combineConfig(e,defaultConfig)});function codeFolding(e){let t=[foldState,baseTheme$1$1];return e&&t.push(foldConfig.of(e)),t}const foldWidget=Decoration.replace({widget:new class extends WidgetType{toDOM(e){let{state:t}=e,i=t.facet(foldConfig),n=t=>{let i=e.lineBlockAt(e.posAtDOM(t.target)),n=findFold(e.state,i.from,i.to);n&&e.dispatch({effects:unfoldEffect.of(n)}),t.preventDefault();};if(i.placeholderDOM)return i.placeholderDOM(e,n);let o=document.createElement("span");return o.textContent=i.placeholderText,o.setAttribute("aria-label",t.phrase("folded code")),o.title=t.phrase("unfold"),o.className="cm-foldPlaceholder",o.onclick=n,o}}}),foldGutterDefaults={openText:"⌄",closedText:"›",markerDOM:null,domEventHandlers:{},foldingChanged:()=>!1};class FoldMarker extends GutterMarker{constructor(e,t){super(),this.config=e,this.open=t;}eq(e){return this.config==e.config&&this.open==e.open}toDOM(e){if(this.config.markerDOM)return this.config.markerDOM(this.open);let t=document.createElement("span");return t.textContent=this.open?this.config.openText:this.config.closedText,t.title=e.state.phrase(this.open?"Fold line":"Unfold line"),t}}function foldGutter(e={}){let t=Object.assign(Object.assign({},foldGutterDefaults),e),i=new FoldMarker(t,!0),n=new FoldMarker(t,!1),o=ViewPlugin.fromClass(class{constructor(e){this.from=e.viewport.from,this.markers=this.buildMarkers(e);}update(e){(e.docChanged||e.viewportChanged||e.startState.facet(language)!=e.state.facet(language)||e.startState.field(foldState,!1)!=e.state.field(foldState,!1)||syntaxTree(e.startState)!=syntaxTree(e.state)||t.foldingChanged(e))&&(this.markers=this.buildMarkers(e.view));}buildMarkers(e){let t=new RangeSetBuilder;for(let o of e.viewportLineBlocks){let r=findFold(e.state,o.from,o.to)?n:foldable(e.state,o.from,o.to)?i:null;r&&t.add(o.from,o.from,r);}return t.finish()}}),{domEventHandlers:r}=t;return [o,gutter({class:"cm-foldGutter",markers(e){var t;return (null===(t=e.plugin(o))||void 0===t?void 0:t.markers)||RangeSet.empty},initialSpacer:()=>new FoldMarker(t,!1),domEventHandlers:Object.assign(Object.assign({},r),{click:(e,t,i)=>{if(r.click&&r.click(e,t,i))return !0;let n=findFold(e.state,t.from,t.to);if(n)return e.dispatch({effects:unfoldEffect.of(n)}),!0;let o=foldable(e.state,t.from,t.to);return !!o&&(e.dispatch({effects:foldEffect.of(o)}),!0)}})}),codeFolding()]}const baseTheme$1$1=EditorView.baseTheme({".cm-foldPlaceholder":{backgroundColor:"#eee",border:"1px solid #ddd",color:"#888",borderRadius:".2em",margin:"0 1px",padding:"0 1px",cursor:"pointer"},".cm-foldGutter span":{padding:"0 1px",cursor:"pointer"}});class HighlightStyle{constructor(e,t){let i;function n(e){let t=StyleModule.newName();return (i||(i=Object.create(null)))["."+t]=e,t}this.specs=e;const o="string"==typeof t.all?t.all:t.all?n(t.all):void 0,r=t.scope;this.scope=r instanceof Language?e=>e.prop(languageDataProp)==r.data:r?e=>e==r:void 0,this.style=tagHighlighter(e.map(e=>({tag:e.tag,class:e.class||n(Object.assign({},e,{tag:null}))})),{all:o}).style,this.module=i?new StyleModule(i):null,this.themeType=t.themeType;}static define(e,t){return new HighlightStyle(e,t||{})}}const highlighterFacet=Facet.define(),fallbackHighlighter=Facet.define({combine:e=>e.length?[e[0]]:null});function getHighlighters(e){let t=e.facet(highlighterFacet);return t.length?t:e.facet(fallbackHighlighter)}function syntaxHighlighting(e,t){let i,n=[treeHighlighter];return e instanceof HighlightStyle&&(e.module&&n.push(EditorView.styleModule.of(e.module)),i=e.themeType),(null===t||void 0===t?void 0:t.fallback)?n.push(fallbackHighlighter.of(e)):i?n.push(highlighterFacet.computeN([EditorView.darkTheme],t=>t.facet(EditorView.darkTheme)==("dark"==i)?[e]:[])):n.push(highlighterFacet.of(e)),n}class TreeHighlighter{constructor(e){this.markCache=Object.create(null),this.tree=syntaxTree(e.state),this.decorations=this.buildDeco(e,getHighlighters(e.state));}update(e){let t=syntaxTree(e.state),i=getHighlighters(e.state),n=i!=getHighlighters(e.startState);t.length<e.view.viewport.to&&!n&&t.type==this.tree.type?this.decorations=this.decorations.map(e.changes):(t!=this.tree||e.viewportChanged||n)&&(this.tree=t,this.decorations=this.buildDeco(e.view,i));}buildDeco(e,t){if(!t||!this.tree.length)return Decoration.none;let i=new RangeSetBuilder;for(let{from:n,to:o}of e.visibleRanges)highlightTree(this.tree,t,(e,t,n)=>{i.add(e,t,this.markCache[n]||(this.markCache[n]=Decoration.mark({class:n})));},n,o);return i.finish()}}const treeHighlighter=Prec.high(ViewPlugin.fromClass(TreeHighlighter,{decorations:e=>e.decorations})),defaultHighlightStyle=HighlightStyle.define([{tag:tags.meta,color:"#7a757a"},{tag:tags.link,textDecoration:"underline"},{tag:tags.heading,textDecoration:"underline",fontWeight:"bold"},{tag:tags.emphasis,fontStyle:"italic"},{tag:tags.strong,fontWeight:"bold"},{tag:tags.strikethrough,textDecoration:"line-through"},{tag:tags.keyword,color:"#708"},{tag:[tags.atom,tags.bool,tags.url,tags.contentSeparator,tags.labelName],color:"#219"},{tag:[tags.literal,tags.inserted],color:"#164"},{tag:[tags.string,tags.deleted],color:"#a11"},{tag:[tags.regexp,tags.escape,tags.special(tags.string)],color:"#e40"},{tag:tags.definition(tags.variableName),color:"#00f"},{tag:tags.local(tags.variableName),color:"#30a"},{tag:[tags.typeName,tags.namespace],color:"#085"},{tag:tags.className,color:"#167"},{tag:[tags.special(tags.variableName),tags.macroName],color:"#256"},{tag:tags.definition(tags.propertyName),color:"#00c"},{tag:tags.comment,color:"#940"},{tag:tags.invalid,color:"#f00"}]),baseTheme$2=EditorView.baseTheme({"&.cm-focused .cm-matchingBracket":{backgroundColor:"#328c8252"},"&.cm-focused .cm-nonmatchingBracket":{backgroundColor:"#bb555544"}}),DefaultScanDist=1e4,DefaultBrackets="()[]{}",bracketMatchingConfig=Facet.define({combine:e=>combineConfig(e,{afterCursor:!0,brackets:DefaultBrackets,maxScanDistance:DefaultScanDist,renderMatch:defaultRenderMatch})}),matchingMark=Decoration.mark({class:"cm-matchingBracket"}),nonmatchingMark=Decoration.mark({class:"cm-nonmatchingBracket"});function defaultRenderMatch(e){let t=[],i=e.matched?matchingMark:nonmatchingMark;return t.push(i.range(e.start.from,e.start.to)),e.end&&t.push(i.range(e.end.from,e.end.to)),t}const bracketMatchingState=StateField.define({create:()=>Decoration.none,update(e,t){if(!t.docChanged&&!t.selection)return e;let i=[],n=t.state.facet(bracketMatchingConfig);for(let e of t.state.selection.ranges){if(!e.empty)continue;let o=matchBrackets(t.state,e.head,-1,n)||e.head>0&&matchBrackets(t.state,e.head-1,1,n)||n.afterCursor&&(matchBrackets(t.state,e.head,1,n)||e.head<t.state.doc.length&&matchBrackets(t.state,e.head+1,-1,n));o&&(i=i.concat(n.renderMatch(o,t.state)));}return Decoration.set(i,!0)},provide:e=>EditorView.decorations.from(e)}),bracketMatchingUnique=[bracketMatchingState,baseTheme$2];function bracketMatching(e={}){return [bracketMatchingConfig.of(e),bracketMatchingUnique]}function matchingNodes(e,t,i){let n=e.prop(t<0?NodeProp.openedBy:NodeProp.closedBy);if(n)return n;if(1==e.name.length){let n=i.indexOf(e.name);if(n>-1&&n%2==(t<0?1:0))return [i[n+t]]}return null}function matchBrackets(e,t,i,n={}){let o=n.maxScanDistance||DefaultScanDist,r=n.brackets||DefaultBrackets,s=syntaxTree(e),a=s.resolveInner(t,i);for(let n=a;n;n=n.parent){let o=matchingNodes(n.type,i,r);if(o&&n.from<n.to)return matchMarkedBrackets(e,t,i,n,o,r)}return matchPlainBrackets(e,t,i,s,a.type,o,r)}function matchMarkedBrackets(e,t,i,n,o,r){let s=n.parent,a={from:n.from,to:n.to},l=0,h=null===s||void 0===s?void 0:s.cursor();if(h&&(i<0?h.childBefore(n.from):h.childAfter(n.to)))do{if(i<0?h.to<=n.from:h.from>=n.to){if(0==l&&o.indexOf(h.type.name)>-1&&h.from<h.to)return {start:a,end:{from:h.from,to:h.to},matched:!0};if(matchingNodes(h.type,i,r))l++;else if(matchingNodes(h.type,-i,r)){if(0==l)return {start:a,end:h.from==h.to?void 0:{from:h.from,to:h.to},matched:!1};l--;}}}while(i<0?h.prevSibling():h.nextSibling());return {start:a,matched:!1}}function matchPlainBrackets(e,t,i,n,o,r,s){let a=i<0?e.sliceDoc(t-1,t):e.sliceDoc(t,t+1),l=s.indexOf(a);if(l<0||l%2==0!=i>0)return null;let h={from:i<0?t-1:t,to:i>0?t+1:t},c=e.doc.iterRange(t,i>0?e.doc.length:0),d=0;for(let e=0;!c.next().done&&e<=r;){let r=c.value;i<0&&(e+=r.length);let a=t+e*i;for(let e=i>0?0:r.length-1,t=i>0?r.length:-1;e!=t;e+=i){let t=s.indexOf(r[e]);if(!(t<0||n.resolveInner(a+e,1).type!=o))if(t%2==0==i>0)d++;else {if(1==d)return {start:h,end:{from:a+e,to:a+e+1},matched:t>>1==l>>1};d--;}}i>0&&(e+=r.length);}return c.done?{start:h,matched:!1}:null}const noTokens=Object.create(null),typeArray=[NodeType.none];new NodeSet(typeArray);const warned=[],defaultTable=Object.create(null);for(let[e,t]of [["variable","variableName"],["variable-2","variableName.special"],["string-2","string.special"],["def","variableName.definition"],["tag","tagName"],["attribute","attributeName"],["type","typeName"],["builtin","variableName.standard"],["qualifier","modifier"],["error","invalid"],["header","heading"],["property","propertyName"]])defaultTable[e]=createTokenType(noTokens,t);class TokenTable{constructor(e){this.extra=e,this.table=Object.assign(Object.create(null),defaultTable);}resolve(e){return e?this.table[e]||(this.table[e]=createTokenType(this.extra,e)):0}}new TokenTable(noTokens);function warnForPart(e,t){warned.indexOf(e)>-1||(warned.push(e),console.warn(t));}function createTokenType(e,t){let i=null;for(let n of t.split(".")){let t=e[n]||tags[n];t?"function"==typeof t?i?i=t(i):warnForPart(n,`Modifier ${n} used at start of tag`):i?warnForPart(n,`Tag ${n} used as modifier`):i=t:warnForPart(n,`Unknown highlighting tag ${n}`);}if(!i)return 0;let n=t.replace(/ /g,"_"),o=NodeType.define({id:typeArray.length,name:n,props:[styleTags({[n]:i})]});return typeArray.push(o),o.id}const toggleComment=e=>{let t=getConfig(e.state);return t.line?toggleLineComment(e):!!t.block&&toggleBlockCommentByLine(e)};function command(e,t){return ({state:i,dispatch:n})=>{if(i.readOnly)return !1;let o=e(t,i);return !!o&&(n(i.update(o)),!0)}}const toggleLineComment=command(changeLineComment,0),toggleBlockComment=command(changeBlockComment,0),toggleBlockCommentByLine=command((e,t)=>changeBlockComment(e,t,selectedLineRanges(t)),0);function getConfig(e,t=e.selection.main.head){let i=e.languageDataAt("commentTokens",t);return i.length?i[0]:{}}const SearchMargin=50;function findBlockComment(e,{open:t,close:i},n,o){let r,s,a=e.sliceDoc(n-SearchMargin,n),l=e.sliceDoc(o,o+SearchMargin),h=/\s*$/.exec(a)[0].length,c=/^\s*/.exec(l)[0].length,d=a.length-h;if(a.slice(d-t.length,d)==t&&l.slice(c,c+i.length)==i)return {open:{pos:n-h,margin:h&&1},close:{pos:o+c,margin:c&&1}};o-n<=2*SearchMargin?r=s=e.sliceDoc(n,o):(r=e.sliceDoc(n,n+SearchMargin),s=e.sliceDoc(o-SearchMargin,o));let u=/^\s*/.exec(r)[0].length,f=/\s*$/.exec(s)[0].length,p=s.length-f-i.length;return r.slice(u,u+t.length)==t&&s.slice(p,p+i.length)==i?{open:{pos:n+u+t.length,margin:/\s/.test(r.charAt(u+t.length))?1:0},close:{pos:o-f-i.length,margin:/\s/.test(s.charAt(p-1))?1:0}}:null}function selectedLineRanges(e){let t=[];for(let i of e.selection.ranges){let n=e.doc.lineAt(i.from),o=i.to<=n.to?n:e.doc.lineAt(i.to),r=t.length-1;r>=0&&t[r].to>n.from?t[r].to=o.to:t.push({from:n.from,to:o.to});}return t}function changeBlockComment(e,t,i=t.selection.ranges){let n=i.map(e=>getConfig(t,e.from).block);if(!n.every(e=>e))return null;let o=i.map((e,i)=>findBlockComment(t,n[i],e.from,e.to));if(2!=e&&!o.every(e=>e))return {changes:t.changes(i.map((e,t)=>o[t]?[]:[{from:e.from,insert:n[t].open+" "},{from:e.to,insert:" "+n[t].close}]))};if(1!=e&&o.some(e=>e)){let e=[];for(let t,i=0;i<o.length;i++)if(t=o[i]){let o=n[i],{open:r,close:s}=t;e.push({from:r.pos-o.open.length,to:r.pos+r.margin},{from:s.pos-s.margin,to:s.pos+o.close.length});}return {changes:e}}return null}function changeLineComment(e,t,i=t.selection.ranges){let n=[],o=-1;for(let{from:e,to:r}of i){let i=n.length,s=1e9;for(let i=e;i<=r;){let a=t.doc.lineAt(i);if(a.from>o&&(e==r||r>a.from)){o=a.from;let e=getConfig(t,i).line;if(!e)continue;let r=/^\s*/.exec(a.text)[0].length,l=r==a.length,h=a.text.slice(r,r+e.length)==e?r:-1;r<a.text.length&&r<s&&(s=r),n.push({line:a,comment:h,token:e,indent:r,empty:l,single:!1});}i=a.to+1;}if(s<1e9)for(let e=i;e<n.length;e++)n[e].indent<n[e].line.text.length&&(n[e].indent=s);n.length==i+1&&(n[i].single=!0);}if(2!=e&&n.some(e=>e.comment<0&&(!e.empty||e.single))){let e=[];for(let{line:t,token:i,indent:o,empty:r,single:s}of n)!s&&r||e.push({from:t.from+o,insert:i+" "});let i=t.changes(e);return {changes:i,selection:t.selection.map(i,1)}}if(1!=e&&n.some(e=>e.comment>=0)){let e=[];for(let{line:t,comment:i,token:o}of n)if(i>=0){let n=t.from+i,r=n+o.length;" "==t.text[r-t.from]&&r++,e.push({from:n,to:r});}return {changes:e}}return null}const fromHistory=Annotation.define(),isolateHistory=Annotation.define(),invertedEffects=Facet.define(),historyConfig=Facet.define({combine:e=>combineConfig(e,{minDepth:100,newGroupDelay:500},{minDepth:Math.max,newGroupDelay:Math.min})});function changeEnd(e){let t=0;return e.iterChangedRanges((e,i)=>t=i),t}const historyField_=StateField.define({create:()=>HistoryState.empty,update(e,t){let i=t.state.facet(historyConfig),n=t.annotation(fromHistory);if(n){let o=t.docChanged?EditorSelection.single(changeEnd(t.changes)):void 0,r=HistEvent.fromTransaction(t,o),s=n.side,a=0==s?e.undone:e.done;return a=r?updateBranch(a,a.length,i.minDepth,r):addSelection(a,t.startState.selection),new HistoryState(0==s?n.rest:a,0==s?a:n.rest)}let o=t.annotation(isolateHistory);if("full"!=o&&"before"!=o||(e=e.isolate()),!1===t.annotation(Transaction.addToHistory))return t.changes.empty?e:e.addMapping(t.changes.desc);let r=HistEvent.fromTransaction(t),s=t.annotation(Transaction.time),a=t.annotation(Transaction.userEvent);return r?e=e.addChanges(r,s,a,i.newGroupDelay,i.minDepth):t.selection&&(e=e.addSelection(t.startState.selection,s,a,i.newGroupDelay)),"full"!=o&&"after"!=o||(e=e.isolate()),e},toJSON:e=>({done:e.done.map(e=>e.toJSON()),undone:e.undone.map(e=>e.toJSON())}),fromJSON:e=>new HistoryState(e.done.map(HistEvent.fromJSON),e.undone.map(HistEvent.fromJSON))});function history(e={}){return [historyField_,historyConfig.of(e),EditorView.domEventHandlers({beforeinput(e,t){let i="historyUndo"==e.inputType?undo:"historyRedo"==e.inputType?redo:null;return !!i&&(e.preventDefault(),i(t))}})]}function cmd(e,t){return function({state:i,dispatch:n}){if(!t&&i.readOnly)return !1;let o=i.field(historyField_,!1);if(!o)return !1;let r=o.pop(e,i,t);return !!r&&(n(r),!0)}}const undo=cmd(0,!1),redo=cmd(1,!1),undoSelection=cmd(0,!0),redoSelection=cmd(1,!0);class HistEvent{constructor(e,t,i,n,o){this.changes=e,this.effects=t,this.mapped=i,this.startSelection=n,this.selectionsAfter=o;}setSelAfter(e){return new HistEvent(this.changes,this.effects,this.mapped,this.startSelection,e)}toJSON(){var e,t,i;return {changes:null===(e=this.changes)||void 0===e?void 0:e.toJSON(),mapped:null===(t=this.mapped)||void 0===t?void 0:t.toJSON(),startSelection:null===(i=this.startSelection)||void 0===i?void 0:i.toJSON(),selectionsAfter:this.selectionsAfter.map(e=>e.toJSON())}}static fromJSON(e){return new HistEvent(e.changes&&ChangeSet.fromJSON(e.changes),[],e.mapped&&ChangeDesc.fromJSON(e.mapped),e.startSelection&&EditorSelection.fromJSON(e.startSelection),e.selectionsAfter.map(EditorSelection.fromJSON))}static fromTransaction(e,t){let i=none$1;for(let t of e.startState.facet(invertedEffects)){let n=t(e);n.length&&(i=i.concat(n));}return !i.length&&e.changes.empty?null:new HistEvent(e.changes.invert(e.startState.doc),i,void 0,t||e.startState.selection,none$1)}static selection(e){return new HistEvent(void 0,none$1,void 0,void 0,e)}}function updateBranch(e,t,i,n){let o=t+1>i+20?t-i-1:0,r=e.slice(o,t);return r.push(n),r}function isAdjacent(e,t){let i=[],n=!1;return e.iterChangedRanges((e,t)=>i.push(e,t)),t.iterChangedRanges((e,t,o,r)=>{for(let e=0;e<i.length;){let t=i[e++],s=i[e++];r>=t&&o<=s&&(n=!0);}}),n}function eqSelectionShape(e,t){return e.ranges.length==t.ranges.length&&0===e.ranges.filter((e,i)=>e.empty!=t.ranges[i].empty).length}function conc(e,t){return e.length?t.length?e.concat(t):e:t}const none$1=[],MaxSelectionsPerEvent=200;function addSelection(e,t){if(e.length){let i=e[e.length-1],n=i.selectionsAfter.slice(Math.max(0,i.selectionsAfter.length-MaxSelectionsPerEvent));return n.length&&n[n.length-1].eq(t)?e:(n.push(t),updateBranch(e,e.length-1,1e9,i.setSelAfter(n)))}return [HistEvent.selection([t])]}function popSelection(e){let t=e[e.length-1],i=e.slice();return i[e.length-1]=t.setSelAfter(t.selectionsAfter.slice(0,t.selectionsAfter.length-1)),i}function addMappingToBranch(e,t){if(!e.length)return e;let i=e.length,n=none$1;for(;i;){let o=mapEvent(e[i-1],t,n);if(o.changes&&!o.changes.empty||o.effects.length){let t=e.slice(0,i);return t[i-1]=o,t}t=o.mapped,i--,n=o.selectionsAfter;}return n.length?[HistEvent.selection(n)]:none$1}function mapEvent(e,t,i){let n=conc(e.selectionsAfter.length?e.selectionsAfter.map(e=>e.map(t)):none$1,i);if(!e.changes)return HistEvent.selection(n);let o=e.changes.map(t),r=t.mapDesc(e.changes,!0),s=e.mapped?e.mapped.composeDesc(r):r;return new HistEvent(o,StateEffect.mapEffects(e.effects,t),s,e.startSelection.map(r),n)}const joinableUserEvent=/^(input\.type|delete)($|\.)/;class HistoryState{constructor(e,t,i=0,n){this.done=e,this.undone=t,this.prevTime=i,this.prevUserEvent=n;}isolate(){return this.prevTime?new HistoryState(this.done,this.undone):this}addChanges(e,t,i,n,o){let r=this.done,s=r[r.length-1];return r=s&&s.changes&&!s.changes.empty&&e.changes&&(!i||joinableUserEvent.test(i))&&(!s.selectionsAfter.length&&t-this.prevTime<n&&isAdjacent(s.changes,e.changes)||"input.type.compose"==i)?updateBranch(r,r.length-1,o,new HistEvent(e.changes.compose(s.changes),conc(e.effects,s.effects),s.mapped,s.startSelection,none$1)):updateBranch(r,r.length,o,e),new HistoryState(r,none$1,t,i)}addSelection(e,t,i,n){let o=this.done.length?this.done[this.done.length-1].selectionsAfter:none$1;return o.length>0&&t-this.prevTime<n&&i==this.prevUserEvent&&i&&/^select($|\.)/.test(i)&&eqSelectionShape(o[o.length-1],e)?this:new HistoryState(addSelection(this.done,e),this.undone,t,i)}addMapping(e){return new HistoryState(addMappingToBranch(this.done,e),addMappingToBranch(this.undone,e),this.prevTime,this.prevUserEvent)}pop(e,t,i){let n=0==e?this.done:this.undone;if(0==n.length)return null;let o=n[n.length-1];if(i&&o.selectionsAfter.length)return t.update({selection:o.selectionsAfter[o.selectionsAfter.length-1],annotations:fromHistory.of({side:e,rest:popSelection(n)}),userEvent:0==e?"select.undo":"select.redo",scrollIntoView:!0});if(o.changes){let i=1==n.length?none$1:n.slice(0,n.length-1);return o.mapped&&(i=addMappingToBranch(i,o.mapped)),t.update({changes:o.changes,selection:o.startSelection,effects:o.effects,annotations:fromHistory.of({side:e,rest:i}),filter:!1,userEvent:0==e?"undo":"redo",scrollIntoView:!0})}return null}}HistoryState.empty=new HistoryState(none$1,none$1);const historyKeymap=[{key:"Mod-z",run:undo,preventDefault:!0},{key:"Mod-y",mac:"Mod-Shift-z",run:redo,preventDefault:!0},{linux:"Ctrl-Shift-z",run:redo,preventDefault:!0},{key:"Mod-u",run:undoSelection,preventDefault:!0},{key:"Alt-u",mac:"Mod-Shift-u",run:redoSelection,preventDefault:!0}];function updateSel(e,t){return EditorSelection.create(e.ranges.map(t),e.mainIndex)}function setSel(e,t){return e.update({selection:t,scrollIntoView:!0,userEvent:"select"})}function moveSel({state:e,dispatch:t},i){let n=updateSel(e.selection,i);return !n.eq(e.selection)&&(t(setSel(e,n)),!0)}function rangeEnd(e,t){return EditorSelection.cursor(t?e.to:e.from)}function cursorByChar(e,t){return moveSel(e,i=>i.empty?e.moveByChar(i,t):rangeEnd(i,t))}function ltrAtCursor(e){return e.textDirectionAt(e.state.selection.main.head)==Direction.LTR}const cursorCharLeft=e=>cursorByChar(e,!ltrAtCursor(e)),cursorCharRight=e=>cursorByChar(e,ltrAtCursor(e));function cursorByGroup(e,t){return moveSel(e,i=>i.empty?e.moveByGroup(i,t):rangeEnd(i,t))}const cursorGroupLeft=e=>cursorByGroup(e,!ltrAtCursor(e)),cursorGroupRight=e=>cursorByGroup(e,ltrAtCursor(e));function interestingNode(e,t,i){if(t.type.prop(i))return !0;let n=t.to-t.from;return n&&(n>2||/[^\s,.;:]/.test(e.sliceDoc(t.from,t.to)))||t.firstChild}function moveBySyntax(e,t,i){let n,o,r=syntaxTree(e).resolveInner(t.head),s=i?NodeProp.closedBy:NodeProp.openedBy;for(let n=t.head;;){let t=i?r.childAfter(n):r.childBefore(n);if(!t)break;interestingNode(e,t,s)?r=t:n=i?t.to:t.from;}return o=r.type.prop(s)&&(n=i?matchBrackets(e,r.from,1):matchBrackets(e,r.to,-1))&&n.matched?i?n.end.to:n.end.from:i?r.to:r.from,EditorSelection.cursor(o,i?-1:1)}const cursorSyntaxLeft=e=>moveSel(e,t=>moveBySyntax(e.state,t,!ltrAtCursor(e))),cursorSyntaxRight=e=>moveSel(e,t=>moveBySyntax(e.state,t,ltrAtCursor(e)));function cursorByLine(e,t){return moveSel(e,i=>{if(!i.empty)return rangeEnd(i,t);let n=e.moveVertically(i,t);return n.head!=i.head?n:e.moveToLineBoundary(i,t)})}const cursorLineUp=e=>cursorByLine(e,!1),cursorLineDown=e=>cursorByLine(e,!0);function pageHeight(e){return Math.max(e.defaultLineHeight,Math.min(e.dom.clientHeight,innerHeight)-5)}function cursorByPage(e,t){let{state:i}=e,n=updateSel(i.selection,i=>i.empty?e.moveVertically(i,t,pageHeight(e)):rangeEnd(i,t));if(n.eq(i.selection))return !1;let o,r=e.coordsAtPos(i.selection.main.head),s=e.scrollDOM.getBoundingClientRect();return r&&r.top>s.top&&r.bottom<s.bottom&&r.top-s.top<=e.scrollDOM.scrollHeight-e.scrollDOM.scrollTop-e.scrollDOM.clientHeight&&(o=EditorView.scrollIntoView(n.main.head,{y:"start",yMargin:r.top-s.top})),e.dispatch(setSel(i,n),{effects:o}),!0}const cursorPageUp=e=>cursorByPage(e,!1),cursorPageDown=e=>cursorByPage(e,!0);function moveByLineBoundary(e,t,i){let n=e.lineBlockAt(t.head),o=e.moveToLineBoundary(t,i);if(o.head==t.head&&o.head!=(i?n.to:n.from)&&(o=e.moveToLineBoundary(t,i,!1)),!i&&o.head==n.from&&n.length){let i=/^\s*/.exec(e.state.sliceDoc(n.from,Math.min(n.from+100,n.to)))[0].length;i&&t.head!=n.from+i&&(o=EditorSelection.cursor(n.from+i));}return o}const cursorLineBoundaryForward=e=>moveSel(e,t=>moveByLineBoundary(e,t,!0)),cursorLineBoundaryBackward=e=>moveSel(e,t=>moveByLineBoundary(e,t,!1)),cursorLineBoundaryLeft=e=>moveSel(e,t=>moveByLineBoundary(e,t,!ltrAtCursor(e))),cursorLineBoundaryRight=e=>moveSel(e,t=>moveByLineBoundary(e,t,ltrAtCursor(e))),cursorLineStart=e=>moveSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).from,1)),cursorLineEnd=e=>moveSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).to,-1));function toMatchingBracket(e,t,i){let n=!1,o=updateSel(e.selection,t=>{let o=matchBrackets(e,t.head,-1)||matchBrackets(e,t.head,1)||t.head>0&&matchBrackets(e,t.head-1,1)||t.head<e.doc.length&&matchBrackets(e,t.head+1,-1);if(!o||!o.end)return t;n=!0;let r=o.start.from==t.head?o.end.to:o.end.from;return i?EditorSelection.range(t.anchor,r):EditorSelection.cursor(r)});return !!n&&(t(setSel(e,o)),!0)}const cursorMatchingBracket=({state:e,dispatch:t})=>toMatchingBracket(e,t,!1);function extendSel(e,t){let i=updateSel(e.state.selection,e=>{let i=t(e);return EditorSelection.range(e.anchor,i.head,i.goalColumn)});return !i.eq(e.state.selection)&&(e.dispatch(setSel(e.state,i)),!0)}function selectByChar(e,t){return extendSel(e,i=>e.moveByChar(i,t))}const selectCharLeft=e=>selectByChar(e,!ltrAtCursor(e)),selectCharRight=e=>selectByChar(e,ltrAtCursor(e));function selectByGroup(e,t){return extendSel(e,i=>e.moveByGroup(i,t))}const selectGroupLeft=e=>selectByGroup(e,!ltrAtCursor(e)),selectGroupRight=e=>selectByGroup(e,ltrAtCursor(e)),selectSyntaxLeft=e=>extendSel(e,t=>moveBySyntax(e.state,t,!ltrAtCursor(e))),selectSyntaxRight=e=>extendSel(e,t=>moveBySyntax(e.state,t,ltrAtCursor(e)));function selectByLine(e,t){return extendSel(e,i=>e.moveVertically(i,t))}const selectLineUp=e=>selectByLine(e,!1),selectLineDown=e=>selectByLine(e,!0);function selectByPage(e,t){return extendSel(e,i=>e.moveVertically(i,t,pageHeight(e)))}const selectPageUp=e=>selectByPage(e,!1),selectPageDown=e=>selectByPage(e,!0),selectLineBoundaryForward=e=>extendSel(e,t=>moveByLineBoundary(e,t,!0)),selectLineBoundaryBackward=e=>extendSel(e,t=>moveByLineBoundary(e,t,!1)),selectLineBoundaryLeft=e=>extendSel(e,t=>moveByLineBoundary(e,t,!ltrAtCursor(e))),selectLineBoundaryRight=e=>extendSel(e,t=>moveByLineBoundary(e,t,ltrAtCursor(e))),selectLineStart=e=>extendSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).from)),selectLineEnd=e=>extendSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).to)),cursorDocStart=({state:e,dispatch:t})=>(t(setSel(e,{anchor:0})),!0),cursorDocEnd=({state:e,dispatch:t})=>(t(setSel(e,{anchor:e.doc.length})),!0),selectDocStart=({state:e,dispatch:t})=>(t(setSel(e,{anchor:e.selection.main.anchor,head:0})),!0),selectDocEnd=({state:e,dispatch:t})=>(t(setSel(e,{anchor:e.selection.main.anchor,head:e.doc.length})),!0),selectAll=({state:e,dispatch:t})=>(t(e.update({selection:{anchor:0,head:e.doc.length},userEvent:"select"})),!0),selectLine=({state:e,dispatch:t})=>{let i=selectedLineBlocks(e).map(({from:t,to:i})=>EditorSelection.range(t,Math.min(i+1,e.doc.length)));return t(e.update({selection:EditorSelection.create(i),userEvent:"select"})),!0},selectParentSyntax=({state:e,dispatch:t})=>{let i=updateSel(e.selection,t=>{var i;let n=syntaxTree(e).resolveInner(t.head,1);for(;!(n.from<t.from&&n.to>=t.to||n.to>t.to&&n.from<=t.from)&&(null===(i=n.parent)||void 0===i?void 0:i.parent);)n=n.parent;return EditorSelection.range(n.to,n.from)});return t(setSel(e,i)),!0},simplifySelection=({state:e,dispatch:t})=>{let i=e.selection,n=null;return i.ranges.length>1?n=EditorSelection.create([i.main]):i.main.empty||(n=EditorSelection.create([EditorSelection.cursor(i.main.head)])),!!n&&(t(setSel(e,n)),!0)};function deleteBy(e,t){if(e.state.readOnly)return !1;let i="delete.selection",{state:n}=e,o=n.changeByRange(n=>{let{from:o,to:r}=n;if(o==r){let n=t(o);n<o?(i="delete.backward",n=skipAtomic(e,n,!1)):n>o&&(i="delete.forward",n=skipAtomic(e,n,!0)),o=Math.min(o,n),r=Math.max(r,n);}else o=skipAtomic(e,o,!1),r=skipAtomic(e,r,!0);return o==r?{range:n}:{changes:{from:o,to:r},range:EditorSelection.cursor(o)}});return !o.changes.empty&&(e.dispatch(n.update(o,{scrollIntoView:!0,userEvent:i,effects:"delete.selection"==i?EditorView.announce.of(n.phrase("Selection deleted")):void 0})),!0)}function skipAtomic(e,t,i){if(e instanceof EditorView)for(let n of e.state.facet(EditorView.atomicRanges).map(t=>t(e)))n.between(t,t,(e,n)=>{e<t&&n>t&&(t=i?n:e);});return t}const deleteByChar=(e,t)=>deleteBy(e,i=>{let n,o,{state:r}=e,s=r.doc.lineAt(i);if(!t&&i>s.from&&i<s.from+200&&!/[^ \t]/.test(n=s.text.slice(0,i-s.from))){if("\t"==n[n.length-1])return i-1;let e=countColumn(n,r.tabSize)%getIndentUnit(r)||getIndentUnit(r);for(let t=0;t<e&&" "==n[n.length-1-t];t++)i--;o=i;}else (o=findClusterBreak(s.text,i-s.from,t,t)+s.from)==i&&s.number!=(t?r.doc.lines:1)&&(o+=t?1:-1);return o}),deleteCharBackward=e=>deleteByChar(e,!1),deleteCharForward=e=>deleteByChar(e,!0),deleteByGroup=(e,t)=>deleteBy(e,i=>{let n=i,{state:o}=e,r=o.doc.lineAt(n),s=o.charCategorizer(n);for(let e=null;;){if(n==(t?r.to:r.from)){n==i&&r.number!=(t?o.doc.lines:1)&&(n+=t?1:-1);break}let a=findClusterBreak(r.text,n-r.from,t)+r.from,l=r.text.slice(Math.min(n,a)-r.from,Math.max(n,a)-r.from),h=s(l);if(null!=e&&h!=e)break;" "==l&&n==i||(e=h),n=a;}return n}),deleteGroupBackward=e=>deleteByGroup(e,!1),deleteGroupForward=e=>deleteByGroup(e,!0),deleteToLineEnd=e=>deleteBy(e,t=>{let i=e.lineBlockAt(t).to;return t<i?i:Math.min(e.state.doc.length,t+1)}),deleteToLineStart=e=>deleteBy(e,t=>{let i=e.lineBlockAt(t).from;return t>i?i:Math.max(0,t-1)}),splitLine=({state:e,dispatch:t})=>{if(e.readOnly)return !1;let i=e.changeByRange(e=>({changes:{from:e.from,to:e.to,insert:Text.of(["",""])},range:EditorSelection.cursor(e.from)}));return t(e.update(i,{scrollIntoView:!0,userEvent:"input"})),!0},transposeChars=({state:e,dispatch:t})=>{if(e.readOnly)return !1;let i=e.changeByRange(t=>{if(!t.empty||0==t.from||t.from==e.doc.length)return {range:t};let i=t.from,n=e.doc.lineAt(i),o=i==n.from?i-1:findClusterBreak(n.text,i-n.from,!1)+n.from,r=i==n.to?i+1:findClusterBreak(n.text,i-n.from,!0)+n.from;return {changes:{from:o,to:r,insert:e.doc.slice(i,r).append(e.doc.slice(o,i))},range:EditorSelection.cursor(r)}});return !i.changes.empty&&(t(e.update(i,{scrollIntoView:!0,userEvent:"move.character"})),!0)};function selectedLineBlocks(e){let t=[],i=-1;for(let n of e.selection.ranges){let o=e.doc.lineAt(n.from),r=e.doc.lineAt(n.to);if(n.empty||n.to!=r.from||(r=e.doc.lineAt(n.to-1)),i>=o.number){let e=t[t.length-1];e.to=r.to,e.ranges.push(n);}else t.push({from:o.from,to:r.to,ranges:[n]});i=r.number+1;}return t}function moveLine(e,t,i){if(e.readOnly)return !1;let n=[],o=[];for(let t of selectedLineBlocks(e)){if(i?t.to==e.doc.length:0==t.from)continue;let r=e.doc.lineAt(i?t.to+1:t.from-1),s=r.length+1;if(i){n.push({from:t.to,to:r.to},{from:t.from,insert:r.text+e.lineBreak});for(let i of t.ranges)o.push(EditorSelection.range(Math.min(e.doc.length,i.anchor+s),Math.min(e.doc.length,i.head+s)));}else {n.push({from:r.from,to:t.from},{from:t.to,insert:e.lineBreak+r.text});for(let e of t.ranges)o.push(EditorSelection.range(e.anchor-s,e.head-s));}}return !!n.length&&(t(e.update({changes:n,scrollIntoView:!0,selection:EditorSelection.create(o,e.selection.mainIndex),userEvent:"move.line"})),!0)}const moveLineUp=({state:e,dispatch:t})=>moveLine(e,t,!1),moveLineDown=({state:e,dispatch:t})=>moveLine(e,t,!0);function copyLine(e,t,i){if(e.readOnly)return !1;let n=[];for(let t of selectedLineBlocks(e))i?n.push({from:t.from,insert:e.doc.slice(t.from,t.to)+e.lineBreak}):n.push({from:t.to,insert:e.lineBreak+e.doc.slice(t.from,t.to)});return t(e.update({changes:n,scrollIntoView:!0,userEvent:"input.copyline"})),!0}const copyLineUp=({state:e,dispatch:t})=>copyLine(e,t,!1),copyLineDown=({state:e,dispatch:t})=>copyLine(e,t,!0),deleteLine=e=>{if(e.state.readOnly)return !1;let{state:t}=e,i=t.changes(selectedLineBlocks(t).map(({from:e,to:i})=>(e>0?e--:i<t.doc.length&&i++,{from:e,to:i}))),n=updateSel(t.selection,t=>e.moveVertically(t,!0)).map(i);return e.dispatch({changes:i,selection:n,scrollIntoView:!0,userEvent:"delete.line"}),!0};function isBetweenBrackets(e,t){if(/\(\)|\[\]|\{\}/.test(e.sliceDoc(t-1,t+1)))return {from:t,to:t};let i,n=syntaxTree(e).resolveInner(t),o=n.childBefore(t),r=n.childAfter(t);return o&&r&&o.to<=t&&r.from>=t&&(i=o.type.prop(NodeProp.closedBy))&&i.indexOf(r.name)>-1&&e.doc.lineAt(o.to).from==e.doc.lineAt(r.from).from?{from:o.to,to:r.from}:null}const insertNewlineAndIndent=newlineAndIndent(!1),insertBlankLine=newlineAndIndent(!0);function newlineAndIndent(e){return ({state:t,dispatch:i})=>{if(t.readOnly)return !1;let n=t.changeByRange(i=>{let{from:n,to:o}=i,r=t.doc.lineAt(n),s=!e&&n==o&&isBetweenBrackets(t,n);e&&(n=o=(o<=r.to?r:t.doc.lineAt(o)).to);let a=new IndentContext(t,{simulateBreak:n,simulateDoubleBreak:!!s}),l=getIndentation(a,n);for(null==l&&(l=/^\s*/.exec(t.doc.lineAt(n).text)[0].length);o<r.to&&/\s/.test(r.text[o-r.from]);)o++;s?({from:n,to:o}=s):n>r.from&&n<r.from+100&&!/\S/.test(r.text.slice(0,n))&&(n=r.from);let h=["",indentString(t,l)];return s&&h.push(indentString(t,a.lineIndent(r.from,-1))),{changes:{from:n,to:o,insert:Text.of(h)},range:EditorSelection.cursor(n+1+h[1].length)}});return i(t.update(n,{scrollIntoView:!0,userEvent:"input"})),!0}}function changeBySelectedLine(e,t){let i=-1;return e.changeByRange(n=>{let o=[];for(let r=n.from;r<=n.to;){let s=e.doc.lineAt(r);s.number>i&&(n.empty||n.to>s.from)&&(t(s,o,n),i=s.number),r=s.to+1;}let r=e.changes(o);return {changes:o,range:EditorSelection.range(r.mapPos(n.anchor,1),r.mapPos(n.head,1))}})}const indentSelection=({state:e,dispatch:t})=>{if(e.readOnly)return !1;let i=Object.create(null),n=new IndentContext(e,{overrideIndentation:e=>{let t=i[e];return null==t?-1:t}}),o=changeBySelectedLine(e,(t,o,r)=>{let s=getIndentation(n,t.from);if(null==s)return;/\S/.test(t.text)||(s=0);let a=/^\s*/.exec(t.text)[0],l=indentString(e,s);(a!=l||r.from<t.from+a.length)&&(i[t.from]=s,o.push({from:t.from,to:t.from+a.length,insert:l}));});return o.changes.empty||t(e.update(o,{userEvent:"indent"})),!0},indentMore=({state:e,dispatch:t})=>!e.readOnly&&(t(e.update(changeBySelectedLine(e,(t,i)=>{i.push({from:t.from,insert:e.facet(indentUnit)});}),{userEvent:"input.indent"})),!0),indentLess=({state:e,dispatch:t})=>!e.readOnly&&(t(e.update(changeBySelectedLine(e,(t,i)=>{let n=/^\s*/.exec(t.text)[0];if(!n)return;let o=countColumn(n,e.tabSize),r=0,s=indentString(e,Math.max(0,o-getIndentUnit(e)));for(;r<n.length&&r<s.length&&n.charCodeAt(r)==s.charCodeAt(r);)r++;i.push({from:t.from+r,to:t.from+n.length,insert:s.slice(r)});}),{userEvent:"delete.dedent"})),!0),emacsStyleKeymap=[{key:"Ctrl-b",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Ctrl-f",run:cursorCharRight,shift:selectCharRight},{key:"Ctrl-p",run:cursorLineUp,shift:selectLineUp},{key:"Ctrl-n",run:cursorLineDown,shift:selectLineDown},{key:"Ctrl-a",run:cursorLineStart,shift:selectLineStart},{key:"Ctrl-e",run:cursorLineEnd,shift:selectLineEnd},{key:"Ctrl-d",run:deleteCharForward},{key:"Ctrl-h",run:deleteCharBackward},{key:"Ctrl-k",run:deleteToLineEnd},{key:"Ctrl-Alt-h",run:deleteGroupBackward},{key:"Ctrl-o",run:splitLine},{key:"Ctrl-t",run:transposeChars},{key:"Ctrl-v",run:cursorPageDown}],standardKeymap=[{key:"ArrowLeft",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Mod-ArrowLeft",mac:"Alt-ArrowLeft",run:cursorGroupLeft,shift:selectGroupLeft,preventDefault:!0},{mac:"Cmd-ArrowLeft",run:cursorLineBoundaryLeft,shift:selectLineBoundaryLeft,preventDefault:!0},{key:"ArrowRight",run:cursorCharRight,shift:selectCharRight,preventDefault:!0},{key:"Mod-ArrowRight",mac:"Alt-ArrowRight",run:cursorGroupRight,shift:selectGroupRight,preventDefault:!0},{mac:"Cmd-ArrowRight",run:cursorLineBoundaryRight,shift:selectLineBoundaryRight,preventDefault:!0},{key:"ArrowUp",run:cursorLineUp,shift:selectLineUp,preventDefault:!0},{mac:"Cmd-ArrowUp",run:cursorDocStart,shift:selectDocStart},{mac:"Ctrl-ArrowUp",run:cursorPageUp,shift:selectPageUp},{key:"ArrowDown",run:cursorLineDown,shift:selectLineDown,preventDefault:!0},{mac:"Cmd-ArrowDown",run:cursorDocEnd,shift:selectDocEnd},{mac:"Ctrl-ArrowDown",run:cursorPageDown,shift:selectPageDown},{key:"PageUp",run:cursorPageUp,shift:selectPageUp},{key:"PageDown",run:cursorPageDown,shift:selectPageDown},{key:"Home",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward,preventDefault:!0},{key:"Mod-Home",run:cursorDocStart,shift:selectDocStart},{key:"End",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward,preventDefault:!0},{key:"Mod-End",run:cursorDocEnd,shift:selectDocEnd},{key:"Enter",run:insertNewlineAndIndent},{key:"Mod-a",run:selectAll},{key:"Backspace",run:deleteCharBackward,shift:deleteCharBackward},{key:"Delete",run:deleteCharForward},{key:"Mod-Backspace",mac:"Alt-Backspace",run:deleteGroupBackward},{key:"Mod-Delete",mac:"Alt-Delete",run:deleteGroupForward},{mac:"Mod-Backspace",run:deleteToLineStart},{mac:"Mod-Delete",run:deleteToLineEnd}].concat(emacsStyleKeymap.map(e=>({mac:e.key,run:e.run,shift:e.shift}))),defaultKeymap=[{key:"Alt-ArrowLeft",mac:"Ctrl-ArrowLeft",run:cursorSyntaxLeft,shift:selectSyntaxLeft},{key:"Alt-ArrowRight",mac:"Ctrl-ArrowRight",run:cursorSyntaxRight,shift:selectSyntaxRight},{key:"Alt-ArrowUp",run:moveLineUp},{key:"Shift-Alt-ArrowUp",run:copyLineUp},{key:"Alt-ArrowDown",run:moveLineDown},{key:"Shift-Alt-ArrowDown",run:copyLineDown},{key:"Escape",run:simplifySelection},{key:"Mod-Enter",run:insertBlankLine},{key:"Alt-l",mac:"Ctrl-l",run:selectLine},{key:"Mod-i",run:selectParentSyntax,preventDefault:!0},{key:"Mod-[",run:indentLess},{key:"Mod-]",run:indentMore},{key:"Mod-Alt-\\",run:indentSelection},{key:"Shift-Mod-k",run:deleteLine},{key:"Shift-Mod-\\",run:cursorMatchingBracket},{key:"Mod-/",run:toggleComment},{key:"Alt-A",run:toggleBlockComment}].concat(standardKeymap),indentWithTab={key:"Tab",run:indentMore,shift:indentLess};class CompletionContext{constructor(e,t,i){this.state=e,this.pos=t,this.explicit=i,this.abortListeners=[];}tokenBefore(e){let t=syntaxTree(this.state).resolveInner(this.pos,-1);for(;t&&e.indexOf(t.name)<0;)t=t.parent;return t?{from:t.from,to:this.pos,text:this.state.sliceDoc(t.from,this.pos),type:t.type}:null}matchBefore(e){let t=this.state.doc.lineAt(this.pos),i=Math.max(t.from,this.pos-250),n=t.text.slice(i-t.from,this.pos-t.from),o=n.search(ensureAnchor(e,!1));return o<0?null:{from:i+o,to:this.pos,text:n.slice(o)}}get aborted(){return null==this.abortListeners}addEventListener(e,t){"abort"==e&&this.abortListeners&&this.abortListeners.push(t);}}function toSet(e){let t=Object.keys(e).join(""),i=/\w/.test(t);return i&&(t=t.replace(/\w/g,"")),`[${i?"\\w":""}${t.replace(/[^\w\s]/g,"\\$&")}]`}function prefixMatch(e){let t=Object.create(null),i=Object.create(null);for(let{label:n}of e){t[n[0]]=!0;for(let e=1;e<n.length;e++)i[n[e]]=!0;}let n=toSet(t)+toSet(i)+"*$";return [new RegExp("^"+n),new RegExp(n)]}function completeFromList(e){let t=e.map(e=>"string"==typeof e?{label:e}:e),[i,n]=t.every(e=>/^\w+$/.test(e.label))?[/\w*$/,/\w+$/]:prefixMatch(t);return e=>{let o=e.matchBefore(n);return o||e.explicit?{from:o?o.from:e.pos,options:t,validFor:i}:null}}class Option{constructor(e,t,i){this.completion=e,this.source=t,this.match=i;}}function cur(e){return e.selection.main.head}function ensureAnchor(e,t){var i;let{source:n}=e,o=t&&"^"!=n[0],r="$"!=n[n.length-1];return o||r?new RegExp(`${o?"^":""}(?:${n})${r?"$":""}`,null!==(i=e.flags)&&void 0!==i?i:e.ignoreCase?"i":""):e}const pickedCompletion=Annotation.define();function insertCompletionText(e,t,i,n){return Object.assign(Object.assign({},e.changeByRange(o=>{if(o==e.selection.main)return {changes:{from:i,to:n,insert:t},range:EditorSelection.cursor(i+t.length)};let r=n-i;return !o.empty||r&&e.sliceDoc(o.from-r,o.from)!=e.sliceDoc(i,n)?{range:o}:{changes:{from:o.from-r,to:o.from,insert:t},range:EditorSelection.cursor(o.from-r+t.length)}})),{userEvent:"input.complete"})}function applyCompletion(e,t){const i=t.completion.apply||t.completion.label;let n=t.source;"string"==typeof i?e.dispatch(Object.assign(Object.assign({},insertCompletionText(e.state,i,n.from,n.to)),{annotations:pickedCompletion.of(t.completion)})):i(e,t.completion,n.from,n.to);}const SourceCache=new WeakMap;function asSource(e){if(!Array.isArray(e))return e;let t=SourceCache.get(e);return t||SourceCache.set(e,t=completeFromList(e)),t}class FuzzyMatcher{constructor(e){this.pattern=e,this.chars=[],this.folded=[],this.any=[],this.precise=[],this.byWord=[];for(let t=0;t<e.length;){let i=codePointAt(e,t),n=codePointSize(i);this.chars.push(i);let o=e.slice(t,t+n),r=o.toUpperCase();this.folded.push(codePointAt(r==o?o.toLowerCase():r,0)),t+=n;}this.astral=e.length!=this.chars.length;}match(e){if(0==this.pattern.length)return [0];if(e.length<this.pattern.length)return null;let{chars:t,folded:i,any:n,precise:o,byWord:r}=this;if(1==t.length){let n=codePointAt(e,0);return n==t[0]?[0,0,codePointSize(n)]:n==i[0]?[-200,0,codePointSize(n)]:null}let s=e.indexOf(this.pattern);if(0==s)return [0,0,this.pattern.length];let a=t.length,l=0;if(s<0){for(let o=0,r=Math.min(e.length,200);o<r&&l<a;){let r=codePointAt(e,o);r!=t[l]&&r!=i[l]||(n[l++]=o),o+=codePointSize(r);}if(l<a)return null}let h=0,c=0,d=!1,u=0,f=-1,p=-1,O=/[a-z]/.test(e),g=!0;for(let n=0,l=Math.min(e.length,200),m=0;n<l&&c<a;){let l=codePointAt(e,n);s<0&&(h<a&&l==t[h]&&(o[h++]=n),u<a&&(l==t[u]||l==i[u]?(0==u&&(f=n),p=n+1,u++):u=0));let S,b=l<255?l>=48&&l<=57||l>=97&&l<=122?2:l>=65&&l<=90?1:0:(S=fromCodePoint(l))!=S.toLowerCase()?1:S!=S.toUpperCase()?2:0;(!n||1==b&&O||0==m&&0!=b)&&(t[c]==l||i[c]==l&&(d=!0)?r[c++]=n:r.length&&(g=!1)),m=b,n+=codePointSize(l);}return c==a&&0==r[0]&&g?this.result((d?-200:0)-100,r,e):u==a&&0==f?[-200-e.length,0,p]:s>-1?[-700-e.length,s,s+this.pattern.length]:u==a?[-900-e.length,f,p]:c==a?this.result((d?-200:0)-100-700+(g?0:-1100),r,e):2==t.length?null:this.result((n[0]?-700:0)-200-1100,n,e)}result(e,t,i){let n=[e-i.length],o=1;for(let e of t){let t=e+(this.astral?codePointSize(codePointAt(i,e)):1);o>1&&n[o-1]==e?n[o-1]=t:(n[o++]=e,n[o++]=t);}return n}}const completionConfig=Facet.define({combine:e=>combineConfig(e,{activateOnTyping:!0,selectOnOpen:!0,override:null,closeOnBlur:!0,maxRenderedOptions:100,defaultKeymap:!0,optionClass:()=>"",aboveCursor:!1,icons:!0,addToOptions:[],compareCompletions:(e,t)=>e.label.localeCompare(t.label),interactionDelay:75},{defaultKeymap:(e,t)=>e&&t,closeOnBlur:(e,t)=>e&&t,icons:(e,t)=>e&&t,optionClass:(e,t)=>i=>joinClass(e(i),t(i)),addToOptions:(e,t)=>e.concat(t)})});function joinClass(e,t){return e?t?e+" "+t:e:t}function optionContent(e){let t=e.addToOptions.slice();return e.icons&&t.push({render(e){let t=document.createElement("div");return t.classList.add("cm-completionIcon"),e.type&&t.classList.add(...e.type.split(/\s+/g).map(e=>"cm-completionIcon-"+e)),t.setAttribute("aria-hidden","true"),t},position:20}),t.push({render(e,t,i){let n=document.createElement("span");n.className="cm-completionLabel";let{label:o}=e,r=0;for(let e=1;e<i.length;){let t=i[e++],s=i[e++];t>r&&n.appendChild(document.createTextNode(o.slice(r,t)));let a=n.appendChild(document.createElement("span"));a.appendChild(document.createTextNode(o.slice(t,s))),a.className="cm-completionMatchedText",r=s;}return r<o.length&&n.appendChild(document.createTextNode(o.slice(r))),n},position:50},{render(e){if(!e.detail)return null;let t=document.createElement("span");return t.className="cm-completionDetail",t.textContent=e.detail,t},position:80}),t.sort((e,t)=>e.position-t.position).map(e=>e.render)}function rangeAroundSelected(e,t,i){if(e<=i)return {from:0,to:e};if(t<0&&(t=0),t<=e>>1){let e=Math.floor(t/i);return {from:e*i,to:(e+1)*i}}let n=Math.floor((e-t)/i);return {from:e-(n+1)*i,to:e-n*i}}class CompletionTooltip{constructor(e,t){this.view=e,this.stateField=t,this.info=null,this.placeInfo={read:()=>this.measureInfo(),write:e=>this.positionInfo(e),key:this},this.space=null;let i=e.state.field(t),{options:n,selected:o}=i.open,r=e.state.facet(completionConfig);this.optionContent=optionContent(r),this.optionClass=r.optionClass,this.range=rangeAroundSelected(n.length,o,r.maxRenderedOptions),this.dom=document.createElement("div"),this.dom.className="cm-tooltip-autocomplete",this.dom.addEventListener("mousedown",t=>{for(let i,o=t.target;o&&o!=this.dom;o=o.parentNode)if("LI"==o.nodeName&&(i=/-(\d+)$/.exec(o.id))&&+i[1]<n.length)return applyCompletion(e,n[+i[1]]),void t.preventDefault()}),this.list=this.dom.appendChild(this.createListBox(n,i.id,this.range)),this.list.addEventListener("scroll",()=>{this.info&&this.view.requestMeasure(this.placeInfo);});}mount(){this.updateSel();}update(e){var t,i,n;let o=e.state.field(this.stateField),r=e.startState.field(this.stateField);o!=r&&(this.updateSel(),(null===(t=o.open)||void 0===t?void 0:t.disabled)!=(null===(i=r.open)||void 0===i?void 0:i.disabled)&&this.dom.classList.toggle("cm-tooltip-autocomplete-disabled",!!(null===(n=o.open)||void 0===n?void 0:n.disabled)));}positioned(e){this.space=e,this.info&&this.view.requestMeasure(this.placeInfo);}updateSel(){let e=this.view.state.field(this.stateField),t=e.open;if((t.selected>-1&&t.selected<this.range.from||t.selected>=this.range.to)&&(this.range=rangeAroundSelected(t.options.length,t.selected,this.view.state.facet(completionConfig).maxRenderedOptions),this.list.remove(),this.list=this.dom.appendChild(this.createListBox(t.options,e.id,this.range)),this.list.addEventListener("scroll",()=>{this.info&&this.view.requestMeasure(this.placeInfo);})),this.updateSelectedOption(t.selected)){this.info&&(this.info.remove(),this.info=null);let{completion:i}=t.options[t.selected],{info:n}=i;if(!n)return;let o="string"==typeof n?document.createTextNode(n):n(i);if(!o)return;"then"in o?o.then(t=>{t&&this.view.state.field(this.stateField,!1)==e&&this.addInfoPane(t);}).catch(e=>logException(this.view.state,e,"completion info")):this.addInfoPane(o);}}addInfoPane(e){let t=this.info=document.createElement("div");t.className="cm-tooltip cm-completionInfo",t.appendChild(e),this.dom.appendChild(t),this.view.requestMeasure(this.placeInfo);}updateSelectedOption(e){let t=null;for(let i=this.list.firstChild,n=this.range.from;i;i=i.nextSibling,n++)n==e?i.hasAttribute("aria-selected")||(i.setAttribute("aria-selected","true"),t=i):i.hasAttribute("aria-selected")&&i.removeAttribute("aria-selected");return t&&scrollIntoView$1(this.list,t),t}measureInfo(){let e=this.dom.querySelector("[aria-selected]");if(!e||!this.info)return null;let t=this.dom.getBoundingClientRect(),i=this.info.getBoundingClientRect(),n=e.getBoundingClientRect(),o=this.space;if(!o){let e=this.dom.ownerDocument.defaultView||window;o={left:0,top:0,right:e.innerWidth,bottom:e.innerHeight};}if(n.top>Math.min(o.bottom,t.bottom)-10||n.bottom<Math.max(o.top,t.top)+10)return null;let r,s=this.view.textDirection==Direction.RTL,a=s,l=!1,h="",c="",d=t.left-o.left,u=o.right-t.right;if(a&&d<Math.min(i.width,u)?a=!1:!a&&u<Math.min(i.width,d)&&(a=!0),i.width<=(a?d:u))h=Math.max(o.top,Math.min(n.top,o.bottom-i.height))-t.top+"px",r=Math.min(400,a?d:u)+"px";else {l=!0,r=Math.min(400,(s?t.right:o.right-t.left)-30)+"px";let e=o.bottom-t.bottom;e>=i.height||e>t.top?h=n.bottom-t.top+"px":c=t.bottom-n.top+"px";}return {top:h,bottom:c,maxWidth:r,class:l?s?"left-narrow":"right-narrow":a?"left":"right"}}positionInfo(e){this.info&&(e?(this.info.style.top=e.top,this.info.style.bottom=e.bottom,this.info.style.maxWidth=e.maxWidth,this.info.className="cm-tooltip cm-completionInfo cm-completionInfo-"+e.class):this.info.style.top="-1e6px");}createListBox(e,t,i){const n=document.createElement("ul");n.id=t,n.setAttribute("role","listbox"),n.setAttribute("aria-expanded","true"),n.setAttribute("aria-label",this.view.state.phrase("Completions"));for(let o=i.from;o<i.to;o++){let{completion:i,match:r}=e[o];const s=n.appendChild(document.createElement("li"));s.id=t+"-"+o,s.setAttribute("role","option");let a=this.optionClass(i);a&&(s.className=a);for(let e of this.optionContent){let t=e(i,this.view.state,r);t&&s.appendChild(t);}}return i.from&&n.classList.add("cm-completionListIncompleteTop"),i.to<e.length&&n.classList.add("cm-completionListIncompleteBottom"),n}}function completionTooltip(e){return t=>new CompletionTooltip(t,e)}function scrollIntoView$1(e,t){let i=e.getBoundingClientRect(),n=t.getBoundingClientRect();n.top<i.top?e.scrollTop-=i.top-n.top:n.bottom>i.bottom&&(e.scrollTop+=n.bottom-i.bottom);}function score(e){return 100*(e.boost||0)+(e.apply?10:0)+(e.info?5:0)+(e.type?1:0)}function sortOptions(e,t){let i=[],n=0;for(let o of e)if(o.hasResult())if(!1===o.result.filter){let e=o.result.getMatch;for(let t of o.result.options){let r=[1e9-n++];if(e)for(let i of e(t))r.push(i);i.push(new Option(t,o,r));}}else {let e,n=new FuzzyMatcher(t.sliceDoc(o.from,o.to));for(let t of o.result.options)(e=n.match(t.label))&&(null!=t.boost&&(e[0]+=t.boost),i.push(new Option(t,o,e)));}let o=[],r=null,s=t.facet(completionConfig).compareCompletions;for(let e of i.sort((e,t)=>t.match[0]-e.match[0]||s(e.completion,t.completion)))!r||r.label!=e.completion.label||r.detail!=e.completion.detail||null!=r.type&&null!=e.completion.type&&r.type!=e.completion.type||r.apply!=e.completion.apply?o.push(e):score(e.completion)>score(r)&&(o[o.length-1]=e),r=e.completion;return o}class CompletionDialog{constructor(e,t,i,n,o,r){this.options=e,this.attrs=t,this.tooltip=i,this.timestamp=n,this.selected=o,this.disabled=r;}setSelected(e,t){return e==this.selected||e>=this.options.length?this:new CompletionDialog(this.options,makeAttrs(t,e),this.tooltip,this.timestamp,e,this.disabled)}static build(e,t,i,n,o){let r=sortOptions(e,t);if(!r.length)return n&&e.some(e=>1==e.state)?new CompletionDialog(n.options,n.attrs,n.tooltip,n.timestamp,n.selected,!0):null;let s=t.facet(completionConfig).selectOnOpen?0:-1;if(n&&n.selected!=s&&-1!=n.selected){let e=n.options[n.selected].completion;for(let t=0;t<r.length;t++)if(r[t].completion==e){s=t;break}}return new CompletionDialog(r,makeAttrs(i,s),{pos:e.reduce((e,t)=>t.hasResult()?Math.min(e,t.from):e,1e8),create:completionTooltip(completionState),above:o.aboveCursor},n?n.timestamp:Date.now(),s,!1)}map(e){return new CompletionDialog(this.options,this.attrs,Object.assign(Object.assign({},this.tooltip),{pos:e.mapPos(this.tooltip.pos)}),this.timestamp,this.selected,this.disabled)}}class CompletionState{constructor(e,t,i){this.active=e,this.id=t,this.open=i;}static start(){return new CompletionState(none$2,"cm-ac-"+Math.floor(2e6*Math.random()).toString(36),null)}update(e){let{state:t}=e,i=t.facet(completionConfig),n=(i.override||t.languageDataAt("autocomplete",cur(t)).map(asSource)).map(t=>{return (this.active.find(e=>e.source==t)||new ActiveSource(t,this.active.some(e=>0!=e.state)?1:0)).update(e,i)});n.length==this.active.length&&n.every((e,t)=>e==this.active[t])&&(n=this.active);let o=this.open;e.selection||n.some(t=>t.hasResult()&&e.changes.touchesRange(t.from,t.to))||!sameResults(n,this.active)?o=CompletionDialog.build(n,t,this.id,this.open,i):o&&o.disabled&&!n.some(e=>1==e.state)?o=null:o&&e.docChanged&&(o=o.map(e.changes)),!o&&n.every(e=>1!=e.state)&&n.some(e=>e.hasResult())&&(n=n.map(e=>e.hasResult()?new ActiveSource(e.source,0):e));for(let t of e.effects)t.is(setSelectedEffect)&&(o=o&&o.setSelected(t.value,this.id));return n==this.active&&o==this.open?this:new CompletionState(n,this.id,o)}get tooltip(){return this.open?this.open.tooltip:null}get attrs(){return this.open?this.open.attrs:baseAttrs}}function sameResults(e,t){if(e==t)return !0;for(let i=0,n=0;;){for(;i<e.length&&!e[i].hasResult;)i++;for(;n<t.length&&!t[n].hasResult;)n++;let o=i==e.length,r=n==t.length;if(o||r)return o==r;if(e[i++].result!=t[n++].result)return !1}}const baseAttrs={"aria-autocomplete":"list"};function makeAttrs(e,t){let i={"aria-autocomplete":"list","aria-haspopup":"listbox","aria-controls":e};return t>-1&&(i["aria-activedescendant"]=e+"-"+t),i}const none$2=[];function getUserEvent(e){return e.isUserEvent("input.type")?"input":e.isUserEvent("delete.backward")?"delete":null}class ActiveSource{constructor(e,t,i=-1){this.source=e,this.state=t,this.explicitPos=i;}hasResult(){return !1}update(e,t){let i=getUserEvent(e),n=this;i?n=n.handleUserEvent(e,i,t):e.docChanged?n=n.handleChange(e):e.selection&&0!=n.state&&(n=new ActiveSource(n.source,0));for(let t of e.effects)if(t.is(startCompletionEffect))n=new ActiveSource(n.source,1,t.value?cur(e.state):-1);else if(t.is(closeCompletionEffect))n=new ActiveSource(n.source,0);else if(t.is(setActiveEffect))for(let e of t.value)e.source==n.source&&(n=e);return n}handleUserEvent(e,t,i){return "delete"!=t&&i.activateOnTyping?new ActiveSource(this.source,1):this.map(e.changes)}handleChange(e){return e.changes.touchesRange(cur(e.startState))?new ActiveSource(this.source,0):this.map(e.changes)}map(e){return e.empty||this.explicitPos<0?this:new ActiveSource(this.source,this.state,e.mapPos(this.explicitPos))}}class ActiveResult extends ActiveSource{constructor(e,t,i,n,o){super(e,2,t),this.result=i,this.from=n,this.to=o;}hasResult(){return !0}handleUserEvent(e,t,i){var n;let o=e.changes.mapPos(this.from),r=e.changes.mapPos(this.to,1),s=cur(e.state);if((this.explicitPos<0?s<=o:s<this.from)||s>r||"delete"==t&&cur(e.startState)==this.from)return new ActiveSource(this.source,"input"==t&&i.activateOnTyping?1:0);let a,l=this.explicitPos<0?-1:e.changes.mapPos(this.explicitPos);return checkValid(this.result.validFor,e.state,o,r)?new ActiveResult(this.source,l,this.result,o,r):this.result.update&&(a=this.result.update(this.result,o,r,new CompletionContext(e.state,s,l>=0)))?new ActiveResult(this.source,l,a,a.from,null!==(n=a.to)&&void 0!==n?n:cur(e.state)):new ActiveSource(this.source,1,l)}handleChange(e){return e.changes.touchesRange(this.from,this.to)?new ActiveSource(this.source,0):this.map(e.changes)}map(e){return e.empty?this:new ActiveResult(this.source,this.explicitPos<0?-1:e.mapPos(this.explicitPos),this.result,e.mapPos(this.from),e.mapPos(this.to,1))}}function checkValid(e,t,i,n){if(!e)return !1;let o=t.sliceDoc(i,n);return "function"==typeof e?e(o,i,n,t):ensureAnchor(e,!0).test(o)}const startCompletionEffect=StateEffect.define(),closeCompletionEffect=StateEffect.define(),setActiveEffect=StateEffect.define({map:(e,t)=>e.map(e=>e.map(t))}),setSelectedEffect=StateEffect.define(),completionState=StateField.define({create:()=>CompletionState.start(),update:(e,t)=>e.update(t),provide:e=>[showTooltip.from(e,e=>e.tooltip),EditorView.contentAttributes.from(e,e=>e.attrs)]});function moveCompletionSelection(e,t="option"){return i=>{let n=i.state.field(completionState,!1);if(!n||!n.open||n.open.disabled||Date.now()-n.open.timestamp<i.state.facet(completionConfig).interactionDelay)return !1;let o,r=1;"page"==t&&(o=getTooltip(i,n.open.tooltip))&&(r=Math.max(2,Math.floor(o.dom.offsetHeight/o.dom.querySelector("li").offsetHeight)-1));let{length:s}=n.open.options,a=n.open.selected>-1?n.open.selected+r*(e?1:-1):e?0:s-1;return a<0?a="page"==t?0:s-1:a>=s&&(a="page"==t?s-1:0),i.dispatch({effects:setSelectedEffect.of(a)}),!0}}const acceptCompletion=e=>{let t=e.state.field(completionState,!1);return !(e.state.readOnly||!t||!t.open||t.open.selected<0||Date.now()-t.open.timestamp<e.state.facet(completionConfig).interactionDelay)&&(t.open.disabled||applyCompletion(e,t.open.options[t.open.selected]),!0)},startCompletion=e=>{return !!e.state.field(completionState,!1)&&(e.dispatch({effects:startCompletionEffect.of(!0)}),!0)},closeCompletion=e=>{let t=e.state.field(completionState,!1);return !(!t||!t.active.some(e=>0!=e.state))&&(e.dispatch({effects:closeCompletionEffect.of(null)}),!0)};class RunningQuery{constructor(e,t){this.active=e,this.context=t,this.time=Date.now(),this.updates=[],this.done=void 0;}}ViewPlugin.fromClass(class{constructor(e){this.view=e,this.debounceUpdate=-1,this.running=[],this.debounceAccept=-1,this.composing=0;for(let t of e.state.field(completionState).active)1==t.state&&this.startQuery(t);}update(e){let t=e.state.field(completionState);if(!e.selectionSet&&!e.docChanged&&e.startState.field(completionState)==t)return;let i=e.transactions.some(e=>(e.selection||e.docChanged)&&!getUserEvent(e));for(let t=0;t<this.running.length;t++){let n=this.running[t];if(i||n.updates.length+e.transactions.length>50&&Date.now()-n.time>1e3){for(let e of n.context.abortListeners)try{e();}catch(e){logException(this.view.state,e);}n.context.abortListeners=null,this.running.splice(t--,1);}else n.updates.push(...e.transactions);}if(this.debounceUpdate>-1&&clearTimeout(this.debounceUpdate),this.debounceUpdate=t.active.some(e=>1==e.state&&!this.running.some(t=>t.active.source==e.source))?setTimeout(()=>this.startUpdate(),50):-1,0!=this.composing)for(let t of e.transactions)"input"==getUserEvent(t)?this.composing=2:2==this.composing&&t.selection&&(this.composing=3);}startUpdate(){this.debounceUpdate=-1;let{state:e}=this.view,t=e.field(completionState);for(let e of t.active)1!=e.state||this.running.some(t=>t.active.source==e.source)||this.startQuery(e);}startQuery(e){let{state:t}=this.view,i=cur(t),n=new CompletionContext(t,i,e.explicitPos==i),o=new RunningQuery(e,n);this.running.push(o),Promise.resolve(e.source(n)).then(e=>{o.context.aborted||(o.done=e||null,this.scheduleAccept());},e=>{this.view.dispatch({effects:closeCompletionEffect.of(null)}),logException(this.view.state,e);});}scheduleAccept(){this.running.every(e=>void 0!==e.done)?this.accept():this.debounceAccept<0&&(this.debounceAccept=setTimeout(()=>this.accept(),50));}accept(){var e;this.debounceAccept>-1&&clearTimeout(this.debounceAccept),this.debounceAccept=-1;let t=[],i=this.view.state.facet(completionConfig);for(let n=0;n<this.running.length;n++){let o=this.running[n];if(void 0===o.done)continue;if(this.running.splice(n--,1),o.done){let n=new ActiveResult(o.active.source,o.active.explicitPos,o.done,o.done.from,null!==(e=o.done.to)&&void 0!==e?e:cur(o.updates.length?o.updates[0].startState:this.view.state));for(let e of o.updates)n=n.update(e,i);if(n.hasResult()){t.push(n);continue}}let r=this.view.state.field(completionState).active.find(e=>e.source==o.active.source);if(r&&1==r.state)if(null==o.done){let e=new ActiveSource(o.active.source,0);for(let t of o.updates)e=e.update(t,i);1!=e.state&&t.push(e);}else this.startQuery(r);}t.length&&this.view.dispatch({effects:setActiveEffect.of(t)});}},{eventHandlers:{blur(){let e=this.view.state.field(completionState,!1);e&&e.tooltip&&this.view.state.facet(completionConfig).closeOnBlur&&this.view.dispatch({effects:closeCompletionEffect.of(null)});},compositionstart(){this.composing=1;},compositionend(){3==this.composing&&setTimeout(()=>this.view.dispatch({effects:startCompletionEffect.of(!1)}),20),this.composing=0;}}});const baseTheme$3=EditorView.baseTheme({".cm-tooltip.cm-tooltip-autocomplete":{"& > ul":{fontFamily:"monospace",whiteSpace:"nowrap",overflow:"hidden auto",maxWidth_fallback:"700px",maxWidth:"min(700px, 95vw)",minWidth:"250px",maxHeight:"10em",height:"100%",listStyle:"none",margin:0,padding:0,"& > li":{overflowX:"hidden",textOverflow:"ellipsis",cursor:"pointer",padding:"1px 3px",lineHeight:1.2}}},"&light .cm-tooltip-autocomplete ul li[aria-selected]":{background:"#17c",color:"white"},"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]":{background:"#777"},"&dark .cm-tooltip-autocomplete ul li[aria-selected]":{background:"#347",color:"white"},"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]":{background:"#444"},".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after":{content:'"···"',opacity:.5,display:"block",textAlign:"center"},".cm-tooltip.cm-completionInfo":{position:"absolute",padding:"3px 9px",width:"max-content",maxWidth:"400px",boxSizing:"border-box"},".cm-completionInfo.cm-completionInfo-left":{right:"100%"},".cm-completionInfo.cm-completionInfo-right":{left:"100%"},".cm-completionInfo.cm-completionInfo-left-narrow":{right:"30px"},".cm-completionInfo.cm-completionInfo-right-narrow":{left:"30px"},"&light .cm-snippetField":{backgroundColor:"#00000022"},"&dark .cm-snippetField":{backgroundColor:"#ffffff22"},".cm-snippetFieldPosition":{verticalAlign:"text-top",width:0,height:"1.15em",display:"inline-block",margin:"0 -0.7px -.7em",borderLeft:"1.4px dotted #888"},".cm-completionMatchedText":{textDecoration:"underline"},".cm-completionDetail":{marginLeft:"0.5em",fontStyle:"italic"},".cm-completionIcon":{fontSize:"90%",width:".8em",display:"inline-block",textAlign:"center",paddingRight:".6em",opacity:"0.6",boxSizing:"content-box"},".cm-completionIcon-function, .cm-completionIcon-method":{"&:after":{content:"'ƒ'"}},".cm-completionIcon-class":{"&:after":{content:"'○'"}},".cm-completionIcon-interface":{"&:after":{content:"'◌'"}},".cm-completionIcon-variable":{"&:after":{content:"'𝑥'"}},".cm-completionIcon-constant":{"&:after":{content:"'𝐶'"}},".cm-completionIcon-type":{"&:after":{content:"'𝑡'"}},".cm-completionIcon-enum":{"&:after":{content:"'∪'"}},".cm-completionIcon-property":{"&:after":{content:"'□'"}},".cm-completionIcon-keyword":{"&:after":{content:"'🔑︎'"}},".cm-completionIcon-namespace":{"&:after":{content:"'▢'"}},".cm-completionIcon-text":{"&:after":{content:"'abc'",fontSize:"50%",verticalAlign:"middle"}}});class FieldPos{constructor(e,t,i,n){this.field=e,this.line=t,this.from=i,this.to=n;}}class FieldRange{constructor(e,t,i){this.field=e,this.from=t,this.to=i;}map(e){let t=e.mapPos(this.from,-1,MapMode.TrackDel),i=e.mapPos(this.to,1,MapMode.TrackDel);return null==t||null==i?null:new FieldRange(this.field,t,i)}}class Snippet{constructor(e,t){this.lines=e,this.fieldPositions=t;}instantiate(e,t){let i=[],n=[t],o=e.doc.lineAt(t),r=/^\s*/.exec(o.text)[0];for(let o of this.lines){if(i.length){let i=r,s=/^\t*/.exec(o)[0].length;for(let t=0;t<s;t++)i+=e.facet(indentUnit);n.push(t+i.length-s),o=i+o.slice(s);}i.push(o),t+=o.length+1;}return {text:i,ranges:this.fieldPositions.map(e=>new FieldRange(e.field,n[e.line]+e.from,n[e.line]+e.to))}}static parse(e){let t,i=[],n=[],o=[];for(let r of e.split(/\r\n?|\n/)){for(;t=/[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(r);){let e=t[1]?+t[1]:null,s=t[2]||t[3]||"",a=-1;for(let t=0;t<i.length;t++)(null!=e?i[t].seq==e:s&&i[t].name==s)&&(a=t);if(a<0){let t=0;for(;t<i.length&&(null==e||null!=i[t].seq&&i[t].seq<e);)t++;i.splice(t,0,{seq:e,name:s}),a=t;for(let e of o)e.field>=a&&e.field++;}o.push(new FieldPos(a,n.length,t.index,t.index+s.length)),r=r.slice(0,t.index)+s+r.slice(t.index+t[0].length);}for(let e;e=/\\([{}])/.exec(r);){r=r.slice(0,e.index)+e[1]+r.slice(e.index+e[0].length);for(let t of o)t.line==n.length&&t.from>e.index&&(t.from--,t.to--);}n.push(r);}return new Snippet(n,o)}}let fieldMarker=Decoration.widget({widget:new class extends WidgetType{toDOM(){let e=document.createElement("span");return e.className="cm-snippetFieldPosition",e}ignoreEvent(){return !1}}}),fieldRange=Decoration.mark({class:"cm-snippetField"});class ActiveSnippet{constructor(e,t){this.ranges=e,this.active=t,this.deco=Decoration.set(e.map(e=>(e.from==e.to?fieldMarker:fieldRange).range(e.from,e.to)));}map(e){let t=[];for(let i of this.ranges){let n=i.map(e);if(!n)return null;t.push(n);}return new ActiveSnippet(t,this.active)}selectionInsideField(e){return e.ranges.every(e=>this.ranges.some(t=>t.field==this.active&&t.from<=e.from&&t.to>=e.to))}}const setActive=StateEffect.define({map:(e,t)=>e&&e.map(t)}),moveToField=StateEffect.define(),snippetState=StateField.define({create:()=>null,update(e,t){for(let i of t.effects){if(i.is(setActive))return i.value;if(i.is(moveToField)&&e)return new ActiveSnippet(e.ranges,i.value)}return e&&t.docChanged&&(e=e.map(t.changes)),e&&t.selection&&!e.selectionInsideField(t.selection)&&(e=null),e},provide:e=>EditorView.decorations.from(e,e=>e?e.deco:Decoration.none)});function fieldSelection(e,t){return EditorSelection.create(e.filter(e=>e.field==t).map(e=>EditorSelection.range(e.from,e.to)))}function snippet(e){let t=Snippet.parse(e);return (e,i,n,o)=>{let{text:r,ranges:s}=t.instantiate(e.state,n),a={changes:{from:n,to:o,insert:Text.of(r)},scrollIntoView:!0};if(s.length&&(a.selection=fieldSelection(s,0)),s.length>1){let t=new ActiveSnippet(s,0),i=a.effects=[setActive.of(t)];void 0===e.state.field(snippetState,!1)&&i.push(StateEffect.appendConfig.of([snippetState,addSnippetKeymap,snippetPointerHandler,baseTheme$3]));}e.dispatch(e.state.update(a));}}function moveField(e){return ({state:t,dispatch:i})=>{let n=t.field(snippetState,!1);if(!n||e<0&&0==n.active)return !1;let o=n.active+e,r=e>0&&!n.ranges.some(t=>t.field==o+e);return i(t.update({selection:fieldSelection(n.ranges,o),effects:setActive.of(r?null:new ActiveSnippet(n.ranges,o))})),!0}}const clearSnippet=({state:e,dispatch:t})=>{return !!e.field(snippetState,!1)&&(t(e.update({effects:setActive.of(null)})),!0)},nextSnippetField=moveField(1),prevSnippetField=moveField(-1),defaultSnippetKeymap=[{key:"Tab",run:nextSnippetField,shift:prevSnippetField},{key:"Escape",run:clearSnippet}],snippetKeymap=Facet.define({combine:e=>e.length?e[0]:defaultSnippetKeymap}),addSnippetKeymap=Prec.highest(keymap.compute([snippetKeymap],e=>e.facet(snippetKeymap)));function snippetCompletion(e,t){return Object.assign(Object.assign({},t),{apply:snippet(e)})}const snippetPointerHandler=EditorView.domEventHandlers({mousedown(e,t){let i,n=t.state.field(snippetState,!1);if(!n||null==(i=t.posAtCoords({x:e.clientX,y:e.clientY})))return !1;let o=n.ranges.find(e=>e.from<=i&&e.to>=i);return !(!o||o.field==n.active)&&(t.dispatch({selection:fieldSelection(n.ranges,o.field),effects:setActive.of(n.ranges.some(e=>e.field>o.field)?new ActiveSnippet(n.ranges,o.field):null)}),!0)}}),defaults$1={brackets:["(","[","{","'",'"'],before:")]}:;>",stringPrefixes:[]},closeBracketEffect=StateEffect.define({map(e,t){let i=t.mapPos(e,-1,MapMode.TrackAfter);return null==i?void 0:i}}),skipBracketEffect=StateEffect.define({map:(e,t)=>t.mapPos(e)}),closedBracket=new class extends RangeValue{};closedBracket.startSide=1,closedBracket.endSide=-1;const bracketState=StateField.define({create:()=>RangeSet.empty,update(e,t){if(t.selection){let i=t.state.doc.lineAt(t.selection.main.head).from,n=t.startState.doc.lineAt(t.startState.selection.main.head).from;i!=t.changes.mapPos(n,-1)&&(e=RangeSet.empty);}e=e.map(t.changes);for(let i of t.effects)i.is(closeBracketEffect)?e=e.update({add:[closedBracket.range(i.value,i.value+1)]}):i.is(skipBracketEffect)&&(e=e.update({filter:e=>e!=i.value}));return e}});function closeBrackets(){return [inputHandler$1,bracketState]}const definedClosing="()[]{}<>";function closing(e){for(let t=0;t<definedClosing.length;t+=2)if(definedClosing.charCodeAt(t)==e)return definedClosing.charAt(t+1);return fromCodePoint(e<128?e:e+1)}function config(e,t){return e.languageDataAt("closeBrackets",t)[0]||defaults$1}const android="object"==typeof navigator&&/Android\b/.test(navigator.userAgent),inputHandler$1=EditorView.inputHandler.of((e,t,i,n)=>{if((android?e.composing:e.compositionStarted)||e.state.readOnly)return !1;let o=e.state.selection.main;if(n.length>2||2==n.length&&1==codePointSize(codePointAt(n,0))||t!=o.from||i!=o.to)return !1;let r=insertBracket(e.state,n);return !!r&&(e.dispatch(r),!0)}),deleteBracketPair=({state:e,dispatch:t})=>{if(e.readOnly)return !1;let i=config(e,e.selection.main.head).brackets||defaults$1.brackets,n=null,o=e.changeByRange(t=>{if(t.empty){let n=prevChar(e.doc,t.head);for(let o of i)if(o==n&&nextChar(e.doc,t.head)==closing(codePointAt(o,0)))return {changes:{from:t.head-o.length,to:t.head+o.length},range:EditorSelection.cursor(t.head-o.length)}}return {range:n=t}});return n||t(e.update(o,{scrollIntoView:!0,userEvent:"delete.backward"})),!n},closeBracketsKeymap=[{key:"Backspace",run:deleteBracketPair}];function insertBracket(e,t){let i=config(e,e.selection.main.head),n=i.brackets||defaults$1.brackets;for(let o of n){let r=closing(codePointAt(o,0));if(t==o)return r==o?handleSame(e,o,n.indexOf(o+o+o)>-1,i):handleOpen(e,o,r,i.before||defaults$1.before);if(t==r&&closedBracketAt(e,e.selection.main.from))return handleClose(e,o,r)}return null}function closedBracketAt(e,t){let i=!1;return e.field(bracketState).between(0,e.doc.length,e=>{e==t&&(i=!0);}),i}function nextChar(e,t){let i=e.sliceString(t,t+2);return i.slice(0,codePointSize(codePointAt(i,0)))}function prevChar(e,t){let i=e.sliceString(t-2,t);return codePointSize(codePointAt(i,0))==i.length?i:i.slice(1)}function handleOpen(e,t,i,n){let o=null,r=e.changeByRange(r=>{if(!r.empty)return {changes:[{insert:t,from:r.from},{insert:i,from:r.to}],effects:closeBracketEffect.of(r.to+t.length),range:EditorSelection.range(r.anchor+t.length,r.head+t.length)};let s=nextChar(e.doc,r.head);return !s||/\s/.test(s)||n.indexOf(s)>-1?{changes:{insert:t+i,from:r.head},effects:closeBracketEffect.of(r.head+t.length),range:EditorSelection.cursor(r.head+t.length)}:{range:o=r}});return o?null:e.update(r,{scrollIntoView:!0,userEvent:"input.type"})}function handleClose(e,t,i){let n=null,o=e.selection.ranges.map(t=>t.empty&&nextChar(e.doc,t.head)==i?EditorSelection.cursor(t.head+i.length):n=t);return n?null:e.update({selection:EditorSelection.create(o,e.selection.mainIndex),scrollIntoView:!0,effects:e.selection.ranges.map(({from:e})=>skipBracketEffect.of(e))})}function handleSame(e,t,i,n){let o=n.stringPrefixes||defaults$1.stringPrefixes,r=null,s=e.changeByRange(n=>{if(!n.empty)return {changes:[{insert:t,from:n.from},{insert:t,from:n.to}],effects:closeBracketEffect.of(n.to+t.length),range:EditorSelection.range(n.anchor+t.length,n.head+t.length)};let s,a=n.head,l=nextChar(e.doc,a);if(l==t){if(nodeStart(e,a))return {changes:{insert:t+t,from:a},effects:closeBracketEffect.of(a+t.length),range:EditorSelection.cursor(a+t.length)};if(closedBracketAt(e,a)){let n=i&&e.sliceDoc(a,a+3*t.length)==t+t+t;return {range:EditorSelection.cursor(a+t.length*(n?3:1)),effects:skipBracketEffect.of(a)}}}else {if(i&&e.sliceDoc(a-2*t.length,a)==t+t&&(s=canStartStringAt(e,a-2*t.length,o))>-1&&nodeStart(e,s))return {changes:{insert:t+t+t+t,from:a},effects:closeBracketEffect.of(a+t.length),range:EditorSelection.cursor(a+t.length)};if(e.charCategorizer(a)(l)!=CharCategory.Word&&canStartStringAt(e,a,o)>-1&&!probablyInString(e,a,t,o))return {changes:{insert:t+t,from:a},effects:closeBracketEffect.of(a+t.length),range:EditorSelection.cursor(a+t.length)}}return {range:r=n}});return r?null:e.update(s,{scrollIntoView:!0,userEvent:"input.type"})}function nodeStart(e,t){let i=syntaxTree(e).resolveInner(t+1);return i.parent&&i.from==t}function probablyInString(e,t,i,n){let o=syntaxTree(e).resolveInner(t,-1),r=n.reduce((e,t)=>Math.max(e,t.length),0);for(let s=0;s<5;s++){let s=e.sliceDoc(o.from,Math.min(o.to,o.from+i.length+r)),a=s.indexOf(i);if(!a||a>-1&&n.indexOf(s.slice(0,a))>-1){let t=o.firstChild;for(;t&&t.from==o.from&&t.to-t.from>i.length+a;){if(e.sliceDoc(t.to-i.length,t.to)==i)return !1;t=t.firstChild;}return !0}let l=o.to==t&&o.parent;if(!l)break;o=l;}return !1}function canStartStringAt(e,t,i){let n=e.charCategorizer(t);if(n(e.sliceDoc(t-1,t))!=CharCategory.Word)return t;for(let o of i){let i=t-o.length;if(e.sliceDoc(i,t)==o&&n(e.sliceDoc(i-1,i))!=CharCategory.Word)return i}return -1}const completionKeymap=[{key:"Ctrl-Space",run:startCompletion},{key:"Escape",run:closeCompletion},{key:"ArrowDown",run:moveCompletionSelection(!0)},{key:"ArrowUp",run:moveCompletionSelection(!1)},{key:"PageDown",run:moveCompletionSelection(!0,"page")},{key:"PageUp",run:moveCompletionSelection(!1,"page")},{key:"Enter",run:acceptCompletion}];Prec.highest(keymap.computeN([completionConfig],e=>e.facet(completionConfig).defaultKeymap?[completionKeymap]:[]));function crelt(){var e=arguments[0];"string"==typeof e&&(e=document.createElement(e));var t=1,i=arguments[1];if(i&&"object"==typeof i&&null==i.nodeType&&!Array.isArray(i)){for(var n in i)if(Object.prototype.hasOwnProperty.call(i,n)){var o=i[n];"string"==typeof o?e.setAttribute(n,o):null!=o&&(e[n]=o);}t++;}for(;t<arguments.length;t++)add(e,arguments[t]);return e}function add(e,t){if("string"==typeof t)e.appendChild(document.createTextNode(t));else if(null==t);else if(null!=t.nodeType)e.appendChild(t);else {if(!Array.isArray(t))throw new RangeError("Unsupported child node: "+t);for(var i=0;i<t.length;i++)add(e,t[i]);}}class SelectedDiagnostic{constructor(e,t,i){this.from=e,this.to=t,this.diagnostic=i;}}class LintState{constructor(e,t,i){this.diagnostics=e,this.panel=t,this.selected=i;}static init(e,t,i){let n=e,o=i.facet(lintConfig).markerFilter;o&&(n=o(n));let r=Decoration.set(n.map(e=>e.from==e.to||e.from==e.to-1&&i.doc.lineAt(e.from).to==e.from?Decoration.widget({widget:new DiagnosticWidget(e),diagnostic:e}).range(e.from):Decoration.mark({attributes:{class:"cm-lintRange cm-lintRange-"+e.severity},diagnostic:e}).range(e.from,e.to)),!0);return new LintState(r,t,findDiagnostic(r))}}function findDiagnostic(e,t=null,i=0){let n=null;return e.between(i,1e9,(e,i,{spec:o})=>{if(!t||o.diagnostic==t)return n=new SelectedDiagnostic(e,i,o.diagnostic),!1}),n}function hideTooltip(e,t){return !(!e.effects.some(e=>e.is(setDiagnosticsEffect))&&!e.changes.touchesRange(t.pos))}function maybeEnableLint(e,t){return e.field(lintState,!1)?t:t.concat(StateEffect.appendConfig.of([lintState,EditorView.decorations.compute([lintState],e=>{let{selected:t,panel:i}=e.field(lintState);return t&&i&&t.from!=t.to?Decoration.set([activeMark.range(t.from,t.to)]):Decoration.none}),hoverTooltip(lintTooltip,{hideOn:hideTooltip}),baseTheme$4]))}function setDiagnostics(e,t){return {effects:maybeEnableLint(e,[setDiagnosticsEffect.of(t)])}}const setDiagnosticsEffect=StateEffect.define(),togglePanel=StateEffect.define(),movePanelSelection=StateEffect.define(),lintState=StateField.define({create:()=>new LintState(Decoration.none,null,null),update(e,t){if(t.docChanged){let i=e.diagnostics.map(t.changes),n=null;if(e.selected){let o=t.changes.mapPos(e.selected.from,1);n=findDiagnostic(i,e.selected.diagnostic,o)||findDiagnostic(i,null,o);}e=new LintState(i,e.panel,n);}for(let i of t.effects)i.is(setDiagnosticsEffect)?e=LintState.init(i.value,e.panel,t.state):i.is(togglePanel)?e=new LintState(e.diagnostics,i.value?LintPanel.open:null,e.selected):i.is(movePanelSelection)&&(e=new LintState(e.diagnostics,e.panel,i.value));return e},provide:e=>[showPanel.from(e,e=>e.panel),EditorView.decorations.from(e,e=>e.diagnostics)]}),activeMark=Decoration.mark({class:"cm-lintRange cm-lintRange-active"});function lintTooltip(e,t,i){let{diagnostics:n}=e.state.field(lintState),o=[],r=2e8,s=0;n.between(t-(i<0?1:0),t+(i>0?1:0),(e,n,{spec:a})=>{t>=e&&t<=n&&(e==n||(t>e||i>0)&&(t<n||i<0))&&(o.push(a.diagnostic),r=Math.min(e,r),s=Math.max(n,s));});let a=e.state.facet(lintConfig).tooltipFilter;return a&&(o=a(o)),o.length?{pos:r,end:s,above:e.state.doc.lineAt(r).to<s,create:()=>({dom:diagnosticsTooltip(e,o)})}:null}function diagnosticsTooltip(e,t){return crelt("ul",{class:"cm-tooltip-lint"},t.map(t=>renderDiagnostic(e,t,!1)))}const closeLintPanel=e=>{let t=e.state.field(lintState,!1);return !(!t||!t.panel)&&(e.dispatch({effects:togglePanel.of(!1)}),!0)},lintPlugin=ViewPlugin.fromClass(class{constructor(e){this.view=e,this.timeout=-1,this.set=!0;let{delay:t}=e.state.facet(lintConfig);this.lintTime=Date.now()+t,this.run=this.run.bind(this),this.timeout=setTimeout(this.run,t);}run(){let e=Date.now();if(e<this.lintTime-10)setTimeout(this.run,this.lintTime-e);else {this.set=!1;let{state:e}=this.view,{sources:t}=e.facet(lintConfig);Promise.all(t.map(e=>Promise.resolve(e(this.view)))).then(t=>{let i=t.reduce((e,t)=>e.concat(t));this.view.state.doc==e.doc&&this.view.dispatch(setDiagnostics(this.view.state,i));},e=>{logException(this.view.state,e);});}}update(e){let t=e.state.facet(lintConfig);(e.docChanged||t!=e.startState.facet(lintConfig))&&(this.lintTime=Date.now()+t.delay,this.set||(this.set=!0,this.timeout=setTimeout(this.run,t.delay)));}force(){this.set&&(this.lintTime=Date.now(),this.run());}destroy(){clearTimeout(this.timeout);}}),lintConfig=Facet.define({combine:e=>Object.assign({sources:e.map(e=>e.source)},combineConfig(e.map(e=>e.config),{delay:750,markerFilter:null,tooltipFilter:null})),enables:lintPlugin});function linter(e,t={}){return lintConfig.of({source:e,config:t})}function assignKeys(e){let t=[];if(e)e:for(let{name:i}of e){for(let e=0;e<i.length;e++){let n=i[e];if(/[a-zA-Z]/.test(n)&&!t.some(e=>e.toLowerCase()==n.toLowerCase())){t.push(n);continue e}}t.push("");}return t}function renderDiagnostic(e,t,i){var n;let o=i?assignKeys(t.actions):[];return crelt("li",{class:"cm-diagnostic cm-diagnostic-"+t.severity},crelt("span",{class:"cm-diagnosticText"},t.renderMessage?t.renderMessage():t.message),null===(n=t.actions)||void 0===n?void 0:n.map((i,n)=>{let r=n=>{n.preventDefault();let o=findDiagnostic(e.state.field(lintState).diagnostics,t);o&&i.apply(e,o.from,o.to);},{name:s}=i,a=o[n]?s.indexOf(o[n]):-1,l=a<0?s:[s.slice(0,a),crelt("u",s.slice(a,a+1)),s.slice(a+1)];return crelt("button",{type:"button",class:"cm-diagnosticAction",onclick:r,onmousedown:r,"aria-label":` Action: ${s}${a<0?"":` (access key "${o[n]})"`}.`},l)}),t.source&&crelt("div",{class:"cm-diagnosticSource"},t.source))}class DiagnosticWidget extends WidgetType{constructor(e){super(),this.diagnostic=e;}eq(e){return e.diagnostic==this.diagnostic}toDOM(){return crelt("span",{class:"cm-lintPoint cm-lintPoint-"+this.diagnostic.severity})}}class PanelItem{constructor(e,t){this.diagnostic=t,this.id="item_"+Math.floor(4294967295*Math.random()).toString(16),this.dom=renderDiagnostic(e,t,!0),this.dom.id=this.id,this.dom.setAttribute("role","option");}}class LintPanel{constructor(e){this.view=e,this.items=[];this.list=crelt("ul",{tabIndex:0,role:"listbox","aria-label":this.view.state.phrase("Diagnostics"),onkeydown:t=>{if(27==t.keyCode)closeLintPanel(this.view),this.view.focus();else if(38==t.keyCode||33==t.keyCode)this.moveSelection((this.selectedIndex-1+this.items.length)%this.items.length);else if(40==t.keyCode||34==t.keyCode)this.moveSelection((this.selectedIndex+1)%this.items.length);else if(36==t.keyCode)this.moveSelection(0);else if(35==t.keyCode)this.moveSelection(this.items.length-1);else if(13==t.keyCode)this.view.focus();else {if(!(t.keyCode>=65&&t.keyCode<=90&&this.selectedIndex>=0))return;{let{diagnostic:i}=this.items[this.selectedIndex],n=assignKeys(i.actions);for(let o=0;o<n.length;o++)if(n[o].toUpperCase().charCodeAt(0)==t.keyCode){let t=findDiagnostic(this.view.state.field(lintState).diagnostics,i);t&&i.actions[o].apply(e,t.from,t.to);}}}t.preventDefault();},onclick:e=>{for(let t=0;t<this.items.length;t++)this.items[t].dom.contains(e.target)&&this.moveSelection(t);}}),this.dom=crelt("div",{class:"cm-panel-lint"},this.list,crelt("button",{type:"button",name:"close","aria-label":this.view.state.phrase("close"),onclick:()=>closeLintPanel(this.view)},"×")),this.update();}get selectedIndex(){let e=this.view.state.field(lintState).selected;if(!e)return -1;for(let t=0;t<this.items.length;t++)if(this.items[t].diagnostic==e.diagnostic)return t;return -1}update(){let{diagnostics:e,selected:t}=this.view.state.field(lintState),i=0,n=!1,o=null;for(e.between(0,this.view.state.doc.length,(e,r,{spec:s})=>{let a,l=-1;for(let e=i;e<this.items.length;e++)if(this.items[e].diagnostic==s.diagnostic){l=e;break}l<0?(a=new PanelItem(this.view,s.diagnostic),this.items.splice(i,0,a),n=!0):(a=this.items[l],l>i&&(this.items.splice(i,l-i),n=!0)),t&&a.diagnostic==t.diagnostic?a.dom.hasAttribute("aria-selected")||(a.dom.setAttribute("aria-selected","true"),o=a):a.dom.hasAttribute("aria-selected")&&a.dom.removeAttribute("aria-selected"),i++;});i<this.items.length&&!(1==this.items.length&&this.items[0].diagnostic.from<0);)n=!0,this.items.pop();0==this.items.length&&(this.items.push(new PanelItem(this.view,{from:-1,to:-1,severity:"info",message:this.view.state.phrase("No diagnostics")})),n=!0),o?(this.list.setAttribute("aria-activedescendant",o.id),this.view.requestMeasure({key:this,read:()=>({sel:o.dom.getBoundingClientRect(),panel:this.list.getBoundingClientRect()}),write:({sel:e,panel:t})=>{e.top<t.top?this.list.scrollTop-=t.top-e.top:e.bottom>t.bottom&&(this.list.scrollTop+=e.bottom-t.bottom);}})):this.selectedIndex<0&&this.list.removeAttribute("aria-activedescendant"),n&&this.sync();}sync(){let e=this.list.firstChild;function t(){let t=e;e=t.nextSibling,t.remove();}for(let i of this.items)if(i.dom.parentNode==this.list){for(;e!=i.dom;)t();e=i.dom.nextSibling;}else this.list.insertBefore(i.dom,e);for(;e;)t();}moveSelection(e){if(this.selectedIndex<0)return;let t=findDiagnostic(this.view.state.field(lintState).diagnostics,this.items[e].diagnostic);t&&this.view.dispatch({selection:{anchor:t.from,head:t.to},scrollIntoView:!0,effects:movePanelSelection.of(t)});}static open(e){return new LintPanel(e)}}function svg(e,t='viewBox="0 0 40 40"'){return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(e)}</svg>')`}function underline(e){return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${e}" fill="none" stroke-width=".7"/>`,'width="6" height="3"')}const baseTheme$4=EditorView.baseTheme({".cm-diagnostic":{padding:"3px 6px 3px 8px",marginLeft:"-1px",display:"block",whiteSpace:"pre-wrap"},".cm-diagnostic-error":{borderLeft:"5px solid #d11"},".cm-diagnostic-warning":{borderLeft:"5px solid orange"},".cm-diagnostic-info":{borderLeft:"5px solid #999"},".cm-diagnosticAction":{font:"inherit",border:"none",padding:"2px 4px",backgroundColor:"#444",color:"white",borderRadius:"3px",marginLeft:"8px"},".cm-diagnosticSource":{fontSize:"70%",opacity:.7},".cm-lintRange":{backgroundPosition:"left bottom",backgroundRepeat:"repeat-x",paddingBottom:"0.7px"},".cm-lintRange-error":{backgroundImage:underline("#d11")},".cm-lintRange-warning":{backgroundImage:underline("orange")},".cm-lintRange-info":{backgroundImage:underline("#999")},".cm-lintRange-active":{backgroundColor:"#ffdd9980"},".cm-tooltip-lint":{padding:0,margin:0},".cm-lintPoint":{position:"relative","&:after":{content:'""',position:"absolute",bottom:0,left:"-2px",borderLeft:"3px solid transparent",borderRight:"3px solid transparent",borderBottom:"4px solid #d11"}},".cm-lintPoint-warning":{"&:after":{borderBottomColor:"orange"}},".cm-lintPoint-info":{"&:after":{borderBottomColor:"#999"}},".cm-panel.cm-panel-lint":{position:"relative","& ul":{maxHeight:"100px",overflowY:"auto","& [aria-selected]":{backgroundColor:"#ddd","& u":{textDecoration:"underline"}},"&:focus [aria-selected]":{background_fallback:"#bdf",backgroundColor:"Highlight",color_fallback:"white",color:"HighlightText"},"& u":{textDecoration:"none"},padding:0,margin:0},"& [name=close]":{position:"absolute",top:"0",right:"2px",background:"inherit",border:"none",font:"inherit",padding:0,margin:0}}});class LintGutterMarker extends GutterMarker{constructor(e){super(),this.diagnostics=e,this.severity=e.reduce((e,t)=>{let i=t.severity;return "error"==i||"warning"==i&&"info"==e?i:e},"info");}toDOM(e){let t=document.createElement("div");t.className="cm-lint-marker cm-lint-marker-"+this.severity;let i=this.diagnostics,n=e.state.facet(lintGutterConfig).tooltipFilter;return n&&(i=n(i)),i.length&&(t.onmouseover=(()=>gutterMarkerMouseOver(e,t,i))),t}}function trackHoverOn(e,t){let i=n=>{let o=t.getBoundingClientRect();if(!(n.clientX>o.left-10&&n.clientX<o.right+10&&n.clientY>o.top-10&&n.clientY<o.bottom+10)){for(let e=n.target;e;e=e.parentNode)if(1==e.nodeType&&e.classList.contains("cm-tooltip-lint"))return;window.removeEventListener("mousemove",i),e.state.field(lintGutterTooltip)&&e.dispatch({effects:setLintGutterTooltip.of(null)});}};window.addEventListener("mousemove",i);}function gutterMarkerMouseOver(e,t,i){function n(){let n=e.elementAtHeight(t.getBoundingClientRect().top+5-e.documentTop);e.coordsAtPos(n.from)&&e.dispatch({effects:setLintGutterTooltip.of({pos:n.from,above:!1,create:()=>({dom:diagnosticsTooltip(e,i),getCoords:()=>t.getBoundingClientRect()})})}),t.onmouseout=t.onmousemove=null,trackHoverOn(e,t);}let{hoverTime:o}=e.state.facet(lintGutterConfig),r=setTimeout(n,o);t.onmouseout=(()=>{clearTimeout(r),t.onmouseout=t.onmousemove=null;}),t.onmousemove=(()=>{clearTimeout(r),r=setTimeout(n,o);});}function markersForDiagnostics(e,t){let i=Object.create(null);for(let n of t){let t=e.lineAt(n.from);(i[t.from]||(i[t.from]=[])).push(n);}let n=[];for(let e in i)n.push(new LintGutterMarker(i[e]).range(+e));return RangeSet.of(n,!0)}const lintGutterExtension=gutter({class:"cm-gutter-lint",markers:e=>e.state.field(lintGutterMarkers)}),lintGutterMarkers=StateField.define({create:()=>RangeSet.empty,update(e,t){e=e.map(t.changes);let i=t.state.facet(lintGutterConfig).markerFilter;for(let n of t.effects)if(n.is(setDiagnosticsEffect)){let o=n.value;i&&(o=i(o||[])),e=markersForDiagnostics(t.state.doc,o.slice(0));}return e}}),setLintGutterTooltip=StateEffect.define(),lintGutterTooltip=StateField.define({create:()=>null,update:(e,t)=>(e&&t.docChanged&&(e=hideTooltip(t,e)?null:Object.assign(Object.assign({},e),{pos:t.changes.mapPos(e.pos)})),t.effects.reduce((e,t)=>t.is(setLintGutterTooltip)?t.value:e,e)),provide:e=>showTooltip.from(e)}),lintGutterTheme=EditorView.baseTheme({".cm-gutter-lint":{width:"1.4em","& .cm-gutterElement":{padding:".2em"}},".cm-lint-marker":{width:"1em",height:"1em"},".cm-lint-marker-info":{content:svg('<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>')},".cm-lint-marker-warning":{content:svg('<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>')},".cm-lint-marker-error":{content:svg('<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>')}}),lintGutterConfig=Facet.define({combine:e=>combineConfig(e,{hoverTime:300,markerFilter:null,tooltipFilter:null})});function lintGutter(e={}){return [lintGutterConfig.of(e),lintGutterMarkers,lintGutterExtension,lintGutterTheme,lintGutterTooltip]}const green="#a6e22c",red="#f92472",cyan="#67d8ef",invalid="#ff0000",ivory="#f8f8f2",stone="#75715e",yellow="#e7db75",whiskey="#d19a66",violet="#ae81ff",cursor="#FFFFFF",oneDarkTheme=EditorView.theme({"&":{color:ivory,backgroundColor:"#282923",fontSize:"15px",lineHeight:"16px",fontFamily:"Consolas, Menlo, Courier, monospace"},"& ::-webkit-scrollbar":{width:"15px",height:"15px"},"& ::-webkit-scrollbar-track":{background:"none"},"& ::-webkit-scrollbar-thumb":{backgroundColor:"#555652",width:"7px",border:"4px solid #282923"},"& ::-webkit-scrollbar-corner":{backgroundColor:"rgba(0,0,0,0)"},".cm-content":{caretColor:cursor},"&.cm-editor":{height:"100%",width:"100%",fontSize:"15px",fontFamily:"Consolas, Menlo, Courier, monospace"},".cm-scroller":{lineHeight:"19px"},".cm-cursor, .cm-dropCursor":{borderLeftColor:cursor},"&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection":{backgroundColor:"#3b3b32"},".cm-panels":{backgroundColor:"#21252b",color:ivory},".cm-panels.cm-panels-top":{borderBottom:"2px solid black"},".cm-panels.cm-panels-bottom":{borderTop:"2px solid black"},".cm-searchMatch":{backgroundColor:"#72a1ff59"},".cm-searchMatch.cm-searchMatch-selected":{backgroundColor:"#6199ff2f"},".cm-activeLine":{backgroundColor:"#6699ff0b"},".cm-selectionMatch":{backgroundColor:"#aafe661a"},"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket":{backgroundColor:"#bad0f847"},".cm-gutters":{backgroundColor:"#282923",color:"#90918b",border:"none"},".cm-activeLineGutter":{color:"#dadad3",backgroundColor:"#3e3d32"},".cm-foldPlaceholder":{backgroundColor:"transparent",border:"none",color:"#ddd"},".cm-tooltip":{border:"none",backgroundColor:"#353a42"},".cm-tooltip .cm-tooltip-arrow:before":{borderTopColor:"transparent",borderBottomColor:"transparent"},".cm-tooltip .cm-tooltip-arrow:after":{borderTopColor:"#353a42",borderBottomColor:"#353a42"},".cm-tooltip-autocomplete":{"& > ul > li[aria-selected]":{backgroundColor:"#3e3d32",color:ivory}}},{dark:!0}),oneDarkHighlightStyle=HighlightStyle.define([{tag:tags.keyword,color:cyan},{tag:[tags.name,tags.deleted,tags.character,tags.macroName],color:green},{tag:[tags.propertyName,tags.punctuation],color:ivory},{tag:[tags.function(tags.variableName),tags.labelName],color:cyan},{tag:[tags.color,tags.constant(tags.name),tags.standard(tags.name)],color:whiskey},{tag:[tags.definition(tags.name),tags.separator],color:ivory},{tag:[tags.typeName,tags.className,tags.number,tags.changed,tags.annotation,tags.modifier,tags.self,tags.namespace],color:violet},{tag:[tags.logicOperator,tags.arithmeticOperator,tags.bitwiseOperator,tags.typeOperator],color:red},{tag:[tags.meta,tags.comment],color:stone},{tag:tags.strong,fontWeight:"bold"},{tag:tags.emphasis,fontStyle:"italic"},{tag:tags.strikethrough,textDecoration:"line-through"},{tag:tags.link,color:stone,textDecoration:"underline"},{tag:tags.heading,fontWeight:"bold",color:green},{tag:[tags.atom,tags.bool,tags.special(tags.variableName)],color:violet},{tag:[tags.processingInstruction,tags.string,tags.inserted],color:yellow},{tag:tags.invalid,color:invalid}]),oneDark=[oneDarkTheme,syntaxHighlighting(oneDarkHighlightStyle)];class Stack{constructor(e,t,i,n,o,r,s,a,l,h=0,c){this.p=e,this.stack=t,this.state=i,this.reducePos=n,this.pos=o,this.score=r,this.buffer=s,this.bufferBase=a,this.curContext=l,this.lookAhead=h,this.parent=c;}toString(){return `[${this.stack.filter((e,t)=>t%3==0).concat(this.state)}]@${this.pos}${this.score?"!"+this.score:""}`}static start(e,t,i=0){let n=e.parser.context;return new Stack(e,[],t,i,i,0,[],0,n?new StackContext(n,n.start):null,0,null)}get context(){return this.curContext?this.curContext.context:null}pushState(e,t){this.stack.push(this.state,t,this.bufferBase+this.buffer.length),this.state=e;}reduce(e){let t=e>>19,i=65535&e,{parser:n}=this.p,o=n.dynamicPrecedence(i);if(o&&(this.score+=o),0==t)return this.pushState(n.getGoto(this.state,i,!0),this.reducePos),i<n.minRepeatTerm&&this.storeNode(i,this.reducePos,this.reducePos,4,!0),void this.reduceContext(i,this.reducePos);let r=this.stack.length-3*(t-1)-(262144&e?6:0),s=this.stack[r-2],a=this.stack[r-1],l=this.bufferBase+this.buffer.length-a;if(i<n.minRepeatTerm||131072&e){let e=n.stateFlag(this.state,1)?this.pos:this.reducePos;this.storeNode(i,s,e,l+4,!0);}if(262144&e)this.state=this.stack[r];else {let e=this.stack[r-3];this.state=n.getGoto(e,i,!0);}for(;this.stack.length>r;)this.stack.pop();this.reduceContext(i,s);}storeNode(e,t,i,n=4,o=!1){if(0==e&&(!this.stack.length||this.stack[this.stack.length-1]<this.buffer.length+this.bufferBase)){let e=this,n=this.buffer.length;if(0==n&&e.parent&&(n=e.bufferBase-e.parent.bufferBase,e=e.parent),n>0&&0==e.buffer[n-4]&&e.buffer[n-1]>-1){if(t==i)return;if(e.buffer[n-2]>=t)return void(e.buffer[n-2]=i)}}if(o&&this.pos!=i){let o=this.buffer.length;if(o>0&&0!=this.buffer[o-4])for(;o>0&&this.buffer[o-2]>i;)this.buffer[o]=this.buffer[o-4],this.buffer[o+1]=this.buffer[o-3],this.buffer[o+2]=this.buffer[o-2],this.buffer[o+3]=this.buffer[o-1],o-=4,n>4&&(n-=4);this.buffer[o]=e,this.buffer[o+1]=t,this.buffer[o+2]=i,this.buffer[o+3]=n;}else this.buffer.push(e,t,i,n);}shift(e,t,i){let n=this.pos;if(131072&e)this.pushState(65535&e,this.pos);else if(0==(262144&e)){let o=e,{parser:r}=this.p;(i>this.pos||t<=r.maxNode)&&(this.pos=i,r.stateFlag(o,1)||(this.reducePos=i)),this.pushState(o,n),this.shiftContext(t,n),t<=r.maxNode&&this.buffer.push(t,n,i,4);}else this.pos=i,this.shiftContext(t,n),t<=this.p.parser.maxNode&&this.buffer.push(t,n,i,4);}apply(e,t,i){65536&e?this.reduce(e):this.shift(e,t,i);}useNode(e,t){let i=this.p.reused.length-1;(i<0||this.p.reused[i]!=e)&&(this.p.reused.push(e),i++);let n=this.pos;this.reducePos=this.pos=n+e.length,this.pushState(t,n),this.buffer.push(i,n,this.reducePos,-1),this.curContext&&this.updateContext(this.curContext.tracker.reuse(this.curContext.context,e,this,this.p.stream.reset(this.pos-e.length)));}split(){let e=this,t=e.buffer.length;for(;t>0&&e.buffer[t-2]>e.reducePos;)t-=4;let i=e.buffer.slice(t),n=e.bufferBase+t;for(;e&&n==e.bufferBase;)e=e.parent;return new Stack(this.p,this.stack.slice(),this.state,this.reducePos,this.pos,this.score,i,n,this.curContext,this.lookAhead,e)}recoverByDelete(e,t){let i=e<=this.p.parser.maxNode;i&&this.storeNode(e,this.pos,t,4),this.storeNode(0,this.pos,t,i?8:4),this.pos=this.reducePos=t,this.score-=190;}canShift(e){for(let t=new SimulatedStack(this);;){let i=this.p.parser.stateSlot(t.state,4)||this.p.parser.hasAction(t.state,e);if(0==i)return !1;if(0==(65536&i))return !0;t.reduce(i);}}recoverByInsert(e){if(this.stack.length>=300)return [];let t=this.p.parser.nextStates(this.state);if(t.length>8||this.stack.length>=120){let i=[];for(let n,o=0;o<t.length;o+=2)(n=t[o+1])!=this.state&&this.p.parser.hasAction(n,e)&&i.push(t[o],n);if(this.stack.length<120)for(let e=0;i.length<8&&e<t.length;e+=2){let n=t[e+1];i.some((e,t)=>1&t&&e==n)||i.push(t[e],n);}t=i;}let i=[];for(let e=0;e<t.length&&i.length<4;e+=2){let n=t[e+1];if(n==this.state)continue;let o=this.split();o.pushState(n,this.pos),o.storeNode(0,o.pos,o.pos,4,!0),o.shiftContext(t[e],this.pos),o.score-=200,i.push(o);}return i}forceReduce(){let e=this.p.parser.stateSlot(this.state,5);if(0==(65536&e))return !1;let{parser:t}=this.p;if(!t.validAction(this.state,e)){let i=e>>19,n=65535&e,o=this.stack.length-3*i;if(o<0||t.getGoto(this.stack[o],n,!1)<0)return !1;this.storeNode(0,this.reducePos,this.reducePos,4,!0),this.score-=100;}return this.reducePos=this.pos,this.reduce(e),!0}forceAll(){for(;!this.p.parser.stateFlag(this.state,2);)if(!this.forceReduce()){this.storeNode(0,this.pos,this.pos,4,!0);break}return this}get deadEnd(){if(3!=this.stack.length)return !1;let{parser:e}=this.p;return 65535==e.data[e.stateSlot(this.state,1)]&&!e.stateSlot(this.state,4)}restart(){this.state=this.stack[0],this.stack.length=0;}sameState(e){if(this.state!=e.state||this.stack.length!=e.stack.length)return !1;for(let t=0;t<this.stack.length;t+=3)if(this.stack[t]!=e.stack[t])return !1;return !0}get parser(){return this.p.parser}dialectEnabled(e){return this.p.parser.dialect.flags[e]}shiftContext(e,t){this.curContext&&this.updateContext(this.curContext.tracker.shift(this.curContext.context,e,this,this.p.stream.reset(t)));}reduceContext(e,t){this.curContext&&this.updateContext(this.curContext.tracker.reduce(this.curContext.context,e,this,this.p.stream.reset(t)));}emitContext(){let e=this.buffer.length-1;(e<0||-3!=this.buffer[e])&&this.buffer.push(this.curContext.hash,this.reducePos,this.reducePos,-3);}emitLookAhead(){let e=this.buffer.length-1;(e<0||-4!=this.buffer[e])&&this.buffer.push(this.lookAhead,this.reducePos,this.reducePos,-4);}updateContext(e){if(e!=this.curContext.context){let t=new StackContext(this.curContext.tracker,e);t.hash!=this.curContext.hash&&this.emitContext(),this.curContext=t;}}setLookAhead(e){e>this.lookAhead&&(this.emitLookAhead(),this.lookAhead=e);}close(){this.curContext&&this.curContext.tracker.strict&&this.emitContext(),this.lookAhead>0&&this.emitLookAhead();}}class StackContext{constructor(e,t){this.tracker=e,this.context=t,this.hash=e.strict?e.hash(t):0;}}var Recover;!function(e){e[e.Insert=200]="Insert",e[e.Delete=190]="Delete",e[e.Reduce=100]="Reduce",e[e.MaxNext=4]="MaxNext",e[e.MaxInsertStackDepth=300]="MaxInsertStackDepth",e[e.DampenInsertStackDepth=120]="DampenInsertStackDepth";}(Recover||(Recover={}));class SimulatedStack{constructor(e){this.start=e,this.state=e.state,this.stack=e.stack,this.base=this.stack.length;}reduce(e){let t=65535&e,i=e>>19;0==i?(this.stack==this.start.stack&&(this.stack=this.stack.slice()),this.stack.push(this.state,0,0),this.base+=3):this.base-=3*(i-1);let n=this.start.p.parser.getGoto(this.stack[this.base-3],t,!0);this.state=n;}}class StackBufferCursor{constructor(e,t,i){this.stack=e,this.pos=t,this.index=i,this.buffer=e.buffer,0==this.index&&this.maybeNext();}static create(e,t=e.bufferBase+e.buffer.length){return new StackBufferCursor(e,t,t-e.bufferBase)}maybeNext(){let e=this.stack.parent;null!=e&&(this.index=this.stack.bufferBase-e.bufferBase,this.stack=e,this.buffer=e.buffer);}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}next(){this.index-=4,this.pos-=4,0==this.index&&this.maybeNext();}fork(){return new StackBufferCursor(this.stack,this.pos,this.index)}}class CachedToken{constructor(){this.start=-1,this.value=-1,this.end=-1,this.extended=-1,this.lookAhead=0,this.mask=0,this.context=0;}}const nullToken=new CachedToken;class InputStream{constructor(e,t){this.input=e,this.ranges=t,this.chunk="",this.chunkOff=0,this.chunk2="",this.chunk2Pos=0,this.next=-1,this.token=nullToken,this.rangeIndex=0,this.pos=this.chunkPos=t[0].from,this.range=t[0],this.end=t[t.length-1].to,this.readNext();}resolveOffset(e,t){let i=this.range,n=this.rangeIndex,o=this.pos+e;for(;o<i.from;){if(!n)return null;let e=this.ranges[--n];o-=i.from-e.to,i=e;}for(;t<0?o>i.to:o>=i.to;){if(n==this.ranges.length-1)return null;let e=this.ranges[++n];o+=e.from-i.to,i=e;}return o}clipPos(e){if(e>=this.range.from&&e<this.range.to)return e;for(let t of this.ranges)if(t.to>e)return Math.max(e,t.from);return this.end}peek(e){let t,i,n=this.chunkOff+e;if(n>=0&&n<this.chunk.length)t=this.pos+e,i=this.chunk.charCodeAt(n);else {let n=this.resolveOffset(e,1);if(null==n)return -1;if((t=n)>=this.chunk2Pos&&t<this.chunk2Pos+this.chunk2.length)i=this.chunk2.charCodeAt(t-this.chunk2Pos);else {let e=this.rangeIndex,n=this.range;for(;n.to<=t;)n=this.ranges[++e];this.chunk2=this.input.chunk(this.chunk2Pos=t),t+this.chunk2.length>n.to&&(this.chunk2=this.chunk2.slice(0,n.to-t)),i=this.chunk2.charCodeAt(0);}}return t>=this.token.lookAhead&&(this.token.lookAhead=t+1),i}acceptToken(e,t=0){let i=t?this.resolveOffset(t,-1):this.pos;if(null==i||i<this.token.start)throw new RangeError("Token end out of bounds");this.token.value=e,this.token.end=i;}getChunk(){if(this.pos>=this.chunk2Pos&&this.pos<this.chunk2Pos+this.chunk2.length){let{chunk:e,chunkPos:t}=this;this.chunk=this.chunk2,this.chunkPos=this.chunk2Pos,this.chunk2=e,this.chunk2Pos=t,this.chunkOff=this.pos-this.chunkPos;}else {this.chunk2=this.chunk,this.chunk2Pos=this.chunkPos;let e=this.input.chunk(this.pos),t=this.pos+e.length;this.chunk=t>this.range.to?e.slice(0,this.range.to-this.pos):e,this.chunkPos=this.pos,this.chunkOff=0;}}readNext(){return this.chunkOff>=this.chunk.length&&(this.getChunk(),this.chunkOff==this.chunk.length)?this.next=-1:this.next=this.chunk.charCodeAt(this.chunkOff)}advance(e=1){for(this.chunkOff+=e;this.pos+e>=this.range.to;){if(this.rangeIndex==this.ranges.length-1)return this.setDone();e-=this.range.to-this.pos,this.range=this.ranges[++this.rangeIndex],this.pos=this.range.from;}return this.pos+=e,this.pos>=this.token.lookAhead&&(this.token.lookAhead=this.pos+1),this.readNext()}setDone(){return this.pos=this.chunkPos=this.end,this.range=this.ranges[this.rangeIndex=this.ranges.length-1],this.chunk="",this.next=-1}reset(e,t){if(t?(this.token=t,t.start=e,t.lookAhead=e+1,t.value=t.extended=-1):this.token=nullToken,this.pos!=e){if(this.pos=e,e==this.end)return this.setDone(),this;for(;e<this.range.from;)this.range=this.ranges[--this.rangeIndex];for(;e>=this.range.to;)this.range=this.ranges[++this.rangeIndex];e>=this.chunkPos&&e<this.chunkPos+this.chunk.length?this.chunkOff=e-this.chunkPos:(this.chunk="",this.chunkOff=0),this.readNext();}return this}read(e,t){if(e>=this.chunkPos&&t<=this.chunkPos+this.chunk.length)return this.chunk.slice(e-this.chunkPos,t-this.chunkPos);if(e>=this.chunk2Pos&&t<=this.chunk2Pos+this.chunk2.length)return this.chunk2.slice(e-this.chunk2Pos,t-this.chunk2Pos);if(e>=this.range.from&&t<=this.range.to)return this.input.read(e,t);let i="";for(let n of this.ranges){if(n.from>=t)break;n.to>e&&(i+=this.input.read(Math.max(n.from,e),Math.min(n.to,t)));}return i}}class TokenGroup{constructor(e,t){this.data=e,this.id=t;}token(e,t){readToken$1(this.data,e,t,this.id);}}TokenGroup.prototype.contextual=TokenGroup.prototype.fallback=TokenGroup.prototype.extend=!1;class ExternalTokenizer{constructor(e,t={}){this.token=e,this.contextual=!!t.contextual,this.fallback=!!t.fallback,this.extend=!!t.extend;}}function readToken$1(e,t,i,n){let o=0,r=1<<n,{parser:s}=i.p,{dialect:a}=s;e:for(;0!=(r&e[o]);){let i=e[o+1];for(let n=o+3;n<i;n+=2)if((e[n+1]&r)>0){let i=e[n];if(a.allows(i)&&(-1==t.token.value||t.token.value==i||s.overrides(i,t.token.value))){t.acceptToken(i);break}}let n=t.next,l=0,h=e[o+2];if(!(t.next<0&&h>l&&65535==e[i+3*h-3]&&65535==e[i+3*h-3])){for(;l<h;){let r=l+h>>1,s=i+r+(r<<1),a=e[s],c=e[s+1]||65536;if(n<a)h=r;else {if(!(n>=c)){o=e[s+2],t.advance();continue e}l=r+1;}}break}o=e[i+3*h-1];}}function decodeArray(e,t=Uint16Array){if("string"!=typeof e)return e;let i=null;for(let n=0,o=0;n<e.length;){let r=0;for(;;){let t=e.charCodeAt(n++),i=!1;if(126==t){r=65535;break}t>=92&&t--,t>=34&&t--;let o=t-32;if(o>=46&&(o-=46,i=!0),r+=o,i)break;r*=46;}i?i[o++]=r:i=new t(r);}return i}const verbose="undefined"!=typeof process&&process.env&&/\bparse\b/.test(process.env.LOG);let stackIDs=null;var Safety,Rec;function cutAt(e,t,i){let n=e.cursor(IterMode.IncludeAnonymous);for(n.moveTo(t);;)if(!(i<0?n.childBefore(t):n.childAfter(t)))for(;;){if((i<0?n.to<t:n.from>t)&&!n.type.isError)return i<0?Math.max(0,Math.min(n.to-1,t-25)):Math.min(e.length,Math.max(n.from+1,t+25));if(i<0?n.prevSibling():n.nextSibling())break;if(!n.parent())return i<0?0:e.length}}!function(e){e[e.Margin=25]="Margin";}(Safety||(Safety={}));class FragmentCursor$1{constructor(e,t){this.fragments=e,this.nodeSet=t,this.i=0,this.fragment=null,this.safeFrom=-1,this.safeTo=-1,this.trees=[],this.start=[],this.index=[],this.nextFragment();}nextFragment(){let e=this.fragment=this.i==this.fragments.length?null:this.fragments[this.i++];if(e){for(this.safeFrom=e.openStart?cutAt(e.tree,e.from+e.offset,1)-e.offset:e.from,this.safeTo=e.openEnd?cutAt(e.tree,e.to+e.offset,-1)-e.offset:e.to;this.trees.length;)this.trees.pop(),this.start.pop(),this.index.pop();this.trees.push(e.tree),this.start.push(-e.offset),this.index.push(0),this.nextStart=this.safeFrom;}else this.nextStart=1e9;}nodeAt(e){if(e<this.nextStart)return null;for(;this.fragment&&this.safeTo<=e;)this.nextFragment();if(!this.fragment)return null;for(;;){let t=this.trees.length-1;if(t<0)return this.nextFragment(),null;let i=this.trees[t],n=this.index[t];if(n==i.children.length){this.trees.pop(),this.start.pop(),this.index.pop();continue}let o=i.children[n],r=this.start[t]+i.positions[n];if(r>e)return this.nextStart=r,null;if(o instanceof Tree){if(r==e){if(r<this.safeFrom)return null;let e=r+o.length;if(e<=this.safeTo){let t=o.prop(NodeProp.lookAhead);if(!t||e+t<this.fragment.to)return o}}this.index[t]++,r+o.length>=Math.max(this.safeFrom,e)&&(this.trees.push(o),this.start.push(r),this.index.push(0));}else this.index[t]++,this.nextStart=r+o.length;}}}class TokenCache{constructor(e,t){this.stream=t,this.tokens=[],this.mainToken=null,this.actions=[],this.tokens=e.tokenizers.map(e=>new CachedToken);}getActions(e){let t=0,i=null,{parser:n}=e.p,{tokenizers:o}=n,r=n.stateSlot(e.state,3),s=e.curContext?e.curContext.hash:0,a=0;for(let n=0;n<o.length;n++){if(0==(1<<n&r))continue;let l=o[n],h=this.tokens[n];if((!i||l.fallback)&&((l.contextual||h.start!=e.pos||h.mask!=r||h.context!=s)&&(this.updateCachedToken(h,l,e),h.mask=r,h.context=s),h.lookAhead>h.end+25&&(a=Math.max(h.lookAhead,a)),0!=h.value)){let n=t;if(h.extended>-1&&(t=this.addActions(e,h.extended,h.end,t)),t=this.addActions(e,h.value,h.end,t),!l.extend&&(i=h,t>n))break}}for(;this.actions.length>t;)this.actions.pop();return a&&e.setLookAhead(a),i||e.pos!=this.stream.end||((i=new CachedToken).value=e.p.parser.eofTerm,i.start=i.end=e.pos,t=this.addActions(e,i.value,i.end,t)),this.mainToken=i,this.actions}getMainToken(e){if(this.mainToken)return this.mainToken;let t=new CachedToken,{pos:i,p:n}=e;return t.start=i,t.end=Math.min(i+1,n.stream.end),t.value=i==n.stream.end?n.parser.eofTerm:0,t}updateCachedToken(e,t,i){let n=this.stream.clipPos(i.pos);if(t.token(this.stream.reset(n,e),i),e.value>-1){let{parser:t}=i.p;for(let n=0;n<t.specialized.length;n++)if(t.specialized[n]==e.value){let o=t.specializers[n](this.stream.read(e.start,e.end),i);if(o>=0&&i.p.parser.dialect.allows(o>>1)){0==(1&o)?e.value=o>>1:e.extended=o>>1;break}}}else e.value=0,e.end=this.stream.clipPos(n+1);}putAction(e,t,i,n){for(let t=0;t<n;t+=3)if(this.actions[t]==e)return n;return this.actions[n++]=e,this.actions[n++]=t,this.actions[n++]=i,n}addActions(e,t,i,n){let{state:o}=e,{parser:r}=e.p,{data:s}=r;for(let e=0;e<2;e++)for(let a=r.stateSlot(o,e?2:1);;a+=3){if(65535==s[a]){if(1!=s[a+1]){0==n&&2==s[a+1]&&(n=this.putAction(pair(s,a+2),t,i,n));break}a=pair(s,a+2);}s[a]==t&&(n=this.putAction(pair(s,a+1),t,i,n));}return n}}!function(e){e[e.Distance=5]="Distance",e[e.MaxRemainingPerStep=3]="MaxRemainingPerStep",e[e.MinBufferLengthPrune=500]="MinBufferLengthPrune",e[e.ForceReduceLimit=10]="ForceReduceLimit",e[e.CutDepth=15e3]="CutDepth",e[e.CutTo=9e3]="CutTo";}(Rec||(Rec={}));class Parse$1{constructor(e,t,i,n){this.parser=e,this.input=t,this.ranges=n,this.recovering=0,this.nextStackID=9812,this.minStackPos=0,this.reused=[],this.stoppedAt=null,this.stream=new InputStream(t,n),this.tokens=new TokenCache(e,this.stream),this.topTerm=e.top[1];let{from:o}=n[0];this.stacks=[Stack.start(this,e.top[0],o)],this.fragments=i.length&&this.stream.end-o>4*e.bufferLength?new FragmentCursor$1(i,e.nodeSet):null;}get parsedPos(){return this.minStackPos}advance(){let e,t,i=this.stacks,n=this.minStackPos,o=this.stacks=[];for(let r=0;r<i.length;r++){let s=i[r];for(;;){if(this.tokens.mainToken=null,s.pos>n)o.push(s);else {if(this.advanceStack(s,o,i))continue;{e||(e=[],t=[]),e.push(s);let i=this.tokens.getMainToken(s);t.push(i.value,i.end);}}break}}if(!o.length){let t=e&&findFinished(e);if(t)return this.stackToTree(t);if(this.parser.strict)throw verbose&&e&&console.log("Stuck with token "+(this.tokens.mainToken?this.parser.getName(this.tokens.mainToken.value):"none")),new SyntaxError("No parse at "+n);this.recovering||(this.recovering=5);}if(this.recovering&&e){let i=null!=this.stoppedAt&&e[0].pos>this.stoppedAt?e[0]:this.runRecovery(e,t,o);if(i)return this.stackToTree(i.forceAll())}if(this.recovering){let e=1==this.recovering?1:3*this.recovering;if(o.length>e)for(o.sort((e,t)=>t.score-e.score);o.length>e;)o.pop();o.some(e=>e.reducePos>n)&&this.recovering--;}else if(o.length>1)e:for(let e=0;e<o.length-1;e++){let t=o[e];for(let i=e+1;i<o.length;i++){let n=o[i];if(t.sameState(n)||t.buffer.length>500&&n.buffer.length>500){if(!((t.score-n.score||t.buffer.length-n.buffer.length)>0)){o.splice(e--,1);continue e}o.splice(i--,1);}}}this.minStackPos=o[0].pos;for(let e=1;e<o.length;e++)o[e].pos<this.minStackPos&&(this.minStackPos=o[e].pos);return null}stopAt(e){if(null!=this.stoppedAt&&this.stoppedAt<e)throw new RangeError("Can't move stoppedAt forward");this.stoppedAt=e;}advanceStack(e,t,i){let n=e.pos,{parser:o}=this,r=verbose?this.stackID(e)+" -> ":"";if(null!=this.stoppedAt&&n>this.stoppedAt)return e.forceReduce()?e:null;if(this.fragments){let t=e.curContext&&e.curContext.tracker.strict,i=t?e.curContext.hash:0;for(let s=this.fragments.nodeAt(n);s;){let n=this.parser.nodeSet.types[s.type.id]==s.type?o.getGoto(e.state,s.type.id):-1;if(n>-1&&s.length&&(!t||(s.prop(NodeProp.contextHash)||0)==i))return e.useNode(s,n),verbose&&console.log(r+this.stackID(e)+` (via reuse of ${o.getName(s.type.id)})`),!0;if(!(s instanceof Tree)||0==s.children.length||s.positions[0]>0)break;let a=s.children[0];if(!(a instanceof Tree&&0==s.positions[0]))break;s=a;}}let s=o.stateSlot(e.state,4);if(s>0)return e.reduce(s),verbose&&console.log(r+this.stackID(e)+` (via always-reduce ${o.getName(65535&s)})`),!0;if(e.stack.length>=15e3)for(;e.stack.length>9e3&&e.forceReduce(););let a=this.tokens.getActions(e);for(let s=0;s<a.length;){let l=a[s++],h=a[s++],c=a[s++],d=s==a.length||!i,u=d?e:e.split();if(u.apply(l,h,c),verbose&&console.log(r+this.stackID(u)+` (via ${0==(65536&l)?"shift":`reduce of ${o.getName(65535&l)}`} for ${o.getName(h)} @ ${n}${u==e?"":", split"})`),d)return !0;u.pos>n?t.push(u):i.push(u);}return !1}advanceFully(e,t){let i=e.pos;for(;;){if(!this.advanceStack(e,null,null))return !1;if(e.pos>i)return pushStackDedup(e,t),!0}}runRecovery(e,t,i){let n=null,o=!1;for(let r=0;r<e.length;r++){let s=e[r],a=t[r<<1],l=t[1+(r<<1)],h=verbose?this.stackID(s)+" -> ":"";if(s.deadEnd){if(o)continue;if(o=!0,s.restart(),verbose&&console.log(h+this.stackID(s)+" (restarted)"),this.advanceFully(s,i))continue}let c=s.split(),d=h;for(let e=0;c.forceReduce()&&e<10;e++){if(verbose&&console.log(d+this.stackID(c)+" (via force-reduce)"),this.advanceFully(c,i))break;verbose&&(d=this.stackID(c)+" -> ");}for(let e of s.recoverByInsert(a))verbose&&console.log(h+this.stackID(e)+" (via recover-insert)"),this.advanceFully(e,i);this.stream.end>s.pos?(l==s.pos&&(l++,a=0),s.recoverByDelete(a,l),verbose&&console.log(h+this.stackID(s)+` (via recover-delete ${this.parser.getName(a)})`),pushStackDedup(s,i)):(!n||n.score<s.score)&&(n=s);}return n}stackToTree(e){return e.close(),Tree.build({buffer:StackBufferCursor.create(e),nodeSet:this.parser.nodeSet,topID:this.topTerm,maxBufferLength:this.parser.bufferLength,reused:this.reused,start:this.ranges[0].from,length:e.pos-this.ranges[0].from,minRepeatType:this.parser.minRepeatTerm})}stackID(e){let t=(stackIDs||(stackIDs=new WeakMap)).get(e);return t||stackIDs.set(e,t=String.fromCodePoint(this.nextStackID++)),t+e}}function pushStackDedup(e,t){for(let i=0;i<t.length;i++){let n=t[i];if(n.pos==e.pos&&n.sameState(e))return void(t[i].score<e.score&&(t[i]=e))}t.push(e);}class Dialect{constructor(e,t,i){this.source=e,this.flags=t,this.disabled=i;}allows(e){return !this.disabled||0==this.disabled[e]}}const id=e=>e;class ContextTracker{constructor(e){this.start=e.start,this.shift=e.shift||id,this.reduce=e.reduce||id,this.reuse=e.reuse||id,this.hash=e.hash||(()=>0),this.strict=!1!==e.strict;}}class LRParser extends Parser{constructor(e){if(super(),this.wrappers=[],14!=e.version)throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);let t=e.nodeNames.split(" ");this.minRepeatTerm=t.length;for(let i=0;i<e.repeatNodeCount;i++)t.push("");let i=Object.keys(e.topRules).map(t=>e.topRules[t][1]),n=[];for(let e=0;e<t.length;e++)n.push([]);function o(e,t,i){n[e].push([t,t.deserialize(String(i))]);}if(e.nodeProps)for(let t of e.nodeProps){let e=t[0];"string"==typeof e&&(e=NodeProp[e]);for(let i=1;i<t.length;){let n=t[i++];if(n>=0)o(n,e,t[i++]);else {let r=t[i+-n];for(let s=-n;s>0;s--)o(t[i++],e,r);i++;}}}this.nodeSet=new NodeSet(t.map((t,o)=>NodeType.define({name:o>=this.minRepeatTerm?void 0:t,id:o,props:n[o],top:i.indexOf(o)>-1,error:0==o,skipped:e.skippedNodes&&e.skippedNodes.indexOf(o)>-1}))),e.propSources&&(this.nodeSet=this.nodeSet.extend(...e.propSources)),this.strict=!1,this.bufferLength=DefaultBufferLength;let r=decodeArray(e.tokenData);this.context=e.context,this.specializerSpecs=e.specialized||[],this.specialized=new Uint16Array(this.specializerSpecs.length);for(let e=0;e<this.specializerSpecs.length;e++)this.specialized[e]=this.specializerSpecs[e].term;this.specializers=this.specializerSpecs.map(getSpecializer),this.states=decodeArray(e.states,Uint32Array),this.data=decodeArray(e.stateData),this.goto=decodeArray(e.goto),this.maxTerm=e.maxTerm,this.tokenizers=e.tokenizers.map(e=>"number"==typeof e?new TokenGroup(r,e):e),this.topRules=e.topRules,this.dialects=e.dialects||{},this.dynamicPrecedences=e.dynamicPrecedences||null,this.tokenPrecTable=e.tokenPrec,this.termNames=e.termNames||null,this.maxNode=this.nodeSet.types.length-1,this.dialect=this.parseDialect(),this.top=this.topRules[Object.keys(this.topRules)[0]];}createParse(e,t,i){let n=new Parse$1(this,e,t,i);for(let o of this.wrappers)n=o(n,e,t,i);return n}getGoto(e,t,i=!1){let n=this.goto;if(t>=n[0])return -1;for(let o=n[t+1];;){let t=n[o++],r=1&t,s=n[o++];if(r&&i)return s;for(let i=o+(t>>1);o<i;o++)if(n[o]==e)return s;if(r)return -1}}hasAction(e,t){let i=this.data;for(let n=0;n<2;n++)for(let o,r=this.stateSlot(e,n?2:1);;r+=3){if(65535==(o=i[r])){if(1!=i[r+1]){if(2==i[r+1])return pair(i,r+2);break}o=i[r=pair(i,r+2)];}if(o==t||0==o)return pair(i,r+1)}return 0}stateSlot(e,t){return this.states[6*e+t]}stateFlag(e,t){return (this.stateSlot(e,0)&t)>0}validAction(e,t){if(t==this.stateSlot(e,4))return !0;for(let i=this.stateSlot(e,1);;i+=3){if(65535==this.data[i]){if(1!=this.data[i+1])return !1;i=pair(this.data,i+2);}if(t==pair(this.data,i+1))return !0}}nextStates(e){let t=[];for(let i=this.stateSlot(e,1);;i+=3){if(65535==this.data[i]){if(1!=this.data[i+1])break;i=pair(this.data,i+2);}if(0==(1&this.data[i+2])){let e=this.data[i+1];t.some((t,i)=>1&i&&t==e)||t.push(this.data[i],e);}}return t}overrides(e,t){let i=findOffset(this.data,this.tokenPrecTable,t);return i<0||findOffset(this.data,this.tokenPrecTable,e)<i}configure(e){let t=Object.assign(Object.create(LRParser.prototype),this);if(e.props&&(t.nodeSet=this.nodeSet.extend(...e.props)),e.top){let i=this.topRules[e.top];if(!i)throw new RangeError(`Invalid top rule name ${e.top}`);t.top=i;}return e.tokenizers&&(t.tokenizers=this.tokenizers.map(t=>{let i=e.tokenizers.find(e=>e.from==t);return i?i.to:t})),e.specializers&&(t.specializers=this.specializers.slice(),t.specializerSpecs=this.specializerSpecs.map((i,n)=>{let o=e.specializers.find(e=>e.from==i.external);if(!o)return i;let r=Object.assign(Object.assign({},i),{external:o.to});return t.specializers[n]=getSpecializer(r),r})),e.contextTracker&&(t.context=e.contextTracker),e.dialect&&(t.dialect=this.parseDialect(e.dialect)),null!=e.strict&&(t.strict=e.strict),e.wrap&&(t.wrappers=t.wrappers.concat(e.wrap)),null!=e.bufferLength&&(t.bufferLength=e.bufferLength),t}hasWrappers(){return this.wrappers.length>0}getName(e){return this.termNames?this.termNames[e]:String(e<=this.maxNode&&this.nodeSet.types[e].name||e)}get eofTerm(){return this.maxNode+1}get topNode(){return this.nodeSet.types[this.top[1]]}dynamicPrecedence(e){let t=this.dynamicPrecedences;return null==t?0:t[e]||0}parseDialect(e){let t=Object.keys(this.dialects),i=t.map(()=>!1);if(e)for(let n of e.split(" ")){let e=t.indexOf(n);e>=0&&(i[e]=!0);}let n=null;for(let e=0;e<t.length;e++)if(!i[e])for(let i,o=this.dialects[t[e]];65535!=(i=this.data[o++]);)(n||(n=new Uint8Array(this.maxTerm+1)))[i]=1;return new Dialect(e,i,n)}static deserialize(e){return new LRParser(e)}}function pair(e,t){return e[t]|e[t+1]<<16}function findOffset(e,t,i){for(let n,o=t;65535!=(n=e[o]);o++)if(n==i)return o-t;return -1}function findFinished(e){let t=null;for(let i of e){let e=i.p.stoppedAt;(i.pos==i.p.stream.end||null!=e&&i.pos>e)&&i.p.parser.stateFlag(i.state,2)&&(!t||t.score<i.score)&&(t=i);}return t}function getSpecializer(e){if(e.external){let t=e.extend?1:0;return (i,n)=>e.external(i,n)<<1|t}return e.get}const space=[9,10,11,12,13,32,133,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288],trackNewline=new ContextTracker({start:!1,shift:(e,t)=>5==t||6==t||299==t?e:300==t,strict:!1}),insertSemicolon=new ExternalTokenizer((e,t)=>{let{next:i}=e;(125==i||-1==i||t.context)&&t.canShift(297)&&e.acceptToken(297);},{contextual:!0,fallback:!0}),noSemicolon=new ExternalTokenizer((e,t)=>{let i,{next:n}=e;space.indexOf(n)>-1||(47!=n||47!=(i=e.peek(1))&&42!=i)&&125!=n&&59!=n&&-1!=n&&!t.context&&t.canShift(294)&&e.acceptToken(294);},{contextual:!0}),incdecToken=new ExternalTokenizer((e,t)=>{let{next:i}=e;if((43==i||45==i)&&(e.advance(),i==e.next)){e.advance();let i=!t.context&&t.canShift(2);e.acceptToken(i?2:3);}},{contextual:!0}),template=new ExternalTokenizer(e=>{for(let t=!1,i=0;;i++){let{next:n}=e;if(n<0){i&&e.acceptToken(295);break}if(96==n){i?e.acceptToken(295):e.acceptToken(296,1);break}if(123==n&&t){1==i?e.acceptToken(4,1):e.acceptToken(295,-1);break}if(10==n&&i){e.advance(),e.acceptToken(295);break}92==n&&e.advance(),t=36==n,e.advance();}}),tsExtends=new ExternalTokenizer((e,t)=>{if(101==e.next&&t.dialectEnabled(1)){e.advance();for(let t=0;t<6;t++){if(e.next!="xtends".charCodeAt(t))return;e.advance();}e.next>=57&&e.next<=65||e.next>=48&&e.next<=90||95==e.next||e.next>=97&&e.next<=122||e.next>160||e.acceptToken(1);}}),jsHighlight=styleTags({"get set async static":tags.modifier,"for while do if else switch try catch finally return throw break continue default case":tags.controlKeyword,"in of await yield void typeof delete instanceof":tags.operatorKeyword,"let var const function class extends":tags.definitionKeyword,"import export from":tags.moduleKeyword,"with debugger as new":tags.keyword,TemplateString:tags.special(tags.string),super:tags.atom,BooleanLiteral:tags.bool,this:tags.self,null:tags.null,Star:tags.modifier,VariableName:tags.variableName,"CallExpression/VariableName TaggedTemplateExpression/VariableName":tags.function(tags.variableName),VariableDefinition:tags.definition(tags.variableName),Label:tags.labelName,PropertyName:tags.propertyName,PrivatePropertyName:tags.special(tags.propertyName),"CallExpression/MemberExpression/PropertyName":tags.function(tags.propertyName),"FunctionDeclaration/VariableDefinition":tags.function(tags.definition(tags.variableName)),"ClassDeclaration/VariableDefinition":tags.definition(tags.className),PropertyDefinition:tags.definition(tags.propertyName),PrivatePropertyDefinition:tags.definition(tags.special(tags.propertyName)),UpdateOp:tags.updateOperator,LineComment:tags.lineComment,BlockComment:tags.blockComment,Number:tags.number,String:tags.string,ArithOp:tags.arithmeticOperator,LogicOp:tags.logicOperator,BitOp:tags.bitwiseOperator,CompareOp:tags.compareOperator,RegExp:tags.regexp,Equals:tags.definitionOperator,Arrow:tags.function(tags.punctuation),": Spread":tags.punctuation,"( )":tags.paren,"[ ]":tags.squareBracket,"{ }":tags.brace,"InterpolationStart InterpolationEnd":tags.special(tags.brace),".":tags.derefOperator,", ;":tags.separator,"@":tags.meta,TypeName:tags.typeName,TypeDefinition:tags.definition(tags.typeName),"type enum interface implements namespace module declare":tags.definitionKeyword,"abstract global Privacy readonly override":tags.modifier,"is keyof unique infer":tags.operatorKeyword,JSXAttributeValue:tags.attributeValue,JSXText:tags.content,"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag":tags.angleBracket,"JSXIdentifier JSXNameSpacedName":tags.tagName,"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName":tags.attributeName,"JSXBuiltin/JSXIdentifier":tags.standard(tags.tagName)}),spec_identifier={__proto__:null,export:18,as:23,from:29,default:32,async:37,function:38,this:50,true:58,false:58,null:68,void:72,typeof:76,super:92,new:126,await:143,yield:145,delete:146,class:156,extends:158,public:213,private:213,protected:213,readonly:215,instanceof:234,satisfies:237,in:238,const:240,import:272,keyof:327,unique:331,infer:337,is:373,abstract:393,implements:395,type:397,let:400,var:402,interface:409,enum:413,namespace:419,module:421,declare:425,global:429,for:450,of:459,while:462,with:466,do:470,if:474,else:476,switch:480,case:486,try:492,catch:496,finally:500,return:504,throw:508,break:512,continue:516,debugger:520},spec_word={__proto__:null,async:113,get:115,set:117,public:175,private:175,protected:175,static:177,abstract:179,override:181,readonly:187,accessor:189,new:377},spec_LessThan={__proto__:null,"<":133},parser=LRParser.deserialize({version:14,states:"$CWO`QdOOO$}QdOOO)WQ(C|O'#ChO)_OWO'#DYO+jQdO'#D_O+zQdO'#DjO$}QdO'#DtO.OQdO'#DzOOQ(C['#ET'#ETO.fQ`O'#EQOOQO'#IW'#IWO.nQ`O'#GgOOQO'#Ee'#EeO.yQ`O'#EdO/OQ`O'#EdO1QQ(C|O'#JQO3nQ(C|O'#JRO4_Q`O'#FSO4dQ!bO'#FkOOQ(C['#F['#F[O4oO#tO'#F[O4}Q&jO'#FrO6bQ`O'#FqOOQ(C['#JR'#JROOQ(CW'#JQ'#JQOOQS'#Jk'#JkO6gQ`O'#H{O6lQ(ChO'#H|OOQS'#Iu'#IuOOQS'#IO'#IOQ`QdOOO$}QdO'#DlO6tQ`O'#GgO6yQ&jO'#CmO7XQ`O'#EcO7dQ`O'#EnO7iQ&jO'#FZO8TQ`O'#GgO8YQ`O'#GkO8eQ`O'#GkO8sQ`O'#GnO8sQ`O'#GoO8sQ`O'#GqO6tQ`O'#GtO9dQ`O'#GwO:uQ`O'#CdO;VQ`O'#HUO;_Q`O'#H[O;_Q`O'#H^O`QdO'#H`O;_Q`O'#HbO;_Q`O'#HeO;dQ`O'#HkO;iQ(CjO'#HqO$}QdO'#HsO;tQ(CjO'#HuO<PQ(CjO'#HwO6lQ(ChO'#HyO<[Q(C|O'#ChO<xQ,UO'#DdQOQ`OOO=mQaO'#D{O6yQ&jO'#EcO={Q`O'#EcO>WQpO'#FZO$}QdO'#DZOOOW'#IQ'#IQO>`OWO,59tOOQ(C[,59t,59tO>kQdO'#IRO?OQ`O'#JSOAQQtO'#JSO)jQdO'#JSOAXQ`O,59yOAoQ`O'#EeOA|Q`O'#J`OBXQ`O'#J_OBXQ`O'#J_OBaQ`O,5;ROBfQ`O'#J^OOQ(C[,5:U,5:UOBmQdO,5:UODnQ(C|O,5:`OE_Q`O,5:fOEdQ`O'#J[OF^Q(ChO'#J]O8YQ`O'#J[OFeQ`O'#J[OFmQ`O,5;QOFrQ`O'#J[OOQ(C]'#Ch'#ChO$}QdO'#DzOGfQpO,5:lOOQO'#JX'#JXOOQO-E<U-E<UO6tQ`O,5=ROG|Q`O,5=ROHRQdO,5;OOJRQ&jO'#E`OKcQ`O,5;OOLxQ&jO'#DnOMPQdO'#DsOMZQ,UO,5;XOMcQ,UO,5;XO$}QdO,5;XOOQS'#Ez'#EzOOQS'#E|'#E|O$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YO$}QdO,5;YOOQS'#FQ'#FQOMqQdO,5;kOOQ(C[,5;p,5;pOOQ(C[,5;q,5;qO! qQ`O,5;qOOQ(C[,5;r,5;rO$}QdO'#I^O! yQ(ChO,5<_OJRQ&jO,5;YO!!hQ&jO,5;YO$}QdO,5;nO!!oQ!bO'#FaO!#lQ!bO'#JdO!#WQ!bO'#JdO!#sQ!bO'#JdOOQO'#Jd'#JdO!$XQ!bO,5;yOOOO,5<V,5<VO!$jQdO'#FmOOOO'#I]'#I]O4oO#tO,5;vO!$qQ!bO'#FoOOQ(C[,5;v,5;vO!%bQ7]O'#CsOOQ(C]'#Cv'#CvO!%uQ`O'#CvO!%zOWO'#CzO!&hQ&kO,5<[O!&oQ`O,5<^O!(RQMhO'#F|O!(`Q`O'#F}O!(eQ`O'#F}O!(jQMhO'#GRO!)iQ,UO'#GVO!*_Q7]O'#I}OOQ(C]'#I}'#I}O!+eQaO'#I|O!+sQ`O'#I{O!+{Q`O'#CrOOQ(C]'#Ct'#CtOOQ(C]'#C}'#C}OOQ(C]'#DP'#DPO.iQ`O'#DROKhQ&jO'#FtOKhQ&jO'#FvO!,TQ`O'#FxO!,YQ`O'#FyO!(eQ`O'#GPOKhQ&jO'#GUO!,_Q`O'#EfO!,yQ`O,5<]O`QdO,5>gOOQS'#Ix'#IxOOQS,5>h,5>hOOQS-E;|-E;|O!.xQ(C|O,5:WOOQ(CX'#Cp'#CpO!/lQ&kO,5=ROOQO'#Cf'#CfO!/}Q(ChO'#IyO6bQ`O'#IyO;dQ`O,59XO!0`Q!bO,59XO!0hQ&jO,59XO6yQ&jO,59XO!0sQ`O,5;OO!0{Q`O'#HTO!1ZQ`O'#JoO$}QdO,5;sO!1cQ,UO,5;uO!1hQ`O,5=nO!1mQ`O,5=nO!1rQ`O,5=nO6lQ(ChO,5=nO!2QQ`O'#EgO!2wQ,UO'#EhOOQ(CW'#J^'#J^O!3OQ(ChO'#JlO6lQ(ChO,5=VO8sQ`O,5=]OOQP'#Cs'#CsO!3ZQ!bO,5=YO!3cQ!cO,5=ZO!3nQ`O,5=]O!3sQpO,5=`O;dQ`O'#GyO6tQ`O'#G{O!3{Q`O'#G{O6yQ&jO'#HOO!4QQ`O'#HOOOQS,5=c,5=cO!4VQ`O'#HPO!4_Q`O'#CmO!4dQ`O,59OO!4nQ`O,59OO!6sQdO,59OOOQS,59O,59OO!7QQ(ChO,59OO$}QdO,59OO!7]QdO'#HWOOQS'#HX'#HXOOQS'#HY'#HYO`QdO,5=pO!7mQ`O,5=pO`QdO,5=vO`QdO,5=xO!7rQ`O,5=zO`QdO,5=|O!7wQ`O,5>PO!7|QdO,5>VOOQS,5>],5>]O$}QdO,5>]O6lQ(ChO,5>_OOQS,5>a,5>aO!<QQ`O,5>aOOQS,5>c,5>cO!<QQ`O,5>cOOQS,5>e,5>eO!<VQ!bO'#DWOOQ(CW'#JU'#JUO$}QdO'#JUO!<tQ!bO'#JUO!=cQ!bO'#DeO!=tQ,UO'#DeO!@PQdO'#DeO!@WQ`O'#JTO!@`Q`O,5:OO!@eQ`O'#EiO!@sQ`O'#JaO!@{Q`O,5;SO!AcQ,UO'#DeO!AmQ,UO'#EOOOQ(C[,5:g,5:gO$}QdO,5:gOJRQ&jO,5:gO!BjQaO,5:gO;dQ`O,5:}O!0`Q!bO,5:}O!0hQ&jO,5:}O6yQ&jO,5:}O!BuQpO,59uOOOW-E<O-E<OOOQ(C[1G/`1G/`O!BzQtO,5>mO)jQdO,5>mOOQO,5>s,5>sO!CUQdO'#IROOQO-E<P-E<PO!CcQ`O,5?nO!CkQtO,5?nO!CrQ`O,5?yOOQ(C[1G/e1G/eO$}QdO,5?zO!CzQ`O'#IXOOQO-E<V-E<VO!CrQ`O,5?yOOQ(CW1G0m1G0mOOQ(C[1G/p1G/pOOQ(C[1G0Q1G0QO!D`Q`O,5?vO8YQ`O,5?vO!DhQ`O,5?vOOQ(CW'#E_'#E_O$}QdO,5?wO!DvQ(ChO,5?wO!EXQ(ChO,5?wO!E`Q`O'#IZO!D`Q`O,5?vOOQ(CW1G0l1G0lOMZQ,UO,5:nOMfQ,UO,5:nOOQO,5:p,5:pO!E}Q`O,5:pO!FVQ&kO1G2mO6tQ`O1G2mOOQ(C[1G0j1G0jO!FhQ(C|O1G0jO!GmQ(CyO,5:zOOQ(C]'#F{'#F{O!JWQ(C}O'#I}OHRQdO1G0jO!J}Q&kO'#JVO!KXQ`O,5:YO!K^QtO'#JWO$}QdO'#JWO!KhQ`O,5:_OOQ(C]'#DW'#DWOOQ(C[1G0s1G0sO$}QdO1G0sOOQ(C[1G1]1G1]O!KmQ`O1G0sO!NUQ(C|O1G0tO!N]Q(C|O1G0tO#!vQ(C|O1G0tO#!}Q(C|O1G0tO#%XQ(C|O1G0tO#%oQ(C|O1G0tO#(iQ(C|O1G0tO#(pQ(C|O1G0tO#+ZQ(C|O1G0tO#+bQ(C|O1G0tO#-YQ(C|O1G0tO#0YQ!LUO'#ChO#2WQ!LUO1G1VO#4UQ!LUO'#JRO! tQ`O1G1]O#4iQ(C|O,5>xOOQ(CW-E<[-E<[O#5]Q(C}O1G0tOOQ(C[1G0t1G0tO#7hQ(C|O1G1YO#8[Q!bO,5;}O#8dQ!bO,5<OO#8lQ!bO'#FfO#9TQ`O'#FeOOQO'#Je'#JeOOQO'#I['#I[O#9YQ!bO1G1eOOQ(C[1G1e1G1eOOOO1G1p1G1pO#9kQ!LUO'#JQO#9uQ`O,5<XOMqQdO,5<XOOOO-E<Z-E<ZOOQ(C[1G1b1G1bOOQ(C[,5<Z,5<ZO#9zQ!bO,5<ZOOQ(C],59b,59bOJRQ&jO'#C|OOOW'#IP'#IPO#:POWO,59fOOQ(C],59f,59fO$}QdO1G1vO!,YQ`O'#I`O#:[Q`O,5<oOOQ(C],5<l,5<lOOQO'#Gb'#GbOKhQ&jO,5<{OOQO'#Gd'#GdOKhQ&jO,5<}OJRQ&jO,5=POOQO1G1x1G1xO#:gQqO'#CpO#:zQqO,5<hO#;RQ`O'#JhO6tQ`O'#JhO#;aQ`O,5<jOKhQ&jO,5<iO#;fQ`O'#GOO#;qQ`O,5<iO#;vQqO'#F{O#<TQqO'#JiO#<_Q`O'#JiOJRQ&jO'#JiO#<dQ`O,5<mOOQ(CW'#Di'#DiO#<iQ!bO'#GWO!)dQ,UO'#GWO#<zQ`O'#GYO#=PQ`O'#G[O!(eQ`O'#G_O#=UQ(ChO'#IbO#=aQ,UO,5<qOOQ(C],5<q,5<qO#=hQ,UO'#GWO#=vQ,UO'#GXO#>OQ,UO'#GXOOQ(C],5=Q,5=QOKhQ&jO,5?hOKhQ&jO,5?hO#>TQ`O'#IcO#>`Q`O,5?gO#>hQ`O,59^O#?XQ&kO,59mOOQ(C],59m,59mO#?zQ&kO,5<`O#@mQ&kO,5<bO#@wQ`O,5<dOOQ(C],5<e,5<eO#@|Q`O,5<kO#ARQ&kO,5<pOHRQdO1G1wO#AcQ`O1G1wOOQS1G4R1G4ROOQ(C[1G/r1G/rO! qQ`O1G/rOOQS1G2m1G2mOJRQ&jO1G2mO$}QdO1G2mOJRQ&jO1G2mO#AhQaO1G2mO#CQQ&jO'#E`OOQ(CW,5?e,5?eO#C[Q(ChO,5?eOOQS1G.s1G.sO;dQ`O1G.sO!0`Q!bO1G.sO!0hQ&jO1G.sO#CmQ`O1G0jO#CrQ`O'#ChO#C}Q`O'#JpO#DVQ`O,5=oO#D[Q`O'#JpO#DaQ`O'#JpO#DiQ`O'#IkO#DwQ`O,5@ZO#EPQtO1G1_OOQ(C[1G1a1G1aO6tQ`O1G3YO#EWQ`O1G3YO#E]Q`O1G3YO#EbQ`O1G3YOOQS1G3Y1G3YO8YQ`O'#J_O8YQ`O'#EiO$}QdO'#EiO8YQ`O'#IeO#EgQ(ChO,5@WOOQS1G2q1G2qO!3nQ`O1G2wOJRQ&jO1G2tO#ErQ`O1G2tOOQS1G2u1G2uOJRQ&jO1G2uO#EwQaO1G2uO#FPQ,UO'#GsOOQS1G2w1G2wO!)dQ,UO'#IgO!3sQpO1G2zOOQS1G2z1G2zOOQS,5=e,5=eO#FXQ&kO,5=gO6tQ`O,5=gO#=PQ`O,5=jO6bQ`O,5=jO!0`Q!bO,5=jO!0hQ&jO,5=jO6yQ&jO,5=jO#FjQ`O'#JnO#FuQ`O,5=kOOQS1G.j1G.jO#FzQ(ChO1G.jO#GVQ`O1G.jO#G[Q`O1G.jO6lQ(ChO1G.jO#GdQtO,5@]O#GnQ`O,5@]O#GyQdO,5=rO#HQQ`O,5=rO8YQ`O,5@]OOQS1G3[1G3[O`QdO1G3[OOQS1G3b1G3bOOQS1G3d1G3dO;_Q`O1G3fO#HVQdO1G3hO#LTQdO'#HgOOQS1G3k1G3kO#LbQ`O'#HmO;dQ`O'#HoOOQS1G3q1G3qO#LjQdO1G3qO6lQ(ChO1G3wOOQS1G3y1G3yOOQ(CW'#GS'#GSO6lQ(ChO1G3{O6lQ(ChO1G3}O$!kQ`O,5?pOMqQdO,5;TO8YQ`O,5;TO;dQ`O,5:POMqQdO,5:PO$}QdO'#JUO!0`Q!bO,5:PO$!pQ!LUO,5:POOQO,5;T,5;TO$!zQ,UO'#ISO$#bQ`O,5?oOOQ(C[1G/j1G/jO$#jQ,UO'#IYO$#tQ`O,5?{OOQ(CW1G0n1G0nO!=tQ,UO,5:PO$#|Q,UO'#E[OOQ(CW'#EZ'#EZO$$sQ(DjO'#E[O$%_Q,UO'#EPOOQO'#IV'#IVO$%pQ,UO,5:jOOQ(C[,5:j,5:jO$&mQ,UO'#EPO$&zQ,UO'#EPO$'[Q,UO'#EbO$'_Q,UO'#E[O$'xQ,UO'#E[O$%_Q,UO'#E[O$(iQ`O1G0RO$(nQqO1G0ROOQ(C[1G0R1G0RO$}QdO1G0ROJRQ&jO1G0ROOQ(C[1G0i1G0iO;dQ`O1G0iO!0`Q!bO1G0iO!0hQ&jO1G0iOOOW1G/a1G/aO$(uQpO,5<_O$(}QtO1G4XOOQO1G4_1G4_O$}QdO,5>mO$)XQ`O1G5YO$)aQ`O1G5eO$)iQtO1G5fO8YQ`O,5>sO$)sQ`O1G5bO$)sQ`O1G5bO8YQ`O1G5bO$){Q(C|O1G5cO$}QdO1G5cO$*]Q(ChO1G5cO$*nQ`O,5>uO8YQ`O,5>uOOQO,5>u,5>uO$+SQ`O,5>uOOQO-E<X-E<XOOQO1G0Y1G0YOOQO1G0[1G0[O! tQ`O1G0[OOQS7+(X7+(XOJRQ&jO7+(XO$}QdO7+(XOJRQ&jO7+(XO$+bQaO7+(XO$+pQ&kO7+(XO$,RQ(C}O,59mO$.ZQ(C}O,5<`O$0fQ(C}O,5<bO$2qQ(C}O,5<pOOQ(C[7+&U7+&UO$5SQ(C|O7+&UO$5vQ&jO'#ITO$6QQ`O,5?qOOQ(C]1G/t1G/tO$6YQdO'#IUO$6gQ`O,5?rO$6oQtO,5?rOOQ(C[1G/y1G/yO$6yQ`O7+&_OOQ(C[7+&_7+&_O$7OQ!LUO,5:`O$}QdO7+&qO$7YQ!LUO,5:WOOQ(C[7+&w7+&wOOQO1G1i1G1iOOQO1G1j1G1jO$7gQ$ISO,5<QOMqQdO,5<POOQO-E<Y-E<YOOQ(C[7+'P7+'POOOO7+'[7+'[OOOO1G1s1G1sO$7rQ`O1G1sOOQ(C[1G1u1G1uO$7wQqO,59hOOOW-E;}-E;}OOQ(C]1G/Q1G/QO$8OQ(C|O7+'bOOQ(C],5>z,5>zO$8rQ`O,5>zOOQ(C]1G2Z1G2ZP$8wQ`O'#I`POQ(C]-E<^-E<^O$9hQ&kO1G2gO$:ZQ&kO1G2iO$:eQqO1G2kOOQ(C]1G2S1G2SO$:lQ`O'#I_O$:zQ`O,5@SO$:zQ`O,5@SO$;SQ`O,5@SO$;_Q`O,5@SOOQO1G2U1G2UO$;mQ&kO1G2TOKhQ&jO1G2TO$;}QMhO'#IaO$<_Q`O,5@TOJRQ&jO,5@TO$<gQqO,5@TOOQ(C]1G2X1G2XOOQ(CW,5<r,5<rOOQ(CW,5<s,5<sO$<qQ`O,5<sO#<uQ`O,5<sO!0`Q!bO,5<rOOQO'#GZ'#GZO$<vQ`O,5<tOOQ(CW,5<v,5<vO$<qQ`O,5<yOOQO,5>|,5>|OOQO-E<`-E<`OOQ(C]1G2]1G2]O!)dQ,UO,5<rO$=OQ`O,5<sO#<zQ`O,5<tO!)dQ,UO,5<sO$=ZQ&kO1G5SO$=eQ&kO1G5SOOQO,5>},5>}OOQO-E<a-E<aOOQP1G.x1G.xO!1cQ,UO,59oO$}QdO,59oO$=rQ`O1G2OOKhQ&jO1G2VO$=wQ(C|O7+'cOOQ(C[7+'c7+'cOHRQdO7+'cOOQ(C[7+%^7+%^O$>kQqO'#JjO$(iQ`O7+(XO$>uQ`O7+(XO$>}QqO7+(XO$?XQ(CyO'#ChO$?lQ(CyO,5<wO$@^Q`O,5<wOOQ(CW1G5P1G5POOQS7+$_7+$_O;dQ`O7+$_O!0`Q!bO7+$_OHRQdO7+&UO$@cQ`O'#IjO$@tQ`O,5@[OOQO1G3Z1G3ZO6tQ`O,5@[O$@tQ`O,5@[O$@|Q`O,5@[OOQO,5?V,5?VOOQO-E<i-E<iOOQ(C[7+&y7+&yO$ARQ`O7+(tO6lQ(ChO7+(tO6tQ`O7+(tO$AWQ`O7+(tO$A]Q`O,5;TOOQ(CW,5?P,5?POOQ(CW-E<c-E<cOOQS7+(c7+(cO$AbQ(CyO7+(`OJRQ&jO7+(`O$AlQqO7+(aOOQS7+(a7+(aOJRQ&jO7+(aO$AsQ`O'#JmO$BOQ`O,5=_OOQO,5?R,5?ROOQO-E<e-E<eOOQS7+(f7+(fO$CUQ,UO'#G|OOQS1G3R1G3ROJRQ&jO1G3RO$}QdO1G3ROJRQ&jO1G3RO$C]QaO1G3RO$CkQ&kO1G3RO6lQ(ChO1G3UO#=PQ`O1G3UO6bQ`O1G3UO!0`Q!bO1G3UO!0hQ&jO1G3UO$C|Q`O'#IiO$DXQ`O,5@YO$DaQ,UO,5@YOOQ(CW1G3V1G3VOOQS7+$U7+$UO$DiQ`O7+$UO6lQ(ChO7+$UO$DnQ`O7+$UO$}QdO1G5wO$}QdO1G5xO$DsQdO1G3^O$DzQ`O1G3^O$EPQdO1G3^O$EWQ(ChO1G5wOOQS7+(v7+(vO6lQ(ChO7+)QO`QdO7+)SOOQS'#Js'#JsOOQS'#Il'#IlO$EbQdO,5>ROOQS,5>R,5>RO$}QdO'#HhO$EoQ`O'#HjOOQS,5>X,5>XO8YQ`O,5>XOOQS,5>Z,5>ZOOQS7+)]7+)]OOQS7+)c7+)cOOQS7+)g7+)gOOQS7+)i7+)iO$EtQ!bO1G5[O$FYQ!LUO1G0oO$FdQ`O1G0oOOQO1G/k1G/kO$FoQ!LUO1G/kO$FyQ`O,5?pO;dQ`O1G/kOMqQdO'#DeOOQO,5>n,5>nOOQO-E<Q-E<QOOQO,5>t,5>tOOQO-E<W-E<WO!0`Q!bO1G/kO$GOQ7[O,5:lO$HOQ(DjO,5:vO$%_Q,UO,5:kO$HjQ,UO,5:kO$HwQ,UO,5:kO$IXQ,UO,5:vO$IrQ,UO,5:vO$%_Q,UO,5:vO;dQ`O,5:kOOQO,5:v,5:vO$}QdO,5:vO$JcQ(ChO,5:vO$JnQ(ChO,5:vO!0`Q!bO,5:kOOQO-E<T-E<TOOQ(C[1G0U1G0UOOQO,5:|,5:|O$J|Q(ChO,5:vOOQ(C[7+%m7+%mO$(iQ`O7+%mO$(nQqO7+%mOOQ(C[7+&T7+&TO;dQ`O7+&TO!0`Q!bO7+&TO$KbQ`O7+*|O$KbQ`O7+*|O$KjQ(C|O7+*}O$}QdO7+*}OOQO1G4a1G4aO8YQ`O1G4aO$KzQ`O1G4aOOQO7+%v7+%vO$(iQ`O<<KsO$LYQ`O<<KsO$LbQqO<<KsOOQS<<Ks<<KsOJRQ&jO<<KsO$}QdO<<KsOJRQ&jO<<KsO$LlQaO<<KsO$LzQ(C}O1G2gO% VQ(C}O1G2iO%#bQ(C}O1G2TO%%sQ&kO,5>oOOQO-E<R-E<RO%%}QtO,5>pO$}QdO,5>pOOQO-E<S-E<SO%&XQ`O1G5^OOQ(C[<<Iy<<IyO%&aQ!LUO1G0jO%(kQ!LUO1G0tO%(rQ!LUO1G0tO%*vQ!LUO1G0tO%*}Q!LUO1G0tO%,rQ!LUO1G0tO%-YQ!LUO1G0tO%/mQ!LUO1G0tO%/tQ!LUO1G0tO%1xQ!LUO1G0tO%2PQ!LUO1G0tO%3wQ!LUO1G0tO%4[Q(C|O<<J]O%5aQ!LVO1G0tO%7VQ!LVO'#I}O%7aQ!LUO1G1YOMqQdO'#FhOOQO'#Jf'#JfOOQO1G1l1G1lO%7nQ`O1G1kO%7sQ!LUO,5>xOOOO7+'_7+'_OOOW1G/S1G/SOOQ(C]1G4f1G4fOKhQ&jO7+(VO%7}Q`O,5>yO6tQ`O,5>yOOQO-E<]-E<]O%8]Q`O1G5nO%8]Q`O1G5nO%8eQ`O1G5nO%8pQ&kO7+'oO%9QQqO,5>{O%9[Q`O,5>{OJRQ&jO,5>{OOQO-E<_-E<_O%9aQqO1G5oO%9kQ`O1G5oOOQ(CW1G2_1G2_O$<qQ`O1G2_OOQ(CW1G2^1G2^O%9sQ`O1G2`OJRQ&jO1G2`OOQ(CW1G2e1G2eO!0`Q!bO1G2^O#<uQ`O1G2_O%9xQ`O1G2`O%:QQ`O1G2_OKhQ&jO7+*nOOQ(C]1G/Z1G/ZO%:]Q`O1G/ZOOQ(C]7+'j7+'jO%:bQ&kO7+'qO%:rQ(C|O<<J}OOQ(C[<<J}<<J}OJRQ&jO'#IdO%;fQ`O,5@UOJRQ&jO1G2cOOQS<<Gy<<GyO;dQ`O<<GyO%;nQ(C|O<<IpOOQ(C[<<Ip<<IpOOQO,5?U,5?UO%<bQ`O,5?UO%<gQ`O,5?UOOQO-E<h-E<hO%<oQ`O1G5vO%<oQ`O1G5vO6tQ`O1G5vO%<wQ`O<<L`OOQS<<L`<<L`O%<|Q`O<<L`O6lQ(ChO<<L`O%=RQ`O1G0oOOQS<<Kz<<KzO$AbQ(CyO<<KzOOQS<<K{<<K{O$AlQqO<<K{O%=WQ,UO'#IfO%=cQ`O,5@XOMqQdO,5@XOOQS1G2y1G2yO%=kQ(DjO'#JUO%>VQdO'#JUO%>^Q,UO'#E[O%>tQ(ChO'#E[O$$sQ(DjO'#E[O$%hQ,UO'#G}OOQO'#Ih'#IhO%?YQ,UO,5=hOOQS,5=h,5=hO%?aQ,UO'#E[O%?rQ,UO'#E[O%@YQ,UO'#E[O%@vQ,UO'#G}O%AXQ`O7+(mO%A^Q`O7+(mO%AfQqO7+(mOOQS7+(m7+(mOJRQ&jO7+(mO$}QdO7+(mOJRQ&jO7+(mO%ApQaO7+(mOOQS7+(p7+(pO6lQ(ChO7+(pO#=PQ`O7+(pO6bQ`O7+(pO!0`Q!bO7+(pO%BOQ`O,5?TOOQO-E<g-E<gOOQO'#HQ'#HQO%BZQ`O1G5tO6lQ(ChO<<GpOOQS<<Gp<<GpO%BcQ`O<<GpO%BhQ`O7++cO%BmQ`O7++dOOQS7+(x7+(xO%BrQ`O7+(xO%BwQdO7+(xO%COQ`O7+(xO$}QdO7++cO$}QdO7++dOOQS<<Ll<<LlOOQS<<Ln<<LnOOQS-E<j-E<jOOQS1G3m1G3mO%CTQ`O,5>SOOQS,5>U,5>UO%CYQ`O1G3sO8YQ`O7+&ZOMqQdO7+&ZOOQ(CW1G5[1G5[OOQO7+%V7+%VO%C_Q!LUO1G5fO;dQ`O7+%VO;dQ`O1G0VOOQO1G0b1G0bO$}QdO1G0bO%CiQ(ChO1G0bO%CtQ(ChO1G0bO!0`Q!bO1G0VO$%_Q,UO1G0VO%DSQ,UO1G0VO%DaQ(DjO1G0bO%D{Q,UO1G0VO$%_Q,UO1G0bO%E]Q,UO1G0bO%EvQ(ChO1G0bOOQO1G0V1G0VO%F[Q(C|O1G0bOOQ(C[<<IX<<IXOOQ(C[<<Io<<IoO;dQ`O<<IoO%FfQ`O<<NhO%FnQ(C|O<<NiOOQO7+){7+){O8YQ`O7+){OOQSANA_ANA_OJRQ&jOANA_O$(iQ`OANA_O%GOQ`OANA_O%GWQqOANA_O$}QdOANA_OJRQ&jOANA_O%GbQ(C}O7+'oO%IsQ(C}O7+'qO%LUQtO1G4[O%L`Q!LUO7+&UO%MUQ!LVO,59mO& YQ!LVO,5<`O&#aQ!LVO,5<bO&%SQ!LVO,5<pO&&xQ!LUO7+'bO&'VQ!LUO7+'cO&'dQ`O,5<SOOQO7+'V7+'VO&'iQ&kO<<KqOOQO1G4e1G4eO&'pQ`O1G4eO&'{Q`O1G4eO&(ZQ`O7++YO&(ZQ`O7++YOJRQ&jO1G4gO&(cQqO1G4gO&(mQ`O7++ZOOQ(CW7+'y7+'yO$<qQ`O7+'zO&(uQqO7+'zOOQ(CW7+'x7+'xO$<qQ`O7+'yO&(|Q`O7+'zOJRQ&jO7+'zO#<uQ`O7+'yO&)RQ&kO<<NYOOQ(C]7+$u7+$uO&)]QqO,5?OOOQO-E<b-E<bO&)gQ(CyO7+'}OOQSAN=eAN=eO6tQ`O1G4pOOQO1G4p1G4pO&)wQ`O1G4pO&)|Q`O7++bO&)|Q`O7++bO6lQ(ChOANAzO&*UQ`OANAzOOQSANAzANAzOOQSANAfANAfOOQSANAgANAgO&*ZQ`O,5?QOOQO-E<d-E<dO&*fQ!LUO1G5sO#=PQ`O,5=iO6bQ`O,5=iO&,vQtO'#ChO&-QQ,UO,5:vO&-[Q,UO,5:vO!0`Q!bO,5=iOOQO-E<f-E<fOOQS1G3S1G3SO%>VQdO,5<tO%=kQ(DjO,5=iO$HOQ(DjO,5:vO$%hQ,UO,5=iO&-lQ,UO,5=iO&-}Q,UO,5:vOOQS<<LX<<LXOJRQ&jO<<LXO%AXQ`O<<LXO&.eQ`O<<LXO&.mQqO<<LXO$}QdO<<LXOJRQ&jO<<LXOOQS<<L[<<L[O6lQ(ChO<<L[O#=PQ`O<<L[O6bQ`O<<L[O&.wQ,UO1G4oO&/PQ`O7++`OOQSAN=[AN=[O6lQ(ChOAN=[OOQS<<N}<<N}OOQS<= O<= OOOQS<<Ld<<LdO&/XQ`O<<LdO&/^QdO<<LdO&/eQ`O<<N}O&/jQ`O<= OOOQS1G3n1G3nO;dQ`O7+)_O&/oQ`O<<IuO&/zQ!LUO<<IuOOQO<<Hq<<HqOOQO7+%q7+%qO%F[Q(C|O7+%|OOQO7+%|7+%|O$}QdO7+%|O&0UQ(ChO7+%|O;dQ`O7+%qO!0`Q!bO7+%qO$%_Q,UO7+%qO&0aQ(ChO7+%|O&0oQ,UO7+%qO&0|Q(ChO7+%|O&1bQ(DjO7+%|O&1lQ,UO7+%qO$%_Q,UO7+%|OOQ(C[AN?ZAN?ZOOQO<<Mg<<MgO$(iQ`OG26yOOQSG26yG26yOJRQ&jOG26yO&1|Q`OG26yO&2UQqOG26yO&2`Q!LUO<<J]O&2mQ!LVO1G2TO&4wQ!LVO1G2gO&7OQ!LVO1G2iO&8qQ!LUO<<J}O&9OQ!LUO<<IpOOQO1G1n1G1nOKhQ&jOANA]OOQO7+*P7+*PO&9]Q`O7+*PO&9hQ`O<<NtO&9pQqO7+*ROOQ(CW<<Kf<<KfO$<qQ`O<<KfOOQ(CW<<Ke<<KeO&9zQqO<<KfO$<qQ`O<<KeOOQO7+*[7+*[O6tQ`O7+*[O&:RQ`O<<N|OOQSG27fG27fO6lQ(ChOG27fOMqQdO1G4lO&:ZQ`O7++_O6lQ(ChO1G3TO#=PQ`O1G3TO&:cQ,UO1G0bO6bQ`O1G3TO!0`Q!bO1G3TO$%hQ,UO1G3TO%=kQ(DjO1G3TO%DaQ(DjO1G0bO&:mQ,UO1G3TO%AXQ`OANAsOOQSANAsANAsOJRQ&jOANAsO&;OQ`OANAsO&;WQqOANAsOOQSANAvANAvO6lQ(ChOANAvO#=PQ`OANAvOOQO'#HR'#HROOQO7+*Z7+*ZOOQSG22vG22vOOQSANBOANBOO&;bQ`OANBOOOQSANDiANDiOOQSANDjANDjOOQS<<Ly<<LyOMqQdOAN?aOOQO<<Ih<<IhO%F[Q(C|O<<IhO$}QdO<<IhOOQO<<I]<<I]O;dQ`O<<I]O!0`Q!bO<<I]O&;gQ(ChO<<IhO$%_Q,UO<<I]O&;rQ(ChO<<IhO&<QQ,UO<<I]O&<_Q(ChO<<IhOOQSLD,eLD,eO$(iQ`OLD,eOJRQ&jOLD,eO&<sQ!LVO7+'oO&>iQ!LVO7+'qO&@_Q&kOG26wOOQO<<Mk<<MkOOQ(CWANAQANAQO$<qQ`OANAQOOQ(CWANAPANAPOOQO<<Mv<<MvOOQSLD-QLD-QO&@oQ!LUO7+*WOOQO7+(o7+(oO6lQ(ChO7+(oO#=PQ`O7+(oO6bQ`O7+(oO!0`Q!bO7+(oO$%hQ,UO7+(oOOQSG27_G27_O%AXQ`OG27_OJRQ&jOG27_OOQSG27bG27bO6lQ(ChOG27bOOQSG27jG27jO&@yQ!LUOG24{OOQOAN?SAN?SO%F[Q(C|OAN?SOOQOAN>wAN>wO;dQ`OAN>wO$}QdOAN?SO!0`Q!bOAN>wO&ATQ(ChOAN?SO$%_Q,UOAN>wO&A`Q(ChOAN?SOOQS!$(!P!$(!PO$(iQ`O!$(!PO&AnQ(C}OG26wOOQ(CWG26lG26lOOQO<<LZ<<LZO6lQ(ChO<<LZO#=PQ`O<<LZO6bQ`O<<LZO!0`Q!bO<<LZOOQSLD,yLD,yO%AXQ`OLD,yOOQSLD,|LD,|OOQOG24nG24nOOQOG24cG24cO%F[Q(C|OG24nO;dQ`OG24cO$}QdOG24nO!0`Q!bOG24cO&DPQ(ChOG24nOOQS!)9Ek!)9EkO&DmQ7]O,5:zOOQOANAuANAuO6lQ(ChOANAuO#=PQ`OANAuO6bQ`OANAuOOQS!$(!e!$(!eOOQOLD*YLD*YOOQOLD)}LD)}O%F[Q(C|OLD*YO;dQ`OLD)}O$}QdOLD*YO&EpQ!LVOG26wO&GfQ7]O,59mO&HfQ7]O,5<`O&IfQ7]O,5<bO&JfQ7]O,5<pOOQOG27aG27aO6lQ(ChOG27aO#=PQ`OG27aOOQO!$'Mt!$'MtOOQO!$'Mi!$'MiO%F[Q(C|O!$'MtO&KiQ7]O1G2gO&LiQ7]O1G2iO&MiQ7]O1G2TOOQOLD,{LD,{O6lQ(ChOLD,{OOQO!)9C`!)9C`O&NlQ7]O7+'oO' oQ7]O7+'qOOQO!$(!g!$(!gO'!rQ7]OG26wOMqQdO'#DtO.fQ`O'#EQO'#uQtO'#JQOMqQdO'#DlO'#|QtO'#ChO'&dQtO'#ChO'&tQdO,5;OO'(tQ&jO'#E`OMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO,5;YOMqQdO'#I^O'*UQ`O,5<_O'*^Q&jO,5;YO'+nQ&jO,5;YOMqQdO,5;nO.iQ`O'#DRO.iQ`O'#DRO.iQ`O'#DROJRQ&jO'#FtO'(tQ&jO'#FtO'*^Q&jO'#FtOJRQ&jO'#FvO'(tQ&jO'#FvO'*^Q&jO'#FvOJRQ&jO'#GUO'(tQ&jO'#GUO'*^Q&jO'#GUOMqQdO,5?zO'&tQdO1G0jO'+uQ!LUO'#ChOMqQdO1G1vOJRQ&jO,5<{O'(tQ&jO,5<{O'*^Q&jO,5<{OJRQ&jO,5<}O'(tQ&jO,5<}O'*^Q&jO,5<}OJRQ&jO,5<iO'(tQ&jO,5<iO'*^Q&jO,5<iO'&tQdO1G1wOMqQdO7+&qOJRQ&jO1G2TO'(tQ&jO1G2TO'*^Q&jO1G2TOJRQ&jO1G2VO'(tQ&jO1G2VO'*^Q&jO1G2VO'&tQdO7+'cO'&tQdO7+&UO',PQ`O7+'zOJRQ&jOANA]O'(tQ&jOANA]O'*^Q&jOANA]O',PQ`O<<KfO',PQ`OANAQO',UQ`O'#EdO',ZQ`O'#EdO',cQ`O'#FSO',hQ`O'#EnO',mQ`O'#J`O',xQ`O'#J^O'-TQ`O,5;OO'-YQ&kO,5<[O'-aQ`O'#F}O'-fQ`O'#F}O'-kQ`O'#F}O'-pQ`O,5<]O'-xQ`O,5;OO'.QQ!LUO1G1VO'.XQ`O,5<iO'.^Q`O,5<iO'.cQ`O,5<iO'.hQ`O,5<kO'.mQ`O,5<kO'.rQ`O,5<kO'.wQ`O1G1wO'.|Q`O1G0jO'/RQ`O1G2`O'/WQ&kO<<KqO'/_Q&kO<<KqO'/fQ&kO<<KqO'/mQqO7+'zO'/tQ`O7+'zO'/yQqO<<KfO4}Q&jO'#FrO6bQ`O'#FqO={Q`O'#EcOMqQdO,5;kO!(eQ`O'#F}O!(eQ`O'#F}O!(eQ`O'#F}O!(eQ`O'#GPO!(eQ`O'#GPO!(eQ`O'#GPO'0QQ`O,5<tOKhQ&jO7+(VOKhQ&jO7+(VOKhQ&jO7+(VOJRQ&jO1G2`O'0YQ`O1G2`OJRQ&jO7+'zO$:eQqO1G2kO$:eQqO1G2kO$:eQqO1G2kOJRQ&jO,5=POJRQ&jO,5=POJRQ&jO,5=P",stateData:"'1c~O'gOS'hOSTOSUOS~OQUORUOX}O]gO_lObrOcqOigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!VTO!aoO!fVO!iUO!jUO!kUO!lUO!mUO!ppO!uXO#lwO#|tO$QbO%[uO%^xO%`vO%avO%dyO%fzO%i{O%j{O%l|O%y!OO&P!PO&R!QO&T!RO&V!SO&Y!TO&`!UO&f!VO&h!WO&j!XO&l!YO&n!ZO'jQO'rRO'|WO(ZeO~OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!V!]O!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'j![O'rRO'|WO(ZeO~OQ[XZ[X_[Xk[Xx[Xy[X{[X!T[X!c[X!d[X!f[X!l[X#T[X#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'e[X'r[X'}[X(U[X(V[X~O!_$vX~P&}OS!cO'c!dO'd!fO~OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!V!]O!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'j;ZO'rRO'|WO(ZeO~O!S!jO!T!gO!Q'vP!Q(RP~P)jO!U!rO~P`OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!V!]O!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'rRO'|WO(ZeO~O!S!xO!uXO#^!{O#_!xO'j;[O!e(OP~P,RO!f!}O'j!|O~O!p#RO!uXO%[#SO~O#`#TO~O!_#UO#`#TO~OQ#lOZ#sOk#aOx#YOy#ZO{#[O!T#pO!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO#r#iO'rRO'}#jO(U#]O(V#^O~O_'tX'e'tX'a'tX!e'tX!Q'tX!V'tX%]'tX!_'tX~P/WO#T#tO#w#tOQ'uXZ'uX_'uXk'uXx'uXy'uX{'uX!T'uX!c'uX!d'uX!f'uX!l'uX#c'uX#d'uX#e'uX#f'uX#g'uX#h'uX#i'uX#j'uX#m'uX#o'uX#q'uX#r'uX'r'uX'}'uX(U'uX(V'uX~O#k'uX'e'uX'a'uX!Q'uX!e'uXo'uX!V'uX%]'uX!_'uX~P1nO#T#tO~O$S#vO$U#uO$]#{O~O!V#|O$QbO$`#}O$b$PO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv$fO{$[O!V$]O!a$kO!f$XO#_$lO#|$iO$i$gO$k$hO$n$jO'j$RO'n$bO'r$UOe'oP~O!f$mO~O!_$oO~O_$pO'e$pO~O'j$tO~O!f$mO'j$tO'k$vO'n$bO~Oc$|O!f$mO'j$tO~O#k#cO~O]%VOx%RO!V%OO!f%QO%^%UO'j$tO'k$vO^(cP~O!p#RO~O{%WO!V%XO'j$tO~O{%WO!V%XO%f%]O'j$tO~O'j%^O~O#lwO%^xO%`vO%avO%dyO%fzO%i{O%j{O~Ob%gOc%fO!p%dO%[%eO%n%cO~P8xOb%jOcqO!V%iO!ppO!uXO#lwO%[uO%`vO%avO%dyO%fzO%i{O%j{O%l|O~O`%mO#T%pO%^%kO'k$vO~P9wO!f%qO!i%uO~O!f!}O~O!VTO~O_$pO'b%}O'e$pO~O_$pO'b&QO'e$pO~O_$pO'b&SO'e$pO~O'a[Xo[X!Q[X!e[X%}[X!V[X%][X!_[X~P&}O]&XOl&XO{&WO!S&[O!Y&bO!Z&ZO![&ZO'k$vO's&UO!U'wP!U(TP~OP&fO!V&cO!q&eO'j$tO~Oc&kO!f$mO'j$tO~Ox%RO!f%QO~OS!cO'c!dO'd&nO~O!S&pO!Q&uX!Q&{X!T&uX!T&{X~P)jO!T&rO!Q'vX~OQ#lOZ#sOk#aOx#YOy#ZO{#[O!T&rO!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO#r#iO'rRO'}#jO(U#]O(V#^O~O!Q'vX~P?WO!Q&wO~O!Q(QX!T(QX!_(QX!e(QX'}(QX~O#T(QX#`#XX!U(QX~PA^O#T&xO!Q(SX!T(SX~O!T&yO!Q(RX~O!Q&|O~O#T#tO~PA^O!U&}O~P`Ox#YOy#ZO{#[O!d#WO!f#XO'rROQ!haZ!hak!ha!T!ha!c!ha!l!ha#c!ha#d!ha#e!ha#f!ha#g!ha#h!ha#i!ha#j!ha#k!ha#m!ha#o!ha#q!ha#r!ha'}!ha(U!ha(V!ha~O_!ha'e!ha'a!ha!Q!ha!e!hao!ha!V!ha%]!ha!_!ha~PBtO!e'OO~O{%WO!V%XO!uXO#^'RO#_'QO'j$tO~O!_#UO#T'TO'}'SO!T(PX_(PX'e(PX~O!e(PX~PExO!T'WO!e(OX~O!e'YO~O{%WO!V%XO#_'QO'j$tO~Ox'ZOy'[O!d#WO!f#XO!u!ta{!ta~O!p!ta%[!ta!V!ta#^!ta#_!ta'j!ta~PGQO!p'`O~OQUORUO]gOb!aOc!`OigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!VTO!aoO!fVO!iUO!jUO!kUO!lUO!mUO!p!_O#|!bO$QbO'j![O'rRO'|WO(ZeO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;oO{$[O!V$]O!a=`O!f$XO#_;xO#|$iO$i;rO$k;uO$n$jO'j'dO'n$bO'r$UO~O#`'fO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv$fO{$[O!V$]O!a$kO!f$XO#_$lO#|$iO$i$gO$k$hO$n$jO'j'dO'n$bO'r$UO~Oe'yP~PKhO!S'jO!e'zP~P$}O's'lO'|WO~O{'nO!f#XO's'lO'|WO~OQ;VOR;VO]gOb=ZOc!`OigOk;VOlgOmgOrgOt;VOv;VO{SO!OgO!PgO!V!]O!a;YO!fVO!i;VO!j;VO!k;VO!l;VO!m;VO!p!_O#|!bO$QbO'j'|O'rRO'|WO(Z=XO~Oy(PO!f#XO~O!T#pO_$ga'e$ga'a$ga!e$ga!Q$ga!V$ga%]$ga!_$ga~O#l(TO~PJROx(WO!_(VO!V$TX$P$TX$S$TX$U$TX$]$TX~O!_(VO!V(WX$P(WX$S(WX$U(WX$](WX~Ox(WO~P!#WOx(WO!V(WX$P(WX$S(WX$U(WX$](WX~O!V(YO$P(^O$S(XO$U(XO$](_O~O!S(bO~PMqO$S#vO$U#uO$](eO~OP$oXx$oX{$oX!d$oX(U$oX(V$oX~OPgXegXe$oX!TgX#TgX~P!$|Ol(gO~OS(hO'c(iO'd(kO~OP(tOx(mO{(nO(U(pO(V(rO~Oe(lO~P!&VOe(uO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;oO{$[O!V$]O!a=`O!f$XO#_;xO#|$iO$i;rO$k;uO$n$jO'n$bO'r$UO~O!S(yO'j(vO!e([P~P!&tO#`({O~O!f(|O~O!S)RO'j)OO!Q(]P~P!&tOk)`O{)WO!Y)^O!Z)VO![)VO!f(|O#P)_O%S)YO'k$vO's)TO~O!U)]O~P!(wO!d#WOP'qXx'qX{'qX(U'qX(V'qX!T'qX#u'qX!U'qX~Oe'qX#T'qX]'qXl'qX!Y'qX!Z'qX!['qX!u'qX!y'qX!z'qX!{'qX#P'qX#Q'qX'k'qX's'qX'|'qX~P!)pOP)cO#T)bOe'pX!T'pX~O!T)dOe'oX~O'j%^Oe'oP~O!f)kO~O'j'dO~O{%WO!S!xO!V%XO!uXO#^!{O#_!xO'j$tO!e(OP~O!_#UO#`)oO~OQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO#r#iO'rRO'}#jO(U#]O(V#^O~O_!`a!T!`a'e!`a'a!`a!Q!`a!e!`ao!`a!V!`a%]!`a!_!`a~P!-ROP)wO!V&cO!q)vO%])uO'n$bO~O!_)yO!V'mX_'mX!T'mX'e'mX~O!f$mO'n$bO~O!f$mO'j$tO'n$bO~O!_#UO#`'fO~O]*UO%^*VO'j*RO!U(dP~O!T*WO^(cX~O's'lO~OZ*[O~O^*]O~O!V%OO'j$tO'k$vO^(cP~O{%WO!S*aO!T&yO!V%XO'j$tO!Q(RP~O]&_Ol&_O{*cO!S*bO's'lO~O!U(TP~P!2fO!T*dO_(`X'e(`X~O#T*hO'n$bO~OP*kO!V$]O'n$bO~O!V*mO~Ox*oO!VTO~O!p*tO~Oc*yO~O'j!|O!U(bP~Oc$|O~O%^xO'j%^O~P9wOZ+PO^+OO~OQUORUO]gObrOcqOigOkUOlgOmgOrgOtUOvUO{SO!OgO!PgO!aoO!fVO!iUO!jUO!kUO!lUO!mUO!ppO!uXO$QbO%[uO'rRO'|WO(ZeO~O!V!]O#|!bO'j![O~P!4vO^+OO_$pO'e$pO~O_+TO#l+VO%`+VO%a+VO~P$}O!f%qO~O&P+[O~O!V+^O~O&b+`O&d+aOQ&_aR&_aX&_a]&_a_&_ab&_ac&_ai&_ak&_al&_am&_ar&_at&_av&_a{&_a!O&_a!P&_a!V&_a!a&_a!f&_a!i&_a!j&_a!k&_a!l&_a!m&_a!p&_a!u&_a#l&_a#|&_a$Q&_a%[&_a%^&_a%`&_a%a&_a%d&_a%f&_a%i&_a%j&_a%l&_a%y&_a&P&_a&R&_a&T&_a&V&_a&Y&_a&`&_a&f&_a&h&_a&j&_a&l&_a&n&_a'a&_a'j&_a'r&_a'|&_a(Z&_a!U&_a&W&_a`&_a&]&_a~O'j+fO~O!TzX!T!]X!UzX!U!]X!_zX!_!]X!f!]X#TzX'n!]X~O!_+kO#T+jO!T#]X!T'xX!U#]X!U'xX!_'xX!f'xX'n'xX~O!_+mO!f$mO'n$bO!T!XX!U!XX~O]&VOl&VO{+nO's)TO~OQ;VOR;VO]gOb=ZOc!`OigOk;VOlgOmgOrgOt;VOv;VO{SO!OgO!PgO!V!]O!a;YO!fVO!i;VO!j;VO!k;VO!l;VO!m;VO!p!_O#|!bO$QbO'rRO'|WO(Z=XO~O'j;}O~P!>SO!T+rO!U'wX~O!U+tO~O!_+kO#T+jO!T#]X!U#]X~O!T+uO!U(TX~O!U+wO~O]&VOl&VO{+nO'k$vO's)TO~O!Z+xO![+xO~P!AQO_+}O!U,PO!Y,QO!Z+|O![+|O!u;WO!y,UO!z,SO!{,TO!|,RO#P,VO#Q,VO'|+zO~P!AQOP,[O!V&cO!q,ZO~Oo,aO~O!Q&ua!T&ua~P!-RO!S,eO!Q&uX!T&uX~P$}O!T&rO!Q'va~O!Q'va~P?WO!T&yO!Q(Ra~O{%WO!S,iO!V%XO'j$tO!Q&{X!T&{X~O!T'WO!e(Oa~O{%WO!V%XO#_,lO'j$tO~O#T,nO!T(Pa!e(Pa_(Pa'e(Pa~O!_#UO~P!DvO{%WO!S,qO!V%XO!uXO#^,sO#_,qO'j$tO!T&}X!e&}X~Oy,wO!f#XO~OP,{O!V&cO!q,zO%],yO'n$bO~O_#Wi!T#Wi'e#Wi'a#Wi!Q#Wi!e#Wio#Wi!V#Wi%]#Wi!_#Wi~P!-ROP=mOx(mO{(nO(U(pO(V(rO~O#`#Sa!T#Sa!e#Sa#T#Sa!V#Sa_#Sa'e#Sa!Q#Sa~P!G[O!d#WOP'qXx'qX{'qX(U'qX(V'qXQ'qXZ'qXk'qXy'qX!T'qX!c'qX!f'qX!l'qX#c'qX#d'qX#e'qX#f'qX#g'qX#h'qX#i'qX#j'qX#k'qX#m'qX#o'qX#q'qX#r'qX'r'qX'}'qX~O#`'qX_'qX'e'qX!e'qX!Q'qX'a'qX!V'qX#T'qXo'qX%]'qX!_'qX~P!HZO!T-UOe'yX~P!&VOe-WO~O!T-XO!e'zX~P!-RO!e-[O~O!Q-^O~OQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO'rROZ#bi_#bik#bi!T#bi!c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi'e#bi'}#bi(U#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~O#c#bi~P!KrO#c#_O~P!KrOQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O'rROZ#bi_#bi!T#bi!c#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi'e#bi'}#bi(U#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~Ok#bi~P!NdOk#aO~P!NdOQ#lOk#aOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO'rRO_#bi!T#bi#m#bi#o#bi#q#bi#r#bi'e#bi'}#bi(U#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~OZ#bi!c#bi#h#bi#i#bi#j#bi#k#bi~P##UOZ#sO!c#cO#h#cO#i#cO#j#rO#k#cO~P##UOQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO'rRO_#bi!T#bi#o#bi#q#bi#r#bi'e#bi'}#bi(V#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~O(U#bi~P#&VO(U#]O~P#&VOQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO'rRO(U#]O_#bi!T#bi#q#bi#r#bi'e#bi'}#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~O(V#bi~P#(wO(V#^O~P#(wOQ#lOZ#sOk#aOx#YOy#ZO{#[O!c#cO!d#WO!f#XO!l#lO#c#_O#d#`O#e#`O#f#`O#g#bO#h#cO#i#cO#j#rO#k#cO#m#dO#o#fO#q#hO'rRO(U#]O(V#^O~O_#bi!T#bi#r#bi'e#bi'}#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~P#+iOQ[XZ[Xk[Xx[Xy[X{[X!c[X!d[X!f[X!l[X#T[X#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'r[X'}[X(U[X(V[X!T[X!U[X~O#u[X~P#.SOQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO#o;fO#q;hO#r;iO'rRO'}#jO(U#]O(V#^O~O#u-`O~P#0aOQ'uXZ'uXk'uXx'uXy'uX{'uX!c'uX!d'uX!f'uX!l'uX#c'uX#d'uX#e'uX#f'uX#g'uX#h'uX#i'uX#j'uX#m'uX#o'uX#q'uX#r'uX'r'uX'}'uX(U'uX(V'uX!T'uX~O#T;nO#w;nO#k'uX#u'uX!U'uX~P#2_O_'Qa!T'Qa'e'Qa'a'Qa!e'Qao'Qa!Q'Qa!V'Qa%]'Qa!_'Qa~P!-ROQ#biZ#bi_#bik#biy#bi!T#bi!c#bi!d#bi!f#bi!l#bi#c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi'e#bi'r#bi'}#bi'a#bi!Q#bi!e#bio#bi!V#bi%]#bi!_#bi~P!G[O_#vi!T#vi'e#vi'a#vi!Q#vi!e#vio#vi!V#vi%]#vi!_#vi~P!-RO$S-cO$U-cO~O$S-dO$U-dO~O!_(VO#T-eO!V$YX$P$YX$S$YX$U$YX$]$YX~O!S-fO~O!V(YO$P-hO$S(XO$U(XO$]-iO~O!T;jO!U'tX~P#0aO!U-jO~O$]-lO~OS(hO'c(iO'd-oO~O]-rOl-rO!Q-sO~O!TdX!_dX!edX!e$oX'}dX~P!$|O!e-yO~P!G[O!T-zO!_#UO'}'SO!e([X~O!e.PO~O!S(yO'j$tO!e([P~O#`.RO~O!Q$oX!T$oX!_$vX~P!$|O!T.SO!Q(]X~P!G[O!_.UO~O!Q.WO~Ok.[O!_#UO!f$mO'n$bO'}'SO~O'j.^O~O!_)yO~O_$pO!T.bO'e$pO~O!U.dO~P!(wO!Z.eO![.eO'k$vO's)TO~O{.gO's)TO~O#P.hO~O'j%^Oe'VX!T'VX~O!T)dOe'oa~Oe.mO~Ox.nOy.nO{.oOPua(Uua(Vua!Tua#Tua~Oeua#uua~P#>mOx(mO{(nOP$ha(U$ha(V$ha!T$ha#T$ha~Oe$ha#u$ha~P#?cOx(mO{(nOP$ja(U$ja(V$ja!T$ja#T$ja~Oe$ja#u$ja~P#@UO].pO~O#`.qO~Oe$xa!T$xa#T$xa#u$xa~P!&VO#`.tO~OP,{O!V&cO!q,zO%],yO~O]$SOk$TOl$SOm$SOr$dOt$eOv;oO{$[O!V$]O!a=`O!f$XO#_;xO#|$iO$i;rO$k;uO$n$jO'n$bO'r$UO~Oi.{O'j.zO~P#AvO!_)yO!V'ma_'ma!T'ma'e'ma~O#`/RO~OZ[X!TdX!UdX~O!T/SO!U(dX~O!U/UO~OZ/VO~O]/XO'j*RO~O!V%OO'j$tO^'_X!T'_X~O!T*WO^(ca~O!e/[O~P!-RO]/^O~OZ/_O~O^/`O~O!T*dO_(`a'e(`a~O#T/fO~OP/iO!V$]O~O's'lO!U(aP~OP/sO!V/oO!q/rO%]/qO'n$bO~OZ/}O!T/{O!U(bX~O!U0OO~O^0QO_$pO'e$pO~O]0RO~O]0SO'j!|O~O#k0TO%}0UO~P1nO#T#tO#k0TO%}0UO~O_0VO~P$}O_0XO~O&W0]OQ&UiR&UiX&Ui]&Ui_&Uib&Uic&Uii&Uik&Uil&Uim&Uir&Uit&Uiv&Ui{&Ui!O&Ui!P&Ui!V&Ui!a&Ui!f&Ui!i&Ui!j&Ui!k&Ui!l&Ui!m&Ui!p&Ui!u&Ui#l&Ui#|&Ui$Q&Ui%[&Ui%^&Ui%`&Ui%a&Ui%d&Ui%f&Ui%i&Ui%j&Ui%l&Ui%y&Ui&P&Ui&R&Ui&T&Ui&V&Ui&Y&Ui&`&Ui&f&Ui&h&Ui&j&Ui&l&Ui&n&Ui'a&Ui'j&Ui'r&Ui'|&Ui(Z&Ui!U&Ui`&Ui&]&Ui~O`0cO!U0aO&]0bO~P`O!VTO!f0eO~O&d+aOQ&_iR&_iX&_i]&_i_&_ib&_ic&_ii&_ik&_il&_im&_ir&_it&_iv&_i{&_i!O&_i!P&_i!V&_i!a&_i!f&_i!i&_i!j&_i!k&_i!l&_i!m&_i!p&_i!u&_i#l&_i#|&_i$Q&_i%[&_i%^&_i%`&_i%a&_i%d&_i%f&_i%i&_i%j&_i%l&_i%y&_i&P&_i&R&_i&T&_i&V&_i&Y&_i&`&_i&f&_i&h&_i&j&_i&l&_i&n&_i'a&_i'j&_i'r&_i'|&_i(Z&_i!U&_i&W&_i`&_i&]&_i~O!Q0kO~O!T!Xa!U!Xa~P#0aO!S0rO!Y&bO!Z&ZO![&ZO!T&vX!U&vX~P!AQO!T+rO!U'wa~O!T&|X!U&|X~P!2fO!T+uO!U(Ta~O!Y0{O!Z0zO![0zO!u;WO!y1OO!z0}O!{0}O!|0|O#P1PO#Q1PO'|+zO~P!AQO_$pO!_#UO!f$mO!l1UO#T1SO'e$pO'n$bO'}'SO~O]&VOl&VO{+nO's)TO'|+zO~O_+}O!U1XO!Y,QO!Z+|O![+|O!u;WO!y,UO!z,SO!{,TO!|,RO#P,VO#Q,VO'|+zO~P!AQO!Z0zO![0zO'|+zO~P!AQO!Y0{O!Z0zO![0zO'|+zO~P!AQO!VTO!Y0{O!Z0zO![0zO!|0|O#P1PO#Q1PO'|+zO~P!AQO!Y0{O!Z0zO![0zO!z0}O!{0}O!|0|O#P1PO#Q1PO'|+zO~P!AQO!V&cO~O!V&cO~P!G[O!T#pOo$ga~O!Q&ui!T&ui~P!-RO!T&rO!Q'vi~O!T&yO!Q(Ri~O!Q(Si!T(Si~P!-RO!T'WO!e(Oi~O!T(Pi!e(Pi_(Pi'e(Pi~P!-RO#T1eO!T(Pi!e(Pi_(Pi'e(Pi~O{%WO!V%XO!uXO#^1hO#_1gO'j$tO~O{%WO!V%XO#_1gO'j$tO~OP1pO!V&cO!q1oO%]1nO~OP1pO!V&cO!q1oO%]1nO'n$bO~O#`uaQuaZua_uakua!cua!dua!fua!lua#cua#dua#eua#fua#gua#hua#iua#jua#kua#mua#oua#qua#rua'eua'rua'}ua!eua!Qua'aua!Vuaoua%]ua!_ua~P#>mO#`$haQ$haZ$ha_$hak$hay$ha!c$ha!d$ha!f$ha!l$ha#c$ha#d$ha#e$ha#f$ha#g$ha#h$ha#i$ha#j$ha#k$ha#m$ha#o$ha#q$ha#r$ha'e$ha'r$ha'}$ha!e$ha!Q$ha'a$ha!V$hao$ha%]$ha!_$ha~P#?cO#`$jaQ$jaZ$ja_$jak$jay$ja!c$ja!d$ja!f$ja!l$ja#c$ja#d$ja#e$ja#f$ja#g$ja#h$ja#i$ja#j$ja#k$ja#m$ja#o$ja#q$ja#r$ja'e$ja'r$ja'}$ja!e$ja!Q$ja'a$ja!V$jao$ja%]$ja!_$ja~P#@UO#`$xaQ$xaZ$xa_$xak$xay$xa!T$xa!c$xa!d$xa!f$xa!l$xa#c$xa#d$xa#e$xa#f$xa#g$xa#h$xa#i$xa#j$xa#k$xa#m$xa#o$xa#q$xa#r$xa'e$xa'r$xa'}$xa!e$xa!Q$xa'a$xa!V$xa#T$xao$xa%]$xa!_$xa~P!G[O_#Wq!T#Wq'e#Wq'a#Wq!Q#Wq!e#Wqo#Wq!V#Wq%]#Wq!_#Wq~P!-ROe&wX!T&wX~PKhO!T-UOe'ya~O!S1xO!T&xX!e&xX~P$}O!T-XO!e'za~O!T-XO!e'za~P!-RO!Q1{O~O#u!ha!U!ha~PBtO#u!`a!T!`a!U!`a~P#0aO!V2^O$QbO$Z2_O~O!U2cO~Oo2dO~P!G[O_$dq!T$dq'e$dq'a$dq!Q$dq!e$dqo$dq!V$dq%]$dq!_$dq~P!-RO!Q2eO~O]-rOl-rO~Ox(mO{(nO(V(rOP%Ti(U%Ti!T%Ti#T%Ti~Oe%Ti#u%Ti~P$9POx(mO{(nOP%Vi(U%Vi(V%Vi!T%Vi#T%Vi~Oe%Vi#u%Vi~P$9rO'}#jO~P!G[O!S2hO'j$tO!T'RX!e'RX~O!T-zO!e([a~O!T-zO!_#UO!e([a~O!T-zO!_#UO'}'SO!e([a~Oe$qi!T$qi#T$qi#u$qi~P!&VO!S2pO'j)OO!Q'TX!T'TX~P!&tO!T.SO!Q(]a~O!T.SO!Q(]a~P!G[O!_#UO~O!_#UO#k2xO~Ok2{O!_#UO'}'SO~Oe'pi!T'pi~P!&VO#T3OOe'pi!T'pi~P!&VO!e3RO~O_$eq!T$eq'e$eq'a$eq!Q$eq!e$eqo$eq!V$eq%]$eq!_$eq~P!-RO!T3VO!V(^X~P!G[O!V&cO%]1nO~O!V&cO%]1nO~P!G[O!V$oX%Q[X_$oX!T$oX'e$oX~P!$|O%Q3XOPhXxhX{hX!VhX(UhX(VhX_hX!ThX'ehX~O%Q3XO~O]3_O%^3`O'j*RO!T'^X!U'^X~O!T/SO!U(da~OZ3dO~O^3eO~O]3hO~O!Q3iO~O_$pO'e$pO~P!G[O!V$]O~P!G[O!T3nO#T3pO!U(aX~O!U3qO~O]&VOl&VO{3sO!Y4OO!Z3wO![3wO!u;WO!y3}O!z3|O!{3|O#P3{O#Q,VO'k$vO's)TO'|+zO~O!U3zO~P$BTOP4VO!V/oO!q4UO%]4TO~OP4VO!V/oO!q4UO%]4TO'n$bO~O'j!|O!T']X!U']X~O!T/{O!U(ba~O]4aO's4`O~O]4bO~O^4dO~O!e4gO~P$}O_4iO~O_4iO~P$}O#k4kO%}4lO~PExO`0cO!U4pO&]0bO~P`O!_4rO~O!_4tO!T'xi!U'xi!_'xi!f'xi'n'xi~O!T#]i!U#]i~P#0aO#T4uO!T#]i!U#]i~O!T!Xi!U!Xi~P#0aO!Q4vO~O]!tal!ta!Y!ta!Z!ta![!ta!y!ta!z!ta!{!ta!|!ta#P!ta#Q!ta'k!ta's!ta'|!ta~PGQO_$pO!_#UO!f$mO!l5OO#T4|O'e$pO'n$bO'}'SO~O!Z5QO![5QO'|+zO~P!AQO!Y5RO!Z5QO![5QO'|+zO~P!AQO!Y5RO!Z5QO![5QO!|5TO#P5UO#Q5UO'|+zO~P!AQO!Y5RO!Z5QO![5QO!z5VO!{5VO!|5TO#P5UO#Q5UO'|+zO~P!AQO_$pO#T4|O'e$pO~O_$pO!_#UO#T4|O'e$pO~O_$pO!_#UO!l5OO#T4|O'e$pO'}'SO~O!T'WO!e(Oq~O!T(Pq!e(Pq_(Pq'e(Pq~P!-RO{%WO!V%XO#_5aO'j$tO~O!V&cO%]5cO~O!V&cO%]5cO~P!G[OP5hO!V&cO!q5gO%]5cO~O#`%TiQ%TiZ%Ti_%Tik%Tiy%Ti!c%Ti!d%Ti!f%Ti!l%Ti#c%Ti#d%Ti#e%Ti#f%Ti#g%Ti#h%Ti#i%Ti#j%Ti#k%Ti#m%Ti#o%Ti#q%Ti#r%Ti'e%Ti'r%Ti'}%Ti!e%Ti!Q%Ti'a%Ti!V%Tio%Ti%]%Ti!_%Ti~P$9PO#`%ViQ%ViZ%Vi_%Vik%Viy%Vi!c%Vi!d%Vi!f%Vi!l%Vi#c%Vi#d%Vi#e%Vi#f%Vi#g%Vi#h%Vi#i%Vi#j%Vi#k%Vi#m%Vi#o%Vi#q%Vi#r%Vi'e%Vi'r%Vi'}%Vi!e%Vi!Q%Vi'a%Vi!V%Vio%Vi%]%Vi!_%Vi~P$9rO#`$qiQ$qiZ$qi_$qik$qiy$qi!T$qi!c$qi!d$qi!f$qi!l$qi#c$qi#d$qi#e$qi#f$qi#g$qi#h$qi#i$qi#j$qi#k$qi#m$qi#o$qi#q$qi#r$qi'e$qi'r$qi'}$qi!e$qi!Q$qi'a$qi!V$qi#T$qio$qi%]$qi!_$qi~P!G[Oe&wa!T&wa~P!&VO!T&xa!e&xa~P!-RO!T-XO!e'zi~O#u#Wi!T#Wi!U#Wi~P#0aOQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO'rROZ#bik#bi!c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi#u#bi'}#bi(U#bi(V#bi!T#bi!U#bi~O#c#bi~P%&nO#c;_O~P%&nOQ#lOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O'rROZ#bi!c#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi#u#bi'}#bi(U#bi(V#bi!T#bi!U#bi~Ok#bi~P%(yOk;aO~P%(yOQ#lOk;aOx#YOy#ZO{#[O!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO'rRO#m#bi#o#bi#q#bi#r#bi#u#bi'}#bi(U#bi(V#bi!T#bi!U#bi~OZ#bi!c#bi#h#bi#i#bi#j#bi#k#bi~P%+UOZ;mO!c;cO#h;cO#i;cO#j;lO#k;cO~P%+UOQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO'rRO#o#bi#q#bi#r#bi#u#bi'}#bi(V#bi!T#bi!U#bi~O(U#bi~P%-pO(U#]O~P%-pOQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO#o;fO'rRO(U#]O#q#bi#r#bi#u#bi'}#bi!T#bi!U#bi~O(V#bi~P%/{O(V#^O~P%/{OQ#lOZ;mOk;aOx#YOy#ZO{#[O!c;cO!d#WO!f#XO!l#lO#c;_O#d;`O#e;`O#f;`O#g;bO#h;cO#i;cO#j;lO#k;cO#m;dO#o;fO#q;hO'rRO(U#]O(V#^O~O#r#bi#u#bi'}#bi!T#bi!U#bi~P%2WO_#sy!T#sy'e#sy'a#sy!Q#sy!e#syo#sy!V#sy%]#sy!_#sy~P!-ROP=oOx(mO{(nO(U(pO(V(rO~OQ#biZ#bik#biy#bi!c#bi!d#bi!f#bi!l#bi#c#bi#d#bi#e#bi#f#bi#g#bi#h#bi#i#bi#j#bi#k#bi#m#bi#o#bi#q#bi#r#bi#u#bi'r#bi'}#bi!T#bi!U#bi~P%5OO#u'qX!U'qX~P!HZO#u#vi!T#vi!U#vi~P#0aO!U5tO~O!T'Qa!U'Qa~P#0aO!_#UO'}'SO!T'Ra!e'Ra~O!T-zO!e([i~O!T-zO!_#UO!e([i~Oe$qq!T$qq#T$qq#u$qq~P!&VO!Q'Ta!T'Ta~P!G[O!_5{O~O!T.SO!Q(]i~P!G[O!T.SO!Q(]i~O!Q6PO~O!_#UO#k6UO~Ok6VO!_#UO'}'SO~O!Q6XO~Oe$sq!T$sq#T$sq#u$sq~P!&VO_$ey!T$ey'e$ey'a$ey!Q$ey!e$eyo$ey!V$ey%]$ey!_$ey~P!-RO!T3VO!V(^a~O_#Wy!T#Wy'e#Wy'a#Wy!Q#Wy!e#Wyo#Wy!V#Wy%]#Wy!_#Wy~P!-ROZ6^O~O]6`O'j*RO~O!T/SO!U(di~O]6cO~O^6dO~O!_4tO~O's'lO!T'YX!U'YX~O!T3nO!U(aa~O!f$mO'n$bO_'xX!_'xX!l'xX#T'xX'e'xX'}'xX~O'j6mO~P,RO!u;WO!y6oO!z6nO!{6nO#P1PO#Q1PO~P$%_O_$pO!_#UO!l1UO#T1SO'e$pO'}'SO~O!U6rO~P$BTO]&VOl&VO{6sO's)TO'|+zO~O!Y6wO!Z6vO![6vO#P1PO#Q1PO'|+zO~P!AQO!Y6wO!Z6vO![6vO!z6xO!{6xO#P1PO#Q1PO'|+zO~P!AQO!Z6vO![6vO'k$vO's)TO'|+zO~O!V/oO~O!V/oO%]6zO~O!V/oO%]6zO~P!G[OP7PO!V/oO!q7OO%]6zO~OZ7UO!T']a!U']a~O!T/{O!U(bi~O]7XO~O!e7YO~O!e7ZO~O!e7[O~O!e7[O~P$}O_7^O~O!_7aO~O!e7bO~O!T(Si!U(Si~P#0aO_$pO#T7iO'e$pO~O_$pO!_#UO#T7iO'e$pO~O!Z7mO![7mO'|+zO~P!AQO_$pO!_#UO!f$mO!l7nO#T7iO'e$pO'n$bO'}'SO~O!Y7oO!Z7mO![7mO'|+zO~P!AQO!Y7oO!Z7mO![7mO!|7rO#P7sO#Q7sO'|+zO~P!AQO_$pO!_#UO!l7nO#T7iO'e$pO'}'SO~O_$pO'e$pO~P!-RO!T'WO!e(Oy~O!T(Py!e(Py_(Py'e(Py~P!-RO!V&cO%]7xO~O!V&cO%]7xO~P!G[O#`$qqQ$qqZ$qq_$qqk$qqy$qq!T$qq!c$qq!d$qq!f$qq!l$qq#c$qq#d$qq#e$qq#f$qq#g$qq#h$qq#i$qq#j$qq#k$qq#m$qq#o$qq#q$qq#r$qq'e$qq'r$qq'}$qq!e$qq!Q$qq'a$qq!V$qq#T$qqo$qq%]$qq!_$qq~P!G[O#`$sqQ$sqZ$sq_$sqk$sqy$sq!T$sq!c$sq!d$sq!f$sq!l$sq#c$sq#d$sq#e$sq#f$sq#g$sq#h$sq#i$sq#j$sq#k$sq#m$sq#o$sq#q$sq#r$sq'e$sq'r$sq'}$sq!e$sq!Q$sq'a$sq!V$sq#T$sqo$sq%]$sq!_$sq~P!G[O!T&xi!e&xi~P!-RO#u#Wq!T#Wq!U#Wq~P#0aOx.nOy.nO{.oOPua(Uua(Vua!Uua~OQuaZuakua!cua!dua!fua!lua#cua#dua#eua#fua#gua#hua#iua#jua#kua#mua#oua#qua#rua#uua'rua'}ua!Tua~P%LmOx(mO{(nOP$ha(U$ha(V$ha!U$ha~OQ$haZ$hak$hay$ha!c$ha!d$ha!f$ha!l$ha#c$ha#d$ha#e$ha#f$ha#g$ha#h$ha#i$ha#j$ha#k$ha#m$ha#o$ha#q$ha#r$ha#u$ha'r$ha'}$ha!T$ha~P%NtOx(mO{(nOP$ja(U$ja(V$ja!U$ja~OQ$jaZ$jak$jay$ja!c$ja!d$ja!f$ja!l$ja#c$ja#d$ja#e$ja#f$ja#g$ja#h$ja#i$ja#j$ja#k$ja#m$ja#o$ja#q$ja#r$ja#u$ja'r$ja'}$ja!T$ja~P&!{OQ$xaZ$xak$xay$xa!c$xa!d$xa!f$xa!l$xa#c$xa#d$xa#e$xa#f$xa#g$xa#h$xa#i$xa#j$xa#k$xa#m$xa#o$xa#q$xa#r$xa#u$xa'r$xa'}$xa!T$xa!U$xa~P%5OO#u$dq!T$dq!U$dq~P#0aO#u$eq!T$eq!U$eq~P#0aO!U8RO~O#u8SO~P!&VO!_#UO!T'Ri!e'Ri~O!_#UO'}'SO!T'Ri!e'Ri~O!T-zO!e([q~O!Q'Ti!T'Ti~P!G[O!T.SO!Q(]q~O!Q8YO~P!G[O!Q8YO~Oe'py!T'py~P!&VO!T'Wa!V'Wa~P!G[O!V%Pq_%Pq!T%Pq'e%Pq~P!G[OZ8_O~O!T/SO!U(dq~O]8bO~O#T8cO!T'Ya!U'Ya~O!T3nO!U(ai~P#0aOQ[XZ[Xk[Xx[Xy[X{[X!Q[X!T[X!c[X!d[X!f[X!l[X#T[X#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'r[X'}[X(U[X(V[X~O!_$}X#k$}X~P&*pO#P5UO#Q5UO~P$%_O!z8gO!{8gO#P5UO#Q5UO~P$%_O!Z8jO![8jO'k$vO's)TO'|+zO~O!Y8mO!Z8jO![8jO#P5UO#Q5UO'|+zO~P!AQO!V/oO%]8pO~O!V/oO%]8pO~P!G[O]8wO's8vO~O!T/{O!U(bq~O!e8yO~O!e8yO~P$}O!e8{O~O!e8|O~O#T9OO!T#]y!U#]y~O!T#]y!U#]y~P#0aO_$pO#T9RO'e$pO~O_$pO!_#UO#T9RO'e$pO~O!Z9WO![9WO'|+zO~P!AQO_$pO!_#UO!l9XO#T9RO'e$pO'}'SO~O!f$mO'n$bO~P&0|O!Y9YO!Z9WO![9WO'|+zO~P!AQO!V&cO%]9^O~O!V&cO%]9^O~P!G[O#u#sy!T#sy!U#sy~P#0aOQ$qiZ$qik$qiy$qi!c$qi!d$qi!f$qi!l$qi#c$qi#d$qi#e$qi#f$qi#g$qi#h$qi#i$qi#j$qi#k$qi#m$qi#o$qi#q$qi#r$qi#u$qi'r$qi'}$qi!T$qi!U$qi~P%5OOx(mO{(nO(V(rOP%Ti(U%Ti!U%Ti~OQ%TiZ%Tik%Tiy%Ti!c%Ti!d%Ti!f%Ti!l%Ti#c%Ti#d%Ti#e%Ti#f%Ti#g%Ti#h%Ti#i%Ti#j%Ti#k%Ti#m%Ti#o%Ti#q%Ti#r%Ti#u%Ti'r%Ti'}%Ti!T%Ti~P&4cOx(mO{(nOP%Vi(U%Vi(V%Vi!U%Vi~OQ%ViZ%Vik%Viy%Vi!c%Vi!d%Vi!f%Vi!l%Vi#c%Vi#d%Vi#e%Vi#f%Vi#g%Vi#h%Vi#i%Vi#j%Vi#k%Vi#m%Vi#o%Vi#q%Vi#r%Vi#u%Vi'r%Vi'}%Vi!T%Vi~P&6jO#u$ey!T$ey!U$ey~P#0aO#u#Wy!T#Wy!U#Wy~P#0aO!_#UO!T'Rq!e'Rq~O!T-zO!e([y~O!Q'Tq!T'Tq~P!G[O!Q9dO~P!G[O!T/SO!U(dy~O!T3nO!U(aq~O#P7sO#Q7sO~P$%_O!Z9nO![9nO'k$vO's)TO'|+zO~O!V/oO%]9qO~O!V/oO%]9qO~P!G[O!e9tO~O_$pO#T9zO'e$pO~O_$pO!_#UO#T9zO'e$pO~O!Z9}O![9}O'|+zO~P!AQO_$pO!_#UO!l:OO#T9zO'e$pO'}'SO~OQ$qqZ$qqk$qqy$qq!c$qq!d$qq!f$qq!l$qq#c$qq#d$qq#e$qq#f$qq#g$qq#h$qq#i$qq#j$qq#k$qq#m$qq#o$qq#q$qq#r$qq#u$qq'r$qq'}$qq!T$qq!U$qq~P%5OOQ$sqZ$sqk$sqy$sq!c$sq!d$sq!f$sq!l$sq#c$sq#d$sq#e$sq#f$sq#g$sq#h$sq#i$sq#j$sq#k$sq#m$sq#o$sq#q$sq#r$sq#u$sq'r$sq'}$sq!T$sq!U$sq~P%5OOe%X!Z!T%X!Z#T%X!Z#u%X!Z~P!&VO!T'Yq!U'Yq~P#0aO!T#]!Z!U#]!Z~P#0aO_$pO#T:aO'e$pO~O_$pO!_#UO#T:aO'e$pO~O#`%X!ZQ%X!ZZ%X!Z_%X!Zk%X!Zy%X!Z!T%X!Z!c%X!Z!d%X!Z!f%X!Z!l%X!Z#c%X!Z#d%X!Z#e%X!Z#f%X!Z#g%X!Z#h%X!Z#i%X!Z#j%X!Z#k%X!Z#m%X!Z#o%X!Z#q%X!Z#r%X!Z'e%X!Z'r%X!Z'}%X!Z!e%X!Z!Q%X!Z'a%X!Z!V%X!Z#T%X!Zo%X!Z%]%X!Z!_%X!Z~P!G[O_$pO#T:oO'e$pO~OP=nOx(mO{(nO(U(pO(V(rO~O]#Sal#Sa!U#Sa!Y#Sa!Z#Sa![#Sa!u#Sa!y#Sa!z#Sa!{#Sa#P#Sa#Q#Sa'k#Sa's#Sa'|#Sa~P&D[OQ%X!ZZ%X!Zk%X!Zy%X!Z!c%X!Z!d%X!Z!f%X!Z!l%X!Z#c%X!Z#d%X!Z#e%X!Z#f%X!Z#g%X!Z#h%X!Z#i%X!Z#j%X!Z#k%X!Z#m%X!Z#o%X!Z#q%X!Z#r%X!Z#u%X!Z'r%X!Z'}%X!Z!T%X!Z!U%X!Z~P%5OO]ualua!Yua!Zua![ua!uua!yua!zua!{ua#Pua#Qua'kua'sua'|ua~P%LmO]$hal$ha!Y$ha!Z$ha![$ha!u$ha!y$ha!z$ha!{$ha#P$ha#Q$ha'k$ha's$ha'|$ha~P%NtO]$jal$ja!Y$ja!Z$ja![$ja!u$ja!y$ja!z$ja!{$ja#P$ja#Q$ja'k$ja's$ja'|$ja~P&!{O]$xal$xa!U$xa!Y$xa!Z$xa![$xa!u$xa!y$xa!z$xa!{$xa#P$xa#Q$xa'k$xa's$xa'|$xa~P&D[O]%Til%Ti!Y%Ti!Z%Ti![%Ti!u%Ti!y%Ti!z%Ti!{%Ti#P%Ti#Q%Ti'k%Ti's%Ti'|%Ti~P&4cO]%Vil%Vi!Y%Vi!Z%Vi![%Vi!u%Vi!y%Vi!z%Vi!{%Vi#P%Vi#Q%Vi'k%Vi's%Vi'|%Vi~P&6jO]$qil$qi!U$qi!Y$qi!Z$qi![$qi!u$qi!y$qi!z$qi!{$qi#P$qi#Q$qi'k$qi's$qi'|$qi~P&D[O]$qql$qq!U$qq!Y$qq!Z$qq![$qq!u$qq!y$qq!z$qq!{$qq#P$qq#Q$qq'k$qq's$qq'|$qq~P&D[O]$sql$sq!U$sq!Y$sq!Z$sq![$sq!u$sq!y$sq!z$sq!{$sq#P$sq#Q$sq'k$sq's$sq'|$sq~P&D[O]%X!Zl%X!Z!U%X!Z!Y%X!Z!Z%X!Z![%X!Z!u%X!Z!y%X!Z!z%X!Z!{%X!Z#P%X!Z#Q%X!Z'k%X!Z's%X!Z'|%X!Z~P&D[Oo'tX~P/WO!QdX!TdX#TdX~P&*pOQ[XZ[Xk[Xx[Xy[X{[X!T[X!TdX!c[X!d[X!f[X!l[X#T[X#TdX#`dX#c[X#d[X#e[X#f[X#g[X#h[X#i[X#j[X#k[X#m[X#o[X#q[X#r[X#w[X'r[X'}[X(U[X(V[X~O!_dX!e[X!edX'}dX~P'$ZOQ;VOR;VO]gOb=ZOc!`OigOk;VOlgOmgOrgOt;VOv;VO{SO!OgO!PgO!VTO!a;YO!fVO!i;VO!j;VO!k;VO!l;VO!m;VO!p!_O#|!bO$QbO'j'|O'rRO'|WO(Z=XO~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;pO{$[O!V$]O!a=aO!f$XO#_;yO#|$iO$i;sO$k;vO$n$jO'j'dO'n$bO'r$UO~O!T;jO!U$ga~O]$SOi$cOk$TOl$SOm$SOr$dOt$eOv;qO{$[O!V$]O!a=bO!f$XO#_;zO#|$iO$i;tO$k;wO$n$jO'j'dO'n$bO'r$UO~O#l(TO~P'*^O!U[X!UdX~P'$ZO!_;^O~O#`;]O~O!_#UO#`;]O~O#T;nO~O#k;cO~O#T;{O!T(SX!U(SX~O#T;nO!T(QX!U(QX~O#`;|O~Oe<OO~P!&VO#`<VO~O#`<WO~O#`<XO~O!_#UO#`<YO~O!_#UO#`;|O~O#u<ZO~P#0aO#`<[O~O#`<]O~O#`<^O~O#`<_O~O#`<`O~O#`<aO~O#`<bO~O#`<cO~O!Q<dO~O#u<eO~P!&VO#u<fO~P!&VO#u<gO~P!&VO!Q<hO~P!G[O!Q<hO~O!Q<iO~P!G[O!_#UO#k=gO~O!_#UO#k=iO~O$Q~!d!y!{!|#P#^#_#j(Z$i$k$n%Q%[%]%^%d%f%i%j%l%n~UT$Q(Z#d!P'g'k#el#c#fkx'h's'h'j$S$U$S~",goto:"$(n(hPPPPPPPP(iP(yP*tPPPP.mPP/SP4y9R9fP9fPPP9fP;l9fP9fP9fP;pPP;vP<a@}PPPARPPPPARC|PPPDSE|PARPHdPPPPJbARPPPPPLlARPP! z!#O!#SP!#s!#w!#sPPPP!&|!(wPP!)P!*VP!#OARAR!-m!0q!5r!5r!9cPPP!9jARPPPPPPPPPPP!<iP!=|PPAR!?]PARPARARARARPAR!@tPP!CvP!FtP!Fx!GQ!GU!GUP!CsP!GY!GYP!JWP!J[ARAR!Jb!M_9fP9fP9f9fP!Ni9f9f#!y9f#%v9f#(Q9f9f#(n#+Q#+Q#+U#+^#+Q#+jP#+QP9f#,f9f#.T9f9f.mPPP#/vPP#0`#0`P#0`P#0u#0`PP#0{P#0rP#0r#1_!({#0r#1|#2S#2V(i#2Y(iP#2a#2a#2aP(iP(iP(iP(iPP(iP#2g#2jP#2j(iP#2nP#2qP(iP(iP(iP(iP(iP(i(iP#2w#3R#3X#3_#3m#3s#3y#4T#4Z#5U#5e#5k#5}#6T#6Z#6i#7O#8w#9V#9]#9c#9i#9o#9y#:P#:V#:a#:s#:yPPPPPPPP#;PPP#;s#?TP#@o#@v#AOPP#Fp#If$ o$ r$ u$#h$#k$#nPP$#t$#x$$q$%q$%u$&ZPP$&_$&e$&iP$&l$&p$&s$'f$'|$(R$(U$(X$(_$(b$(f$(jmlOTn!R!s$o%t%v%w%y+X+^0]0`Q${qQ%StQ%l}S&Z!]+rQ&j!`S)V$])[Q*P$|Q*^%UQ*x%fQ+x&bS+|&c,OQ,`&kQ.e)^Q/z*y[0z+y,Q,R,S,T,US3w/o3yW5Q0{0|0}1OU6v3|3}4OU7m5R5T5VS8j6w6xS9W7o7rQ9n8mR9}9Y%Q`OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oS#PX;W!l(O#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[Q)g$fQ*U%OQ*z%iQ+R%qQ-O;oQ.|)yQ/X*VQ0S+PQ3_/SQ4^/{Q5m;qQ6`3`R:q;ppiOTn}!R!s$o%k%t%v%w%y+X+^0]0`R*|%m&j[OPTUnor!R!W!a!c!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&e&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=Z=[[!lSV!g!j&[&pQ$upQ$zqS%Pt%U!U%Yvw!v!x!{$m%W&y'Q'R'W*a*b*d+V+k,i,l,p,q,s0e1g1h4t5aQ%b{Q&g!_Q&i!`Q'_#RS(x$X(|S*O${$|Q*S%OQ*s%dQ*w%fS,_&j&kQ,}'`Q.O(yQ/Q*PQ/W*VQ/Y*WQ/]*[Q/u*tS/y*x*yQ1a,`Q2g-zQ3^/SQ3b/VQ3g/_Q4]/zQ5x2hQ6_3`Q6b3dQ8^6^R9f8_x$Ze#W$g$h$l(q(s({)b)c-U.R.q2f3O8S=X=d=e=f!^$xq!`$z${$|&Y&i&j&k)U*O*P+o+{,_,`.]/Q0w0y1V1a2z5P5S7l7q9U9{:bQ)x$uQ*i%_Q*l%`Q*v%fQ,|'_Q/t*sU/x*w*x*yQ1q,}Q4W/uS4[/y/zS6l3r3vQ7T4]U8h6p6t6uU9l8i8k8lQ:W9mQ:i:X#b=]#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=od=^;^;s;v;y<Q<T<W<]<`<fg=_;l;m;t;w;z<R<U<X<^<a<gW$`e$b)d=XS%_x%kQ%`yQ%azR*g%]%X$_e#U#W#r#s$X$[$g$h$l&f(h(q(s(t({)R)b)c)u)w)y*h*k,[,y,{-U.R.S.U.q/f/i/q/s1n1p2f2p2x3O3V3X4T4V5c5h5{6U6z7P7x8S8p9^9q;^;l;m;r;s;t;u;v;w;x;y;z<P<Q<R<S<T<U<V<W<X<[<]<^<_<`<a<e<f<g=X=d=e=f=g=i=m=n=oT(i$U(jX)h$f;o;p;qU&_!]%X+uS'm#Y#ZQ*Z%RS,u'Z'[Q/j*mQ3P.nR6h3n&pgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[$a#o_!i!t$s&o&u'b'i'q'r's't'u'v'w'x'y'z'{'}(Q(U(`*Y+p,c,h,m-T-Z-_-a-p.r0l0o1d1w1|1}2O2P2Q2R2S2T2U2V2W2X2Y2]2b3T3[4x5Y5_5k5l5q5r6j7d7g7{8P8Q9Q9h9u9w:_:m:z;X<wT!dR!e&qgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[Q&]!]R0s+r!n&V!]&Z&b&c+r+x+y+|,O,Q,R,S,T,U,V0z0{0|0}1O1P3t3{5Q5R5T5U5V6n6o7m7o7r7s8g9W9Y9}S)U$])[S.])V)^Q.f)_Q/l*oQ2z.eQ2}.hS3r/o3yS6p3w4OS6t3|3}S8i6v6wQ8k6xS9m8j8mR:X9nllOTn!R!s$o%t%v%w%y+X+^0]0`Q%{!US'a#T;]Q)|$yQ*q%bQ*r%cQ,]&hS-S'f;|S.s)o<YQ/O)}Q/n*pQ0d+`Q0f+aQ0n+lQ1Y,SQ1_,^S3U.t<bQ3Y/PS3]/R<cQ4w0qQ5X1QQ5[1`Q6]3ZQ7e4yQ7f4zQ7t5]Q8}7bQ9S7kQ9x9TQ:^9yQ:l:`R:y:n$[#n_!i!t&o&u'b'i'q'r's't'u'v'w'x'y'z'{'}(Q(U(`*Y+p,c,h,m-T-Z-_-p.r0l0o1d1w1|1}2O2P2Q2R2S2T2U2V2W2X2Y2]2b3T3[4x5Y5_5k5l5q5r6j7d7g7{8P8Q9Q9h9u9w:_:m:z;X<wS'^#O0xU)a$^'e2[T)s$s-a$[#m_!i!t&o&u'b'i'q'r's't'u'v'w'x'y'z'{'}(Q(U(`*Y+p,c,h,m-T-Z-_-p.r0l0o1d1w1|1}2O2P2Q2R2S2T2U2V2W2X2Y2]2b3T3[4x5Y5_5k5l5q5r6j7d7g7{8P8Q9Q9h9u9w:_:m:z;X<wS']#O0xS'o#Z#nS)r$s-aS,v'['^Q-b(PQ.u)sR1i,w&pgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[S#PX;WQ%v!PQ%w!QQ%y!SQ%z!TR0[+[Q&d!_Q)t$uQ,Y&gS,x'_)xS1[,W,XY1m,|,}.w.x.yS5Z1]1^W5b1j1k1l1qU7w5d5e5fU9[7v7y7zQ:P9]R:d:QT+}&c,O!]YOTVZn}!R!s!v$m$o%k%m%t%v%w%y&c'W+X+^+y,O,p/o0]0`3t3yT#PX;W%SsOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oS'm#Y#ZS,u'Z'[!m<m#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[S+{&c,OW0y+y,S,T,UU1V+|,Q,RU1Z,V3t3{S3v/o3yU5P0z0{0|S5S0}1OU5W1P6n6oS6p3w4OS6u3|3}U7l5Q5R5TS7p5U8gQ7q5VS8i6v6wQ8l6xU9U7m7o7rQ9Z7sS9m8j8mS9{9W9YQ:X9nR:b9}S+}&c,OT3x/o3yS'V!w0YQ-}(xQ.Z)UU1U+{3u3vQ2l.OS2u.[.fU5O0y1Z6uQ5w2gS6S2{2}U7n5S5W8lQ8U5xQ8]6VS9X7p7qR:O9ZQ#V^S'U!w0YQ)p$nQ)z$wQ*Q$}Q,o'VQ-|(xQ.Y)UQ.`)XQ.}){Q/v*uU1T+{3u3vS2k-}.OS2t.Z.fQ2w._Q2y.aQ4Y/wW4}0y1U1Z6uQ5v2gQ5z2lS6O2u2}Q6T2|Q7R4ZW7j5O5S5W8lS8T5w5xS8X6P<dQ8Z6SQ8e6kQ8t7SU9V7n7p7qQ9b8US9c8Y<hQ9e8]Q9j8fQ9s8uS9|9X9ZS:S9d<iQ:U9kQ:c:OQ:g:VQ:v:hQ;P:wQ<p<kQ=O<uQ=P<vQ=Q=cR=V=h%S]OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oS#Vr!a!l<j#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[R<p=Z%S^OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oQ$nf!^$wq!`$z${$|&Y&i&j&k)U*O*P+o+{,_,`.]/Q0w0y1V1a2z5P5S7l7q9U9{:bS$}r!aQ){$xQ*u%fW/w*v*w*x*yU4Z/x/y/zS6k3r3vS7S4[4]W8f6l6p6t6uQ8u7TW9k8h8i8k8lS:V9l9mS:h:W:XQ:w:i!l<k#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[Q<u=YR<v=Z$vaOPTUno!R!W!c!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%t%v%w%y%}&W&e&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:oY!qSV!g!j&p!U%Yvw!v!x!{$m%W&y'Q'R'W*a*b*d+V+k,i,l,p,q,s0e1g1h4t5aQ+S%q!j<l#k#|(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[R<o&[S&`!]%XR0u+u%Q`OPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:o!l(O#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[R+R%q!j#e_!i$s&o&u'b'i'x'y'z'{(Q(U*Y,c,h,m-T-Z-p.r1d1w2Y3T3[5Y5_5k7g9Q9w:_:m:z;X!T;e'}(`+p-a0l0o1|2U2V2W2X2]2b4x5l5q5r6j7d7{8P8Q9h9u<w!f#g_!i$s&o&u'b'i'z'{(Q(U*Y,c,h,m-T-Z-p.r1d1w2Y3T3[5Y5_5k7g9Q9w:_:m:z;X!P;g'}(`+p-a0l0o1|2W2X2]2b4x5l5q5r6j7d7{8P8Q9h9u<w!b#k_!i$s&o&u'b'i(Q(U*Y,c,h,m-T-Z-p.r1d1w2Y3T3[5Y5_5k7g9Q9w:_:m:z;XQ2f-xz=['}(`+p-a0l0o1|2]2b4x5l5q5r6j7d7{8P8Q9h9u<wQ=d=jQ=e=kR=f=l&pgOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[S#}d$OR2_-e&wcOPSTUVdno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$O$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-e-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[T#yb$PS#wb$PT(X#z(]T#xb$PT(Z#z(]&wdOPSTUVdno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#k#p#t#|$O$o%Q%m%p%q%t%v%w%y%}&W&[&e&p&r&x'T'f'j'n(b(l)o)v*c+T+X+^+j+m+n,Z,e,n,z-X-`-e-f.o.t/R/r0T0U0V0X0]0`0b0r1S1e1o1x2^3p3s4U4i4k4l4u4|5g6s7O7^7i8c9O9R9z:a:o;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[T#}d$OQ$QdR(d$O%SfOPSTUVno!R!W!c!g!j!s!}#T#X#[#_#`#a#b#c#d#e#f#g#h#i#p#t$o%Q%m%p%q%t%v%w%y%}&W&e&p&r&x'T'f'j'n(l)o)v*c+T+X+^+n,Z,e,n,z-X-`.o.t/R/r0T0U0V0X0]0`0b1S1e1o1x3s4U4i4k4l4|5g6s7O7^7i9R9z:a:o!m=Y#k#|&[(b+j+m-f0r2^3p4u8c9O;V;Y;];_;`;a;b;c;d;e;f;g;h;i;j;n;{;|<O<Y<Z<b<c=[#ahOPTVn!R!W!c!s!}#[#|$o%m%p%q%t%v%w%y%}&W&e'n(b)v*c+T+X+^+n,Z,z-f.o/r0T0U0V0X0]0`0b1o2^3s4U4i4k4l5g6s7O7^!^$^e#W$g$h$l(q(s({)b)c-U.R.q2f3O8S;^;s;v;y<Q<T<W<]<`<f=X=d=e=f#b'e#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=oQ)l$jQ-q(mg2[;l;m;t;w;z<R<U<X<^<a<gx$Ye#W$g$h$l(q(s({)b)c-U.R.q2f3O8S=X=d=e=fQ(}$ZS)X$])[Q)m$kQ.a)Y#b<r#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=od<s;^;s;v;y<Q<T<W<]<`<ff<t;l;m;t;w;z<R<U<X<^<a<gQ<x=]Q<y=^Q<z=_Q<{=`Q<|=aR<}=b!^$^e#W$g$h$l(q(s({)b)c-U.R.q2f3O8S;^;s;v;y<Q<T<W<]<`<f=X=d=e=f#b'e#U#r#s$X$[&f(h(t)R)u)w)y*h*k,[,y,{.S.U/f/i/q/s1n1p2p2x3V3X4T4V5c5h5{6U6z7P7x8p9^9q;r;u;x<P<S<V<[<_<e=g=i=m=n=og2[;l;m;t;w;z<R<U<X<^<a<gljOTn!R!s$o%t%v%w%y+X+^0]0`Q)Q$[Q+g&QQ+h&SR2o.S%W$_e#U#W#r#s$X$[$g$h$l&f(h(q(s(t({)R)b)c)u)w)y*h*k,[,y,{-U.R.S.U.q/f/i/q/s1n1p2f2p2x3O3V3X4T4V5c5h5{6U6z7P7x8S8p9^9q;^;l;m;r;s;t;u;v;w;x;y;z<P<Q<R<S<T<U<V<W<X<[<]<^<_<`<a<e<f<g=X=d=e=f=g=i=m=n=oQ*j%`Q/h*lQ3l/gR6g3mT)Z$])[S)Z$])[T3x/o3yQ._)WQ2|.gQ=c3sR=h6sQ)z$wQ.`)XQ.}){Q/v*uQ4Y/wQ7R4ZQ8e6kQ8t7SQ9j8fQ9s8uQ:U9kQ:g:VQ:v:hR;P:wp(q$V'g)n.Q.i.j1u2m3S5u6W9a<q=R=S=T!p<P'c(S(w)P,X-R-m-x.V.v.y/e/g1^1l1t2n2r3k3m4R5f5i5j5|6Q6Y6[6}7z8W8[8r:R=U=W=j=k=l[<Q:e:t:};R;S;U]<R2Z5p7|9_9`:pr(s$V'g)n-v.Q.i.j1u2m3S5u6W9a<q=R=S=T!r<S'c(S(w)P,X-R-m-x.V.v.y/e/g1^1l1r1t2n2r3k3m4R5f5i5j5|6Q6Y6[6}7z8W8[8r:R=U=W=j=k=l^<T:e:t:{:};R;S;U_<U2Z5p7|7}9_9`:ppiOTn}!R!s$o%k%t%v%w%y+X+^0]0`Q%h|R+T%qpiOTn}!R!s$o%k%t%v%w%y+X+^0]0`R%h|Q*n%aR/d*gqiOTn}!R!s$o%k%t%v%w%y+X+^0]0`Q/p*sS4S/t/uW6y4P4Q4R4WU8o6{6|6}U9o8n8q8rQ:Y9pR:j:ZQ%o}R*}%kR4a/}R8w7US%Pt%UR/Y*WQ%t!OR+X%uR+_%zT0^+^0`R+c%{Q+b%{R0g+cQnOQ!sTT$rn!sQ(j$UR-n(jQ!eRR&m!eQ!hSU&s!h&t,fQ&t!iR,f&uQ+s&]R0t+sQ-V'gR1v-VQ-Y'iS1y-Y1zR1z-ZQ,O&cR1W,OrZOTn}!R!s$o%k%m%t%v%w%y+X+^0]0`S!vV$mY#QZ!v+y,p3tS+y&c,OQ,p'WT3t/o3yS!nS%WU&z!n&{,gQ&{!oR,g&vQ+v&`R0v+vQ'X!yQ,j'PW,t'X,j1b5^Q1b,kR5^1cQ(]#zR-g(]Q$OdR(c$OQ#q_U(R#q,b;kQ,b;XR;k(`Q-{(xW2i-{2j5y8VU2j-|-}.OS5y2k2lR8V5z$m(o$V'c'g(S(w)P)i)j)n,X-P-Q-R-m-v-w-x.Q.V.i.j.v.y/e/g1^1l1r1s1t1u2Z2m2n2r3S3k3m4R5f5i5j5n5o5p5u5|6Q6W6Y6[6}7z7|7}8O8W8[8r9_9`9a:R:e:p:r:s:t:{:|:};R;S;U<q=R=S=T=U=W=j=k=lQ.T)PU2q.T2s5}Q2s.VR5}2rQ)[$]R.c)[Q)e$aR.l)eQ3W.vR6Z3WQ*e%ZR/c*eQ3o/jS6i3o8dR8d6jQ*p%bR/m*pQ3y/oR6q3yQ/|*zS4_/|7VR7V4aQ/T*SW3a/T3c6a8`Q3c/WQ6a3bR8`6bQ*X%PR/Z*XQ0`+^R4o0`WmOTn!sQ%x!RQ)q$oQ+W%tQ+Y%vQ+Z%wQ+]%yQ0Z+XS0^+^0`R4n0]Q$qkQ%|!VQ&P!XQ&R!YQ&T!ZQ*`%VQ*f%[Q*|%oQ+e&OQ.b)ZS0P*}+QQ0h+dQ0i+gQ0j+hU1R+{3u3vQ3f/^Q3j/eQ4X/vQ4c0RQ4m0[Y4{0y1T1U1Z6uQ6e3hQ6f3kQ7Q4YQ7W4b[7h4}5O5S5W5Y8lQ8a6cQ8s7RQ8x7XY9P7g7j7n7p7qQ9g8bQ9i8eQ9r8tW9v9Q9V9X9ZQ:T9jQ:[9sU:]9w9|:OQ:f:US:k:_:cQ:u:gQ:x:mQ;O:vQ;Q:zR;T;PQ$yqQ&h!`U)}$z${$|Q+l&YU,^&i&j&kQ.X)US/P*O*PQ0q+oQ1Q+{S1`,_,`Q2v.]Q3Z/QQ4y0wS4z0y1VQ5]1aQ6R2zS7k5P5SS9T7l7qQ9y9UQ:`9{R:n:bS$We=XR)f$bU$ae$b=XR.k)dQ$VeS'c#U)yQ'g#WS(S#r#sQ(w$XQ)P$[Q)i$gQ)j$hQ)n$lQ,X&fQ-P;rQ-Q;uQ-R;xQ-m(hQ-v(qQ-w(sQ-x(tQ.Q({Q.V)RQ.i)bQ.j)cf.v)u,y/q1n4T5c6z7x8p9^9qQ.y)wQ/e*hQ/g*kQ1^,[Q1l,{Q1r<PQ1s<SQ1t<VQ1u-US2Z;l;mQ2m.RQ2n.SQ2r.UQ3S.qQ3k/fQ3m/iQ4R/sQ5f1pQ5i<[Q5j<_Q5n;tQ5o;wQ5p;zQ5u2fQ5|2pQ6Q2xQ6W3OQ6Y3VQ6[3XQ6}4VQ7z5hQ7|<XQ7}<RQ8O<UQ8W5{Q8[6UQ8r7PQ9_<^Q9`<aQ9a8SQ:R<eQ:e;^Q:p<gQ:r;sQ:s;vQ:t;yQ:{<QQ:|<TQ:}<WQ;R<]Q;S<`Q;U<fQ<q=XQ=R=dQ=S=eQ=T=fQ=U=gQ=W=iQ=j=mQ=k=nR=l=olkOTn!R!s$o%t%v%w%y+X+^0]0`Q!^PS!uV!}Q&O!WQ&l!cQ'p#[Q(a#|S+Q%m%pQ+U%qQ+d%}Q+i&WQ,W&eQ-]'nQ-k(bQ.x)vQ/a*cQ0W+TU0p+n3s6sQ1],ZQ1k,zQ2a-fQ3Q.oQ4Q/rQ4e0TQ4f0UQ4h0VQ4j0XQ4q0bQ5e1oQ5s2^Q6|4UQ7]4iQ7_4kQ7`4lQ7y5gQ8q7OR8z7^#U_OPTVn!R!W!s!}#[$o%m%p%q%t%v%w%y%}&W&e'n)v*c+T+X+^+n,Z,z.o/r0T0U0V0X0]0`0b1o3s4U4i4k4l5g6s7O7^Q!iSQ!tUQ$soS&o!g&rQ&u!jQ'b#TQ'i#XQ'q#_Q'r#`Q's#aQ't#bQ'u#cQ'v#dQ'w#eQ'x#fQ'y#gQ'z#hQ'{#iQ'}#kQ(Q#pQ(U#tW(`#|(b-f2^Q*Y%QS+p&[0rS,c&p,eQ,h&xQ,m'TQ-T'fQ-Z'jQ-_;VQ-a;YQ-p(lQ.r)oQ0l+jQ0o+mQ1d,nQ1w-XQ1|;]Q1};_Q2O;`Q2P;aQ2Q;bQ2R;cQ2S;dQ2T;eQ2U;fQ2V;gQ2W;hQ2X;iQ2Y-`Q2];nQ2b;jQ3T.tQ3[/RQ4x;{Q5Y1SQ5_1eQ5k1xQ5l;|Q5q<OQ5r<YQ6j3pQ7d4uQ7g4|Q7{<ZQ8P<bQ8Q<cQ9Q7iQ9h8cQ9u9OQ9w9RQ:_9zQ:m:aQ:z:oQ;X!cR<w=[R!kSR&^!]S&Y!]+rS+o&Z&bS+{&c,OQ0w+xW0y+y,S,T,UU1V+|,Q,RY1Z,V3t3{3|3}S3u/o3yU5P0z0{0|S5S0}1OW5W1P6n6o6xU7l5Q5R5TS7p5U8gQ7q5VU9U7m7o7rQ9Z7sS9{9W9YR:b9}R'h#WR'k#XQ#OXR0x;WT!zV$mS!yV$mU%Zvw+VU'P!v!x!{S,k'Q'RQ,r'WQ/b*dQ1c,lU1f,p,q,sS5`1g1hR7u5a`!mS!g!j%W&p&y*a,it!wVvw!v!x!{$m'Q'R'W*d,l,p,q,s1g1h5aQ0Y+VQ0m+kQ4s0eQ7c4tT<n&[*bT!pS%WS!oS%WS&q!g&yS&v!j*aS+q&[*bT,d&p,iT&a!]%XQ#zbR(f$PT([#z(]R2`-eT(z$X(|R)S$[Q.w)uQ1j,yQ4P/qQ5d1nQ6{4TQ7v5cQ8n6zQ9]7xQ9p8pQ:Q9^R:Z9qllOTn!R!s$o%t%v%w%y+X+^0]0`Q%n}R*|%kV%[vw+VR/k*mR*{%iQ%TtR*_%UR*T%OT%r!O%uT%s!O%uT0_+^0`",nodeNames:"⚠ extends ArithOp ArithOp InterpolationStart LineComment BlockComment Script ExportDeclaration export Star as VariableName String from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression",maxTerm:345,context:trackNewline,nodeProps:[["closedBy",4,"InterpolationEnd",43,"]",53,"}",68,")",140,"JSXSelfCloseEndTag JSXEndTag",156,"JSXEndTag"],["group",-26,8,15,17,60,195,199,202,203,205,208,211,222,224,230,232,234,236,239,245,251,253,255,257,259,261,262,"Statement",-30,12,13,25,28,29,34,44,46,47,49,54,62,70,76,77,99,100,109,110,127,130,132,133,134,135,137,138,158,159,161,"Expression",-23,24,26,30,33,35,37,162,164,166,167,169,170,171,173,174,175,177,178,179,189,191,193,194,"Type",-3,81,92,98,"ClassItem"],["openedBy",31,"InterpolationStart",48,"[",52,"{",67,"(",139,"JSXStartTag",151,"JSXStartTag JSXStartCloseTag"]],propSources:[jsHighlight],skippedNodes:[0,5,6],repeatNodeCount:29,tokenData:"#2k~R!bOX%ZXY%uYZ'kZ[%u[]%Z]^'k^p%Zpq%uqr(Rrs)mst7]tu9guv<avw=bwx>lxyJcyzJyz{Ka{|Lm|}MW}!OLm!O!PMn!P!Q!$v!Q!R!Er!R![!G_![!]!Nc!]!^!N{!^!_# c!_!`#!`!`!a##d!a!b#%s!b!c#'h!c!}9g!}#O#(O#O#P%Z#P#Q#(f#Q#R#(|#R#S9g#S#T#)g#T#o#)}#o#p#,w#p#q#,|#q#r#-j#r#s#.S#s$f%Z$f$g%u$g#BY9g#BY#BZ#.j#BZ$IS9g$IS$I_#.j$I_$I|9g$I|$I}#1X$I}$JO#1X$JO$JT9g$JT$JU#.j$JU$KV9g$KV$KW#.j$KW&FU9g&FU&FV#.j&FV;'S9g;'S;=`<Z<%l?HT9g?HT?HU#.j?HUO9gW%`T$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%ZW%rP;=`<%l%Z7Z%|i$`W'g7ROX%ZXY%uYZ%ZZ[%u[p%Zpq%uq!^%Z!_#o%Z#p$f%Z$f$g%u$g#BY%Z#BY#BZ%u#BZ$IS%Z$IS$I_%u$I_$JT%Z$JT$JU%u$JU$KV%Z$KV$KW%u$KW&FU%Z&FU&FV%u&FV;'S%Z;'S;=`%o<%l?HT%Z?HT?HU%u?HUO%Z7Z'rT$`W'h7RO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&y(YU$`W!l&qO!^%Z!_!`(l!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t(sU#m&l$`WO!^%Z!_!`)V!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t)^T#m&l$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z1i)t]$`W]&ZOY)mYZ*mZr)mrs,js!^)m!^!_-S!_#O)m#O#P1q#P#o)m#o#p-S#p;'S)m;'S;=`7V<%lO)m,^*rX$`WOr*mrs+_s!^*m!^!_+u!_#o*m#o#p+u#p;'S*m;'S;=`,d<%lO*m,^+fT$Z,U$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,U+xTOr+urs,Xs;'S+u;'S;=`,^<%lO+u,U,^O$Z,U,U,aP;=`<%l+u,^,gP;=`<%l*m1i,sT$Z,U$`W]&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z1a-XX]&ZOY-SYZ+uZr-Srs-ts#O-S#O#P-{#P;'S-S;'S;=`1k<%lO-S1a-{O$Z,U]&Z1a.OUOr-Srs.bs;'S-S;'S;=`0y;=`<%l/R<%lO-S1a.iW$Z,U]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s<%lO/R&Z/WW]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s<%lO/R&Z/uO]&Z&Z/xRO;'S/R;'S;=`0R;=`O/R&Z0WX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l/R<%lO/R&Z0vP;=`<%l/R1a1OX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l-S<%lO/R1a1nP;=`<%l-S1i1vY$`WOr)mrs2fs!^)m!^!_-S!_#o)m#o#p-S#p;'S)m;'S;=`6e;=`<%l/R<%lO)m1i2o]$Z,U$`W]&ZOY3hYZ%ZZr3hrs4hs!^3h!^!_/R!_#O3h#O#P5O#P#o3h#o#p/R#p;'S3h;'S;=`6_<%lO3h&c3o]$`W]&ZOY3hYZ%ZZr3hrs4hs!^3h!^!_/R!_#O3h#O#P5O#P#o3h#o#p/R#p;'S3h;'S;=`6_<%lO3h&c4oT$`W]&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c5TW$`WO!^3h!^!_/R!_#o3h#o#p/R#p;'S3h;'S;=`5m;=`<%l/R<%lO3h&c5rX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l3h<%lO/R&c6bP;=`<%l3h1i6jX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l)m<%lO/R1i7YP;=`<%l)m#]7b]$`WOt%Ztu8Zu!^%Z!_!c%Z!c!}8Z!}#R%Z#R#S8Z#S#T%Z#T#o8Z#p$g%Z$g;'S8Z;'S;=`9a<%lO8Z#]8b_$`W'|#TOt%Ztu8Zu!Q%Z!Q![8Z![!^%Z!_!c%Z!c!}8Z!}#R%Z#R#S8Z#S#T%Z#T#o8Z#p$g%Z$g;'S8Z;'S;=`9a<%lO8Z#]9dP;=`<%l8Z,T9ra$`W's#S'j)s$SSOt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$g%Z$g;'S9g;'S;=`<Z<%lO9g[;Oa$`W$SSOt%Ztu:wu}%Z}!O:w!O!Q%Z!Q![:w![!^%Z!_!c%Z!c!}:w!}#R%Z#R#S:w#S#T%Z#T#o:w#p$g%Z$g;'S:w;'S;=`<T<%lO:w[<WP;=`<%l:w,T<^P;=`<%l9g&t<hU$`W#e&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t=RT$`W#w&lO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z(h=iW(V(`$`WOv%Zvw>Rw!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t>YU$`W#q&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z1i>s]$`W]&ZOY>lYZ?lZw>lwx,jx!^>l!^!_@|!_#O>l#O#PE_#P#o>l#o#p@|#p;'S>l;'S;=`J]<%lO>l,^?qX$`WOw?lwx+_x!^?l!^!_@^!_#o?l#o#p@^#p;'S?l;'S;=`@v<%lO?l,U@aTOw@^wx,Xx;'S@^;'S;=`@p<%lO@^,U@sP;=`<%l@^,^@yP;=`<%l?l1aARX]&ZOY@|YZ@^Zw@|wx-tx#O@|#O#PAn#P;'S@|;'S;=`EX<%lO@|1aAqUOw@|wxBTx;'S@|;'S;=`Dg;=`<%lBt<%lO@|1aB[W$Z,U]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da<%lOBt&ZByW]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da<%lOBt&ZCfRO;'SBt;'S;=`Co;=`OBt&ZCtX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%lBt<%lOBt&ZDdP;=`<%lBt1aDlX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%l@|<%lOBt1aE[P;=`<%l@|1iEdY$`WOw>lwxFSx!^>l!^!_@|!_#o>l#o#p@|#p;'S>l;'S;=`Ik;=`<%lBt<%lO>l1iF]]$Z,U$`W]&ZOYGUYZ%ZZwGUwx4hx!^GU!^!_Bt!_#OGU#O#PHU#P#oGU#o#pBt#p;'SGU;'S;=`Ie<%lOGU&cG]]$`W]&ZOYGUYZ%ZZwGUwx4hx!^GU!^!_Bt!_#OGU#O#PHU#P#oGU#o#pBt#p;'SGU;'S;=`Ie<%lOGU&cHZW$`WO!^GU!^!_Bt!_#oGU#o#pBt#p;'SGU;'S;=`Hs;=`<%lBt<%lOGU&cHxX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%lGU<%lOBt&cIhP;=`<%lGU1iIpX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%l>l<%lOBt1iJ`P;=`<%l>l,TJjT!f+{$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$PKQT!e#w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z)ZKjW$`W'k#e#f&lOz%Zz{LS{!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&tLZU$`W#c&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z*qLtU$`Wk*iO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z,TM_T!T+{$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,TMuX$`Wx(dO!O%Z!O!PNb!P!Q%Z!Q![! d![!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$oNgV$`WO!O%Z!O!PN|!P!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$o! TT!S$g$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c! k]$`Wl&ZO!Q%Z!Q![! d![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S! d#S#X%Z#X#Y!!d#Y#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!!i]$`WO{%Z{|!#b|}%Z}!O!#b!O!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!#gX$`WO!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!$ZX$`Wl&ZO!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z7Z!$}b$`W#d&lOY!&VYZ%ZZz!&Vz{!-n{!P!&V!P!Q!BV!Q!^!&V!^!_!(f!_!`!Ch!`!a!Dm!a!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!&^^$`W!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!'aa$`W!PPO!^%Z!_#Z%Z#Z#[!'Y#[#]%Z#]#^!'Y#^#a%Z#a#b!'Y#b#g%Z#g#h!'Y#h#i%Z#i#j!'Y#j#m%Z#m#n!'Y#n#o%Z#p;'S%Z;'S;=`%o<%lO%ZP!(kX!PPOY!(fZ!P!(f!P!Q!)W!Q!}!(f!}#O!)o#O#P!*n#P;'S!(f;'S;=`!*}<%lO!(fP!)]U!PP#Z#[!)W#]#^!)W#a#b!)W#g#h!)W#i#j!)W#m#n!)WP!)rVOY!)oZ#O!)o#O#P!*X#P#Q!(f#Q;'S!)o;'S;=`!*h<%lO!)oP!*[SOY!)oZ;'S!)o;'S;=`!*h<%lO!)oP!*kP;=`<%l!)oP!*qSOY!(fZ;'S!(f;'S;=`!*}<%lO!(fP!+QP;=`<%l!(fX!+Y[$`WOY!+TYZ%ZZ!^!+T!^!_!)o!_#O!+T#O#P!,O#P#Q!&V#Q#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+TX!,TX$`WOY!+TYZ%ZZ!^!+T!^!_!)o!_#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+TX!,sP;=`<%l!+TX!,{X$`WOY!&VYZ%ZZ!^!&V!^!_!(f!_#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!-kP;=`<%l!&V7Z!-u`$`W!PPOY!-nYZ!.wZz!-nz{!2U{!P!-n!P!Q!@m!Q!^!-n!^!_!4m!_!}!-n!}#O!;l#O#P!?o#P#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!.|X$`WOz!.wz{!/i{!^!.w!^!_!0w!_#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!/nZ$`WOz!.wz{!/i{!P!.w!P!Q!0a!Q!^!.w!^!_!0w!_#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!0hT$`WU7RO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z7R!0zTOz!0wz{!1Z{;'S!0w;'S;=`!1x<%lO!0w7R!1^VOz!0wz{!1Z{!P!0w!P!Q!1s!Q;'S!0w;'S;=`!1x<%lO!0w7R!1xOU7R7R!1{P;=`<%l!0w7Z!2RP;=`<%l!.w7Z!2]`$`W!PPOY!-nYZ!.wZz!-nz{!2U{!P!-n!P!Q!3_!Q!^!-n!^!_!4m!_!}!-n!}#O!;l#O#P!?o#P#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!3ha$`WU7R!PPO!^%Z!_#Z%Z#Z#[!'Y#[#]%Z#]#^!'Y#^#a%Z#a#b!'Y#b#g%Z#g#h!'Y#h#i%Z#i#j!'Y#j#m%Z#m#n!'Y#n#o%Z#p;'S%Z;'S;=`%o<%lO%Z7R!4r[!PPOY!4mYZ!0wZz!4mz{!5h{!P!4m!P!Q!:b!Q!}!4m!}#O!6|#O#P!9r#P;'S!4m;'S;=`!:[<%lO!4m7R!5m[!PPOY!4mYZ!0wZz!4mz{!5h{!P!4m!P!Q!6c!Q!}!4m!}#O!6|#O#P!9r#P;'S!4m;'S;=`!:[<%lO!4m7R!6jUU7R!PP#Z#[!)W#]#^!)W#a#b!)W#g#h!)W#i#j!)W#m#n!)W7R!7PYOY!6|YZ!0wZz!6|z{!7o{#O!6|#O#P!9S#P#Q!4m#Q;'S!6|;'S;=`!9l<%lO!6|7R!7r[OY!6|YZ!0wZz!6|z{!7o{!P!6|!P!Q!8h!Q#O!6|#O#P!9S#P#Q!4m#Q;'S!6|;'S;=`!9l<%lO!6|7R!8mVU7ROY!)oZ#O!)o#O#P!*X#P#Q!(f#Q;'S!)o;'S;=`!*h<%lO!)o7R!9VVOY!6|YZ!0wZz!6|z{!7o{;'S!6|;'S;=`!9l<%lO!6|7R!9oP;=`<%l!6|7R!9uVOY!4mYZ!0wZz!4mz{!5h{;'S!4m;'S;=`!:[<%lO!4m7R!:_P;=`<%l!4m7R!:ga!PPOz!0wz{!1Z{#Z!0w#Z#[!:b#[#]!0w#]#^!:b#^#a!0w#a#b!:b#b#g!0w#g#h!:b#h#i!0w#i#j!:b#j#m!0w#m#n!:b#n;'S!0w;'S;=`!1x<%lO!0w7Z!;q^$`WOY!;lYZ!.wZz!;lz{!<m{!^!;l!^!_!6|!_#O!;l#O#P!>q#P#Q!-n#Q#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!<r`$`WOY!;lYZ!.wZz!;lz{!<m{!P!;l!P!Q!=t!Q!^!;l!^!_!6|!_#O!;l#O#P!>q#P#Q!-n#Q#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!={[$`WU7ROY!+TYZ%ZZ!^!+T!^!_!)o!_#O!+T#O#P!,O#P#Q!&V#Q#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+T7Z!>vZ$`WOY!;lYZ!.wZz!;lz{!<m{!^!;l!^!_!6|!_#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!?lP;=`<%l!;l7Z!?tZ$`WOY!-nYZ!.wZz!-nz{!2U{!^!-n!^!_!4m!_#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!@jP;=`<%l!-n7Z!@te$`W!PPOz!.wz{!/i{!^!.w!^!_!0w!_#Z!.w#Z#[!@m#[#]!.w#]#^!@m#^#a!.w#a#b!@m#b#g!.w#g#h!@m#h#i!.w#i#j!@m#j#m!.w#m#n!@m#n#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!B^X$`WT7ROY!BVYZ%ZZ!^!BV!^!_!By!_#o!BV#o#p!By#p;'S!BV;'S;=`!Cb<%lO!BV7R!COST7ROY!ByZ;'S!By;'S;=`!C[<%lO!By7R!C_P;=`<%l!By7Z!CeP;=`<%l!BV&u!Cq^$`W#w&l!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&V]!Dv^$PS$`W!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&V&c!Eyf$`Wl&ZO!O%Z!O!P! d!P!Q%Z!Q![!G_![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S!G_#S#U%Z#U#V!IR#V#X%Z#X#Y!!d#Y#b%Z#b#c!Hk#c#d!Js#d#l%Z#l#m!L_#m#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Gfa$`Wl&ZO!O%Z!O!P! d!P!Q%Z!Q![!G_![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S!G_#S#X%Z#X#Y!!d#Y#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!HrT$`Wl&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!IWY$`WO!Q%Z!Q!R!Iv!R!S!Iv!S!^%Z!_#R%Z#R#S!Iv#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!I}[$`Wl&ZO!Q%Z!Q!R!Iv!R!S!Iv!S!^%Z!_#R%Z#R#S!Iv#S#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!JxX$`WO!Q%Z!Q!Y!Ke!Y!^%Z!_#R%Z#R#S!Ke#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!KlZ$`Wl&ZO!Q%Z!Q!Y!Ke!Y!^%Z!_#R%Z#R#S!Ke#S#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Ld]$`WO!Q%Z!Q![!M]![!^%Z!_!c%Z!c!i!M]!i#R%Z#R#S!M]#S#T%Z#T#Z!M]#Z#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Md_$`Wl&ZO!Q%Z!Q![!M]![!^%Z!_!c%Z!c!i!M]!i#R%Z#R#S!M]#S#T%Z#T#Z!M]#Z#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m!NlT!_V$`W#u(^O!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z!P# ST_w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z6i# nR'n$Y!c(O$Q,_(ZP!P!Q# w!^!_# |!_!`#!ZW# |O$bW&l#!RP#g&l!_!`#!U&l#!ZO#w&l&l#!`O#h&l(m#!gV#T(e$`WO!^%Z!_!`(l!`!a#!|!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&u##TT#`&m$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m##oVe!s#h&l$]S$`WO!^%Z!_!`#$U!`!a#$l!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#$]T#h&l$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#$sV#g&l$`WO!^%Z!_!`<z!`!a#%Y!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#%aU#g&l$`WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m#%zX'}&q$`WO!O%Z!O!P#&g!P!^%Z!_!a%Z!a!b#&}!b#o%Z#p;'S%Z;'S;=`%o<%lO%Z(i#&nTy(a$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#'UU$`W#r&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z#_#'oT!u#V$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,P#(VT{+w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$P#(mT!Q#w$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#)TU#o&l$`WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z){#)nT$`W'r)sO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,T#*Ya$`W's#S'j)s$USOt%Ztu#)}u}%Z}!O#+_!O!Q%Z!Q![#)}![!^%Z!_!c%Z!c!}#)}!}#R%Z#R#S#)}#S#T%Z#T#o#)}#p$g%Z$g;'S#)};'S;=`#,q<%lO#)}[#+fa$`W$USOt%Ztu#+_u}%Z}!O#+_!O!Q%Z!Q![#+_![!^%Z!_!c%Z!c!}#+_!}#R%Z#R#S#+_#S#T%Z#T#o#+_#p$g%Z$g;'S#+_;'S;=`#,k<%lO#+_[#,nP;=`<%l#+_,T#,tP;=`<%l#)}~#,|O!V~(h#-TV(U(`$`WO!^%Z!_!`<z!`#o%Z#p#q#&}#q;'S%Z;'S;=`%o<%lO%Z(}#-sT!U(soQ$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%ZX#.ZT!mP$`WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z7Z#.wt$`W'g7R's#S'j)s$SSOX%ZXY%uYZ%ZZ[%u[p%Zpq%uqt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$f%Z$f$g%u$g#BY9g#BY#BZ#.j#BZ$IS9g$IS$I_#.j$I_$JT9g$JT$JU#.j$JU$KV9g$KV$KW#.j$KW&FU9g&FU&FV#.j&FV;'S9g;'S;=`<Z<%l?HT9g?HT?HU#.j?HUO9g7Z#1fa$`W'h7R's#S'j)s$SSOt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$g%Z$g;'S9g;'S;=`<Z<%lO9g",tokenizers:[tsExtends,noSemicolon,incdecToken,template,0,1,2,3,4,5,6,7,8,9,insertSemicolon],topRules:{Script:[0,7],SingleExpression:[1,263]},dialects:{jsx:13404,ts:13406},dynamicPrecedences:{159:1,187:1},specialized:[{term:302,get:e=>spec_identifier[e]||-1},{term:311,get:e=>spec_word[e]||-1},{term:65,get:e=>spec_LessThan[e]||-1}],tokenPrec:13429});[snippetCompletion("function ${name}(${params}) {\n\t${}\n}",{label:"function",detail:"definition",type:"keyword"}),snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}",{label:"for",detail:"loop",type:"keyword"}),snippetCompletion("for (let ${name} of ${collection}) {\n\t${}\n}",{label:"for",detail:"of loop",type:"keyword"}),snippetCompletion("do {\n\t${}\n} while (${})",{label:"do",detail:"loop",type:"keyword"}),snippetCompletion("while (${}) {\n\t${}\n}",{label:"while",detail:"loop",type:"keyword"}),snippetCompletion("try {\n\t${}\n} catch (${error}) {\n\t${}\n}",{label:"try",detail:"/ catch block",type:"keyword"}),snippetCompletion("if (${}) {\n\t${}\n}",{label:"if",detail:"block",type:"keyword"}),snippetCompletion("if (${}) {\n\t${}\n} else {\n\t${}\n}",{label:"if",detail:"/ else block",type:"keyword"}),snippetCompletion("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}",{label:"class",detail:"definition",type:"keyword"}),snippetCompletion('import {${names}} from "${module}"\n${}',{label:"import",detail:"named",type:"keyword"}),snippetCompletion('import ${name} from "${module}"\n${}',{label:"import",detail:"default",type:"keyword"})];const javascriptLanguage=LRLanguage.define({name:"javascript",parser:parser.configure({props:[indentNodeProp.add({IfStatement:continuedIndent({except:/^\s*({|else\b)/}),TryStatement:continuedIndent({except:/^\s*({|catch\b|finally\b)/}),LabeledStatement:flatIndent,SwitchBody:e=>{let t=e.textAfter,i=/^\s*\}/.test(t),n=/^\s*(case|default)\b/.test(t);return e.baseIndent+(i?0:n?1:2)*e.unit},Block:delimitedIndent({closing:"}"}),ArrowFunction:e=>e.baseIndent+e.unit,"TemplateString BlockComment":()=>null,"Statement Property":continuedIndent({except:/^{/}),JSXElement(e){let t=/^\s*<\//.test(e.textAfter);return e.lineIndent(e.node.from)+(t?0:e.unit)},JSXEscape(e){let t=/\s*\}/.test(e.textAfter);return e.lineIndent(e.node.from)+(t?0:e.unit)},"JSXOpenTag JSXSelfClosingTag":e=>e.column(e.node.from)+e.unit}),foldNodeProp.add({"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression":foldInside,BlockComment:e=>({from:e.from+2,to:e.to-2})})]}),languageData:{closeBrackets:{brackets:["(","[","{","'",'"',"`"]},commentTokens:{line:"//",block:{open:"/*",close:"*/"}},indentOnInput:/^\s*(?:case |default:|\{|\}|<\/)$/,wordChars:"$"}});javascriptLanguage.configure({dialect:"ts"},"typescript");javascriptLanguage.configure({dialect:"jsx"});javascriptLanguage.configure({dialect:"jsx ts"},"typescript");function elementName(e,t,i=e.length){if(!t)return "";let n=t.getChild("JSXIdentifier");return n?e.sliceString(n.from,Math.min(n.to,i)):""}const android$1="object"==typeof navigator&&/Android\b/.test(navigator.userAgent);EditorView.inputHandler.of((e,t,i,n)=>{if((android$1?e.composing:e.compositionStarted)||e.state.readOnly||t!=i||">"!=n&&"/"!=n||!javascriptLanguage.isActiveAt(e.state,t,-1))return !1;let{state:o}=e,r=o.changeByRange(e=>{var t,i,r;let s,{head:a}=e,l=syntaxTree(o).resolveInner(a,-1);if("JSXStartTag"==l.name&&(l=l.parent),">"==n&&"JSXFragmentTag"==l.name)return {range:EditorSelection.cursor(a+1),changes:{from:a,insert:"><>"}};if(">"==n&&"JSXIdentifier"==l.name){if("JSXEndTag"!=(null===(i=null===(t=l.parent)||void 0===t?void 0:t.lastChild)||void 0===i?void 0:i.name)&&(s=elementName(o.doc,l.parent,a)))return {range:EditorSelection.cursor(a+1),changes:{from:a,insert:`></${s}>`}}}else if("/"==n&&"JSXFragmentTag"==l.name){let e=l.parent,t=null===e||void 0===e?void 0:e.parent;if(e.from==a-1&&"JSXEndTag"!=(null===(r=t.lastChild)||void 0===r?void 0:r.name)&&(s=elementName(o.doc,null===t||void 0===t?void 0:t.firstChild,a))){let e=`/${s}>`;return {range:EditorSelection.cursor(a+e.length),changes:{from:a,insert:e}}}}return {range:e}});return !r.changes.empty&&(e.dispatch(r,{userEvent:"input.type",scrollIntoView:!0}),!0)});let updateCallback=function(){},internCallback=function(){};const listenChangesExtension=StateField.define({create:()=>null,update:(e,t)=>(t.docChanged&&internCallback(t.newDoc.toString()),null)}),errorLinter=linter(e=>{let t=[],i=e.errorLines.length;if(0===i)return t;for(;i--;)t.push({from:e.state.doc.line(e.errorLines[i].lineNumber).from,to:e.state.doc.line(e.errorLines[i].lineNumber).from+2,message:e.errorLines[i].description,severity:"error"});return t});function createEditorState(e="",t={}){let i=[lineNumbers(),highlightActiveLineGutter(),highlightSpecialChars(),history(),foldGutter(),drawSelection(),indentUnit.of("    "),EditorState.allowMultipleSelections.of(!0),indentOnInput(),bracketMatching(),closeBrackets(),keymap.of([indentWithTab,...closeBracketsKeymap,...defaultKeymap,...historyKeymap,...foldKeymap,...completionKeymap]),javascriptLanguage,syntaxHighlighting(defaultHighlightStyle,{fallback:!0}),listenChangesExtension,errorLinter,lintGutter(),oneDark];return EditorState.create({doc:e,extensions:i})}class CodeMirror extends EditorView{constructor(e,t){super({state:createEditorState(),parent:e}),this.isEdit=!1,this.errorLines=[],updateCallback=t,internCallback=this.onChange.bind(this);}addError(e){this.errorLines=e;}noError(){this.errorLines=[];}setValue(e){this.isEdit=!1,this.dispatch({changes:{from:0,to:this.state.doc.length,insert:e}});}clear(){this.setValue("");}getValue(){return this.state.doc.toString()}onChange(e){const t=this.getValue();""!==t&&(this.isEdit=e!==t),updateCallback(e);}}

//import * as UIL from 'uil'

/** __
*    _)_|_|_
*   __) |_| | 2023
* @author lo.th / https://github.com/lo-th
*/

class Editor {

    constructor ( solo = false ) {

        this.esprimaReady = false;

        this.loadEsprima();

        this.isSolo = solo;
        this.isOpen = false;
        this.source = null;
        this.left = 0;
        this.refresh = false;
        this.old = '';

        this.extraCode = [];

        this.useCodeMirror = true;
        this.errorLines = [];
        this.widgets = [];


        if( this.isSolo ) this.open();

    }

    message ( e ) {

        let type = e.data.type;

        switch( type ){
            case 'connect' :

            this.source = e.source;
            this.send({ type:'connect', msg:'Editor connected !!'});

            break;
            case 'set' :

            this.set( e.data.code, e.data.name );

            break;
        }

    }

    send( data ){

        if( !this.source )  return 
        this.source.postMessage( data );

    }

    detach () {

        if(this.isSolo) this.send({ type:'close' });
        else Main.externEditor();

    }

    reset(){

        //let extra = document.getElementById("extra");
        //if(extra)document.head.removeChild(extra);//Remooves main.js from the DOM tree

        
        let i = this.extraCode.length;
        while( i-- ){
            this.extraCode[i].remove(); 
            //document.getElementsByTagName('head')[0].removeChild(this.extraCode[i]);
        }
        this.extraCode = [];
        //console.log('extra is reset')

    }

    loadSrcipt ( url ) {

        const name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        var xml = new XMLHttpRequest();
        xml.open('GET', url );
        xml.overrideMimeType( "text/javascript" );
        xml.onreadystatechange = function() {
            if ( xml.readyState === 4 ) {
                if ( xml.status === 200 || xml.status === 0 ) {
                    this.set( xml.responseText, name );
                }
                else console.error( "Couldn't load ["+ name + "] [" + xml.status + "]" );
            }
        }.bind(this);
        xml.send();

    }

    loadExtra ( url, callback ) {

        const name = url.substring( url.lastIndexOf('/')+1, url.lastIndexOf('.') );
        var xml = new XMLHttpRequest();
        xml.open('GET', url );
        xml.overrideMimeType( "text/javascript" );
        xml.onreadystatechange = function() {
            if ( xml.readyState === 4 ) {
                if ( xml.status === 200 || xml.status === 0 ) {
                    let n = document.createElement("script");
                    n.language = "javascript";
                    n.type = "text/javascript";
                    n.charset = "utf-8";
                    n.async = false;
                    n.innerHTML =  '{' + xml.responseText + '}';
                    this.extraCode.push(n);
                    document.getElementsByTagName('head')[0].appendChild(n);
                    //document.head.appendChild(n)
                    callback();
                }
                else console.error( "Couldn't load ["+ name + "] [" + xml.status + "]" );
            }
        }.bind(this);
        xml.send();

    }

    loadEsprima () {

        var xml = new XMLHttpRequest();
        xml.open('GET', './src/libs/esprima.js');
        xml.overrideMimeType( "text/javascript" );
        xml.onreadystatechange = function() {
            if ( xml.readyState === 4 ) {
                if ( xml.status === 200 || xml.status === 0 ) {
                    let n = document.createElement("script");
                    n.type = "text/javascript";
                    n.async = true;
                    n.charset = "utf-8";
                    n.text = xml.responseText;
                    document.getElementsByTagName('head')[0].appendChild(n);
                    this.esprimaReady = true;
                }
                else console.error( "Couldn't load [esprima] [" + xml.status + "]" );
            }
            
        }.bind(this);
        xml.send();

    }

    show ( b ) {

        if( this.isOpen && !b ) this.close();
        else this.open();
        if( Main ) Main.setLeft( this.left );

    }
 
    open () {

        this.left = this.isSolo ? window.innerWidth : (window.innerWidth*0.5)-200;
        this.isOpen = true;

        let text = 'font-smooth: antialiased; -webkit-font-smoothing : antialiased; -moz-osx-font-smoothing: grayscale;';//text-rendering: optimizeSpeed; text-shadow: 1px 1px 1px #000;

        let unselectable = '-o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none; pointer-events:none; ';

        this.content = document.createElement( 'div' );

        if( this.isSolo ) this.content.style.cssText = 'position:absolute; margin:0; padding:0; top:0px; left:0px; width:100%;  height:100%; ';
        else this.content.style.cssText = 'position:absolute; margin:0; padding:0; top:0px; left:0px; width:'+this.left+'px;  height:100%; ';
        this.content.style.cssText += "font-size:18px; font-family:'Roboto Mono', 'Source Code Pro', Consolas, monospace; color:#f8f8f2; background:#181915;";//background: #282923;#20211c
        document.body.appendChild( this.content );


        this.codeContent = document.createElement( 'div' );
        this.codeContent.style.cssText = text + 'position:absolute; margin:0; padding:0; top:30px; left:3px; width:calc( 100% - 6px); height:calc( 100% - 60px); border-top: 1px solid #3e4036; border-bottom: 1px solid #3e4036;';
        
        if(this.useCodeMirror){
            this.code = new CodeMirror( this.codeContent, this.onUpdate.bind(this) );
            //this.code = CodeMirror( this.codeContent, { theme:'monokai', lineNumbers: true, matchBrackets: true, indentWithTabs: false, styleActiveLine: false, tabSize: 4, indentUnit: 4/*, highlightSelectionMatches: {showToken: /\w/}*/});
            //this.code.on('change', function () { this.onUpdate(this.code.getValue()) }.bind(this) );
        } else {
            this.code = new CodeFlask( this.codeContent, { language: 'js', handleTabs: true, lineNumbers: true });
            this.code.onUpdate( this.onUpdate.bind(this) );
        }

        this.content.appendChild( this.codeContent );

        this.title = document.createElement( 'div' );
        this.title.style.cssText = unselectable + "position:absolute; top:3px; left:10px; width:calc( 100% - 20px); color:#7c806c; text-shadow: 1px 1px 1px #000;";
        this.content.appendChild( this.title );

        //  mini menu
        
        this.solo = document.createElement( 'div' );
        this.solo.style.cssText = unselectable + "position:absolute; top:0px; right:0px; width:30px; height:30px; pointer-events:auto; cursor: pointer;";
        this.solo.appendChild( h$2.dom( 'path', 'position:absolute; width:14px; height:14px; left:8px; top:8px; pointer-events:none;', { d:h$2.svgs[ 'extern' ], fill:'#DDD', stroke:'none'} ));
        this.content.appendChild( this.solo );
        this.solo.name = 'detach';

        this.saver = document.createElement( 'div' );
        this.saver.style.cssText = unselectable + "position:absolute; top:0px; right:30px; width:30px; height:30px; pointer-events:auto; cursor: pointer;";
        this.saver.appendChild( h$2.dom( 'path', 'position:absolute; width:14px; height:14px; left:8px; top:8px; pointer-events:none;', { d:h$2.svgs[ 'save' ], fill:'#DDD', stroke:'none'} ));
        this.content.appendChild( this.saver );
        this.saver.name = 'save';

        this.loader = document.createElement( 'div' );
        this.loader.style.cssText = unselectable + "position:absolute; top:0px; right:60px; width:30px; height:30px; pointer-events:auto; cursor: pointer;";
        this.loader.appendChild( h$2.dom( 'path', 'position:absolute; width:14px; height:14px; left:8px; top:8px; pointer-events:none;', { d:h$2.svgs[ 'load' ], fill:'#DDD', stroke:'none'} ));
        this.content.appendChild( this.loader );
        this.loader.name = 'load';

        this.help = document.createElement( 'div' );
        this.help.style.cssText = unselectable + "position:absolute; top:3px; right:100px; width:60px; height:30px; pointer-events:none; color:#7c806c; text-shadow: 1px 1px 1px #000; text-align:right";
        this.content.appendChild( this.help );

        //

        this.info = document.createElement( 'div' );
        this.info.style.cssText = unselectable + "position:absolute; bottom:2px; left:10px; width:calc( 100% - 20px); text-shadow: 1px 1px 1px #000;";
        this.content.appendChild( this.info );

        this.separator = document.createElement( 'div' );
        this.separator.style.cssText = unselectable + 'background:none; position:absolute; top:0px; right:0px; width:3px; height:100%; cursor: e-resize; pointer-events:auto; z-index: 5; display:block; ';
        this.content.appendChild( this.separator );

        this.midDown = function (e) { this.isDown = true;  }.bind(this);

        this.midUp = function (e) { 
            this.isDown = false; 
            document.body.style.cursor = 'auto';
            this.codeContent.style.pointerEvents = 'auto';
        }.bind(this);

        this.midMove = function (e) { 

            if( e.target.name ){
                this.help.innerHTML = e.target.name;
            }  else this.help.innerHTML = '';

            if(!this.isDown) return

            this.codeContent.style.pointerEvents = 'none';
            document.body.style.cursor = 'e-resize';

            this.left = e.clientX+2;
            this.content.style.width = this.left+'px';
            if(Main) Main.setLeft( this.left );

        }.bind(this);

        this.helpers = function (e) { console.log(e.target.name); }.bind(this);

        if( !this.isSolo ){
            this.separator.addEventListener( 'pointerdown', this.midDown, false );
            document.addEventListener('pointermove', this.midMove, false );
            document.addEventListener('pointerup', this.midUp, false );
        }
        
        this.saver.addEventListener( 'pointerdown', this.save.bind(this), false );
        this.loader.addEventListener( 'pointerdown', this.load.bind(this), false );
        this.solo.addEventListener( 'pointerdown', this.detach.bind(this), false );

        if( Main ) {
            this.setInternCode( Main.getCode() );
            this.setTitle( Main.getCodeName() );
        }

        if( this.isSolo ){
            var hash = location.hash.substr( 1 );
            if( hash !== '' ) this.loadSrcipt('./demos/'+ hash + '.js');
        } else {
           if(!this.useCodeMirror) this.content.addEventListener( 'wheel', function(e){ this.code.wheel(e); }.bind(this) );
        }

        this.content.addEventListener( 'dragover', function(e){ e.preventDefault(); }, false );
        this.content.addEventListener( 'dragend', function(e){ e.preventDefault(); }, false );
        this.content.addEventListener( 'dragleave', function(e){ e.preventDefault();}, false );
        this.content.addEventListener( 'drop', this.drop.bind(this), false );

    }

    setTitle ( name ) {

        this.codeName = name;
        this.title.innerHTML = '&#x2022;&#160;' + this.codeName;

    }

    close () {

        this.left = 0;
        this.isOpen = false;

        document.removeEventListener('pointerdown', this.midDown );
        document.removeEventListener('pointerup', this.midUp );
        document.removeEventListener('pointermove', this.midMove );

        this.code.clear();

        this.content.innerHTML = '';

        document.body.removeChild( this.content );
        
    }

    onUpdate ( code ){

        let b = this.validate( code );//this.useCodeMirror ? this.validateMirror( code ) : this.validate( code )
        
        if( !this.refresh ) this.refresh = this.code.isEdit;

        if( b && this.refresh ){ 
            if( Main ) Main.injectCode( code );
            if( this.source ) this.send({ type:'inject', code:code });
            this.refresh = false;
        }

    }

    set ( code, name, refresh ){

        //console.log('editor set')

        if( !this.isOpen ) return

        this.setTitle( name );

        if( this.isSolo ) location.hash = name;

        if( refresh ) this.refresh = refresh;

        this.setInternCode( code );

    }

    setInternCode( code ) {

        if( this.useCodeMirror ) this.code.setValue( code );
        else this.code.updateCode( code );
        this.code.isEdit = false;

    }

    get () {

        return this.useCodeMirror ? this.code.getValue() : this.code.getCode()

    }

    save ( e ) {

        o$1.save( { name:this.codeName, data:this.get(), type:'js' } );
    
    }

    load ( e ) {

        o$1.load( { callback:this.onLoad.bind(this), type:'js' } );
    
    }

    onLoad ( src, Name ) {

        const name = Name.substring( 0, Name.lastIndexOf('.') );
        this.set( src, name );

    }

    setInfo ( message, e=0 ) {

        this.info.style.color = e ? '#ff0000':'#7c806c';
        this.info.innerHTML = message;

    }

    /*validate ( code ) {

        if( !code ) return
        if( !this.esprimaReady ) return true

        try {
            const syntax = esprima.parseModule(code, { tolerant: true, loc: true, range: true, jsx: true });
            if (syntax.errors.length > 0) {
                for (let i = 0; i < syntax.errors.length; ++i) {
                    let e = syntax.errors[i]
                    console.log( e.description, e.lineNumber, e.column )
                    this.code.addError(e.description, e.lineNumber, e.column)
                }
                this.setInfo('Invalid code. Total issues: ' + syntax.errors.length, 1)
                return false
            } else {
                if (syntax.body.length === 0) this.setInfo('info', 'Empty code. Nothing to validate.')
                this.setInfo('&#2039;')
                this.code.noError()
                return true
            }
        } catch (e) {
            this.code.addError(e.toString(), e.lineNumber, e.column);
            this.setInfo(e.toString(), 1)
            return false
        }

    }*/

    validate ( code ) {

        if( !code ) return
        if( !this.esprimaReady ) return true

        let errorLines = [];

        try {
            errorLines = esprima.parseModule( code, { tolerant: true, loc: true, range: true, jsx: true }).errors;
        } catch ( e ) {
            errorLines.push( e );
        }

        let j = errorLines.length;
        if( j === 0) this.setInfo('&#2039;');
        else this.setInfo('Invalid code. Total issues: ' + j , 1);

        this.code.addError( errorLines );

        return j === 0

    }

    /*validateMirror ( value ) {

        if( !value ) return
        if( !this.esprimaReady ) return true

        const code = this.code
        const errorLines = this.errorLines
        const widgets = this.widgets
        let _selt = this

        return code.operation( function () {
            while ( errorLines.length > 0 ) code.removeLineClass( errorLines.shift(), 'background', 'errorLine' );
            var i = widgets.length;
            while(i--) code.removeLineWidget( widgets[ i ] );
            widgets.length = 0;
            var string = value//currentCode;
            try {
                var result = esprima.parse( string, { tolerant: true } ).errors;
                i = result.length;
                while(i--){
                    var error = result[ i ];
                    var m = document.createElement( 'div' );
                    m.className = 'esprima-error';
                    m.textContent = error.message.replace(/Line [0-9]+: /, '');
                    var l = error.lineNumber - 1;
                    errorLines.push( l );
                    code.addLineClass( l, 'background', 'errorLine' );
                    var widget = code.addLineWidget( l, m );
                    widgets.push( widget );
                }
            } catch ( error ) {
                var m = document.createElement( 'div' );
                m.className = 'esprima-error';
                m.textContent = error.message.replace(/Line [0-9]+: /, '');
                var l = error.lineNumber - 1;
                errorLines.push( l );
                code.addLineClass( l, 'background', 'errorLine' );
                var widget = code.addLineWidget( l, m );
                widgets.push( widget );
            }
            let rs = errorLines.length ;
            if( rs === 0) _selt.setInfo('&#2039;')
            else _selt.setInfo('Invalid code. Total issues: ' + rs , 1)
            return rs === 0
        });

    }*/

    drop ( e ) {

        e.preventDefault();
        if ( !e.dataTransfer.items) return

        const file = e.dataTransfer.files[0];
        const reader = new FileReader();
        const name = file.name;
        const type = name.substring(name.lastIndexOf('.')+1, name.length );
        const finalName = name.substring( name.lastIndexOf('/')+1, name.lastIndexOf('.') );

        if ( type === 'js' ) reader.readAsText( file );
        else return

        reader.onload = function ( e ) {
            this.set( e.target.result, finalName, true );
        }.bind(this);

    }

}

/**
 * Full-screen textured quad shader
 */

var CopyShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'opacity': { value: 1.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`

};

class Pass {

	constructor() {

		// if set to true, the pass is processed by the composer
		this.enabled = true;

		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;

		// if set to true, the pass clears its buffer before rendering
		this.clear = false;

		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
		this.renderToScreen = false;

	}

	setSize( /* width, height */ ) {}

	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

	}

}

// Helper for passes that need to fill the viewport with a single quad.

const _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

const _geometry$1 = new BufferGeometry();
_geometry$1.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
_geometry$1.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

class FullScreenQuad {

	constructor( material ) {

		this._mesh = new Mesh( _geometry$1, material );

	}

	dispose() {

		this._mesh.geometry.dispose();

	}

	render( renderer ) {

		renderer.render( this._mesh, _camera );

	}

	get material() {

		return this._mesh.material;

	}

	set material( value ) {

		this._mesh.material = value;

	}

}

class ShaderPass extends Pass {

	constructor( shader, textureID ) {

		super();

		this.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';

		if ( shader instanceof ShaderMaterial ) {

			this.uniforms = shader.uniforms;

			this.material = shader;

		} else if ( shader ) {

			this.uniforms = UniformsUtils.clone( shader.uniforms );

			this.material = new ShaderMaterial( {

				defines: Object.assign( {}, shader.defines ),
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader

			} );

		}

		this.fsQuad = new FullScreenQuad( this.material );

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}

		this.fsQuad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( writeBuffer );
			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
			this.fsQuad.render( renderer );

		}

	}

}

class MaskPass extends Pass {

	constructor( scene, camera ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.clear = true;
		this.needsSwap = false;

		this.inverse = false;

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const context = renderer.getContext();
		const state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask( false );
		state.buffers.depth.setMask( false );

		// lock buffers

		state.buffers.color.setLocked( true );
		state.buffers.depth.setLocked( true );

		// set up stencil

		let writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		state.buffers.stencil.setTest( true );
		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
		state.buffers.stencil.setClear( clearValue );
		state.buffers.stencil.setLocked( true );

		// draw into the stencil buffer

		renderer.setRenderTarget( readBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		renderer.setRenderTarget( writeBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		// unlock color and depth buffer for subsequent rendering

		state.buffers.color.setLocked( false );
		state.buffers.depth.setLocked( false );

		// only render where stencil is set to 1

		state.buffers.stencil.setLocked( false );
		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1
		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );
		state.buffers.stencil.setLocked( true );

	}

}

class ClearMaskPass extends Pass {

	constructor() {

		super();

		this.needsSwap = false;

	}

	render( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		renderer.state.buffers.stencil.setLocked( false );
		renderer.state.buffers.stencil.setTest( false );

	}

}

class EffectComposer {

	constructor( renderer, renderTarget ) {

		this.renderer = renderer;

		if ( renderTarget === undefined ) {

			const parameters = {
				minFilter: LinearFilter,
				magFilter: LinearFilter,
				format: RGBAFormat
			};

			const size = renderer.getSize( new Vector2() );
			this._pixelRatio = renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );
			renderTarget.texture.name = 'EffectComposer.rt1';

		} else {

			this._pixelRatio = 1;
			this._width = renderTarget.width;
			this._height = renderTarget.height;

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.renderTarget2.texture.name = 'EffectComposer.rt2';

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		this.renderToScreen = true;

		this.passes = [];

		this.copyPass = new ShaderPass( CopyShader );

		this.clock = new Clock();

	}

	swapBuffers() {

		const tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	}

	addPass( pass ) {

		this.passes.push( pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	insertPass( pass, index ) {

		this.passes.splice( index, 0, pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	removePass( pass ) {

		const index = this.passes.indexOf( pass );

		if ( index !== - 1 ) {

			this.passes.splice( index, 1 );

		}

	}

	isLastEnabledPass( passIndex ) {

		for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {

			if ( this.passes[ i ].enabled ) {

				return false;

			}

		}

		return true;

	}

	render( deltaTime ) {

		// deltaTime value is in seconds

		if ( deltaTime === undefined ) {

			deltaTime = this.clock.getDelta();

		}

		const currentRenderTarget = this.renderer.getRenderTarget();

		let maskActive = false;

		for ( let i = 0, il = this.passes.length; i < il; i ++ ) {

			const pass = this.passes[ i ];

			if ( pass.enabled === false ) continue;

			pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );
			pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					const context = this.renderer.getContext();
					const stencil = this.renderer.state.buffers.stencil;

					//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
					stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );

					//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
					stencil.setFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( MaskPass !== undefined ) {

				if ( pass instanceof MaskPass ) {

					maskActive = true;

				} else if ( pass instanceof ClearMaskPass ) {

					maskActive = false;

				}

			}

		}

		this.renderer.setRenderTarget( currentRenderTarget );

	}

	reset( renderTarget ) {

		if ( renderTarget === undefined ) {

			const size = this.renderer.getSize( new Vector2() );
			this._pixelRatio = this.renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	}

	setSize( width, height ) {

		this._width = width;
		this._height = height;

		const effectiveWidth = this._width * this._pixelRatio;
		const effectiveHeight = this._height * this._pixelRatio;

		this.renderTarget1.setSize( effectiveWidth, effectiveHeight );
		this.renderTarget2.setSize( effectiveWidth, effectiveHeight );

		for ( let i = 0; i < this.passes.length; i ++ ) {

			this.passes[ i ].setSize( effectiveWidth, effectiveHeight );

		}

	}

	setPixelRatio( pixelRatio ) {

		this._pixelRatio = pixelRatio;

		this.setSize( this._width, this._height );

	}

}

// Helper for passes that need to fill the viewport with a single quad.

new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

const _geometry = new BufferGeometry();
_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

class RenderPass extends Pass {

	constructor( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.overrideMaterial = overrideMaterial;

		this.clearColor = clearColor;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

		this.clear = true;
		this.clearDepth = false;
		this.needsSwap = false;
		this._oldClearColor = new Color();

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		let oldClearAlpha, oldOverrideMaterial;

		if ( this.overrideMaterial !== undefined ) {

			oldOverrideMaterial = this.scene.overrideMaterial;

			this.scene.overrideMaterial = this.overrideMaterial;

		}

		if ( this.clearColor ) {

			renderer.getClearColor( this._oldClearColor );
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		if ( this.clearDepth ) {

			renderer.clearDepth();

		}

		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

		// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
		if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
		renderer.render( this.scene, this.camera );

		if ( this.clearColor ) {

			renderer.setClearColor( this._oldClearColor, oldClearAlpha );

		}

		if ( this.overrideMaterial !== undefined ) {

			this.scene.overrideMaterial = oldOverrideMaterial;

		}

		renderer.autoClear = oldAutoClear;

	}

}

/**
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

const LuminosityHighPassShader = {

	shaderID: 'luminosityHighPass',

	uniforms: {

		'tDiffuse': { value: null },
		'luminosityThreshold': { value: 1.0 },
		'smoothWidth': { value: 1.0 },
		'defaultColor': { value: new Color( 0x000000 ) },
		'defaultOpacity': { value: 0.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`

};

/**
 * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a
 * mip map chain of bloom textures and blurs them with different radii. Because
 * of the weighted combination of mips, and because larger blurs are done on
 * higher mips, this effect provides good quality and performance.
 *
 * Reference:
 * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */
class UnrealBloomPass extends Pass {

	constructor( resolution, strength, radius, threshold, noBack ) {

		super();

		this.strength = ( strength !== undefined ) ? strength : 1;
		this.radius = radius;
		this.threshold = threshold;
		this.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );

		this.noBackground = noBack || false;

		// create color only once here, reuse it later inside the render function
		this.clearColor = new Color( 0, 0, 0 );

		// render targets
		const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
		this.renderTargetsHorizontal = [];
		this.renderTargetsVertical = [];
		this.nMips = 5;
		let resx = Math.round( this.resolution.x / 2 );
		let resy = Math.round( this.resolution.y / 2 );

		this.renderTargetBright = new WebGLRenderTarget( resx, resy, pars );
		this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';
		this.renderTargetBright.texture.generateMipmaps = false;

		for ( let i = 0; i < this.nMips; i ++ ) {

			const renderTargetHorizonal = new WebGLRenderTarget( resx, resy, pars );

			renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;
			renderTargetHorizonal.texture.generateMipmaps = false;

			this.renderTargetsHorizontal.push( renderTargetHorizonal );

			const renderTargetVertical = new WebGLRenderTarget( resx, resy, pars );

			renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;
			renderTargetVertical.texture.generateMipmaps = false;

			this.renderTargetsVertical.push( renderTargetVertical );

			resx = Math.round( resx / 2 );

			resy = Math.round( resy / 2 );

		}

		// luminosity high pass material

		if ( LuminosityHighPassShader === undefined )
			console.error( 'THREE.UnrealBloomPass relies on LuminosityHighPassShader' );

		const highPassShader = LuminosityHighPassShader;
		this.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );

		this.highPassUniforms[ 'luminosityThreshold' ].value = threshold;
		this.highPassUniforms[ 'smoothWidth' ].value = 0.01;

		this.materialHighPassFilter = new ShaderMaterial( {
			uniforms: this.highPassUniforms,
			vertexShader: highPassShader.vertexShader,
			fragmentShader: highPassShader.fragmentShader,
			defines: {}
		} );

		// Gaussian Blur Materials
		this.separableBlurMaterials = [];
		const kernelSizeArray = [ 3, 5, 7, 9, 11 ];
		resx = Math.round( this.resolution.x / 2 );
		resy = Math.round( this.resolution.y / 2 );

		for ( let i = 0; i < this.nMips; i ++ ) {

			this.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );

			this.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );

			resx = Math.round( resx / 2 );

			resy = Math.round( resy / 2 );

		}

		// Composite material
		this.compositeMaterial = this.getCompositeMaterial( this.nMips );
		this.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;
		this.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;
		this.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;
		this.compositeMaterial.needsUpdate = true;

		const bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];
		this.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;
		this.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];
		this.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;

		// copy material
		if ( CopyShader === undefined ) {

			console.error( 'THREE.UnrealBloomPass relies on CopyShader' );

		}

		const copyShader = CopyShader;

		this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );
		this.copyUniforms[ 'opacity' ].value = 1.0;

		this.materialCopy = new ShaderMaterial( {
			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: AdditiveBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		} );

		this.enabled = true;
		this.needsSwap = false;

		this._oldClearColor = new Color();
		this.oldClearAlpha = 1;

		this.basic = new MeshBasicMaterial();

		this.fsQuad = new FullScreenQuad( null );

		this.applyValue();

	}

	dispose() {

		for ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {

			this.renderTargetsHorizontal[ i ].dispose();

		}

		for ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {

			this.renderTargetsVertical[ i ].dispose();

		}

		this.renderTargetBright.dispose();

	}

	setSize( width, height ) {

		let resx = Math.round( width / 2 );
		let resy = Math.round( height / 2 );

		this.renderTargetBright.setSize( resx, resy );

		for ( let i = 0; i < this.nMips; i ++ ) {

			this.renderTargetsHorizontal[ i ].setSize( resx, resy );
			this.renderTargetsVertical[ i ].setSize( resx, resy );

			this.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );

			resx = Math.round( resx / 2 );
			resy = Math.round( resy / 2 );

		}

	}

	applyValue (){

		this.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;

		/*for ( let i = 0; i < this.nMips; i ++ ) {
			this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;
			this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;
		}*/

		this.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;
		this.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;
		this.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;

	}

	render( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

	//	if( this.Env ) 
		//	this.Env.setBackgroud(0x111111)

		renderer.getClearColor( this._oldClearColor );
		this.oldClearAlpha = renderer.getClearAlpha();
		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setClearColor( this.clearColor, 0 );
		


		if ( maskActive ) renderer.state.buffers.stencil.setTest( false );

		// Render input to screen

		if ( this.renderToScreen ) {

			this.fsQuad.material = this.basic;
			this.basic.map = readBuffer.texture;

			renderer.setRenderTarget( null );
			renderer.clear();
			this.fsQuad.render( renderer );

		}

		// 1. Extract Bright Areas

		this.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;
		//this.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;
		this.fsQuad.material = this.materialHighPassFilter;

		renderer.setRenderTarget( this.renderTargetBright );
		renderer.clear();
		this.fsQuad.render( renderer );

		// 2. Blur All the mips progressively

		let inputRenderTarget = this.renderTargetBright;

		for ( let i = 0; i < this.nMips; i ++ ) {

			this.fsQuad.material = this.separableBlurMaterials[ i ];

			this.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;
			this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;
			renderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );
			renderer.clear();
			this.fsQuad.render( renderer );

			this.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;
			this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;
			renderer.setRenderTarget( this.renderTargetsVertical[ i ] );
			renderer.clear();
			this.fsQuad.render( renderer );

			inputRenderTarget = this.renderTargetsVertical[ i ];

		}

		// Composite All the mips

		this.fsQuad.material = this.compositeMaterial;
		//this.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;
		//this.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;
		//this.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;

		renderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );
		renderer.clear();
		this.fsQuad.render( renderer );

		// Blend it additively over the input texture

		this.fsQuad.material = this.materialCopy;
		this.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;

		if ( maskActive ) renderer.state.buffers.stencil.setTest( true );

		if ( this.renderToScreen ) {

			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( readBuffer );
			this.fsQuad.render( renderer );

		}

		// Restore renderer settings

		renderer.setClearColor( this._oldClearColor, this.oldClearAlpha );
		renderer.autoClear = oldAutoClear;
		//if( this.Env ) this.Env.setBackgroud()

	}

	getSeperableBlurMaterial( kernelRadius ) {

		return new ShaderMaterial( {

			defines: {
				'KERNEL_RADIUS': kernelRadius,
				'SIGMA': kernelRadius
			},

			uniforms: {
				'colorTexture': { value: null },
				'texSize': { value: new Vector2( 0.5, 0.5 ) },
				'direction': { value: new Vector2( 0.5, 0.5 ) }
			},

			vertexShader:
				`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

			fragmentShader:
				`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
		} );

	}

	getCompositeMaterial( nMips ) {

		return new ShaderMaterial( {

			defines: {
				'NUM_MIPS': nMips
			},

			uniforms: {
				'blurTexture1': { value: null },
				'blurTexture2': { value: null },
				'blurTexture3': { value: null },
				'blurTexture4': { value: null },
				'blurTexture5': { value: null },
				'dirtTexture': { value: null },
				'bloomStrength': { value: 1.0 },
				'bloomFactors': { value: null },
				'bloomTintColors': { value: null },
				'bloomRadius': { value: 0.0 }
			},

			vertexShader:
				`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

			fragmentShader:
				`varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
		} );

	}

}

UnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );
UnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );

const LUTShader = {

	defines: {
		USE_3DTEXTURE: 1,
	},

	uniforms: {
		lut3d: { value: null },

		lut: { value: null },
		lutSize: { value: 0 },

		tDiffuse: { value: null },
		intensity: { value: 1.0 },
	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`,


	fragmentShader: /* glsl */`

		uniform float lutSize;
		#if USE_3DTEXTURE
		precision highp sampler3D;
		uniform sampler3D lut3d;
		#else
		uniform sampler2D lut;

		vec3 lutLookup( sampler2D tex, float size, vec3 rgb ) {

			float sliceHeight = 1.0 / size;
			float yPixelHeight = 1.0 / ( size * size );

			// Get the slices on either side of the sample
			float slice = rgb.b * size;
			float interp = fract( slice );
			float slice0 = slice - interp;
			float centeredInterp = interp - 0.5;

			float slice1 = slice0 + sign( centeredInterp );

			// Pull y sample in by half a pixel in each direction to avoid color
			// bleeding from adjacent slices.
			float greenOffset = clamp( rgb.g * sliceHeight, yPixelHeight * 0.5, sliceHeight - yPixelHeight * 0.5 );

			vec2 uv0 = vec2(
				rgb.r,
				slice0 * sliceHeight + greenOffset
			);
			vec2 uv1 = vec2(
				rgb.r,
				slice1 * sliceHeight + greenOffset
			);

			vec3 sample0 = texture2D( tex, uv0 ).rgb;
			vec3 sample1 = texture2D( tex, uv1 ).rgb;

			return mix( sample0, sample1, abs( centeredInterp ) );

		}
		#endif

		varying vec2 vUv;
		uniform float intensity;
		uniform sampler2D tDiffuse;
		void main() {

			vec4 val = texture2D( tDiffuse, vUv );
			vec4 lutVal;

			// pull the sample in by half a pixel so the sample begins
			// at the center of the edge pixels.
			float pixelWidth = 1.0 / lutSize;
			float halfPixelWidth = 0.5 / lutSize;
			vec3 uvw = vec3( halfPixelWidth ) + val.rgb * ( 1.0 - pixelWidth );

			#if USE_3DTEXTURE

			lutVal = vec4( texture( lut3d, uvw ).rgb, val.a );

			#else

			lutVal = vec4( lutLookup( lut, lutSize, uvw ), val.a );

			#endif

			gl_FragColor = vec4( mix( val, lutVal, intensity ) );

		}

	`,

};

class LUTPass extends ShaderPass {

	set lut( v ) {

		const material = this.material;
		if ( v !== this.lut ) {

			material.uniforms.lut3d.value = null;
			material.uniforms.lut.value = null;

			if ( v ) {

				const is3dTextureDefine = v.isDataTexture3D ? 1 : 0;
				if ( is3dTextureDefine !== material.defines.USE_3DTEXTURE ) {

					material.defines.USE_3DTEXTURE = is3dTextureDefine;
					material.needsUpdate = true;

				}

				material.uniforms.lutSize.value = v.image.width;
				if ( v.isDataTexture3D ) {

					material.uniforms.lut3d.value = v;

				} else {

					material.uniforms.lut.value = v;

				}

			}

		}

	}

	get lut() {

		return this.material.uniforms.lut.value || this.material.uniforms.lut3d.value;

	}

	set intensity( v ) {

		this.material.uniforms.intensity.value = v;

	}

	get intensity() {

		return this.material.uniforms.intensity.value;

	}

	constructor( options = {} ) {

		super( LUTShader );
		this.lut = options.lut || null;
		this.intensity = 'intensity' in options ? options.intensity : 1;

	}

}

/**
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */

const BokehShader = {

	defines: {
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1,
	},

	uniforms: {

		'tColor': { value: null },
		'tDepth': { value: null },
		'focus': { value: 1.0 },
		'aspect': { value: 1.0 },
		'aperture': { value: 0.025 },
		'maxblur': { value: 0.01 },
		'nearClip': { value: 1.0 },
		'farClip': { value: 1000.0 },

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`

};

/**
 * Depth-of-field post-process with bokeh shader
 */

class BokehPass extends Pass {

	constructor( scene, camera, params ) {

		super();

		this.scene = scene;
		this.camera = camera;

		const focus = ( params.focus !== undefined ) ? params.focus : 1.0;
		const aspect = ( params.aspect !== undefined ) ? params.aspect : camera.aspect;
		const aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;
		const maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;

		// render targets

		const width = params.width || window.innerWidth || 1;
		const height = params.height || window.innerHeight || 1;

		this.renderTargetDepth = new WebGLRenderTarget( width, height, {
			minFilter: NearestFilter,
			magFilter: NearestFilter
		} );

		this.renderTargetDepth.texture.name = 'BokehPass.depth';

		// depth material

		this.materialDepth = new MeshDepthMaterial();
		this.materialDepth.depthPacking = RGBADepthPacking;
		this.materialDepth.blending = NoBlending;

		// bokeh material

		if ( BokehShader === undefined ) {

			console.error( 'THREE.BokehPass relies on BokehShader' );

		}

		const bokehShader = BokehShader;
		const bokehUniforms = UniformsUtils.clone( bokehShader.uniforms );

		bokehUniforms[ 'tDepth' ].value = this.renderTargetDepth.texture;

		bokehUniforms[ 'focus' ].value = focus;
		bokehUniforms[ 'aspect' ].value = aspect;
		bokehUniforms[ 'aperture' ].value = aperture;
		bokehUniforms[ 'maxblur' ].value = maxblur;
		bokehUniforms[ 'nearClip' ].value = camera.near;
		bokehUniforms[ 'farClip' ].value = camera.far;

		this.materialBokeh = new ShaderMaterial( {
			defines: Object.assign( {}, bokehShader.defines ),
			uniforms: bokehUniforms,
			vertexShader: bokehShader.vertexShader,
			fragmentShader: bokehShader.fragmentShader
		} );

		this.uniforms = bokehUniforms;
		this.needsSwap = false;

		this.fsQuad = new FullScreenQuad( this.materialBokeh );

		this._oldClearColor = new Color();

	}

	render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {

		// Render depth into texture

		this.scene.overrideMaterial = this.materialDepth;

		renderer.getClearColor( this._oldClearColor );
		const oldClearAlpha = renderer.getClearAlpha();
		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setClearColor( 0xffffff );
		renderer.setClearAlpha( 1.0 );
		renderer.setRenderTarget( this.renderTargetDepth );
		renderer.clear();
		renderer.render( this.scene, this.camera );

		// Render bokeh composite

		this.uniforms[ 'tColor' ].value = readBuffer.texture;
		this.uniforms[ 'nearClip' ].value = this.camera.near;
		this.uniforms[ 'farClip' ].value = this.camera.far;

		if ( this.renderToScreen ) {

			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( writeBuffer );
			renderer.clear();
			this.fsQuad.render( renderer );

		}

		this.scene.overrideMaterial = null;
		renderer.setClearColor( this._oldClearColor );
		renderer.setClearAlpha( oldClearAlpha );
		renderer.autoClear = oldAutoClear;

	}

}

// Ported from Stefan Gustavson's java implementation
// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com
//
// Added 4D noise

/**
 * You can pass in a random number generator object if you like.
 * It is assumed to have a random() method.
 */
class SimplexNoise {

	constructor( r = Math ) {

		this.grad3 = [[ 1, 1, 0 ], [ - 1, 1, 0 ], [ 1, - 1, 0 ], [ - 1, - 1, 0 ],
			[ 1, 0, 1 ], [ - 1, 0, 1 ], [ 1, 0, - 1 ], [ - 1, 0, - 1 ],
			[ 0, 1, 1 ], [ 0, - 1, 1 ], [ 0, 1, - 1 ], [ 0, - 1, - 1 ]];

		this.grad4 = [[ 0, 1, 1, 1 ], [ 0, 1, 1, - 1 ], [ 0, 1, - 1, 1 ], [ 0, 1, - 1, - 1 ],
			[ 0, - 1, 1, 1 ], [ 0, - 1, 1, - 1 ], [ 0, - 1, - 1, 1 ], [ 0, - 1, - 1, - 1 ],
			[ 1, 0, 1, 1 ], [ 1, 0, 1, - 1 ], [ 1, 0, - 1, 1 ], [ 1, 0, - 1, - 1 ],
			[ - 1, 0, 1, 1 ], [ - 1, 0, 1, - 1 ], [ - 1, 0, - 1, 1 ], [ - 1, 0, - 1, - 1 ],
			[ 1, 1, 0, 1 ], [ 1, 1, 0, - 1 ], [ 1, - 1, 0, 1 ], [ 1, - 1, 0, - 1 ],
			[ - 1, 1, 0, 1 ], [ - 1, 1, 0, - 1 ], [ - 1, - 1, 0, 1 ], [ - 1, - 1, 0, - 1 ],
			[ 1, 1, 1, 0 ], [ 1, 1, - 1, 0 ], [ 1, - 1, 1, 0 ], [ 1, - 1, - 1, 0 ],
			[ - 1, 1, 1, 0 ], [ - 1, 1, - 1, 0 ], [ - 1, - 1, 1, 0 ], [ - 1, - 1, - 1, 0 ]];

		this.p = [];

		for ( let i = 0; i < 256; i ++ ) {

			this.p[ i ] = Math.floor( r.random() * 256 );

		}

		// To remove the need for index wrapping, double the permutation table length
		this.perm = [];

		for ( let i = 0; i < 512; i ++ ) {

			this.perm[ i ] = this.p[ i & 255 ];

		}

		// A lookup table to traverse the simplex around a given point in 4D.
		// Details can be found where this table is used, in the 4D noise method.
		this.simplex = [
			[ 0, 1, 2, 3 ], [ 0, 1, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 2, 3, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 2, 3, 0 ],
			[ 0, 2, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 3, 1, 2 ], [ 0, 3, 2, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 3, 2, 0 ],
			[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],
			[ 1, 2, 0, 3 ], [ 0, 0, 0, 0 ], [ 1, 3, 0, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 3, 0, 1 ], [ 2, 3, 1, 0 ],
			[ 1, 0, 2, 3 ], [ 1, 0, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 0, 3, 1 ], [ 0, 0, 0, 0 ], [ 2, 1, 3, 0 ],
			[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],
			[ 2, 0, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 0, 1, 2 ], [ 3, 0, 2, 1 ], [ 0, 0, 0, 0 ], [ 3, 1, 2, 0 ],
			[ 2, 1, 0, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 1, 0, 2 ], [ 0, 0, 0, 0 ], [ 3, 2, 0, 1 ], [ 3, 2, 1, 0 ]];

	}

	dot( g, x, y ) {

		return g[ 0 ] * x + g[ 1 ] * y;

	}

	dot3( g, x, y, z ) {

		return g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z;

	}

	dot4( g, x, y, z, w ) {

		return g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z + g[ 3 ] * w;

	}

	noise( xin, yin ) {

		let n0; // Noise contributions from the three corners
		let n1;
		let n2;
		// Skew the input space to determine which simplex cell we're in
		const F2 = 0.5 * ( Math.sqrt( 3.0 ) - 1.0 );
		const s = ( xin + yin ) * F2; // Hairy factor for 2D
		const i = Math.floor( xin + s );
		const j = Math.floor( yin + s );
		const G2 = ( 3.0 - Math.sqrt( 3.0 ) ) / 6.0;
		const t = ( i + j ) * G2;
		const X0 = i - t; // Unskew the cell origin back to (x,y) space
		const Y0 = j - t;
		const x0 = xin - X0; // The x,y distances from the cell origin
		const y0 = yin - Y0;

		// For the 2D case, the simplex shape is an equilateral triangle.
		// Determine which simplex we are in.
		let i1; // Offsets for second (middle) corner of simplex in (i,j) coords

		let j1;
		if ( x0 > y0 ) {

			i1 = 1; j1 = 0;

			// lower triangle, XY order: (0,0)->(1,0)->(1,1)

		}	else {

			i1 = 0; j1 = 1;

		} // upper triangle, YX order: (0,0)->(0,1)->(1,1)

		// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
		// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
		// c = (3-sqrt(3))/6
		const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
		const y1 = y0 - j1 + G2;
		const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
		const y2 = y0 - 1.0 + 2.0 * G2;
		// Work out the hashed gradient indices of the three simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const gi0 = this.perm[ ii + this.perm[ jj ] ] % 12;
		const gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 ] ] % 12;
		const gi2 = this.perm[ ii + 1 + this.perm[ jj + 1 ] ] % 12;
		// Calculate the contribution from the three corners
		let t0 = 0.5 - x0 * x0 - y0 * y0;
		if ( t0 < 0 ) n0 = 0.0;
		else {

			t0 *= t0;
			n0 = t0 * t0 * this.dot( this.grad3[ gi0 ], x0, y0 ); // (x,y) of grad3 used for 2D gradient

		}

		let t1 = 0.5 - x1 * x1 - y1 * y1;
		if ( t1 < 0 ) n1 = 0.0;
		else {

			t1 *= t1;
			n1 = t1 * t1 * this.dot( this.grad3[ gi1 ], x1, y1 );

		}

		let t2 = 0.5 - x2 * x2 - y2 * y2;
		if ( t2 < 0 ) n2 = 0.0;
		else {

			t2 *= t2;
			n2 = t2 * t2 * this.dot( this.grad3[ gi2 ], x2, y2 );

		}

		// Add contributions from each corner to get the final noise value.
		// The result is scaled to return values in the interval [-1,1].
		return 70.0 * ( n0 + n1 + n2 );

	}

	// 3D simplex noise
	noise3d( xin, yin, zin ) {

		let n0; // Noise contributions from the four corners
		let n1;
		let n2;
		let n3;
		// Skew the input space to determine which simplex cell we're in
		const F3 = 1.0 / 3.0;
		const s = ( xin + yin + zin ) * F3; // Very nice and simple skew factor for 3D
		const i = Math.floor( xin + s );
		const j = Math.floor( yin + s );
		const k = Math.floor( zin + s );
		const G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too
		const t = ( i + j + k ) * G3;
		const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
		const Y0 = j - t;
		const Z0 = k - t;
		const x0 = xin - X0; // The x,y,z distances from the cell origin
		const y0 = yin - Y0;
		const z0 = zin - Z0;

		// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
		// Determine which simplex we are in.
		let i1; // Offsets for second corner of simplex in (i,j,k) coords

		let j1;
		let k1;
		let i2; // Offsets for third corner of simplex in (i,j,k) coords
		let j2;
		let k2;
		if ( x0 >= y0 ) {

			if ( y0 >= z0 ) {

				i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;

				// X Y Z order

			} else if ( x0 >= z0 ) {

				i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;

				// X Z Y order

			} else {

				i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;

			} // Z X Y order

		} else { // x0<y0

			if ( y0 < z0 ) {

				i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;

				// Z Y X order

			} else if ( x0 < z0 ) {

				i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;

				// Y Z X order

			} else {

				i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;

			} // Y X Z order

		}

		// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
		// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
		// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
		// c = 1/6.
		const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
		const y1 = y0 - j1 + G3;
		const z1 = z0 - k1 + G3;
		const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
		const y2 = y0 - j2 + 2.0 * G3;
		const z2 = z0 - k2 + 2.0 * G3;
		const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
		const y3 = y0 - 1.0 + 3.0 * G3;
		const z3 = z0 - 1.0 + 3.0 * G3;
		// Work out the hashed gradient indices of the four simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const kk = k & 255;
		const gi0 = this.perm[ ii + this.perm[ jj + this.perm[ kk ] ] ] % 12;
		const gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 + this.perm[ kk + k1 ] ] ] % 12;
		const gi2 = this.perm[ ii + i2 + this.perm[ jj + j2 + this.perm[ kk + k2 ] ] ] % 12;
		const gi3 = this.perm[ ii + 1 + this.perm[ jj + 1 + this.perm[ kk + 1 ] ] ] % 12;
		// Calculate the contribution from the four corners
		let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
		if ( t0 < 0 ) n0 = 0.0;
		else {

			t0 *= t0;
			n0 = t0 * t0 * this.dot3( this.grad3[ gi0 ], x0, y0, z0 );

		}

		let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
		if ( t1 < 0 ) n1 = 0.0;
		else {

			t1 *= t1;
			n1 = t1 * t1 * this.dot3( this.grad3[ gi1 ], x1, y1, z1 );

		}

		let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
		if ( t2 < 0 ) n2 = 0.0;
		else {

			t2 *= t2;
			n2 = t2 * t2 * this.dot3( this.grad3[ gi2 ], x2, y2, z2 );

		}

		let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
		if ( t3 < 0 ) n3 = 0.0;
		else {

			t3 *= t3;
			n3 = t3 * t3 * this.dot3( this.grad3[ gi3 ], x3, y3, z3 );

		}

		// Add contributions from each corner to get the final noise value.
		// The result is scaled to stay just inside [-1,1]
		return 32.0 * ( n0 + n1 + n2 + n3 );

	}

	// 4D simplex noise
	noise4d( x, y, z, w ) {

		// For faster and easier lookups
		const grad4 = this.grad4;
		const simplex = this.simplex;
		const perm = this.perm;

		// The skewing and unskewing factors are hairy again for the 4D case
		const F4 = ( Math.sqrt( 5.0 ) - 1.0 ) / 4.0;
		const G4 = ( 5.0 - Math.sqrt( 5.0 ) ) / 20.0;
		let n0; // Noise contributions from the five corners
		let n1;
		let n2;
		let n3;
		let n4;
		// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
		const s = ( x + y + z + w ) * F4; // Factor for 4D skewing
		const i = Math.floor( x + s );
		const j = Math.floor( y + s );
		const k = Math.floor( z + s );
		const l = Math.floor( w + s );
		const t = ( i + j + k + l ) * G4; // Factor for 4D unskewing
		const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
		const Y0 = j - t;
		const Z0 = k - t;
		const W0 = l - t;
		const x0 = x - X0; // The x,y,z,w distances from the cell origin
		const y0 = y - Y0;
		const z0 = z - Z0;
		const w0 = w - W0;

		// For the 4D case, the simplex is a 4D shape I won't even try to describe.
		// To find out which of the 24 possible simplices we're in, we need to
		// determine the magnitude ordering of x0, y0, z0 and w0.
		// The method below is a good way of finding the ordering of x,y,z,w and
		// then find the correct traversal order for the simplex we’re in.
		// First, six pair-wise comparisons are performed between each possible pair
		// of the four coordinates, and the results are used to add up binary bits
		// for an integer index.
		const c1 = ( x0 > y0 ) ? 32 : 0;
		const c2 = ( x0 > z0 ) ? 16 : 0;
		const c3 = ( y0 > z0 ) ? 8 : 0;
		const c4 = ( x0 > w0 ) ? 4 : 0;
		const c5 = ( y0 > w0 ) ? 2 : 0;
		const c6 = ( z0 > w0 ) ? 1 : 0;
		const c = c1 + c2 + c3 + c4 + c5 + c6;

		// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
		// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
		// impossible. Only the 24 indices which have non-zero entries make any sense.
		// We use a thresholding to set the coordinates in turn from the largest magnitude.
		// The number 3 in the "simplex" array is at the position of the largest coordinate.
		const i1 = simplex[ c ][ 0 ] >= 3 ? 1 : 0;
		const j1 = simplex[ c ][ 1 ] >= 3 ? 1 : 0;
		const k1 = simplex[ c ][ 2 ] >= 3 ? 1 : 0;
		const l1 = simplex[ c ][ 3 ] >= 3 ? 1 : 0;
		// The number 2 in the "simplex" array is at the second largest coordinate.
		const i2 = simplex[ c ][ 0 ] >= 2 ? 1 : 0;
		const j2 = simplex[ c ][ 1 ] >= 2 ? 1 : 0;
		const k2 = simplex[ c ][ 2 ] >= 2 ? 1 : 0;
		const l2 = simplex[ c ][ 3 ] >= 2 ? 1 : 0;
		// The number 1 in the "simplex" array is at the second smallest coordinate.
		const i3 = simplex[ c ][ 0 ] >= 1 ? 1 : 0;
		const j3 = simplex[ c ][ 1 ] >= 1 ? 1 : 0;
		const k3 = simplex[ c ][ 2 ] >= 1 ? 1 : 0;
		const l3 = simplex[ c ][ 3 ] >= 1 ? 1 : 0;
		// The fifth corner has all coordinate offsets = 1, so no need to look that up.
		const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
		const y1 = y0 - j1 + G4;
		const z1 = z0 - k1 + G4;
		const w1 = w0 - l1 + G4;
		const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
		const y2 = y0 - j2 + 2.0 * G4;
		const z2 = z0 - k2 + 2.0 * G4;
		const w2 = w0 - l2 + 2.0 * G4;
		const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
		const y3 = y0 - j3 + 3.0 * G4;
		const z3 = z0 - k3 + 3.0 * G4;
		const w3 = w0 - l3 + 3.0 * G4;
		const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
		const y4 = y0 - 1.0 + 4.0 * G4;
		const z4 = z0 - 1.0 + 4.0 * G4;
		const w4 = w0 - 1.0 + 4.0 * G4;
		// Work out the hashed gradient indices of the five simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const kk = k & 255;
		const ll = l & 255;
		const gi0 = perm[ ii + perm[ jj + perm[ kk + perm[ ll ] ] ] ] % 32;
		const gi1 = perm[ ii + i1 + perm[ jj + j1 + perm[ kk + k1 + perm[ ll + l1 ] ] ] ] % 32;
		const gi2 = perm[ ii + i2 + perm[ jj + j2 + perm[ kk + k2 + perm[ ll + l2 ] ] ] ] % 32;
		const gi3 = perm[ ii + i3 + perm[ jj + j3 + perm[ kk + k3 + perm[ ll + l3 ] ] ] ] % 32;
		const gi4 = perm[ ii + 1 + perm[ jj + 1 + perm[ kk + 1 + perm[ ll + 1 ] ] ] ] % 32;
		// Calculate the contribution from the five corners
		let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
		if ( t0 < 0 ) n0 = 0.0;
		else {

			t0 *= t0;
			n0 = t0 * t0 * this.dot4( grad4[ gi0 ], x0, y0, z0, w0 );

		}

		let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
		if ( t1 < 0 ) n1 = 0.0;
		else {

			t1 *= t1;
			n1 = t1 * t1 * this.dot4( grad4[ gi1 ], x1, y1, z1, w1 );

		}

		let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
		if ( t2 < 0 ) n2 = 0.0;
		else {

			t2 *= t2;
			n2 = t2 * t2 * this.dot4( grad4[ gi2 ], x2, y2, z2, w2 );

		}

		let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
		if ( t3 < 0 ) n3 = 0.0;
		else {

			t3 *= t3;
			n3 = t3 * t3 * this.dot4( grad4[ gi3 ], x3, y3, z3, w3 );

		}

		let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
		if ( t4 < 0 ) n4 = 0.0;
		else {

			t4 *= t4;
			n4 = t4 * t4 * this.dot4( grad4[ gi4 ], x4, y4, z4, w4 );

		}

		// Sum up and scale the result to cover the range [-1,1]
		return 27.0 * ( n0 + n1 + n2 + n3 + n4 );

	}

}

/**
 * References:
 * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html
 * https://learnopengl.com/Advanced-Lighting/SSAO
 * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl
 */

const SSAOShader = {

	defines: {
		'PERSPECTIVE_CAMERA': 1,
		'KERNEL_SIZE': 32
	},

	uniforms: {

		'tDiffuse': { value: null },
		'tNormal': { value: null },
		'tDepth': { value: null },
		'tNoise': { value: null },
		'kernel': { value: null },
		'cameraNear': { value: null },
		'cameraFar': { value: null },
		'resolution': { value: new Vector2() },
		'cameraProjectionMatrix': { value: new Matrix4() },
		'cameraInverseProjectionMatrix': { value: new Matrix4() },
		'kernelRadius': { value: 8 },
		'minDistance': { value: 0.005 },
		'maxDistance': { value: 0.05 },

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform sampler2D tNormal;
		uniform sampler2D tDepth;
		uniform sampler2D tNoise;

		uniform vec3 kernel[ KERNEL_SIZE ];

		uniform vec2 resolution;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float kernelRadius;
		uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance; // avoid the influence of fragments which are too far away

		varying vec2 vUv;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {

			return texture2D( tDepth, screenPosition ).x;

		}

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		float getViewZ( const in float depth ) {

			#if PERSPECTIVE_CAMERA == 1

				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );

			#else

				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );

			#endif

		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {

			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];

			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );

			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;

		}

		vec3 getViewNormal( const in vec2 screenPosition ) {

			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );

		}

		void main() {

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );

			vec3 viewPosition = getViewPosition( vUv, depth, viewZ );
			vec3 viewNormal = getViewNormal( vUv );

			vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
			vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;

			// compute matrix used to reorient a kernel vector

			vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
			vec3 bitangent = cross( viewNormal, tangent );
			mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );

		 float occlusion = 0.0;

		 for ( int i = 0; i < KERNEL_SIZE; i ++ ) {

				vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
				vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point

				vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
				samplePointNDC /= samplePointNDC.w;

				vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates

				float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
				float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
				float delta = sampleDepth - realDepth;

				if ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion

					occlusion += 1.0;

				}

			}

			occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );

			gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );

		}`

};

const SSAODepthShader = {

	defines: {
		'PERSPECTIVE_CAMERA': 1
	},

	uniforms: {

		'tDepth': { value: null },
		'cameraNear': { value: null },
		'cameraFar': { value: null },

	},

	vertexShader:

		`varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader:

		`uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );

		}`

};

const SSAOBlurShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'resolution': { value: new Vector2() }

	},

	vertexShader:

		`varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader:

		`uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		void main() {

			vec2 texelSize = ( 1.0 / resolution );
			float result = 0.0;

			for ( int i = - 2; i <= 2; i ++ ) {

				for ( int j = - 2; j <= 2; j ++ ) {

					vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
					result += texture2D( tDiffuse, vUv + offset ).r;

				}

			}

			gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );

		}`

};

class SSAOPass extends Pass {

	constructor( scene, camera, width, height, sharedTarget ) {

		super();

		this.width = ( width !== undefined ) ? width : 512;
		this.height = ( height !== undefined ) ? height : 512;

		this.clear = true;

		this.camera = camera;
		this.scene = scene;

		this.kernelRadius = 8;
		this.kernelSize = 32;
		this.kernel = [];
		this.noiseTexture = null;
		this.output = 0;

		this.minDistance = 0.005;
		this.maxDistance = 0.1;

		this._visibilityCache = new Map();

		this.isSharedTarget = sharedTarget || false;

		//

		this.generateSampleKernel();
		this.generateRandomKernelRotations();

		// beauty render target

		const depthTexture = new DepthTexture();
		depthTexture.type = UnsignedShortType;

		this.beautyRenderTarget = new WebGLRenderTarget( this.width, this.height, {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			format: RGBAFormat
		} );

		// normal render target with depth buffer

		this.normalRenderTarget = new WebGLRenderTarget( this.width, this.height, {
			minFilter: NearestFilter,
			magFilter: NearestFilter,
			format: RGBAFormat,
			depthTexture: depthTexture
		} );

		this.depthRenderTarget = this.normalRenderTarget.clone();

		// ssao render target

		this.ssaoRenderTarget = new WebGLRenderTarget( this.width, this.height, {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			format: RGBAFormat
		} );

		this.blurRenderTarget = this.ssaoRenderTarget.clone();

		// ssao material

		if ( SSAOShader === undefined ) {

			console.error( 'THREE.SSAOPass: The pass relies on SSAOShader.' );

		}

		this.ssaoMaterial = new ShaderMaterial( {
			defines: Object.assign( {}, SSAOShader.defines ),
			uniforms: UniformsUtils.clone( SSAOShader.uniforms ),
			vertexShader: SSAOShader.vertexShader,
			fragmentShader: SSAOShader.fragmentShader,
			blending: NoBlending
		} );

		this.ssaoMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
		this.ssaoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;
		this.ssaoMaterial.uniforms[ 'tDepth' ].value = this.isSharedTarget ? this.depthRenderTarget.texture:this.normalRenderTarget.depthTexture;
		this.ssaoMaterial.uniforms[ 'tNoise' ].value = this.noiseTexture;
		this.ssaoMaterial.uniforms[ 'kernel' ].value = this.kernel;
		this.ssaoMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
		this.ssaoMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;
		this.ssaoMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );
		this.ssaoMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );
		this.ssaoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );

		// normal material

		this.normalMaterial = new MeshNormalMaterial();
		this.normalMaterial.blending = NoBlending;

		// blur material

		this.blurMaterial = new ShaderMaterial( {
			defines: Object.assign( {}, SSAOBlurShader.defines ),
			uniforms: UniformsUtils.clone( SSAOBlurShader.uniforms ),
			vertexShader: SSAOBlurShader.vertexShader,
			fragmentShader: SSAOBlurShader.fragmentShader
		} );
		this.blurMaterial.uniforms[ 'tDiffuse' ].value = this.ssaoRenderTarget.texture;
		this.blurMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );

		// material for rendering the depth

		this.depthRenderMaterial = new ShaderMaterial( {
			defines: Object.assign( {}, SSAODepthShader.defines ),
			uniforms: UniformsUtils.clone( SSAODepthShader.uniforms ),
			vertexShader: SSAODepthShader.vertexShader,
			fragmentShader: SSAODepthShader.fragmentShader,
			blending: NoBlending
		} );
		this.depthRenderMaterial.uniforms[ 'tDepth' ].value = this.normalRenderTarget.depthTexture;
		this.depthRenderMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
		this.depthRenderMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;

		// material for rendering the content of a render target

		this.copyMaterial = new ShaderMaterial( {
			uniforms: UniformsUtils.clone( CopyShader.uniforms ),
			vertexShader: CopyShader.vertexShader,
			fragmentShader: CopyShader.fragmentShader,
			transparent: true,
			depthTest: false,
			depthWrite: false,
			blendSrc: DstColorFactor,
			blendDst: ZeroFactor,
			blendEquation: AddEquation,
			blendSrcAlpha: DstAlphaFactor,
			blendDstAlpha: ZeroFactor,
			blendEquationAlpha: AddEquation
		} );

		this.fsQuad = new FullScreenQuad( null );

		this.originalClearColor = new Color();

	}

	dispose() {

		// dispose render targets

		this.beautyRenderTarget.dispose();
		this.normalRenderTarget.dispose();
		this.ssaoRenderTarget.dispose();
		this.blurRenderTarget.dispose();

		// dispose materials

		this.normalMaterial.dispose();
		this.blurMaterial.dispose();
		this.copyMaterial.dispose();
		this.depthRenderMaterial.dispose();

		// dipsose full screen quad

		this.fsQuad.dispose();

	}

	render( renderer, writeBuffer /*, readBuffer, deltaTime, maskActive */ ) {


		if(!this.isSharedTarget){

		

			// render beauty

			renderer.setRenderTarget( this.beautyRenderTarget );
			renderer.clear();
			renderer.render( this.scene, this.camera );

			// render normals and depth (honor only meshes, points and lines do not contribute to SSAO)

			this.overrideVisibility();
			this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );
			this.restoreVisibility();

		} else {
			/*renderer.setRenderTarget( this.beautyRenderTarget );
			renderer.clear();
			renderer.render( this.scene, this.camera );*/

			this.ssaoMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
			this.ssaoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;
			this.ssaoMaterial.uniforms[ 'tDepth' ].value = this.depthRenderTarget.texture;
		}

		// render SSAO

		this.ssaoMaterial.uniforms[ 'kernelRadius' ].value = this.kernelRadius;
		this.ssaoMaterial.uniforms[ 'minDistance' ].value = this.minDistance;
		this.ssaoMaterial.uniforms[ 'maxDistance' ].value = this.maxDistance;
		this.renderPass( renderer, this.ssaoMaterial, this.ssaoRenderTarget );

		// render blur

		this.renderPass( renderer, this.blurMaterial, this.blurRenderTarget );

		// output result to screen

		switch ( this.output ) {

			case SSAOPass.OUTPUT.SSAO:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssaoRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			case SSAOPass.OUTPUT.Blur:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			case SSAOPass.OUTPUT.Beauty:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			case SSAOPass.OUTPUT.Depth:

				this.renderPass( renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			case SSAOPass.OUTPUT.Normal:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			case SSAOPass.OUTPUT.Default:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;
				this.copyMaterial.blending = CustomBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

				break;

			default:
				console.warn( 'THREE.SSAOPass: Unknown output type.' );

		}

	}

	renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {

		// save original state
		renderer.getClearColor( this.originalClearColor );
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );

		// setup pass state
		renderer.autoClear = false;
		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.fsQuad.material = passMaterial;
		this.fsQuad.render( renderer );

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {

		renderer.getClearColor( this.originalClearColor );
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );
		renderer.autoClear = false;

		clearColor = overrideMaterial.clearColor || clearColor;
		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;

		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.scene.overrideMaterial = overrideMaterial;
		renderer.render( this.scene, this.camera );
		this.scene.overrideMaterial = null;

		// restore original state

		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	setSize( width, height ) {

		this.width = width;
		this.height = height;

		this.beautyRenderTarget.setSize( width, height );
		this.ssaoRenderTarget.setSize( width, height );
		this.normalRenderTarget.setSize( width, height );
		this.blurRenderTarget.setSize( width, height );

		this.ssaoMaterial.uniforms[ 'resolution' ].value.set( width, height );
		this.ssaoMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );
		this.ssaoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );

		this.blurMaterial.uniforms[ 'resolution' ].value.set( width, height );

	}

	generateSampleKernel() {

		const kernelSize = this.kernelSize;
		const kernel = this.kernel;

		for ( let i = 0; i < kernelSize; i ++ ) {

			const sample = new Vector3();
			sample.x = ( Math.random() * 2 ) - 1;
			sample.y = ( Math.random() * 2 ) - 1;
			sample.z = Math.random();

			sample.normalize();

			let scale = i / kernelSize;
			scale = MathUtils.lerp( 0.1, 1, scale * scale );
			sample.multiplyScalar( scale );

			kernel.push( sample );

		}

	}

	generateRandomKernelRotations() {

		const width = 4, height = 4;

		if ( SimplexNoise === undefined ) {

			console.error( 'THREE.SSAOPass: The pass relies on SimplexNoise.' );

		}

		const simplex = new SimplexNoise();

		const size = width * height;
		const data = new Float32Array( size * 4 );

		for ( let i = 0; i < size; i ++ ) {

			const stride = i * 4;

			const x = ( Math.random() * 2 ) - 1;
			const y = ( Math.random() * 2 ) - 1;
			const z = 0;

			const noise = simplex.noise3d( x, y, z );

			data[ stride ] = noise;
			data[ stride + 1 ] = noise;
			data[ stride + 2 ] = noise;
			data[ stride + 3 ] = 1;

		}

		this.noiseTexture = new DataTexture( data, width, height, RGBAFormat, FloatType );
		this.noiseTexture.wrapS = RepeatWrapping;
		this.noiseTexture.wrapT = RepeatWrapping;

	}

	overrideVisibility() {

		const scene = this.scene;
		const cache = this._visibilityCache;

		scene.traverse( function ( object ) {

			cache.set( object, object.visible );

			if ( object.isPoints || object.isLine ) object.visible = false;

		} );

	}

	restoreVisibility() {

		const scene = this.scene;
		const cache = this._visibilityCache;

		scene.traverse( function ( object ) {

			const visible = cache.get( object );
			object.visible = visible;

		} );

		cache.clear();

	}

	setBeautyTarget ( target ) {

		this.beautyRenderTarget = target;
		
	}

	setNormalTarget ( target ) {

		this.normalRenderTarget = target;

	}

	setDepthTarget ( target ) {

		this.depthRenderTarget = target;
		
	}

}

SSAOPass.OUTPUT = {
	'Default': 0,
	'SSAO': 1,
	'Blur': 2,
	'Beauty': 3,
	'Depth': 4,
	'Normal': 5
};

/**
 * TODO
 */

const SAOShader = {
	defines: {
		'NUM_SAMPLES': 7,
		'NUM_RINGS': 4,
		'NORMAL_TEXTURE': 0,
		'DIFFUSE_TEXTURE': 0,
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1
	},
	uniforms: {

		'tDepth': { value: null },
		'tDiffuse': { value: null },
		'tNormal': { value: null },
		'size': { value: new Vector2( 512, 512 ) },

		'cameraNear': { value: 1 },
		'cameraFar': { value: 100 },
		'cameraProjectionMatrix': { value: new Matrix4() },
		'cameraInverseProjectionMatrix': { value: new Matrix4() },

		'scale': { value: 1.0 },
		'intensity': { value: 0.1 },
		'bias': { value: 0.5 },

		'minResolution': { value: 0.0 },
		'kernelRadius': { value: 100.0 },
		'randomSeed': { value: 0.0 }
	},
	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,

	fragmentShader: /* glsl */`

		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform sampler2D tDepth;

		#if NORMAL_TEXTURE == 1
		uniform sampler2D tNormal;
		#endif

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			#if NORMAL_TEXTURE == 1
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#else
			return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}`

};

/**
 * TODO
 */

const DepthLimitedBlurShader = {
	defines: {
		'KERNEL_RADIUS': 4,
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1
	},
	uniforms: {
		'tDiffuse': { value: null },
		'size': { value: new Vector2( 512, 512 ) },
		'sampleUvOffsets': { value: [ new Vector2( 0, 0 ) ] },
		'sampleWeights': { value: [ 1.0 ] },
		'tDepth': { value: null },
		'cameraNear': { value: 10 },
		'cameraFar': { value: 1000 },
		'depthCutoff': { value: 10 },
	},
	vertexShader: /* glsl */`

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,

	fragmentShader: /* glsl */`

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}`

};

const BlurShaderUtils = {

	createSampleWeights: function ( kernelRadius, stdDev ) {

		const weights = [];

		for ( let i = 0; i <= kernelRadius; i ++ ) {

			weights.push( gaussian( i, stdDev ) );

		}

		return weights;

	},

	createSampleOffsets: function ( kernelRadius, uvIncrement ) {

		const offsets = [];

		for ( let i = 0; i <= kernelRadius; i ++ ) {

			offsets.push( uvIncrement.clone().multiplyScalar( i ) );

		}

		return offsets;

	},

	configure: function ( material, kernelRadius, stdDev, uvIncrement ) {

		material.defines[ 'KERNEL_RADIUS' ] = kernelRadius;
		material.uniforms[ 'sampleUvOffsets' ].value = BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );
		material.uniforms[ 'sampleWeights' ].value = BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );
		material.needsUpdate = true;

	}

};

function gaussian( x, stdDev ) {

	return Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );

}

/**
 * Unpack RGBA depth shader
 * - show RGBA encoded depth as monochrome color
 */

const UnpackDepthRGBAShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'opacity': { value: 1.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		#include <packing>

		void main() {

			float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );
			gl_FragColor = vec4( vec3( depth ), opacity );

		}`

};

/**
 * SAO implementation inspired from bhouston previous SAO work
 */

class SAOPass extends Pass {

	constructor( scene, camera, useDepthTexture = false, useNormals = false, resolution = new Vector2( 256, 256 ) ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.clear = true;
		this.needsSwap = false;

		this.isDirectDepth = false;
		this.isDirectNormal = false;


		this.supportsDepthTextureExtension = useDepthTexture;
		this.supportsNormalTexture = useNormals;

		this.originalClearColor = new Color();
		this._oldClearColor = new Color();
		this.oldClearAlpha = 1;

		this.params = {
			output: 0,
			saoBias: 0.5,
			saoIntensity: 0.18,
			saoScale: 1,
			saoKernelRadius: 100,
			saoMinResolution: 0,
			saoBlur: true,
			saoBlurRadius: 8,
			saoBlurStdDev: 4,
			saoBlurDepthCutoff: 0.01
		};

		this.resolution = new Vector2( resolution.x, resolution.y );

		this.saoRenderTarget = new WebGLRenderTarget( this.resolution.x, this.resolution.y, {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			format: RGBAFormat,
			//encoding: sRGBEncoding 
		} );
		this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
		this.beautyRenderTarget = this.saoRenderTarget.clone();

		this.normalRenderTarget = new WebGLRenderTarget( this.resolution.x, this.resolution.y, {
			minFilter: NearestFilter,
			magFilter: NearestFilter,
			format: RGBAFormat
		} );
		this.depthRenderTarget = this.normalRenderTarget.clone();
		
		let depthTexture;

		if ( this.supportsDepthTextureExtension ) {

			depthTexture = new DepthTexture();
			depthTexture.type = UnsignedShortType;

			this.beautyRenderTarget.depthTexture = depthTexture;
			this.beautyRenderTarget.depthBuffer = true;

		}

		this.depthMaterial = new MeshDepthMaterial();
		this.depthMaterial.depthPacking = RGBADepthPacking;
		this.depthMaterial.blending = NoBlending;

		this.normalMaterial = new MeshNormalMaterial();
		this.normalMaterial.blending = NoBlending;

		if ( SAOShader === undefined ) {

			console.error( 'THREE.SAOPass relies on SAOShader' );

		}

		this.saoMaterial = new ShaderMaterial( {
			defines: Object.assign( {}, SAOShader.defines ),
			fragmentShader: SAOShader.fragmentShader,
			vertexShader: SAOShader.vertexShader,
			uniforms: UniformsUtils.clone( SAOShader.uniforms )
		} );
		this.saoMaterial.extensions.derivatives = true;
		this.saoMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;
		this.saoMaterial.defines[ 'NORMAL_TEXTURE' ] = this.supportsNormalTexture ? 1 : 0;
		this.saoMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;
		this.saoMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;
		this.saoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;
		this.saoMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );
		this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );
		this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;
		this.saoMaterial.blending = NoBlending;

		if ( DepthLimitedBlurShader === undefined ) {

			console.error( 'THREE.SAOPass relies on DepthLimitedBlurShader' );

		}

		this.vBlurMaterial = new ShaderMaterial( {
			uniforms: UniformsUtils.clone( DepthLimitedBlurShader.uniforms ),
			defines: Object.assign( {}, DepthLimitedBlurShader.defines ),
			vertexShader: DepthLimitedBlurShader.vertexShader,
			fragmentShader: DepthLimitedBlurShader.fragmentShader
		} );
		this.vBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;
		this.vBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;
		this.vBlurMaterial.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;
		this.vBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;
		this.vBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );
		this.vBlurMaterial.blending = NoBlending;

		this.hBlurMaterial = new ShaderMaterial( {
			uniforms: UniformsUtils.clone( DepthLimitedBlurShader.uniforms ),
			defines: Object.assign( {}, DepthLimitedBlurShader.defines ),
			vertexShader: DepthLimitedBlurShader.vertexShader,
			fragmentShader: DepthLimitedBlurShader.fragmentShader
		} );
		this.hBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;
		this.hBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;
		this.hBlurMaterial.uniforms[ 'tDiffuse' ].value = this.blurIntermediateRenderTarget.texture;
		this.hBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;
		this.hBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );
		this.hBlurMaterial.blending = NoBlending;

		if ( CopyShader === undefined ) {

			console.error( 'THREE.SAOPass relies on CopyShader' );

		}

		this.materialCopy = new ShaderMaterial( {
			uniforms: UniformsUtils.clone( CopyShader.uniforms ),
			vertexShader: CopyShader.vertexShader,
			fragmentShader: CopyShader.fragmentShader,
			blending: NoBlending
		} );
		this.materialCopy.transparent = true;
		this.materialCopy.depthTest = false;
		this.materialCopy.depthWrite = false;
		this.materialCopy.blending = CustomBlending;
		this.materialCopy.blendSrc = DstColorFactor;
		this.materialCopy.blendDst = ZeroFactor;
		this.materialCopy.blendEquation = AddEquation;
		this.materialCopy.blendSrcAlpha = DstAlphaFactor;
		this.materialCopy.blendDstAlpha = ZeroFactor;
		this.materialCopy.blendEquationAlpha = AddEquation;

		if ( UnpackDepthRGBAShader === undefined ) {

			console.error( 'THREE.SAOPass relies on UnpackDepthRGBAShader' );

		}

		this.depthCopy = new ShaderMaterial( {
			uniforms: UniformsUtils.clone( UnpackDepthRGBAShader.uniforms ),
			vertexShader: UnpackDepthRGBAShader.vertexShader,
			fragmentShader: UnpackDepthRGBAShader.fragmentShader,
			blending: NoBlending
		} );

		this.fsQuad = new FullScreenQuad( null );

		this.applyValue();

	}

	applyValue (){

		let uni = this.saoMaterial.uniforms;

		uni.bias.value = this.params.saoBias;
		uni.intensity.value = this.params.saoIntensity;
		uni.scale.value = this.params.saoScale;
		uni.kernelRadius.value = this.params.saoKernelRadius;
		uni.minResolution.value = this.params.saoMinResolution;
		uni.cameraNear.value = this.camera.near;
		uni.cameraFar.value = this.camera.far;
		// this.saoMaterial.uniforms['randomSeed'].value = Math.random();

		const depthCutoff = this.params.saoBlurDepthCutoff * ( this.camera.far - this.camera.near );

		uni = this.vBlurMaterial.uniforms;

		uni.depthCutoff.value = depthCutoff;
		uni.cameraNear.value = this.camera.near;
		uni.cameraFar.value = this.camera.far;

		uni = this.hBlurMaterial.uniforms;

		uni.depthCutoff.value = depthCutoff;
		uni.cameraNear.value = this.camera.near;
		uni.cameraFar.value = this.camera.far;

		this.params.saoBlurRadius = Math.floor( this.params.saoBlurRadius );
		if ( ( this.prevStdDev !== this.params.saoBlurStdDev ) || ( this.prevNumSamples !== this.params.saoBlurRadius ) ) {

			BlurShaderUtils.configure( this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 0, 1 ) );
			BlurShaderUtils.configure( this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 1, 0 ) );
			this.prevStdDev = this.params.saoBlurStdDev;
			this.prevNumSamples = this.params.saoBlurRadius;

		}

	}

	render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {

		// Rendering readBuffer first when rendering to screen
		if ( this.renderToScreen ) {

			this.materialCopy.blending = NoBlending;
			this.materialCopy.uniforms[ 'tDiffuse' ].value = readBuffer.texture;
			this.materialCopy.needsUpdate = true;
			this.renderPass( renderer, this.materialCopy, null );

		}

		if ( this.params.output === 1 ) return;

		renderer.getClearColor( this._oldClearColor );
		this.oldClearAlpha = renderer.getClearAlpha();
		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setRenderTarget( this.depthRenderTarget );
		renderer.clear();

		/*this.params.saoBlurRadius = Math.floor( this.params.saoBlurRadius );
		if ( ( this.prevStdDev !== this.params.saoBlurStdDev ) || ( this.prevNumSamples !== this.params.saoBlurRadius ) ) {

			BlurShaderUtils.configure( this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 0, 1 ) );
			BlurShaderUtils.configure( this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 1, 0 ) );
			this.prevStdDev = this.params.saoBlurStdDev;
			this.prevNumSamples = this.params.saoBlurRadius;

		}*/

		if ( ! this.isDirectDepth ){
			
			// Rendering scene to depth texture
			renderer.setClearColor( 0x000000 );
			renderer.setRenderTarget( this.beautyRenderTarget );
			renderer.clear();
			renderer.render( this.scene, this.camera );

			// Re-render scene if depth texture extension is not supported
			if ( ! this.supportsDepthTextureExtension ) {

				// Clear rule : far clipping plane in both RGBA and Basic encoding
				this.renderOverride( renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0 );

			}
		}

		if ( this.supportsNormalTexture ) {

			// Clear rule : default normal is facing the camera
			if ( ! this.isDirectNormal ) this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );

		}

		// Rendering SAO texture
		this.renderPass( renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0 );

		// Blurring SAO texture
		if ( this.params.saoBlur ) {

			this.renderPass( renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0 );
			this.renderPass( renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0 );

		}

		let outputMaterial = this.materialCopy;
		// Setting up SAO rendering
		if ( this.params.output === 3 ) {

			if ( this.supportsDepthTextureExtension ) {

				this.materialCopy.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.depthTexture;
				this.materialCopy.needsUpdate = true;

			} else {

				this.depthCopy.uniforms[ 'tDiffuse' ].value = this.depthRenderTarget.texture;
				this.depthCopy.needsUpdate = true;
				outputMaterial = this.depthCopy;

			}

		} else if ( this.params.output === 4 ) {

			this.materialCopy.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;
			this.materialCopy.needsUpdate = true;

		} else {

			this.materialCopy.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;
			this.materialCopy.needsUpdate = true;

		}

		// Blending depends on output, only want a CustomBlending when showing SAO
		if ( this.params.output === 0 ) {

			outputMaterial.blending = CustomBlending;

		} else {

			outputMaterial.blending = NoBlending;

		}

		// Rendering SAOPass result on top of previous pass
		this.renderPass( renderer, outputMaterial, this.renderToScreen ? null : readBuffer );

		renderer.setClearColor( this._oldClearColor, this.oldClearAlpha );
		renderer.autoClear = oldAutoClear;

	}

	renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {

		// save original state
		renderer.getClearColor( this.originalClearColor );
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );

		// setup pass state
		renderer.autoClear = false;
		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.fsQuad.material = passMaterial;
		this.fsQuad.render( renderer );

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {

		renderer.getClearColor( this.originalClearColor );
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );
		renderer.autoClear = false;

		clearColor = overrideMaterial.clearColor || clearColor;
		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.scene.overrideMaterial = overrideMaterial;
		renderer.render( this.scene, this.camera );
		this.scene.overrideMaterial = null;

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	setSize( width, height ) {

		this.beautyRenderTarget.setSize( width, height );
		this.saoRenderTarget.setSize( width, height );
		this.blurIntermediateRenderTarget.setSize( width, height );
		this.normalRenderTarget.setSize( width, height );
		this.depthRenderTarget.setSize( width, height );

		this.saoMaterial.uniforms[ 'size' ].value.set( width, height );
		this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );
		this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;
		this.saoMaterial.needsUpdate = true;

		this.vBlurMaterial.uniforms[ 'size' ].value.set( width, height );
		this.vBlurMaterial.needsUpdate = true;

		this.hBlurMaterial.uniforms[ 'size' ].value.set( width, height );
		this.hBlurMaterial.needsUpdate = true;

	}

	setNormalTarget ( target ) {

		this.isDirectNormal = true;
		this.normalRenderTarget = target;
		this.saoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;

	}

	setDepthTarget ( target ) {

		if( this.supportsDepthTextureExtension ) return;

		this.isDirectDepth = true;
		this.depthRenderTarget = target;
		this.saoMaterial.uniforms[ 'tDepth' ].value = this.depthRenderTarget.texture;
		
	}

}

SAOPass.OUTPUT = {
	'Beauty': 1,
	'Default': 0,
	'SAO': 2,
	'Depth': 3,
	'Normal': 4
};

/**
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

const FXAAShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'resolution': { value: new Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader:

	// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

	//----------------------------------------------------------------------------------
	// File:				es3-kepler\FXAA\assets\shaders/FXAA_DefaultES.frag
	// SDK Version: v3.00
	// Email:			 gameworks@nvidia.com
	// Site:				http://developer.nvidia.com/
	//
	// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions
	// are met:
	//	* Redistributions of source code must retain the above copyright
	//		notice, this list of conditions and the following disclaimer.
	//	* Redistributions in binary form must reproduce the above copyright
	//		notice, this list of conditions and the following disclaimer in the
	//		documentation and/or other materials provided with the distribution.
	//	* Neither the name of NVIDIA CORPORATION nor the names of its
	//		contributors may be used to endorse or promote products derived
	//		from this software without specific prior written permission.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\'\' AND ANY
	// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	// PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	//
	//----------------------------------------------------------------------------------

		/* glsl */`

		precision highp float;

		uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		#define FXAA_PC 1
		#define FXAA_GLSL_100 1
		#define FXAA_QUALITY_PRESET 12

		#define FXAA_GREEN_AS_LUMA 1

		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_PC_CONSOLE
				//
				// The console algorithm for PC is included
				// for developers targeting really low spec machines.
				// Likely better to just run FXAA_PC, and use a really low preset.
				//
				#define FXAA_PC_CONSOLE 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GLSL_120
				#define FXAA_GLSL_120 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GLSL_130
				#define FXAA_GLSL_130 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_3
				#define FXAA_HLSL_3 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_4
				#define FXAA_HLSL_4 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_5
				#define FXAA_HLSL_5 0
		#endif
		/*==========================================================================*/
		#ifndef FXAA_GREEN_AS_LUMA
				//
				// For those using non-linear color,
				// and either not able to get luma in alpha, or not wanting to,
				// this enables FXAA to run using green as a proxy for luma.
				// So with this enabled, no need to pack luma in alpha.
				//
				// This will turn off AA on anything which lacks some amount of green.
				// Pure red and blue or combination of only R and B, will get no AA.
				//
				// Might want to lower the settings for both,
				//		fxaaConsoleEdgeThresholdMin
				//		fxaaQualityEdgeThresholdMin
				// In order to insure AA does not get turned off on colors
				// which contain a minor amount of green.
				//
				// 1 = On.
				// 0 = Off.
				//
				#define FXAA_GREEN_AS_LUMA 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_EARLY_EXIT
				//
				// Controls algorithm\'s early exit path.
				// On PS3 turning this ON adds 2 cycles to the shader.
				// On 360 turning this OFF adds 10ths of a millisecond to the shader.
				// Turning this off on console will result in a more blurry image.
				// So this defaults to on.
				//
				// 1 = On.
				// 0 = Off.
				//
				#define FXAA_EARLY_EXIT 1
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_DISCARD
				//
				// Only valid for PC OpenGL currently.
				// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
				//
				// 1 = Use discard on pixels which don\'t need AA.
				//		 For APIs which enable concurrent TEX+ROP from same surface.
				// 0 = Return unchanged color on pixels which don\'t need AA.
				//
				#define FXAA_DISCARD 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_FAST_PIXEL_OFFSET
				//
				// Used for GLSL 120 only.
				//
				// 1 = GL API supports fast pixel offsets
				// 0 = do not use fast pixel offsets
				//
				#ifdef GL_EXT_gpu_shader4
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifdef GL_NV_gpu_shader5
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifdef GL_ARB_gpu_shader5
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifndef FXAA_FAST_PIXEL_OFFSET
						#define FXAA_FAST_PIXEL_OFFSET 0
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GATHER4_ALPHA
				//
				// 1 = API supports gather4 on alpha channel.
				// 0 = API does not support gather4 on alpha channel.
				//
				#if (FXAA_HLSL_5 == 1)
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifdef GL_ARB_gpu_shader5
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifdef GL_NV_gpu_shader5
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifndef FXAA_GATHER4_ALPHA
						#define FXAA_GATHER4_ALPHA 0
				#endif
		#endif


		/*============================================================================
														FXAA QUALITY - TUNING KNOBS
		------------------------------------------------------------------------------
		NOTE the other tuning knobs are now in the shader function inputs!
		============================================================================*/
		#ifndef FXAA_QUALITY_PRESET
				//
				// Choose the quality preset.
				// This needs to be compiled into the shader as it effects code.
				// Best option to include multiple presets is to
				// in each shader define the preset, then include this file.
				//
				// OPTIONS
				// -----------------------------------------------------------------------
				// 10 to 15 - default medium dither (10=fastest, 15=highest quality)
				// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
				// 39			 - no dither, very expensive
				//
				// NOTES
				// -----------------------------------------------------------------------
				// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
				// 13 = about same speed as FXAA 3.9 and better than 12
				// 23 = closest to FXAA 3.9 visually and performance wise
				//	_ = the lowest digit is directly related to performance
				// _	= the highest digit is directly related to style
				//
				#define FXAA_QUALITY_PRESET 12
		#endif


		/*============================================================================

															 FXAA QUALITY - PRESETS

		============================================================================*/

		/*============================================================================
												 FXAA QUALITY - MEDIUM DITHER PRESETS
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 10)
				#define FXAA_QUALITY_PS 3
				#define FXAA_QUALITY_P0 1.5
				#define FXAA_QUALITY_P1 3.0
				#define FXAA_QUALITY_P2 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 11)
				#define FXAA_QUALITY_PS 4
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 3.0
				#define FXAA_QUALITY_P3 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 12)
				#define FXAA_QUALITY_PS 5
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 4.0
				#define FXAA_QUALITY_P4 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 13)
				#define FXAA_QUALITY_PS 6
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 4.0
				#define FXAA_QUALITY_P5 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 14)
				#define FXAA_QUALITY_PS 7
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 4.0
				#define FXAA_QUALITY_P6 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 15)
				#define FXAA_QUALITY_PS 8
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 4.0
				#define FXAA_QUALITY_P7 12.0
		#endif

		/*============================================================================
												 FXAA QUALITY - LOW DITHER PRESETS
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 20)
				#define FXAA_QUALITY_PS 3
				#define FXAA_QUALITY_P0 1.5
				#define FXAA_QUALITY_P1 2.0
				#define FXAA_QUALITY_P2 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 21)
				#define FXAA_QUALITY_PS 4
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 22)
				#define FXAA_QUALITY_PS 5
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 23)
				#define FXAA_QUALITY_PS 6
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 24)
				#define FXAA_QUALITY_PS 7
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 3.0
				#define FXAA_QUALITY_P6 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 25)
				#define FXAA_QUALITY_PS 8
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 4.0
				#define FXAA_QUALITY_P7 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 26)
				#define FXAA_QUALITY_PS 9
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 4.0
				#define FXAA_QUALITY_P8 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 27)
				#define FXAA_QUALITY_PS 10
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 4.0
				#define FXAA_QUALITY_P9 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 28)
				#define FXAA_QUALITY_PS 11
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 4.0
				#define FXAA_QUALITY_P10 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 29)
				#define FXAA_QUALITY_PS 12
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 2.0
				#define FXAA_QUALITY_P10 4.0
				#define FXAA_QUALITY_P11 8.0
		#endif

		/*============================================================================
												 FXAA QUALITY - EXTREME QUALITY
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 39)
				#define FXAA_QUALITY_PS 12
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.0
				#define FXAA_QUALITY_P2 1.0
				#define FXAA_QUALITY_P3 1.0
				#define FXAA_QUALITY_P4 1.0
				#define FXAA_QUALITY_P5 1.5
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 2.0
				#define FXAA_QUALITY_P10 4.0
				#define FXAA_QUALITY_P11 8.0
		#endif



		/*============================================================================

																		API PORTING

		============================================================================*/
		#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)
				#define FxaaBool bool
				#define FxaaDiscard discard
				#define FxaaFloat float
				#define FxaaFloat2 vec2
				#define FxaaFloat3 vec3
				#define FxaaFloat4 vec4
				#define FxaaHalf float
				#define FxaaHalf2 vec2
				#define FxaaHalf3 vec3
				#define FxaaHalf4 vec4
				#define FxaaInt2 ivec2
				#define FxaaSat(x) clamp(x, 0.0, 1.0)
				#define FxaaTex sampler2D
		#else
				#define FxaaBool bool
				#define FxaaDiscard clip(-1)
				#define FxaaFloat float
				#define FxaaFloat2 float2
				#define FxaaFloat3 float3
				#define FxaaFloat4 float4
				#define FxaaHalf half
				#define FxaaHalf2 half2
				#define FxaaHalf3 half3
				#define FxaaHalf4 half4
				#define FxaaSat(x) saturate(x)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_100 == 1)
			#define FxaaTexTop(t, p) texture2D(t, p, 0.0)
			#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_120 == 1)
				// Requires,
				//	#version 120
				// And at least,
				//	#extension GL_EXT_gpu_shader4 : enable
				//	(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)
				#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
				#if (FXAA_FAST_PIXEL_OFFSET == 1)
						#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)
				#else
						#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
				#endif
				#if (FXAA_GATHER4_ALPHA == 1)
						// use #extension GL_ARB_gpu_shader5 : enable
						#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
						#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
						#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
						#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_130 == 1)
				// Requires "#version 130" or better
				#define FxaaTexTop(t, p) textureLod(t, p, 0.0)
				#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
				#if (FXAA_GATHER4_ALPHA == 1)
						// use #extension GL_ARB_gpu_shader5 : enable
						#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
						#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
						#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
						#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_3 == 1)
				#define FxaaInt2 float2
				#define FxaaTex sampler2D
				#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))
				#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_4 == 1)
				#define FxaaInt2 int2
				struct FxaaTex { SamplerState smpl; Texture2D tex; };
				#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
				#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_5 == 1)
				#define FxaaInt2 int2
				struct FxaaTex { SamplerState smpl; Texture2D tex; };
				#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
				#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
				#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)
				#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)
				#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)
				#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)
		#endif


		/*============================================================================
											 GREEN AS LUMA OPTION SUPPORT FUNCTION
		============================================================================*/
		#if (FXAA_GREEN_AS_LUMA == 0)
				FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }
		#else
				FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
		#endif




		/*============================================================================

																 FXAA3 QUALITY - PC

		============================================================================*/
		#if (FXAA_PC == 1)
		/*--------------------------------------------------------------------------*/
		FxaaFloat4 FxaaPixelShader(
				//
				// Use noperspective interpolation here (turn off perspective interpolation).
				// {xy} = center of pixel
				FxaaFloat2 pos,
				//
				// Used only for FXAA Console, and not used on the 360 version.
				// Use noperspective interpolation here (turn off perspective interpolation).
				// {xy_} = upper left of pixel
				// {_zw} = lower right of pixel
				FxaaFloat4 fxaaConsolePosPos,
				//
				// Input color texture.
				// {rgb_} = color in linear or perceptual color space
				// if (FXAA_GREEN_AS_LUMA == 0)
				//		 {__a} = luma in perceptual color space (not linear)
				FxaaTex tex,
				//
				// Only used on the optimized 360 version of FXAA Console.
				// For everything but 360, just use the same input here as for "tex".
				// For 360, same texture, just alias with a 2nd sampler.
				// This sampler needs to have an exponent bias of -1.
				FxaaTex fxaaConsole360TexExpBiasNegOne,
				//
				// Only used on the optimized 360 version of FXAA Console.
				// For everything but 360, just use the same input here as for "tex".
				// For 360, same texture, just alias with a 3nd sampler.
				// This sampler needs to have an exponent bias of -2.
				FxaaTex fxaaConsole360TexExpBiasNegTwo,
				//
				// Only used on FXAA Quality.
				// This must be from a constant/uniform.
				// {x_} = 1.0/screenWidthInPixels
				// {_y} = 1.0/screenHeightInPixels
				FxaaFloat2 fxaaQualityRcpFrame,
				//
				// Only used on FXAA Console.
				// This must be from a constant/uniform.
				// This effects sub-pixel AA quality and inversely sharpness.
				//	 Where N ranges between,
				//		 N = 0.50 (default)
				//		 N = 0.33 (sharper)
				// {x__} = -N/screenWidthInPixels
				// {_y_} = -N/screenHeightInPixels
				// {_z_} =	N/screenWidthInPixels
				// {__w} =	N/screenHeightInPixels
				FxaaFloat4 fxaaConsoleRcpFrameOpt,
				//
				// Only used on FXAA Console.
				// Not used on 360, but used on PS3 and PC.
				// This must be from a constant/uniform.
				// {x__} = -2.0/screenWidthInPixels
				// {_y_} = -2.0/screenHeightInPixels
				// {_z_} =	2.0/screenWidthInPixels
				// {__w} =	2.0/screenHeightInPixels
				FxaaFloat4 fxaaConsoleRcpFrameOpt2,
				//
				// Only used on FXAA Console.
				// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.
				// This must be from a constant/uniform.
				// {x__} =	8.0/screenWidthInPixels
				// {_y_} =	8.0/screenHeightInPixels
				// {_z_} = -4.0/screenWidthInPixels
				// {__w} = -4.0/screenHeightInPixels
				FxaaFloat4 fxaaConsole360RcpFrameOpt2,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_SUBPIX define.
				// It is here now to allow easier tuning.
				// Choose the amount of sub-pixel aliasing removal.
				// This can effect sharpness.
				//	 1.00 - upper limit (softer)
				//	 0.75 - default amount of filtering
				//	 0.50 - lower limit (sharper, less sub-pixel aliasing removal)
				//	 0.25 - almost off
				//	 0.00 - completely off
				FxaaFloat fxaaQualitySubpix,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
				// It is here now to allow easier tuning.
				// The minimum amount of local contrast required to apply algorithm.
				//	 0.333 - too little (faster)
				//	 0.250 - low quality
				//	 0.166 - default
				//	 0.125 - high quality
				//	 0.063 - overkill (slower)
				FxaaFloat fxaaQualityEdgeThreshold,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
				// It is here now to allow easier tuning.
				// Trims the algorithm from processing darks.
				//	 0.0833 - upper limit (default, the start of visible unfiltered edges)
				//	 0.0625 - high quality (faster)
				//	 0.0312 - visible limit (slower)
				// Special notes when using FXAA_GREEN_AS_LUMA,
				//	 Likely want to set this to zero.
				//	 As colors that are mostly not-green
				//	 will appear very dark in the green channel!
				//	 Tune by looking at mostly non-green content,
				//	 then start at zero and increase until aliasing is a problem.
				FxaaFloat fxaaQualityEdgeThresholdMin,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.
				// It is here now to allow easier tuning.
				// This does not effect PS3, as this needs to be compiled in.
				//	 Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.
				//	 Due to the PS3 being ALU bound,
				//	 there are only three safe values here: 2 and 4 and 8.
				//	 These options use the shaders ability to a free *|/ by 2|4|8.
				// For all other platforms can be a non-power of two.
				//	 8.0 is sharper (default!!!)
				//	 4.0 is softer
				//	 2.0 is really soft (good only for vector graphics inputs)
				FxaaFloat fxaaConsoleEdgeSharpness,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.
				// It is here now to allow easier tuning.
				// This does not effect PS3, as this needs to be compiled in.
				//	 Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.
				//	 Due to the PS3 being ALU bound,
				//	 there are only two safe values here: 1/4 and 1/8.
				//	 These options use the shaders ability to a free *|/ by 2|4|8.
				// The console setting has a different mapping than the quality setting.
				// Other platforms can use other values.
				//	 0.125 leaves less aliasing, but is softer (default!!!)
				//	 0.25 leaves more aliasing, and is sharper
				FxaaFloat fxaaConsoleEdgeThreshold,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.
				// It is here now to allow easier tuning.
				// Trims the algorithm from processing darks.
				// The console setting has a different mapping than the quality setting.
				// This only applies when FXAA_EARLY_EXIT is 1.
				// This does not apply to PS3,
				// PS3 was simplified to avoid more shader instructions.
				//	 0.06 - faster but more aliasing in darks
				//	 0.05 - default
				//	 0.04 - slower and less aliasing in darks
				// Special notes when using FXAA_GREEN_AS_LUMA,
				//	 Likely want to set this to zero.
				//	 As colors that are mostly not-green
				//	 will appear very dark in the green channel!
				//	 Tune by looking at mostly non-green content,
				//	 then start at zero and increase until aliasing is a problem.
				FxaaFloat fxaaConsoleEdgeThresholdMin,
				//
				// Extra constants for 360 FXAA Console only.
				// Use zeros or anything else for other platforms.
				// These must be in physical constant registers and NOT immediates.
				// Immediates will result in compiler un-optimizing.
				// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)
				FxaaFloat4 fxaaConsole360ConstDir
		) {
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posM;
				posM.x = pos.x;
				posM.y = pos.y;
				#if (FXAA_GATHER4_ALPHA == 1)
						#if (FXAA_DISCARD == 0)
								FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
								#if (FXAA_GREEN_AS_LUMA == 0)
										#define lumaM rgbyM.w
								#else
										#define lumaM rgbyM.y
								#endif
						#endif
						#if (FXAA_GREEN_AS_LUMA == 0)
								FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);
								FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));
						#else
								FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);
								FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));
						#endif
						#if (FXAA_DISCARD == 1)
								#define lumaM luma4A.w
						#endif
						#define lumaE luma4A.z
						#define lumaS luma4A.x
						#define lumaSE luma4A.y
						#define lumaNW luma4B.w
						#define lumaN luma4B.z
						#define lumaW luma4B.x
				#else
						FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
						#if (FXAA_GREEN_AS_LUMA == 0)
								#define lumaM rgbyM.w
						#else
								#define lumaM rgbyM.y
						#endif
						#if (FXAA_GLSL_100 == 1)
							FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));
						#else
							FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
						#endif
				#endif
		/*--------------------------------------------------------------------------*/
				FxaaFloat maxSM = max(lumaS, lumaM);
				FxaaFloat minSM = min(lumaS, lumaM);
				FxaaFloat maxESM = max(lumaE, maxSM);
				FxaaFloat minESM = min(lumaE, minSM);
				FxaaFloat maxWN = max(lumaN, lumaW);
				FxaaFloat minWN = min(lumaN, lumaW);
				FxaaFloat rangeMax = max(maxWN, maxESM);
				FxaaFloat rangeMin = min(minWN, minESM);
				FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
				FxaaFloat range = rangeMax - rangeMin;
				FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
				FxaaBool earlyExit = range < rangeMaxClamped;
		/*--------------------------------------------------------------------------*/
				if(earlyExit)
						#if (FXAA_DISCARD == 1)
								FxaaDiscard;
						#else
								return rgbyM;
						#endif
		/*--------------------------------------------------------------------------*/
				#if (FXAA_GATHER4_ALPHA == 0)
						#if (FXAA_GLSL_100 == 1)
							FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));
						#else
							FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
						#endif
				#else
						FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
						FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
				#endif
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNS = lumaN + lumaS;
				FxaaFloat lumaWE = lumaW + lumaE;
				FxaaFloat subpixRcpRange = 1.0/range;
				FxaaFloat subpixNSWE = lumaNS + lumaWE;
				FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
				FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNESE = lumaNE + lumaSE;
				FxaaFloat lumaNWNE = lumaNW + lumaNE;
				FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
				FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNWSW = lumaNW + lumaSW;
				FxaaFloat lumaSWSE = lumaSW + lumaSE;
				FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
				FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
				FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
				FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
				FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
				FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
		/*--------------------------------------------------------------------------*/
				FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
				FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
				FxaaBool horzSpan = edgeHorz >= edgeVert;
				FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
		/*--------------------------------------------------------------------------*/
				if(!horzSpan) lumaN = lumaW;
				if(!horzSpan) lumaS = lumaE;
				if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
				FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
		/*--------------------------------------------------------------------------*/
				FxaaFloat gradientN = lumaN - lumaM;
				FxaaFloat gradientS = lumaS - lumaM;
				FxaaFloat lumaNN = lumaN + lumaM;
				FxaaFloat lumaSS = lumaS + lumaM;
				FxaaBool pairN = abs(gradientN) >= abs(gradientS);
				FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
				if(pairN) lengthSign = -lengthSign;
				FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posB;
				posB.x = posM.x;
				posB.y = posM.y;
				FxaaFloat2 offNP;
				offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
				offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
				if(!horzSpan) posB.x += lengthSign * 0.5;
				if( horzSpan) posB.y += lengthSign * 0.5;
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posN;
				posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
				posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
				FxaaFloat2 posP;
				posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
				posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
				FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
				FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
				FxaaFloat subpixE = subpixC * subpixC;
				FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
		/*--------------------------------------------------------------------------*/
				if(!pairN) lumaNN = lumaSS;
				FxaaFloat gradientScaled = gradient * 1.0/4.0;
				FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
				FxaaFloat subpixF = subpixD * subpixE;
				FxaaBool lumaMLTZero = lumaMM < 0.0;
		/*--------------------------------------------------------------------------*/
				lumaEndN -= lumaNN * 0.5;
				lumaEndP -= lumaNN * 0.5;
				FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
				FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
				if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
				if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
				FxaaBool doneNP = (!doneN) || (!doneP);
				if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
				if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
		/*--------------------------------------------------------------------------*/
				if(doneNP) {
						if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
						if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
						doneNP = (!doneN) || (!doneP);
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
		/*--------------------------------------------------------------------------*/
						#if (FXAA_QUALITY_PS > 3)
						if(doneNP) {
								if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
								if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
								if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
								if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
								doneN = abs(lumaEndN) >= gradientScaled;
								doneP = abs(lumaEndP) >= gradientScaled;
								if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
								if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
								doneNP = (!doneN) || (!doneP);
								if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
								if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
		/*--------------------------------------------------------------------------*/
								#if (FXAA_QUALITY_PS > 4)
								if(doneNP) {
										if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
										if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
										if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
										if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
										doneN = abs(lumaEndN) >= gradientScaled;
										doneP = abs(lumaEndP) >= gradientScaled;
										if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
										if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
										doneNP = (!doneN) || (!doneP);
										if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
										if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
		/*--------------------------------------------------------------------------*/
										#if (FXAA_QUALITY_PS > 5)
										if(doneNP) {
												if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
												if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
												if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
												if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
												doneN = abs(lumaEndN) >= gradientScaled;
												doneP = abs(lumaEndP) >= gradientScaled;
												if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
												if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
												doneNP = (!doneN) || (!doneP);
												if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
												if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
		/*--------------------------------------------------------------------------*/
												#if (FXAA_QUALITY_PS > 6)
												if(doneNP) {
														if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
														if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
														if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
														if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
														doneN = abs(lumaEndN) >= gradientScaled;
														doneP = abs(lumaEndP) >= gradientScaled;
														if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
														if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
														doneNP = (!doneN) || (!doneP);
														if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
														if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
		/*--------------------------------------------------------------------------*/
														#if (FXAA_QUALITY_PS > 7)
														if(doneNP) {
																if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
																if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
																if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
																if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
																doneN = abs(lumaEndN) >= gradientScaled;
																doneP = abs(lumaEndP) >= gradientScaled;
																if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
																if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
																doneNP = (!doneN) || (!doneP);
																if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
																if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
		/*--------------------------------------------------------------------------*/
				#if (FXAA_QUALITY_PS > 8)
				if(doneNP) {
						if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
						if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
						doneNP = (!doneN) || (!doneP);
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
		/*--------------------------------------------------------------------------*/
						#if (FXAA_QUALITY_PS > 9)
						if(doneNP) {
								if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
								if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
								if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
								if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
								doneN = abs(lumaEndN) >= gradientScaled;
								doneP = abs(lumaEndP) >= gradientScaled;
								if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
								if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
								doneNP = (!doneN) || (!doneP);
								if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
								if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
		/*--------------------------------------------------------------------------*/
								#if (FXAA_QUALITY_PS > 10)
								if(doneNP) {
										if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
										if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
										if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
										if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
										doneN = abs(lumaEndN) >= gradientScaled;
										doneP = abs(lumaEndP) >= gradientScaled;
										if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
										if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
										doneNP = (!doneN) || (!doneP);
										if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
										if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
		/*--------------------------------------------------------------------------*/
										#if (FXAA_QUALITY_PS > 11)
										if(doneNP) {
												if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
												if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
												if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
												if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
												doneN = abs(lumaEndN) >= gradientScaled;
												doneP = abs(lumaEndP) >= gradientScaled;
												if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
												if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
												doneNP = (!doneN) || (!doneP);
												if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
												if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
		/*--------------------------------------------------------------------------*/
												#if (FXAA_QUALITY_PS > 12)
												if(doneNP) {
														if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
														if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
														if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
														if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
														doneN = abs(lumaEndN) >= gradientScaled;
														doneP = abs(lumaEndP) >= gradientScaled;
														if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
														if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
														doneNP = (!doneN) || (!doneP);
														if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
														if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
		/*--------------------------------------------------------------------------*/
												}
												#endif
		/*--------------------------------------------------------------------------*/
										}
										#endif
		/*--------------------------------------------------------------------------*/
								}
								#endif
		/*--------------------------------------------------------------------------*/
						}
						#endif
		/*--------------------------------------------------------------------------*/
				}
				#endif
		/*--------------------------------------------------------------------------*/
														}
														#endif
		/*--------------------------------------------------------------------------*/
												}
												#endif
		/*--------------------------------------------------------------------------*/
										}
										#endif
		/*--------------------------------------------------------------------------*/
								}
								#endif
		/*--------------------------------------------------------------------------*/
						}
						#endif
		/*--------------------------------------------------------------------------*/
				}
		/*--------------------------------------------------------------------------*/
				FxaaFloat dstN = posM.x - posN.x;
				FxaaFloat dstP = posP.x - posM.x;
				if(!horzSpan) dstN = posM.y - posN.y;
				if(!horzSpan) dstP = posP.y - posM.y;
		/*--------------------------------------------------------------------------*/
				FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
				FxaaFloat spanLength = (dstP + dstN);
				FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
				FxaaFloat spanLengthRcp = 1.0/spanLength;
		/*--------------------------------------------------------------------------*/
				FxaaBool directionN = dstN < dstP;
				FxaaFloat dst = min(dstN, dstP);
				FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
				FxaaFloat subpixG = subpixF * subpixF;
				FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
				FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
		/*--------------------------------------------------------------------------*/
				FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
				FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
				if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
				if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
				#if (FXAA_DISCARD == 1)
						return FxaaTexTop(tex, posM);
				#else
						return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
				#endif
		}
		/*==========================================================================*/
		#endif

		void main() {
			gl_FragColor = FxaaPixelShader(
				vUv,
				vec4(0.0),
				tDiffuse,
				tDiffuse,
				tDiffuse,
				resolution,
				vec4(0.0),
				vec4(0.0),
				vec4(0.0),
				0.75,
				0.166,
				0.0833,
				0.0,
				0.0,
				0.0,
				vec4(0.0)
			);

			// TODO avoid querying texture twice for same texel
			gl_FragColor.a = texture2D(tDiffuse, vUv).a;
		}`

};

/**
 * BloomMix shader
 */

const BloomMix = {

	uniforms: {

		'tDiffuse': { value: null },
		'bloomTexture': { value: null }

	},

	vertexShader: /* glsl */`

        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`,

	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
        uniform sampler2D bloomTexture;
        varying vec2 vUv;

        void main() {
            gl_FragColor = ( texture2D( tDiffuse, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );
        }`

};

// https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf

class LUTCubeLoader extends Loader {

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'text' );
		loader.load( url, text => {

			try {

				onLoad( this.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				this.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( str ) {

		// Remove empty lines and comments
		str = str
			.replace( /^#.*?(\n|\r)/gm, '' )
			.replace( /^\s*?(\n|\r)/gm, '' )
			.trim();

		let title = null;
		let size = null;
		const domainMin = new Vector3( 0, 0, 0 );
		const domainMax = new Vector3( 1, 1, 1 );

		const lines = str.split( /[\n\r]+/g );
		let data = null;

		let currIndex = 0;
		for ( let i = 0, l = lines.length; i < l; i ++ ) {

			const line = lines[ i ].trim();
			const split = line.split( /\s/g );

			switch ( split[ 0 ] ) {

				case 'TITLE':
					title = line.substring( 7, line.length - 1 );
					break;
				case 'LUT_3D_SIZE':
					// TODO: A .CUBE LUT file specifies floating point values and could be represented with
					// more precision than can be captured with Uint8Array.
					const sizeToken = split[ 1 ];
					size = parseFloat( sizeToken );
					data = new Uint8Array( size * size * size * 4 );
					break;
				case 'DOMAIN_MIN':
					domainMin.x = parseFloat( split[ 1 ] );
					domainMin.y = parseFloat( split[ 2 ] );
					domainMin.z = parseFloat( split[ 3 ] );
					break;
				case 'DOMAIN_MAX':
					domainMax.x = parseFloat( split[ 1 ] );
					domainMax.y = parseFloat( split[ 2 ] );
					domainMax.z = parseFloat( split[ 3 ] );
					break;
				default:
					const r = parseFloat( split[ 0 ] );
					const g = parseFloat( split[ 1 ] );
					const b = parseFloat( split[ 2 ] );

					if (
						r > 1.0 || r < 0.0 ||
						g > 1.0 || g < 0.0 ||
						b > 1.0 || b < 0.0
					) {

						throw new Error( 'LUTCubeLoader : Non normalized values not supported.' );

					}

					data[ currIndex + 0 ] = r * 255;
					data[ currIndex + 1 ] = g * 255;
					data[ currIndex + 2 ] = b * 255;
					data[ currIndex + 3 ] = 255;
					currIndex += 4;

			}

		}

		const texture = new DataTexture();
		texture.image.data = data;
		texture.image.width = size;
		texture.image.height = size * size;
		texture.type = UnsignedByteType;
		texture.magFilter = LinearFilter;
		texture.minFilter = LinearFilter;
		texture.wrapS = ClampToEdgeWrapping;
		texture.wrapT = ClampToEdgeWrapping;
		texture.generateMipmaps = false;
		texture.needsUpdate = true;

		const texture3D = new Data3DTexture();
		texture3D.image.data = data;
		texture3D.image.width = size;
		texture3D.image.height = size;
		texture3D.image.depth = size;
		texture3D.type = UnsignedByteType;
		texture3D.magFilter = LinearFilter;
		texture3D.minFilter = LinearFilter;
		texture3D.wrapS = ClampToEdgeWrapping;
		texture3D.wrapT = ClampToEdgeWrapping;
		texture3D.wrapR = ClampToEdgeWrapping;
		texture3D.generateMipmaps = false;
		texture3D.needsUpdate = true;

		return {
			title,
			size,
			domainMin,
			domainMax,
			texture,
			texture3D,
		};

	}

}

// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492

class LUT3dlLoader extends Loader {

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'text' );
		loader.load( url, text => {

			try {

				onLoad( this.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				this.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( str ) {

		// remove empty lines and comment lints
		str = str
			.replace( /^#.*?(\n|\r)/gm, '' )
			.replace( /^\s*?(\n|\r)/gm, '' )
			.trim();

		const lines = str.split( /[\n\r]+/g );

		// first line is the positions on the grid that are provided by the LUT
		const gridLines = lines[ 0 ].trim().split( /\s+/g ).map( e => parseFloat( e ) );
		const gridStep = gridLines[ 1 ] - gridLines[ 0 ];
		const size = gridLines.length;

		for ( let i = 1, l = gridLines.length; i < l; i ++ ) {

			if ( gridStep !== ( gridLines[ i ] - gridLines[ i - 1 ] ) ) {

				throw new Error( 'LUT3dlLoader: Inconsistent grid size not supported.' );

			}

		}

		const dataArray = new Array( size * size * size * 4 );
		let index = 0;
		let maxOutputValue = 0.0;
		for ( let i = 1, l = lines.length; i < l; i ++ ) {

			const line = lines[ i ].trim();
			const split = line.split( /\s/g );

			const r = parseFloat( split[ 0 ] );
			const g = parseFloat( split[ 1 ] );
			const b = parseFloat( split[ 2 ] );
			maxOutputValue = Math.max( maxOutputValue, r, g, b );

			const bLayer = index % size;
			const gLayer = Math.floor( index / size ) % size;
			const rLayer = Math.floor( index / ( size * size ) ) % size;

			// b grows first, then g, then r
			const pixelIndex = bLayer * size * size + gLayer * size + rLayer;
			dataArray[ 4 * pixelIndex + 0 ] = r;
			dataArray[ 4 * pixelIndex + 1 ] = g;
			dataArray[ 4 * pixelIndex + 2 ] = b;
			dataArray[ 4 * pixelIndex + 3 ] = 1.0;
			index += 1;

		}

		// Find the apparent bit depth of the stored RGB values and map the
		// values to [ 0, 255 ].
		const bits = Math.ceil( Math.log2( maxOutputValue ) );
		const maxBitValue = Math.pow( 2.0, bits );
		for ( let i = 0, l = dataArray.length; i < l; i += 4 ) {

			const r = dataArray[ i + 0 ];
			const g = dataArray[ i + 1 ];
			const b = dataArray[ i + 2 ];
			dataArray[ i + 0 ] = 255 * r / maxBitValue; // r
			dataArray[ i + 1 ] = 255 * g / maxBitValue; // g
			dataArray[ i + 2 ] = 255 * b / maxBitValue; // b

		}

		const data = new Uint8Array( dataArray );
		const texture = new DataTexture();
		texture.image.data = data;
		texture.image.width = size;
		texture.image.height = size * size;
		texture.format = RGBAFormat;
		texture.type = UnsignedByteType;
		texture.magFilter = LinearFilter;
		texture.minFilter = LinearFilter;
		texture.wrapS = ClampToEdgeWrapping;
		texture.wrapT = ClampToEdgeWrapping;
		texture.generateMipmaps = false;
		texture.needsUpdate = true;

		const texture3D = new Data3DTexture();
		texture3D.image.data = data;
		texture3D.image.width = size;
		texture3D.image.height = size;
		texture3D.image.depth = size;
		texture3D.format = RGBAFormat;
		texture3D.type = UnsignedByteType;
		texture3D.magFilter = LinearFilter;
		texture3D.minFilter = LinearFilter;
		texture3D.wrapS = ClampToEdgeWrapping;
		texture3D.wrapT = ClampToEdgeWrapping;
		texture3D.wrapR = ClampToEdgeWrapping;
		texture3D.generateMipmaps = false;
		texture3D.needsUpdate = true;

		return {
			size,
			texture,
			texture3D,
		};

	}

}

//import { Vector2 } from '../../../build/three.module.js';


/**
 * Distortion shader
 * based on Giliam de Carpentier's shader for lens distortion
 */

const DistortionShader = {

	uniforms: {

		'tDiffuse': { value: null },
        //'resolution': { value: new Vector2() },
		'strength': { value: 0 },
		'height': { value: 1 },
		'aspectRatio': { value: 1 },
		'cylindricalRatio': { value: 1 }

	},

	vertexShader: /* glsl */`

		uniform float strength;          // s: 0 = perspective, 1 = stereographic
        uniform float height;            // h: tan(verticalFOVInRadians / 2)
        uniform float aspectRatio;       // a: screenWidth / screenHeight
        uniform float cylindricalRatio;  // c: cylindrical distortion ratio. 1 = spherical

        varying vec3 vUV;                // output to interpolate over screen
        varying vec2 vUVDot;             // output to interpolate over screen

        void main() {

            gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));

            float scaledHeight = strength * height;
            float cylAspectRatio = aspectRatio * cylindricalRatio;
            float aspectDiagSq = aspectRatio * aspectRatio + 1.0;
            float diagSq = scaledHeight * scaledHeight * aspectDiagSq;
            vec2 signedUV = (2.0 * uv + vec2(-1.0, -1.0));

            float z = 0.5 * sqrt(diagSq + 1.0) + 0.5;
            float ny = (z - 1.0) / (cylAspectRatio * cylAspectRatio + 1.0);

            vUVDot = sqrt(ny) * vec2(cylAspectRatio, 1.0) * signedUV;
            vUV = vec3(0.5, 0.5, 1.0) * z + vec3(-0.5, -0.5, 0.0);
            vUV.xy += uv;
            
        }`,

	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;      // sampler of rendered scene?s render target
        varying vec3 vUV;                // interpolated vertex output data
        varying vec2 vUVDot;             // interpolated vertex output data

        void main() {
            vec3 uv = dot(vUVDot, vUVDot) * vec3(-0.5, -0.5, -1.0) + vUV;
            gl_FragColor = texture2DProj(tDiffuse, uv);
        }`

};

/**
 * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)
 *
 * As mentioned in the video the Sobel operator expects a grayscale image as input.
 *
 */

const SharpenShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'resolution': { value: new Vector2() },
		'power': { value: 0.1 },
		'kernel': { value: [-1, -1, -1, -1, 9, -1, -1, -1, -1] }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		uniform float power;
		varying vec2 vUv;
		uniform float kernel[9];

		void main() {

			vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );

			vec2 offset[9];
			offset[0] = vec2(-texel.x, -texel.y);
			offset[1] = vec2(0.0, -texel.y);
			offset[2] = vec2(texel.x, -texel.y);
			offset[3] = vec2(-texel.x, 0.0);
			offset[4] = vec2(0.0, 0.0);
			offset[5] = vec2(texel.x, 0.0);
			offset[6] = vec2(-texel.x, texel.y);
			offset[7] = vec2(0.0, texel.y);
			offset[8] = vec2(texel.x, texel.y);
		   	vec4 sum = vec4(0.0);


		   	for( int i=0; i<9; i++ ) sum.rgb += texture2D( tDiffuse, vUv + offset[i] ).rgb * kernel[i];

		   	sum.a = 1.0;

		    vec4 texelColor = texture2D( tDiffuse, vUv );

		    gl_FragColor = mix( texelColor, sum, power );

		}`

};

class Composer extends EffectComposer {

	constructor( renderer, scene, camera, controls, size ) {

		let isGl2 = renderer.capabilities.isWebGL2;
		let px = renderer.getPixelRatio();

		/*const sizeFX = renderer.getDrawingBufferSize( new THREE.Vector2() );
		console.log( sizeFX, size.w*px, size.h*px )
		//let RTClass = WebGLRenderTarget
*/
		const renderTarget = new WebGLRenderTarget( size.w*px, size.h*px , {
			//minFilter: LinearFilter,
			//magFilter: LinearFilter,
			//format: RGBAFormat,//??? slow down
			//encoding: sRGBEncoding,
			//type:FloatType ,
		});

		if( renderTarget.samples );

		super( renderer, renderTarget );

	    this.renderTarget = renderTarget;

	    //this.needNormal = false
	    //this.needDepth = false

	    this.normalTarget = renderTarget.clone();
	    this.depthTarget = renderTarget.clone();
	    //this.beautyTarget = renderTarget.clone()

	    this.normalTarget.texture.minFilter = NearestFilter;
	    this.normalTarget.texture.magFilter = NearestFilter;
	    //this.normalTarget.texture.format=RGBFormat

	    //this.saoEnable = true

	    this.lutCubeLoader = null;
	    this.lut3DLoader = null;


		this.v = new Vector3();

		this.torad = Math.PI / 180;
		this.todeg = 180 / Math.PI;

		this.isGl2 = isGl2;
		this._pixelRatio = px;

		this.scene = scene;
		this.camera = camera;
		this.controls = controls;
		this.size = size;

		this._width = size.w;
		this._height = size.h;

		this.enabled = false;

		this.options = {

			// focus
			focus: 2.0,
			aperture: 2.5,
			maxblur: 0.01,

			// bloom
			threshold:0.85,
			strength:1.5,
			bloomRadius: 0,


			// sao
			saoBias:0.5,
			saoIntensity:0.06,
			saoScale:40,
			saoKernelRadius:50,
			saoMinResolution:0,

			// ssao
			kernelRadius:0.1,
			minDistance:0.0001,
			maxDistance:2,

			// distortion
			horizontal: 100,
			distortion:0.5,
			cylindrical: 1,


			// lut
			lutIntensity:1,

			// sharpen
			power: 0.1,

		};

		this.pass = {};

		this.pass.render = new RenderPass( scene, camera );
		this.addPass( this.pass.render );


		// SAO PASS
		this.pass.sao = new SAOPass( scene, camera, this.isGl2, true );
		this.pass.sao.params = {
			output: 0,
			saoBias: this.options.saoBias,//0.5,
			saoIntensity: this.options.saoIntensity,
			saoScale: this.options.saoScale,//1,
			saoKernelRadius: this.options.saoKernelRadius,//100,
			saoMinResolution: this.options.saoMinResolution,
			saoBlur: true,
			saoBlurRadius: 4,//8,
			saoBlurStdDev: 2,//4,
			saoBlurDepthCutoff: 0.01,//0.01
		};

		this.pass.sao.setNormalTarget( this.normalTarget );
		if(!this.isGl2) this.pass.sao.setDepthTarget( this.depthTarget );

		this.pass.sao.enabled = true;

		this.lutMap = null;
		this.pass.lut = new LUTPass();
		//this.loadLut( 'premium', 'cube' )
		this.loadLut( 'realism', '3dl' );

		this.pass.lut.intensity = this.options.lutIntensity;
		
		this.pass.lut.enabled = true;


		// SSAO PASS
		/*this.pass.ssao = new SSAOPass( scene, camera, this._width, this._height, true );
		this.pass.ssao.output = 0
		this.pass.ssao.kernelRadius = this.options.kernelRadius;
		this.pass.ssao.minDistance = this.options.minDistance;
		this.pass.ssao.maxDistance = this.options.maxDistance;

		this.pass.ssao.setNormalTarget( this.normalTarget )
		this.pass.ssao.setDepthTarget( this.depthTarget )
		this.pass.ssao.setBeautyTarget( this.beautyTarget )
		this.addPass( this.pass.ssao );*/

		
		this.pass.sharpen = new ShaderPass( SharpenShader );
		this.pass.sharpen.setSize = function (w,h){ this.uniforms[ 'resolution' ].value.set(w,h); };	
		this.pass.sharpen.enabled = false;
		

		
		this.pass.focus = new BokehPass( this.scene, this.camera, { focus: 20.0, aperture: 0.2, maxblur: 2, width: size.w, height: size.h } );
		this.addPass( this.pass.focus );
		this.pass.focus.enabled = false;
		



		this.pass.distortion = new ShaderPass( DistortionShader );
		this.pass.distortion.enabled = true;



		/*this.pass.bloom = new UnrealBloomPass( new Vector2( size.w, size.h ), 1.5, 0.4, 0.85, true, Env )
		
		this.pass.bloom.enabled = true*/

		this.bloomPass = new UnrealBloomPass( new Vector2( size.w, size.h ), this.options.strength, this.options.bloomRadius, this.options.threshold, true );
		this.bloomPass.enabled = true;

		this.bloomComposer = new EffectComposer( renderer, renderTarget );
		this.bloomComposer.renderToScreen = false;
		this.bloomComposer.addPass( this.pass.render );
		this.bloomComposer.addPass( this.bloomPass );



		this.pass.bloom = new ShaderPass( BloomMix );
		this.pass.bloom.enabled = true;
		this.pass.bloom.needsSwap = true;
		this.pass.bloom.uniforms[ "bloomTexture" ].value = this.bloomComposer.renderTarget2.texture;






		
		this.addPass( this.pass.bloom );
		this.addPass( this.pass.sao );
		this.addPass( this.pass.distortion );
		this.addPass( this.pass.lut );
		this.addPass( this.pass.sharpen );
		this.addPass( this.pass.focus );

		/*this.pass.tone = new ShaderPass( ToneMapShader )
		this.addPass( this.pass.tone )
		this.pass.tone.enabled = true

		this.pass.gamma = new ShaderPass( GammaCorrectionShader )
		this.addPass( this.pass.gamma )
		this.pass.gamma.enabled = true*/


		if( !this.isGl2 ){
			this.pass.fxaa = new ShaderPass( FXAAShader );
			this.pass.fxaa.setSize = function (w,h){ this.uniforms[ 'resolution' ].value.set(1/w,1/h); };
			this.addPass( this.pass.fxaa );
		}


		

		//this.setSize( this.size.w, this.size.h );
		this.update();
		
	}


	renderNormal () {

		//if( !this.needNormal ) return
		//if( this.normalTarget === null  ) this.normalTarget = this.renderTarget.clone()
		Shader.up( {renderMode:2} );
		Env.setBackgroud(0x7777ff);
		this.scene.helper.visible = false;
	    this.renderer.setRenderTarget( this.normalTarget );
	    //this.renderer.clear();
	    this.renderer.render( this.scene, this.camera );


	}

	renderDepth () {
		
		//if( !this.needDepth ) return
		//if( this.depthTarget === null  ) this.depthTarget = this.renderTarget.clone()
		Shader.up( {renderMode:1} );
		Env.setBackgroud(0x000000);
		this.scene.helper.visible = false;

	    this.renderer.setRenderTarget( this.depthTarget );
	    //this.renderer.clear();
	    this.renderer.render( this.scene, this.camera );

	}

	renderBeauty() {
		
		//if( this.depthTarget === null  ) this.depthTarget = this.renderTarget.clone()
		Shader.up( {renderMode:0} );
		Env.setBackgroud();
		this.scene.helper.visible = true;

		this.renderer.setRenderTarget( null );

	    //this.renderer.setRenderTarget( this.beautyTarget )
	    //this.renderer.render( this.scene, this.camera )

	}

	

	

	update (){

		if( this.pass.focus ){
			this.pass.focus.uniforms[ "focus" ].value = this.options.focus;//this.camera.dist //
			this.pass.focus.uniforms[ "aperture" ].value = this.options.aperture * 0.001;
			this.pass.focus.uniforms[ "maxblur" ].value = this.options.maxblur;
			//this.pass.focus.uniforms[ "aspect" ].value = this.camera.aspect;
		}

		if( this.bloomPass ){
			this.bloomPass.threshold = this.options.threshold;
			this.bloomPass.strength = this.options.strength;
			this.bloomPass.radius = this.options.bloomRadius; 

			this.bloomPass.applyValue();

		}

		/*if( this.pass.bloom ){
			this.pass.bloom.threshold = this.options.threshold;
			this.pass.bloom.strength = this.options.strength;
			this.pass.bloom.bloomRadius = this.options.bloomRadius; 
		}*/

		if(this.pass.sao){

			this.pass.sao.params.saoBias = this.options.saoBias;
			this.pass.sao.params.saoIntensity = this.options.saoIntensity;
			this.pass.sao.params.saoScale = this.options.saoScale;
			this.pass.sao.params.saoKernelRadius = this.options.saoKernelRadius;
			this.pass.sao.params.saoMinResolution = this.options.saoMinResolution;

			this.pass.sao.applyValue();
		}

		if(this.pass.sharpen){
			this.pass.sharpen.uniforms[ "power" ].value = this.options.power;
		}

		this.setDistortion();

		

		/*if(this.pass.ssaoPass){
			this.pass.ssao.kernelRadius = this.options.kernelRadius;
			this.pass.ssao.minDistance = this.options.minDistance;
			this.pass.ssao.maxDistance = this.options.maxDistance;
		}*/

	}


	setDistortion () {

		if(!this.pass.distortion) return

		const o = this.options;

	    //console.log(this.camera, this.camera.ratio)

		let horizontalFOV = o.horizontal;
		let strength = o.distortion;
		let cylindricalRatio = o.cylindrical;
		let height = Math.tan( ( horizontalFOV * this.torad ) * 0.5 ) / this.camera.aspect;

		//this.camera.fov = Math.floor( Math.atan(height) * 2 * this.todeg );
		//this.camera.updateProjectionMatrix();
		//console.log(this.camera.fov)

		this.pass.distortion.uniforms[ "strength" ].value = strength;
		this.pass.distortion.uniforms[ "height" ].value = height;
		this.pass.distortion.uniforms[ "aspectRatio" ].value = this.camera.aspect;//this.camera.ratio;
		this.pass.distortion.uniforms[ "cylindricalRatio" ].value = cylindricalRatio;

	}




	changeLut ( txt, name, type ) {

		type = type.toLowerCase();

		if( this.lutMap !== null ){
			if(this.lutMap.texture)this.lutMap.texture.dispose();
			if(this.lutMap.texture3D)this.lutMap.texture3D.dispose();
		}

		switch(type){
			case 'cube':
				if( this.lutCubeLoader === null ) this.lutCubeLoader = new LUTCubeLoader();
				this.lutMap = this.lutCubeLoader.parse( txt );
			break;
			case '3dl':
				if( this.lut3DLoader === null ) this.lut3DLoader = new LUT3dlLoader();
				this.lutMap = this.lut3DLoader.parse( txt );
			break;
		}

		this.setLut();

	}

	loadLut ( name, type ){

		switch(type){
			case 'cube':
				if( this.lutCubeLoader === null ) this.lutCubeLoader = new LUTCubeLoader();
				this.lutCubeLoader.load( 'assets/luts/' + name + '.cube', function ( result ) {
					this.lutMap = result;
					this.setLut();
				}.bind(this) );
			break;
			case '3dl':
				if( this.lut3DLoader === null ) this.lut3DLoader = new LUT3dlLoader();
				this.lut3DLoader.load( 'assets/luts/' + name + '.3dl', function ( result ) {
						this.lutMap = result;
						this.setLut();
				}.bind(this) );
			break;
		}

	}

	setLut (){

		this.pass.lut.lut = this.isGl2 ? this.lutMap.texture : this.lutMap.texture3D;

	}

	resize ( size ) {

		if( !this.enabled ) return;

		this.size = size;
		this.setSize( this.size.w, this.size.h );
		this.bloomComposer.setSize( this.size.w, this.size.h );

	}

	dispose() {
		this.enabled = false;
	}

	render ( deltaTime ) {


		if( this.pass.bloom.enabled ){ 
			this.bloomPass.enabled = true;

			Env.setBackgroud(0x000000);
			this.scene.helper.visible = false;
			if( this.scene.ground ) this.scene.ground.setBlack( true );
			this.bloomComposer.render( deltaTime );
		    if( this.scene.ground ) this.scene.ground.setBlack( false );
		    this.scene.helper.visible = true;
			Env.setBackgroud();
		} else {
			this.bloomPass.enabled = false;
		}

		if( this.pass.sao.isDirectNormal || this.pass.sao.isDirectDepth ){

			this.renderNormal();
	       // this.renderDepth()
	        this.renderBeauty();

		}



		//Env.setBackgroud(0x111111)

		
		//let d = this.controls.target.distanceTo( this.camera.position );
		//this.pass.focus.uniforms[ "focus" ].value = d;

		super.render( deltaTime );

	}

}

class Hub3D extends Mesh {

    constructor( o = {} ) {

        super();

        this.color = new Color();

        this.geometry = new PlaneGeometry( 2,2, 1,1 );
        /*this.material = new MeshBasicMaterial({
            wireframe:true
        })*/
        this.material = new ShaderMaterial( {

            name: 'HuvShader',

            uniforms: {

                color: { value: new Color( 0.01, 0.01, 0.01 ) },
                darkness: { value: 1 },
                offset: { value: 1.05  },

                ratio: { value: 1 },
                radius: { value: 2 },
                step: { value: new Vector4(0.6, 0.7, 1.25, 1.5 ) },
                
            },

            vertexShader:`
            varying vec2 vUv;
            varying vec3 pos;

            void main() {
                vUv = uv;
                //gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

                pos = position;
                gl_Position = vec4(position, 1.);
            }
            `,
            fragmentShader:`

            uniform vec3 color;
            uniform float offset;
            uniform float darkness;

            uniform float ratio;
            uniform float radius;
            uniform vec4 step;
            varying vec2 vUv;
            varying vec3 pos;

            void main() {
                
                /*vec2 c = vec2(0.5, 0.5);
                vec2 pos = (vUv - 0.5) * vec2(ratio, 1) + 0.5;
      
                float dist = length( pos - c ) * radius;

                vec4 cOne = vec4(0.0, 0.0, 0.0, 0.0);
                vec4 cTwo = vec4(0.0, 0.0, 0.0, 0.0);
                vec4 cTree = vec4(0.0, 0.0, 0.0, 0.25);
                vec4 cFour = vec4(0.0, 0.0, 0.0, 0.95);

                vec4 cc = mix( cOne, cTwo, smoothstep( step.x, step.y, dist ));
                cc = mix( cc, cTree, smoothstep(step.y, step.z, dist ));
                cc = mix( cc, cFour, smoothstep(step.z, step.w, dist ));

                gl_FragColor = cc;
                */

                //vec4 texel = vec4(0.0);
                vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
                //gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );

                float alpha =  smoothstep( 0.0, 1.0, dot( uv, uv ) )-(1.0 - darkness);

                //gl_FragColor = vec4( color, dot( uv, uv )-(1.0 - darkness) );
                gl_FragColor = vec4( color, alpha );

            }
            `, 
            transparent:true,
            depthWrite:false,
            depthTest:false,
            toneMapped: false,

        });


        Object.defineProperties(this, {
            color: {
                enumerable: true,
                get: () => ( this.material.uniforms.color.value.getHex() ),
                set: ( v ) => { this.material.uniforms.color.value.setHex( v ); },
            },
            offset: {
                enumerable: true,
                get: () => ( this.material.uniforms.offset.value ),
                set: ( v ) => { this.material.uniforms.offset.value = v; },
            },
            darkness: {
                enumerable: true,
                get: () => ( this.material.uniforms.darkness.value ),
                set: ( v ) => { this.material.uniforms.darkness.value = v; },
            },
        });

        
        this.frustumCulled = false;
        this.renderOrder = Infinity;
        this.matrixAutoUpdate = false;

    }

    /*updateMatrixWorld ( force ) {

        if( this.parent.isCamera ){
            const c = this.parent
            let r = (1 / ( 2 * Math.tan( (c.fov * MathUtils.DEG2RAD) * 0.5 ) ));
            this.scale.set( c.aspect, 1, 0 );
            this.position.z = -r*c.zoom;

            //this.material.uniforms.ratio.value = c.aspect
        }

        super.updateMatrixWorld(force);

    }*/

    raycast() {

        return

    }

    dispose () {

        this.parent.remove(this);
        this.geometry.dispose();
        this.material.dispose();
        
    }

    /*static setRenderMode ( v ){

        panelMat.uniforms.renderMode.value = v
        
    }

    static hide( b ){

        panel.visible = b

    }

    static update ( Size, type ) {

        if( Size ) size = Size;
        let s = size;

        type = type || '';

        //let s = root.view.getSizer();
        let fov = this.parent.fov;
        let z = this.parent.zoom;
        let d = 0, r = 1;


        if( s.w !== old.w || s.h !== old.h || fov !== old.f || z !== old.z ){ 

            this.resizeOld( s, fov, z );

            if(!isPanel3D) return

            if( isSnipper && type === 'fps' ){

                r = (z-1.2)/12.8;

                this.material.uniforms.ratio.value = math.lerp( 1, old.ratio, r ); 
                this.material.uniforms.radius.value = math.lerp( 2, 3, r );

            } else {
                d = type === 'tps' ? z - 0.6 : z-1.2;
                d*=0.25;
                this.material.uniforms.step.value.x = 0.6 - d;
                this.material.uniforms.step.value.y = 0.7 - d;
                this.material.uniforms.step.value.z = 1.25 - d*0.5;
            }

            
            //panelMat.uniforms.step.value.w = 1.5 - d 

        }

    }

    static resizeOld ( s, fov, z ){

        content.style.left = (s.left + 10) + "px"

        if(!isPanel3D) return

        //var d = 0.0001
        let d = 0.001
        let v = fov * math.torad; // convert to radians
        let r = (s.h / ( 2 * Math.tan( v * 0.5 ) ));
        let e = 1//3/5; // ???

        this.scale.set( s.w, s.h, 0 ).multiplyScalar(d);
        //panel.scale.set( 50, 50, 0 ).multiplyScalar(0.0001);
        //panel.scale.z = 1;
        this.position.z = -r*d*z;

        old.f = fov;
        old.z = z;
        old.w = s.w;
        old.h = s.h;
        old.ratio = s.w / s.h;

    }*/




}

// @TODO: Consider rename WebGLRenderTarget to just RenderTarget

class RenderTarget extends WebGLRenderTarget {

	constructor( width, height, options = {} ) {

		super( width, height, options );

	}

}

//import WebGPUTextureRenderer from '../jsm/renderers/webgpu/WebGPUTextureRenderer.js';


/**
 * @author Slayvin / http://slayvin.net
 */

//export var Reflector = function ( o ) {
class Reflector extends Mesh {

	constructor( o = {} ) {

		//let geometry = o.geometry !== undefined ? o.geometry : new PlaneGeometry( 1, 1, 1, 1 );
		//geometry.setAttribute( 'uv2', geometry.attributes.uv );

		//super( geometry );
		super();

		this.geometry = new PlaneGeometry( 1, 1, 1, 1 );
		//this.geometry.setAttribute( 'uv2', this.geometry.attributes.uv );

		//console.log('ground is add')

		this.settings = {
			size: [30,30],
			gAlpha:true,
			opacity:1,

		};

		//this.scale.set( 30, 30, 1 )
		
		this.rotateX( -Math.PI / 2 );
		this.castShadow = false;
		this.receiveShadow = true;

		this.type = 'Reflector';

		this.isShow = true;

		var scope = this;

		o = o || {};

		this.map = o.map || null;
		this.color = o.color || 0x808080;
		this.reflect = o.reflect !== undefined ? o.reflect : 0.4;
		//this.opacity = o.opacity !== undefined ? o.opacity : 1;
		this.isWater = o.water !== undefined ? o.water : false;
		this.uv = o.uv || 1;
		this.normalScale = o.normalScale || 1;



		/*if( this.isWater ){ 
			this.material.normalMap = Pool.directTexture('./assets/textures/terrain/water_n.jpg', { flip:false, repeat:[30,30] });
			this.reflect = 1
			//this.opacity = 0.5
		} else {
			this.normalMap = Pool.directTexture('./assets/textures/floor.png', { flip:false, repeat:[200,200] });
		}*/

		//this.normalMap = null

		//if(o.normal){
			//new TextureLoader().load( './assets/textures/floor.png' );
			//this.normalMap.wrapS = this.normalMap.wrapT = RepeatWrapping
			//this.normalMap.repeat.x = this.normalMap.repeat.y = 200
		//}
		
		//normalMap.offset.x=normalMap.offset.y=0.5

		//this.encoding = o.encoding || false;

		this.textureSize = o.textureSize || 512;

		this.renderTarget = null;

		
		const clipBias = o.clipBias || 0;

		const reflectorPlane = new Plane();
		const normal = new Vector3();
		const reflectorWorldPosition = new Vector3();
		const cameraWorldPosition = new Vector3();
		const rotationMatrix = new Matrix4();
		const lookAtPosition = new Vector3( 0, 0, - 1 );
		const clipPlane = new Vector4();

		const view = new Vector3();
		const target = new Vector3();
		const q = new Vector4();

		const textureMatrix = new Matrix4();
		const virtualCamera = new PerspectiveCamera();


		this.material = new MeshStandardMaterial({ //new MeshStandardMaterial({ 
			name:'Ground', 
			color:this.color,
			//emissive:0xFFFFFF,
			//map:this.map, 
			roughness:0.2,//0.25, 
			metalness:0,//1, 
			opacity:1,
			transparent:true,
			depthWrite:false,
			normalMap: null,//this.normalMap,
			//blending:AdditiveBlending,
			///blending:MultiplyBlending,
			//aoMap: normalMap,
	        //depthTest: false, 
	        //premultipliedAlpha:true,
	        //format:sRGBEncoding,

		});


		

		//this.material.reflect = o.reflect !== undefined ? o.reflect : 0.35;

		//this.material.color.convertSRGBToLinear();


		this.groundAlpha();
		this.renderOrder = -1;

		//if( this.isWater ) this.setWater();

		this.material.userData = {
			reflectif: { value: this.reflect },
			mirrorMap:{ value: null },
			blackAll:{ value: 0 }
		};


		Object.defineProperty( this.material, 'reflectif', {
			  get() { return this.userData.reflectif.value; },
			  set( value ) { this.userData.reflectif.value = value; }
		});

		this.textureRenderer = null;

		this.setTarget();

		const self = this;

		this.material.onBeforeCompile = function ( shader ) {

			var uniforms = shader.uniforms;

			//uniforms['fogTime'] = { value: 0 };
			
			//var uniforms = THREE.UniformsUtils.clone( THREE.ShaderLib[ 'standard' ].uniforms );
			uniforms[ "mirrorMap" ] = this.userData.mirrorMap;//{ value: scope.renderTarget.texture };
			//uniforms[ "mirrorPower" ] = { value: scope.reflect };
			uniforms[ "textureMatrix" ] = { value: textureMatrix };
			uniforms[ "reflectif" ] =  this.userData.reflectif;

			uniforms[ "blackAll" ] = this.userData.blackAll;
			//uniforms[ "shadowPower" ] =  { value: 0.01 };
			shader.uniforms = uniforms;

			//shader.uniforms.reflectif = this.userData.reflectif;

			var vertex = shader.vertexShader;
		
			vertex = vertex.replace( '#include <common>', ['#include <common>', 'varying vec4 vUvR;', 'uniform mat4 textureMatrix;'].join("\n") );
			vertex = vertex.replace( '#include <uv_vertex>', ['#include <uv_vertex>', 'vUvR = textureMatrix * vec4( position, 1.0 );'].join("\n") );
			shader.vertexShader = vertex;

			var fragment = shader.fragmentShader;
			fragment = fragment.replace( 'uniform vec3 diffuse;', ['uniform vec3 diffuse;', 'varying vec4 vUvR;', 'uniform float reflectif;', 'uniform sampler2D mirrorMap;', 'uniform int blackAll;'].join("\n") );
			fragment = fragment.replace( '#include <map_fragment>', ReflectShader.map_fragment );
			fragment = fragment.replace( '#include <fog_fragment>', ReflectShader.fog_fragment );

			//fragment = fragment.replace( '#include <alphamap_fragment>', ReflectShader.alphamap_fragment );

			//fragment = fragment.replace( '#include <normal_fragment_maps>', ReflectShader.normal_fragment_maps );

			//fragment = fragment.replace( '#include <aomap_pars_fragment>', '' );
			fragment = fragment.replace( '#include <aomap_fragment>', '' );
			//fragment = fragment.replace( '#include <emissivemap_fragment>', '' );
			//fragment = fragment.replace( '#include <clearcoat_normal_fragment_begin>', '' );
			//fragment = fragment.replace( '#include <clearcoat_normal_fragment_maps>', '' );
			//fragment = fragment.replace( '#include <clearcoat_pars_fragment>', '' );
			fragment = fragment.replace( '#include <bumpmap_pars_fragment>', '' );

			//fragment = fragment.replace( '#include <alphamap_fragment>', '' );

			shader.fragmentShader = fragment;

			Shader.modify( shader );

		};




		Shader.setDefines( this.material );

		//Pool.set( 'Ground', this.material, 'material', true );
		
		this.onBeforeRender = function ( renderer, scene, camera ) {

			if( !this.isShow ) return;
			if( self.reflect === 0 ) return;

			if( self.isWater ) {
				self.material.normalMap.offset.x+=0.0005;
				self.material.normalMap.offset.y+=0.00025;
			}

			let isWebGPU = renderer.isWebGPURenderer || false;

			reflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );
			cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

			rotationMatrix.extractRotation( scope.matrixWorld );

			normal.set( 0, 0, 1 );
			normal.applyMatrix4( rotationMatrix );

			view.subVectors( reflectorWorldPosition, cameraWorldPosition );

			// Avoid rendering when reflector is facing away

			if ( view.dot( normal ) > 0 ) return;

			view.reflect( normal ).negate();
			view.add( reflectorWorldPosition );

			rotationMatrix.extractRotation( camera.matrixWorld );

			lookAtPosition.set( 0, 0, - 1 );
			lookAtPosition.applyMatrix4( rotationMatrix );
			lookAtPosition.add( cameraWorldPosition );

			target.subVectors( reflectorWorldPosition, lookAtPosition );
			target.reflect( normal ).negate();
			target.add( reflectorWorldPosition );

			virtualCamera.position.copy( view );
			virtualCamera.up.set( 0, 1, 0 );
			virtualCamera.up.applyMatrix4( rotationMatrix );
			virtualCamera.up.reflect( normal );
			virtualCamera.lookAt( target );

			virtualCamera.far = camera.far; // Used in WebGLBackground

			virtualCamera.updateMatrixWorld();
			virtualCamera.projectionMatrix.copy( camera.projectionMatrix );

			// Update the texture matrix
			textureMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);
			textureMatrix.multiply( virtualCamera.projectionMatrix );
			textureMatrix.multiply( virtualCamera.matrixWorldInverse );
			textureMatrix.multiply( scope.matrixWorld );

			// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
			// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
			reflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );
			reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );

			clipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );

			const projectionMatrix = virtualCamera.projectionMatrix;

			q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
			q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
			q.z = - 1.0;
			q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

			// Calculate the scaled plane vector
			clipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );

			// Replacing the third row of the projection matrix
			projectionMatrix.elements[ 2 ] = clipPlane.x;
			projectionMatrix.elements[ 6 ] = clipPlane.y;
			projectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;
			projectionMatrix.elements[ 14 ] = clipPlane.w;

			// Render

			//scope.renderTarget.texture.colorSpace = renderer.outputColorSpace;

			scope.visible = false;

			const currentFog = scene.fog;
			const currentRenderTarget = renderer.getRenderTarget();
			let currentXrEnabled = renderer.xr.enabled;
			let currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
			//const currentOutputEncoding = renderer.outputColorSpace;
			//const currentToneMapping = renderer.toneMapping;

			scene.fog = null;
			renderer.xr.enabled = false; // Avoid camera modification and recursion

			// bug with HAIR ????
			//renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows
			//renderer.toneMapping = NoToneMapping;

			renderer.setRenderTarget( scope.renderTarget );
			
			if( !isWebGPU ) renderer.state.buffers.depth.setMask( true );// make sure depth buffer is writable

			if( renderer.autoClear === false ) renderer.clear();
			renderer.render( scene, virtualCamera );
			
			renderer.xr.enabled = currentXrEnabled;
		    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
			//renderer.toneMapping = currentToneMapping;
			scene.fog = currentFog;

			//renderer.shadowMap.needsUpdate = true

			renderer.setRenderTarget( currentRenderTarget );

			// Restore viewport
			const viewport = camera.viewport;
			if ( viewport !== undefined ) renderer.state.viewport( viewport );

			scope.visible = true;

		};

	}

	reset(){
		//console.log('reset map')
		if( this.material.map ) this.material.map.dispose();
		//if( this.material.alphaMap ) this.material.alphaMap.dispose()
		if( this.material.normalMap ) this.material.normalMap.dispose();

		//this.groundAutoColor = true;
        //this.material.color = null;
		this.material.map = null;
		//this.material.alphaMap = null;
		this.material.normalMap = null;

	}
//}

//Reflector.prototype = Object.create( THREE.Mesh.prototype );
//Reflector.prototype.constructor = THREE.Reflector;

//Reflector.prototype = Object.assign( Object.create( Mesh.prototype ), {

	//constructor: Reflector,

	dispose() {

		this.onBeforeRender = function (){};

		if( this.material.map ) this.material.map.dispose();
		if( this.material.alphaMap ) this.material.alphaMap.dispose();
		if( this.material.normalMap ) this.material.normalMap.dispose();
		if( this.renderTarget ) this.renderTarget.dispose();

		if( this.parent ) this.parent.remove(this);
		this.geometry.dispose();
		this.material.dispose();

	}

	getRenderTarget () {
		return this.renderTarget;
	}

	setTarget () {

		if( this.renderTarget ) this.renderTarget.dispose();

		var parameters = {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			//format: RGBFormat,
			stencilBuffer: false,
			//colorSpace : this.encoding ? SRGBColorSpace : LinearEncoding,
			generateMipmaps:true,
		};

		this.renderTarget = new RenderTarget( this.textureSize, this.textureSize, parameters );
		//this.material.alphaMap = this.renderTarget.texture;

		this.material.userData.mirrorMap.value = this.renderTarget.texture;

	}

	setAlphaMap ( b = true ) {

		if( b === this.settings.gAlpha ) return
		this.settings.gAlpha = b;
		this.material.alphaMap = b ? this.alphaMap : null;
		if( b ) this.material.alphaMap.needsUpdate = true;
		this.material.needsUpdate = true;
		
	}

	setSize ( s = [ 200, 200 ] ){

		if( s === this.settings.size ) return
		this.settings.size = s;
		this.scale.set( s[0], s[1], 1 );

	}

	setColor ( v, srgb ) {

		//console.log('setColor', v)

		//return;
		this.color = v !== undefined ? v : 0xa87232;
		this.material.color.setHex( this.color );

		//if(srgb) this.material.color.convertSRGBToLinear()

	}

	setMapRepeat ( v ) {
		
		if(!this.map) return;
		this.map.repeat.set( v, v );

	}

	setMap ( v ) {

		this.map = v;
		this.material.map = this.map;
		this.material.needsUpdate = true;

	}

	setWater ( b, repeat, scale ) {

		if( b!==undefined ) this.isWater = b;

		if( this.isWater ) {
			this.uv = 30;
			var r = repeat !== undefined ? repeat : this.uv;
			var s = scale !== undefined ? scale : this.normalScale;
			this.material.normalMap = Pool.texture( { url:'./assets/textures/terrain/water_n.jpg', flip:false, repeat:[r,r] });//null;//Tools.loadTextures('./textures/terrain/water_n.jpg', { repeat:[r,r], anisotropy:4, generateMipmaps:true });
			this.material.normalScale.set( s, s );
			this.material.roughness = 0.;
			this.material.metalness = 0.;
			this.material.opacity = 0.8;
			this.material.side = DoubleSide;
			//console.log('water')
		} else {
			//this.material.normalMap = Pool.texture( { url:'./assets/textures/floor.png', flip:false, repeat:[200,200] });
			//this.material.normalMap.channel = 1;
			//this.material.normalMap = null;
			this.material.roughness = 0.8;
			this.material.metalness = 0.2;
			this.material.side = FrontSide;
		}

	}

	

	setOpacity ( v = 1 ) {

		if( v === this.settings.opacity ) return

		this.settings.opacity = v;
		this.material.opacity = this.settings.opacity;
	    //this.material.transparent = this.settings.opacity < 1 ? true : false;

	}

	setReflect ( v ) {

		this.reflect = v !== undefined ? v : 0.35;
		this.material.userData.reflectif.value = this.reflect;

	}

	show ( b ) {

		this.isShow = b;
		this.visible = b;

	}

	groundAlpha () {

		//if(!this.settings.gAlpha ) return

		let c = document.createElement('canvas');
		c.width = c.height = 512;
        let ctx = c.getContext('2d');

        let grd = ctx.createRadialGradient( 256,256, 128, 256,256,256 );

		grd.addColorStop(0, 'white');
		grd.addColorStop(.2, 'white');
		grd.addColorStop(1, 'black');

		ctx.fillStyle = grd;
		ctx.fillRect(0, 0, 512, 512);

		var img = new Image( 512, 512 );
	    img.src = c.toDataURL( 'image/png' );

	    this.alphaMap = new Texture( img );
	   // this.alphaMap.channel = 1;
	    this.material.alphaMap = this.alphaMap;//new Texture( img );

	    img.onload = function (){
		    this.alphaMap.needsUpdate = true;
	    }.bind(this);

	    

		/*const self = this;

		img.onload = function(){
			//self.material.alphaMap = self.alphaMap;
		    if(self.material.alphaMap !== null) self.material.alphaMap.needsUpdate = true; 
		}*/


	}

	setBlack ( b ){

		this.isShow = !b  ;
		this.material.userData.blackAll.value = b ? 1 : 0 ;

	}

}

const ReflectShader = {

	map_fragment :/* glsl */`

	

	#ifdef USE_MAP
	    
	    diffuseColor *= texture2D( map, vMapUv );

	#endif

	if( reflectif != 0.0 ){
		vec4 reflector = texture2DProj( mirrorMap, vUvR );
	    diffuseColor.rgb = mix( diffuseColor.rgb, diffuseColor.rgb + reflector.rgb, reflectif );
	}
	`,

	fog_fragment :/* glsl */`
	if( blackAll == 1 ) gl_FragColor = vec4( vec3(0.0), diffuseColor.a );
	#ifdef USE_FOG

		#ifdef FOG_EXP2

			float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

		#else

			float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );

		#endif

		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

	#endif
	`,

	extra_Function :/* glsl */`

	float blendOverlay( float base, float blend ) {

		return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

	}

	vec3 blendOverlay( vec3 base, vec3 blend ) {

		return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

	}`,

	

};

class Planet extends Mesh {

    constructor( o = {} ) {

        super();

        o = o == undefined ? {} : o;

        this.radius = o.radius !== undefined ? o.radius : 100;
        this.resolution = o.resolution !== undefined ? o.resolution : 10;

        this.data = {
            level: o.level || [1,0.25],
            frequency: o.frequency || [0.1,0.5],
            expo: o.expo || 2,
            height: o.height || 4,
        };

        this.uvx = o.uv || [2,2];

        let typer = ['cliff', 'crater', 'desert', 'ice', 'plate', 'rock', 'rock2', 'mud', 'snow'];

        const tname = typer[ math$1.randInt(0, typer.length-1) ];

        this.m1 = Pool.texture({ url:'./assets/textures/terrain/'+tname+'_c.jpg', flip:false, repeat:this.uvx, encoding:true });
        this.m2 = Pool.texture({ url:'./assets/textures/terrain/'+tname+'_n.jpg', flip:false, repeat:this.uvx });

        this.material = new MeshStandardMaterial({ 
            name:'planet',
            vertexColors:true,
            map:this.m1, 
            normalMap:this.m2,
            normalScale:new Vector2(1,1), 
            roughness:0.6, 
            metalness:0.5,
         });

        this.material.onBeforeCompile = function ( shader ) {
            Shader.modify( shader );
        };

        

        this.makeGeometry();

        //root.garbage.push( this.geometry );

        this.name = o.name || 'planet';

        this.castShadow = true;
        this.receiveShadow = true;

    }

    makeGeometry () {

        this.geometry = new BoxGeometry( 1, 1, 1, this.resolution, this.resolution, this.resolution );

        this.lng = this.geometry.attributes.position.count;

        this.colors = new Float32Array( this.lng * 3 );
        this.geometry.setAttribute( 'color', new BufferAttribute( this.colors, 3 ) );


        var i = this.lng, n, w = new Vector3();
        this.vertices = this.geometry.attributes.position.array;
        this.s = [];

        while( i-- ) {

            n = i*3;

            w.set( this.vertices[n], this.vertices[n+1], this.vertices[n+2] ).normalize().multiplyScalar( this.radius );

            this.s.push( w.x, w.y, w.z );

        }

        this.update();

    }

    update(){

        var i = this.lng, c, hh, n, w = new Vector3();

        while(i--){

            n = i*3;

            w.set( this.s[n], this.s[n+1], this.s[n+2] );

            c = math$1.noise( w, this.data );

            c = Math.pow( c, this.data.expo );

            c = c>1 ? 1:c;
            c = c<0 ? 0:c;

            w.normalize().multiplyScalar( c * this.data.height );

            this.vertices[n] = this.s[n] + w.x;
            this.vertices[n+1] = this.s[n+1] + w.y;
            this.vertices[n+2] = this.s[n+2] +  w.z;

            hh = (c*0.75)+0.25;

            this.colors[n] = hh;
            this.colors[n+1] = hh;
            this.colors[n+2] = hh;

        }

        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.color.needsUpdate = true;
        this.geometry.computeVertexNormals();

        math$1.resetPerlin();

    }

    dispose () {

        this.geometry.dispose();
        this.material.dispose();
        
    }
}

class Building extends MeshStandardMaterial {

	constructor( o = {}, extra = {} ) {

		o.metalness = 1;
		o.roughness = 0.2;
		o.side = DoubleSide;
		//o.opacity = 0.9;
		//o.side = DoubleSide;
		//o.transparent = true;
		o.envMapIntensity = 1;
		//o.premultipliedAlpha = true;
		o.normalScale = new Vector2(2,2);
		//o.opacity = 1.0;

		super( o );

		this.onBeforeCompile = function ( shader ) {

			var uniforms = shader.uniforms;

			uniforms[ "insideMap" ] = { value: extra.insideMap || null };
			uniforms[ "wallFreq" ] = { value: new Vector3().fromArray( extra.freq || [1,1,1])  };
			uniforms[ "wallsBias" ] = { value: extra.bias || 0.01 };

			uniforms[ "time" ] = { value: extra.time || 1 };
			uniforms[ "lightning" ] = { value: 1 };
			uniforms[ "isNoise" ] = { value: 1 };
			uniforms[ "isNoSection" ] = { value: 0 };

			shader.uniforms = uniforms;

			var vertex = shader.vertexShader;
			vertex = vertex.replace( 'varying vec3 vViewPosition;', Shader.getGl2() ? vertAdd$2 : inverse$1+vertAdd$2  );
			vertex = vertex.replace( '#include <fog_vertex>', vertMainAdd$2 );
			shader.vertexShader = vertex;

			//console.log(vertex)

			var fragment = shader.fragmentShader;
			fragment = fragment.replace( 'void main() {', fragAdd$2 );
			//fragment = fragment.replace( 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', fragMainAdd );

			fragment = fragment.replace( '#include <map_fragment>', fragMap$1 );
			fragment = fragment.replace( '#include <normal_fragment_maps>', fragNormal );
			fragment = fragment.replace( '#include <emissivemap_fragment>', fragLuma );

			shader.fragmentShader = fragment;

			Shader.modify( shader );

		};
	}
}



const inverse$1 =/* glsl */`

mat4 inverse(mat4 m) {

    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3], a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3], a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3], a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

    b00 = a00 * a11 - a01 * a10,
    b01 = a00 * a12 - a02 * a10,
    b02 = a00 * a13 - a03 * a10,
    b03 = a01 * a12 - a02 * a11,
    b04 = a01 * a13 - a03 * a11,
    b05 = a02 * a13 - a03 * a12,
    b06 = a20 * a31 - a21 * a30,
    b07 = a20 * a32 - a22 * a30,
    b08 = a20 * a33 - a23 * a30,
    b09 = a21 * a32 - a22 * a31,
    b10 = a21 * a33 - a23 * a31,
    b11 = a22 * a33 - a23 * a32,

  det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat4( a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03, a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07,
      a00 * b11 - a02 * b08 + a03 * b07, a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06, a01 * b08 - a00 * b10 - a03 * b06,
      a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00, a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00,
      a20 * b03 - a21 * b01 + a22 * b00) / det;
}
`;

const vertAdd$2 =/* glsl */`
varying vec3 vViewPosition;

varying mat4 invMat;
varying mat4 modelMatrixOn;

varying vec3 oP; // surface position in object space
varying vec3 oE; // position of the eye in object space
varying vec3 oI; // incident ray direction in object space
varying vec3 oN; // surface normal

`;

const vertMainAdd$2 =/* glsl */`
#include <fog_vertex>

mat4 modelViewMatrixInverse = inverse( modelViewMatrix );

// surface position in object space
oP = position;

// position of the eye in object space
oE = modelViewMatrixInverse[3].xyz;

// incident ray direction in object space
oI = oP - oE;

// surface normal
oN = normalize( vec3( normal ) );

`;



const fragAdd$2 =/* glsl */`

varying vec3 oP; // surface position in object space
varying vec3 oE; // position of the eye in object space
varying vec3 oI; // incident ray direction in object space
varying vec3 oN; // surface normal

uniform sampler2D insideMap;
uniform vec3 wallFreq;
uniform float wallsBias;

uniform float time;
uniform float lightning;
uniform bool isNoise;
uniform bool isNoSection;

float randomized( vec2 co ){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec2 tileUV( vec2 uv, vec2 pos, vec2 ntile ){

	pos.y = ntile.y-pos.y-1.0;
	vec2 div = 1.0/ntile;
	vec2 v = vec2(uv*div)+(pos*div);
	return v;
	
}

void main() {

`;


const fragMap$1 =/* glsl */`

#ifdef USE_MAP

	//vec4 texelColor = texture2D( map, vUv );

	//texelColor = mapTexelToLinear( texelColor );
	//diffuseColor *= texelColor;


vec3 wallFrequencies = wallFreq - wallsBias;

// calculate wall locations
vec3 wallFrame = floor( oP * wallFrequencies);
vec3 walls = ( wallFrame + step( vec3( 0.0 ), oI )) / wallFrequencies;

// how much of the ray is needed to get from the oE to each of the walls

vec3 rayFractions = ( walls - oE ) / oI;

// texture-coordinates of intersections
vec2 uvXY = fract((oE + rayFractions.z * oI).xy * wallFrequencies.xy);
vec2 uvXZ = fract((oE + rayFractions.y * oI).xz * wallFrequencies.xz);
vec2 uvZY = fract((oE + rayFractions.x * oI).zy * wallFrequencies.zy);

vec2 nuv = vec2( 2.0, 4.0 );

// floor / ceiling  

vec4 tmp_color_1 = texture2D( insideMap, tileUV( uvXZ, vec2(1.0,0.0), nuv ) );// floor
vec4 tmp_color_2 = texture2D( insideMap, tileUV( uvXZ, vec2(0.0,0.0), nuv ) );// ceilling
vec4 verticalColour = mix( tmp_color_1, tmp_color_2, step(0.0, oI.y));

tmp_color_1 = texture2D( insideMap, tileUV( uvXY, vec2(0.0,2.0), nuv ) ); // back
tmp_color_2 = texture2D( insideMap, tileUV( uvXY, vec2(1.0,2.0), nuv ) ); // front
vec4 wallXYColour = mix( tmp_color_1, tmp_color_2, step(oI.z, 0.0));

tmp_color_1 = texture2D( insideMap, tileUV( uvZY, vec2(0.0,3.0), nuv ) ); // left
tmp_color_2 = texture2D( insideMap, tileUV( uvZY, vec2(1.0,3.0), nuv ) ); // right
vec4 wallZYColour = mix( tmp_color_1, tmp_color_2, step(oI.x, 0.0) );

// add some noise

vec4 noiseColor = vec4( 0.0 );

if( isNoise ){
	float t = time*0.00000001;
	noiseColor.xyz = vec3( vec3( randomized(wallFrame.xy+t) ) + vec3( randomized(wallFrame.zy) ) + vec3( randomized(wallFrame.xz+t)) ) / 3.0;
	wallXYColour *= noiseColor;
    wallZYColour *= noiseColor;
    verticalColour *= noiseColor;
}

// intersect walls

vec4 insideColor = vec4(0.0);
if( isNoSection ){
	//insideColor = ( wallXYColour + wallZYColour + verticalColour ) / 3.0;
	///insideColor.a = alph;

	insideColor = mix( wallXYColour, wallZYColour, step(wallXYColour.a, wallZYColour.a) );
	insideColor = mix( insideColor, verticalColour, step(insideColor.a, verticalColour.a)  );
	//insideColor = verticalColour;
	//insideColor = mix( insideColor, verticalColour, insideColor.a );

} else {

    float xVSz = step( rayFractions.x, rayFractions.z );
	insideColor = mix( wallXYColour, wallZYColour, xVSz );

	float rayFraction_xVSz = mix( rayFractions.z, rayFractions.x, xVSz );
	float xzVSy = step( rayFraction_xVSz, rayFractions.y );
	insideColor = mix( verticalColour, insideColor, xzVSy );

}



// exterior

vec2 nuvo = vec2( 2.0, 4.0 );// texture reapeat

vec4 Ftop = texture2D( map, tileUV( fract( oP.xz * wallFrequencies.xz ) , vec2(1.0,2.0), nuv ) );
vec4 Fleft = texture2D( map, tileUV( fract( oP.zy * wallFrequencies.zy ) , vec2(1.0,1.0), nuv ) );
vec4 Ffront = texture2D( map, tileUV( fract( oP.xy * wallFrequencies.xy ) , vec2(0.0,0.0), nuv ) );

float n = abs(oN.z) > abs(oN.x) ? 1.0 : 0.0;
float ny = abs(oN.y) > ( abs(oN.x) + abs(oN.z) * 0.5 ) ? 1.0 : 0.0;

vec4 outsideColor =  mix( Fleft, Ffront, n );
//outsideColor =  mix( outsideColor, Ftop, ny );


//vec4 building_color = mapTexelToLinear(vec4( mix( insideColor, outsideColor, outsideColor.a ).xyz, 1.0));
vec4 building_color = mapTexelToLinear( mix( insideColor, outsideColor, outsideColor.a ));

//if(building_color.a < 0.01) discard;

diffuseColor *= building_color;

#endif


`;
const fragLuma =/* glsl */`
vec4 emissiveColor = vec4( mix( insideColor, vec4(0.0, 0.0, 0.0, 1.0), outsideColor.a ).xyz, 1.0);
//emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor.rgb );
totalEmissiveRadiance = emissiveColor.xyz*lightning*noiseColor.xyz;
`;


const fragNormal =/* glsl */`
#ifdef USE_NORMALMAP

vec3 nWallFrequencies = wallFreq - wallsBias;
vec2 nuvn = vec2( 2.0, 4.0 );
vec3 Ntop = texture2D( normalMap, tileUV( fract( oP.xz * nWallFrequencies.xz ) , vec2(1.0,2.0), nuvn ) ).rgb;
vec3 Nleft = texture2D( normalMap, tileUV( fract( oP.zy * nWallFrequencies.zy ) , vec2(1.0,1.0), nuvn ) ).rgb;
vec3 Nfront = texture2D( normalMap, tileUV( fract( oP.xy * nWallFrequencies.xy ) , vec2(0.0,0.0), nuvn ) ).rgb;

float nn = abs(oN.z) > abs(oN.x) ? 1.0 : 0.0;
float nny = abs(oN.y) > ( abs(oN.x) + abs(oN.z) * 0.5 ) ? 1.0 : 0.0;

vec3 tmpNormal =  mix( Nleft, Nfront, nn );
//tmpNormal =  mix( tmpNormal, Ntop, nny );
tmpNormal = tmpNormal * 2.0 - 1.0;


vec3 eye_pos = -vViewPosition;
vec3 surf_norm = normal;

vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
vec2 st0 = dFdx( vUv.st );
vec2 st1 = dFdy( vUv.st );

float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude

vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
vec3 N = normalize( surf_norm );
mat3 tsn = mat3( S, T, N );

vec3 mapN = tmpNormal;//texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;

mapN.xy *= normalScale;
mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

normal = normalize( tsn * mapN );

#endif
`;

/**
 * Utility class for sampling weighted random points on the surface of a mesh.
 *
 * Building the sampler is a one-time O(n) operation. Once built, any number of
 * random samples may be selected in O(logn) time. Memory usage is O(n).
 *
 * References:
 * - http://www.joesfer.com/?p=84
 * - https://stackoverflow.com/a/4322940/1314762
 */

const _face = new Triangle();
const _color = new Vector3();

class MeshSurfaceSampler {

	constructor( mesh ) {

		let geometry = mesh.geometry;

		if ( ! geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3 ) {

			throw new Error( 'THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.' );

		}

		if ( geometry.index ) {

			console.warn( 'THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.' );

			geometry = geometry.toNonIndexed();

		}

		this.geometry = geometry;
		this.randomFunction = Math.random;

		this.positionAttribute = this.geometry.getAttribute( 'position' );
		this.colorAttribute = this.geometry.getAttribute( 'color' );
		this.weightAttribute = null;

		this.distribution = null;

	}

	setWeightAttribute( name ) {

		this.weightAttribute = name ? this.geometry.getAttribute( name ) : null;

		return this;

	}

	build() {

		const positionAttribute = this.positionAttribute;
		const weightAttribute = this.weightAttribute;

		const faceWeights = new Float32Array( positionAttribute.count / 3 );

		// Accumulate weights for each mesh face.

		for ( let i = 0; i < positionAttribute.count; i += 3 ) {

			let faceWeight = 1;

			if ( weightAttribute ) {

				faceWeight = weightAttribute.getX( i )
					+ weightAttribute.getX( i + 1 )
					+ weightAttribute.getX( i + 2 );

			}

			_face.a.fromBufferAttribute( positionAttribute, i );
			_face.b.fromBufferAttribute( positionAttribute, i + 1 );
			_face.c.fromBufferAttribute( positionAttribute, i + 2 );
			faceWeight *= _face.getArea();

			faceWeights[ i / 3 ] = faceWeight;

		}

		// Store cumulative total face weights in an array, where weight index
		// corresponds to face index.

		this.distribution = new Float32Array( positionAttribute.count / 3 );

		let cumulativeTotal = 0;

		for ( let i = 0; i < faceWeights.length; i ++ ) {

			cumulativeTotal += faceWeights[ i ];

			this.distribution[ i ] = cumulativeTotal;

		}

		return this;

	}

	setRandomGenerator( randomFunction ) {

		this.randomFunction = randomFunction;
		return this;

	}

	sample( targetPosition, targetNormal, targetColor ) {

		const cumulativeTotal = this.distribution[ this.distribution.length - 1 ];

		const faceIndex = this.binarySearch( this.randomFunction() * cumulativeTotal );

		return this.sampleFace( faceIndex, targetPosition, targetNormal, targetColor );

	}

	binarySearch( x ) {

		const dist = this.distribution;
		let start = 0;
		let end = dist.length - 1;

		let index = - 1;

		while ( start <= end ) {

			const mid = Math.ceil( ( start + end ) / 2 );

			if ( mid === 0 || dist[ mid - 1 ] <= x && dist[ mid ] > x ) {

				index = mid;

				break;

			} else if ( x < dist[ mid ] ) {

				end = mid - 1;

			} else {

				start = mid + 1;

			}

		}

		return index;

	}

	sampleFace( faceIndex, targetPosition, targetNormal, targetColor ) {

		let u = this.randomFunction();
		let v = this.randomFunction();

		if ( u + v > 1 ) {

			u = 1 - u;
			v = 1 - v;

		}

		_face.a.fromBufferAttribute( this.positionAttribute, faceIndex * 3 );
		_face.b.fromBufferAttribute( this.positionAttribute, faceIndex * 3 + 1 );
		_face.c.fromBufferAttribute( this.positionAttribute, faceIndex * 3 + 2 );

		targetPosition
			.set( 0, 0, 0 )
			.addScaledVector( _face.a, u )
			.addScaledVector( _face.b, v )
			.addScaledVector( _face.c, 1 - ( u + v ) );

		if ( targetNormal !== undefined ) {

			_face.getNormal( targetNormal );

		}

		if ( targetColor !== undefined && this.colorAttribute !== undefined ) {

			_face.a.fromBufferAttribute( this.colorAttribute, faceIndex * 3 );
			_face.b.fromBufferAttribute( this.colorAttribute, faceIndex * 3 + 1 );
			_face.c.fromBufferAttribute( this.colorAttribute, faceIndex * 3 + 2 );

			_color
				.set( 0, 0, 0 )
				.addScaledVector( _face.a, u )
				.addScaledVector( _face.b, v )
				.addScaledVector( _face.c, 1 - ( u + v ) );

			targetColor.r = _color.x;
			targetColor.g = _color.y;
			targetColor.b = _color.z;

		}

		return this;

	}

}

class Sparkle extends Points {

	constructor( o = {} ) {

        super();

        this.num = o.num || 12;

        this.controler = o.controler || null;

        this.sampler = new MeshSurfaceSampler( new Mesh( new BoxGeometry().toNonIndexed() ) );
        this.v = new Vector3();

        this.objectList = o.objectList;
        this.lng = this.objectList.length;

        this.numParticle = this.lng * this.num;

	    this.range = o.range || [2, 2, 2];
	    this.speed = o.speed || [0.002, 0.001];

	    this.disp = o.disp || [0.5, 0.5, 0.5];

        let cc = new Color();
        this.velocities = [];
        this.pos = [];

        let alphas = [];
        let sizes = [];
        let angles = [];
        let position = [];
        let color = [];

        this.tt = [];

        let i = this.numParticle, j, n, c;

        while( i-- ){

        	position.push( 0,0,0 );
            color.push( 1,1,1 );
	        sizes.push( math$1.rand(0.2, 1.5) );
	        alphas.push( math$1.rand(0, 1) );
	        angles.push( 0 );
	        //this.ba.push( math.rand( 0, Math.PI * 2 ) )
	        this.tt.push( math$1.randInt(-300,1) );
	        
	    }

	    // point on geometry
	    i = this.lng;

	    while( i-- ){

            this.setSamplerGeometry( this.objectList[i].children[0].geometry );

	    	c = this.objectList[i].children[0].material.color;
	    	
	    	//g = this.objectList[i].children[0].geometry.attributes.position;
	    	//glng = g.count;
	    	j = this.num;

	    	while( j-- ){

	    		n = ((i*this.num) + j) * 3;
	    		//m = math.randInt(1, glng-1) * 3;

	    		this.v.set(math$1.rand(-5,5), math$1.rand(-5,5), math$1.rand(-5,5));
	    		this.sampler.sample( this.v );

                this.v.toArray( this.pos, n);

	    		cc.copy(c);

	    		color[n] = c.r;
	    		color[n+1] = c.g;
	    		color[n+2] = c.b;

	    	}
	    }



	    this.positions = new Float32Array(position);
	    this.angles = new Float32Array(angles);
	    this.alphas = new Float32Array(alphas);
        this.sizes = new Float32Array(sizes);

	    this.geometry.setAttribute('position', new BufferAttribute( this.positions, 3 ) );
        this.geometry.setAttribute('color', new BufferAttribute( new Float32Array(color), 3 ) );
        this.geometry.setAttribute('sizer', new BufferAttribute( this.sizes, 1 ) );
        this.geometry.setAttribute('alphas', new BufferAttribute( this.alphas, 1 ) );
        this.geometry.setAttribute('angles', new BufferAttribute( this.angles, 1 ) );

        this.texture = this.makeTexture();

        this.material = new PointsMaterial({

	        name:'snow',
	        size: 1,
	        color: 0xffffff,
	        vertexColors: true,
	        map: this.texture,
	        blending: AdditiveBlending,
	        transparent: true,
	        // opacity: 0.8,
	        fog: false,
	        //depthWrite: false,
	        //depthTest: false,
	        depthWrite: false,

            premultipliedAlpha : true,
            alphaToCoverage : true,
	        /*polygonOffset: true,
	        polygonOffsetFactor: -1,
            polygonOffsetUnits: -4*/
	    });

	    this.material.onBeforeCompile = function ( shader ) {

	    	var vertex = shader.vertexShader;
			vertex = vertex.replace( '#include <clipping_planes_pars_vertex>', vertAdd$1 );
			vertex = vertex.replace( '#include <fog_vertex>', vertMainAdd$1 );
			shader.vertexShader = vertex;

			var fragment = shader.fragmentShader;
			fragment = fragment.replace( '#include <clipping_planes_pars_fragment>', fragAdd$1 );

            fragment = fragment.replace( '#include <output_fragment>', '#include <output_fragment>' + fragMainAdd$1 );
			//fragment = fragment.replace( 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', fragMainAdd );

			fragment = fragment.replace( '#include <map_particle_fragment>', fragMap );

			shader.fragmentShader = fragment;


        };

	    this.mTime = 0.0;
	    this.castShadow = false;
	    this.receiveShadow = false;
	    //this.renderDepth = -1;

    }

    setSamplerGeometry( g ) {

        this.sampler.geometry.dispose();

        this.sampler.geometry = g.clone().toNonIndexed();
        this.sampler.positionAttribute = this.sampler.geometry.getAttribute( 'position' );
        //this.sampler.colorAttribute = this.sampler.geometry.getAttribute( 'color' );

        this.sampler.build();

    }

    makeTexture (){

    	let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');

        let d = 64;
        canvas.width = d;
        canvas.height = d;
        let mid = d * 0.5;

        //ctx.save();
        let g1 = ctx.createRadialGradient(mid,mid,0,mid,mid,mid);
        g1.addColorStop(0, 'rgba(255,255,255,0.4)');
        g1.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        g1.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g1;
        ctx.fillRect(0,0,d,d);
        //ctx.restore();

        g1 = ctx.createRadialGradient(mid,mid,0,mid,mid,mid);
        g1.addColorStop(0, 'rgba(255,255,255,1.0)');
        g1.addColorStop(0.5, 'rgba(255,255,255,0.5)');
        g1.addColorStop(1, 'rgba(255,255,255,0)');

        ctx.strokeStyle = g1;
        ctx.beginPath();
        ctx.moveTo(0, mid);
        ctx.lineTo(d, mid);
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(mid, 0);
        ctx.lineTo(mid, d );
        ctx.lineWidth = 2;
        ctx.stroke();

        g1 = ctx.createRadialGradient(mid,mid,0,mid,mid,mid);
        g1.addColorStop(0, 'rgba(255,255,255,0.4)');
        g1.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        g1.addColorStop(1, 'rgba(255,255,255,0)');

        ctx.strokeStyle = g1;

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(d, d );
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(d, 0);
        ctx.lineTo(0, d );
        ctx.lineWidth = 1;
        ctx.stroke();

        var texture = new Texture(canvas);
        //texture.type = FloatType;
        texture.colorSpace = SRGBColorSpace;
        texture.needsUpdate = true;
        return texture;

    }

    updateMatrixWorld ( force ) {

    	let dt = 0.01666;
        let v = this.v;

        this.mTime += dt;

        let angular = 0;
        if(this.controler) angular = this.controler.getAzimuthalAngle();

        let i = this.lng, j, p, n, q, a, t;
        while(i--){

        	//this.m.copy( this.objectList[i].matrix )//.invert();

        	p = this.objectList[i].position;
        	q = this.objectList[i].quaternion;
        	//v.copy(p).applyQuaternion( q )//.add( p );
        	//
        	//p.applyNormalMatrix(this.m);
        	j = this.num;

        	while( j-- ){

        		n = ((i*this.num) + j);

        		a = this.alphas[ n ];
        		t = this.tt[n];

        		if(t===0){
        			a += dt*0.1;
        			if( a>0.5 ) t = 1;
        		} else if(t===1){
        			a -= dt*0.1;
        			if( a<0 ){ 
        				t = math$1.randInt(-300,0);
        				//this.ba[n] = math.rand( 0, Math.PI * 2 );
                        this.sizes[n] = math$1.rand(0.2, 1.5);
        			}
        		} else {
        			t++;
        		}

        		this.alphas[ n ] = math$1.clamp(a,0,1);
        		this.tt[n] = t;

        		//this.angles[ n ] = this.ba[n] - angular;

                this.angles[ n ] = - angular;

        		
        		if(this.alphas[ n ]>1) this.alphas[ n ] = math$1.rand(-5, 0);

        		n *= 3;
                v.fromArray( this.pos, n ).applyQuaternion( q ).add( p );
                v.toArray( this.positions, n);

        	}

        }


        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.alphas.needsUpdate = true;
        this.geometry.attributes.angles.needsUpdate = true;
        this.geometry.attributes.sizer.needsUpdate = true;

    }

    dispose () {

    	this.parent.remove(this);
        this.geometry.dispose();
        this.material.map.dispose();
        this.material.dispose();
        
    }

    raycast( raycaster, intersects ) {
        return
    }

}


const vertAdd$1 =/* glsl */`
#include <clipping_planes_pars_vertex>

attribute float sizer;
attribute float alphas;
attribute float angles;

varying float aaa;
varying float ang;
`;

const vertMainAdd$1 =/* glsl */`
#include <fog_vertex>

aaa = alphas;
ang = angles;

gl_PointSize *= sizer;

`;


const fragAdd$1 =/* glsl */`
#include <clipping_planes_pars_fragment>

varying float aaa;
varying float ang;

vec2 rotUV(vec2 uv, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat2 r = mat2( c, -s, s, c);
    r *= 0.5; r += 0.5; r = r * 2.0 - 1.0;
    uv -= 0.5; uv = uv * r; uv += 0.5;
    return uv;
}
`;

const fragMainAdd$1 =/* glsl */`

gl_FragColor.a *= aaa;

//gl_FragColor = vec4( outgoingLight, diffuseColor.a * aaa  );
//gl_FragColor = vec4( outgoingLight, aaa );

`;


const fragMap =/* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, rotUV( uv, ang ) );
	diffuseColor *= mapTexel;

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`;

//import { Main } from '../../Main.js';


class Diamond extends MeshPhysicalMaterial {

	constructor( o = {}, extra = {} ) {

		o.metalness = 0;
		o.roughness = 0;

        o.clearcoat = 1;
        //o.clearcoatRoughness = 0.01

        o.iridescenceIOR = 2.33;
        o.iridescence = 1;


        
		
		//o.side = DoubleSide
		
		//o.envMapIntensity = 1
        o.reflectivity = 1.0;
        o.envMapIntensity = 1.3;
        //o.iridescence = 1.0
        //o.ior=1.7

        //o.transparent = true
        //o.opacity = 0.9


        //o.transmission = 1
        //o.thickness = 2.5

        //o.depthTest = false
        //o.depthWrite = false
		//o.premultipliedAlpha = true
        //o.alphaToCoverage = true

        /*o.polygonOffset = true
        o.polygonOffsetFactor = 1
        o.polygonOffsetUnits = 4.0*/

		super( o );

        this.normal = this.cubeNormal( extra );

        //this.color.convertSRGBToLinear();

		this.onBeforeCompile = function ( shader ) {

			var uniforms = shader.uniforms;
			uniforms[ "normalCube" ] = { value: this.normal.texture };
			uniforms[ "bDebugBounces" ] = { value: 0 };

			uniforms[ "mFresnelBias" ] = { value: 0.02 };
			uniforms[ "mFresnelScale" ] = { value: 0.1 };
			uniforms[ "mFresnelPower" ] = { value: 1 };

			uniforms[ "aberration" ] = { value: 0.012 };
			uniforms[ "refraction" ] = { value: 2.417 };

			uniforms[ "normalOffset" ] = { value: 0.0 };
			uniforms[ "squashFactor" ] = { value: 0.98 };
			uniforms[ "distanceOffset" ] = { value: 0 };
			uniforms[ "geometryFactor" ] = { value: 0.28 };

			uniforms[ "absorbption" ] = { value: new Color(0,0,0) };
			uniforms[ "correction" ] = { value: new Color( o.color || 0xFFFFFF ) };
			uniforms[ "boost" ] = { value: new Color(.892, .892, .98595025) };

			uniforms[ "radius" ] = { value: 1.5 };
			uniforms[ "centreOffset" ] = { value: new Vector3(0, 0, 0) };

			shader.uniforms = uniforms;

			//shader.uniforms.reflectif = this.userData.reflectif;

			var vertex = shader.vertexShader;
			vertex = vertex.replace( 'varying vec3 vViewPosition;', Shader.getGl2() ? vertAdd : inverse+vertAdd  );
			vertex = vertex.replace( '#include <fog_vertex>', vertMainAdd );
			shader.vertexShader = vertex;

			//console.log(vertex)

			var fragment = shader.fragmentShader;
			fragment = fragment.replace( 'void main() {', fragAdd );
			//fragment = fragment.replace( 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', fragMainAdd );
            //fragment = fragment.replace( '#include <output_fragment>', '#include <output_fragment>' + fragMainAdd );
            fragment = fragment.replace( '#include <opaque_fragment>', '#include <opaque_fragment>' + fragMainAdd );

			shader.fragmentShader = fragment;

			Shader.modify( shader );

		};

	}

	cubeNormal ( o = {} ){

        let target = new WebGLCubeRenderTarget( 1024, { format:RGBAFormat/*, anisotropy:1, generateMipmaps:false, minFilter:LinearMipmapLinearFilter*/ });

        //console.log(target)

        let camera = new CubeCamera( 0.01, 10, target );
        let scene = new Scene();
        scene.add( camera );

        let normal = new ShaderMaterial({
            vertexShader: ["varying vec3 vNormalm;", "void main() {", "vNormalm = normal;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["varying vec3 vNormalm;", "void main() {", "vec3 color = normalize(vNormalm);", "color = color * 0.5 + 0.5;", "gl_FragColor = vec4( color.xyz, 1.0 );", "}"].join("\n"),
            side: BackSide
        });

        //console.log(normal)

        let m = new Mesh( o.geometry, normal );
        m.scale.set(10,10,10);
        m.frustumCulled = false;
        m.geometry.center();
        scene.add( m );

        camera.update( Shader.renderer, scene );

        scene.remove( m );
        scene.remove( camera );

        m.material.dispose();
        m.geometry.dispose();

        return target;

    }

    dispose() {
        this.normal.dispose();
        this.dispatchEvent( { type: 'dispose' } );
    }

}


const inverse =/* glsl */`

mat4 inverse(mat4 m) {

    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3], a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3], a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3], a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

    b00 = a00 * a11 - a01 * a10,
    b01 = a00 * a12 - a02 * a10,
    b02 = a00 * a13 - a03 * a10,
    b03 = a01 * a12 - a02 * a11,
    b04 = a01 * a13 - a03 * a11,
    b05 = a02 * a13 - a03 * a12,
    b06 = a20 * a31 - a21 * a30,
    b07 = a20 * a32 - a22 * a30,
    b08 = a20 * a33 - a23 * a30,
    b09 = a21 * a32 - a22 * a31,
    b10 = a21 * a33 - a23 * a31,
    b11 = a22 * a33 - a23 * a32,

  det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat4( a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03, a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07,
      a00 * b11 - a02 * b08 + a03 * b07, a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06, a01 * b08 - a00 * b10 - a03 * b06,
      a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00, a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00,
      a20 * b03 - a21 * b01 + a22 * b00) / det;
}
`;

const vertAdd =/* glsl */`
varying vec3 vViewPosition;

varying mat4 invMat;
varying mat4 modelMatrixOn;

varying vec3 worldNormal;
varying vec3 vecPos;
//varying vec3 vEye;
varying vec3 vI;
`;

const vertMainAdd =/* glsl */`
#include <fog_vertex>

modelMatrixOn = modelMatrix;
invMat = inverse( modelMatrix );
vecPos = worldPosition.xyz;//(modelMatrix * vec4(position, 1.0 )).xyz;
//worldNormal = (modelMatrix * vec4(normal,0.0)).xyz;
worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
//vEye = normalize(-cameraPosition);
vI = normalize( worldPosition.xyz - cameraPosition );//vecPos - cameraPosition;

`;

const fragMainAdd =/* glsl */`
#ifdef USE_ENVMAP
float vReflectionFactor = mFresnelBias + mFresnelScale * pow( abs((1.0 + dot( normalize( vI ), vNormal ))), mFresnelPower );

vec3 refractedColor = traceRayTest( vecPos, vI, normalize( worldNormal ) );

vec3 finalColor = mix( refractedColor, refractedColor*outgoingLight, clamp( vReflectionFactor, 0.0, 1.0 ) );
//vec3 finalColor = outgoingLight * refractedColor;
gl_FragColor = vec4( finalColor, diffuseColor.a);
//reflectedColor.rgb = textureCube( envMap, vec3( -vReflect.x, vReflect.yz ) ).rgb;
#endif

`;

const fragAdd =/* glsl */`

#define RAY_BOUNCES 5

varying mat4 invMat;
varying mat4 modelMatrixOn;
varying vec3 worldNormal;
varying vec3 vecPos;
//varying vec3 vEye;
varying vec3 vI;

uniform samplerCube normalCube;
uniform bool bDebugBounces;

uniform float mFresnelBias;
uniform float mFresnelScale;
uniform float mFresnelPower;

uniform float refraction;
uniform float aberration;

uniform float normalOffset;
uniform float squashFactor;
uniform float distanceOffset;
uniform float geometryFactor;

uniform vec3 absorbption;
uniform vec3 correction;
uniform vec3 boost;

uniform float radius;
uniform vec3 centreOffset;

#ifdef USE_ENVMAP

vec3 BRDF_Specular_GGX_EnvironmentTest( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
    float dotNV = abs( dot( normal, viewDir ) );
    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
    vec4 r = roughness * c0 + c1; 
    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
    return specularColor * AB.x + AB.y;
}

vec4 SampleSpecularReflectionTest( vec4 specularColor, vec3 direction ) {
    direction.x *= -1.0;
    direction.z *= -1.0;
    vec4 sampleColorRGB = envMapIntensity * textureCubeUV( envMap, direction, 0.0 );
    sampleColorRGB = clamp( sampleColorRGB, 0.0, 1.0);
    return sampleColorRGB;
}

vec4 SampleSpecularContributionTest( vec4 specularColor, vec3 direction ) { 
    direction = normalize(direction);
    direction.x *= -1.0; 
    direction.z *= -1.0;
    vec4 sampleColorRGB = envMapIntensity * textureCubeUV( envMap, direction, 0.0 );

    //sampleColorRGB.a = 1.0;

    sampleColorRGB = clamp( sampleColorRGB, 0.0, 1.0);
    return sampleColorRGB;
}

vec3 intersectSphereTest( vec3 origin, vec3 direction ) {
    origin -= centreOffset;
    direction.y /= squashFactor;
    float A = dot(direction, direction);
    float B = 2.0*dot(origin, direction);
    float C = dot(origin, origin) - radius * radius;
    float disc = B*B - 4.0 * A * C;
    if(disc > 0.0){ 
        disc = sqrt(disc);
        float t1 = (-B + disc)*geometryFactor/A;
        float t2 = (-B - disc)*geometryFactor/A;
        float t = (t1 > t2) ? t1 : t2;
        direction.y *= squashFactor;
        return vec3(origin + centreOffset + direction * t);
     }
     return vec3(0.0); 
}

vec3 debugBounces( int count ) { 
    vec3 color = vec3(1.,1.,1.);
    if(count == 1) color = vec3(0.0,1.0,0.0);
    else if(count == 2) color = vec3(0.0,0.0,1.0);
    else if(count == 3) color = vec3(1.0,1.0,0.0);
    else if(count == 4) color = vec3(0.0,1.0,1.0);
    else color = vec3(0.0,1.0,0.0); 
    if(count == 0) color = vec3(1.0,0.0,0.0);
    return color;
}

vec3 traceRayTest( vec3 origin, vec3 direction, vec3 normal ) { 

    mat4 invModelMat = invMat;

    vec3 outColor = vec3(0.0); 
    // Reflect/Refract ray entering the diamond 
    const float n1 = 1.0; 
    const float epsilon = 1e-8;
    float f0 = (2.4- n1)/(2.4 + n1);
    f0 *= f0;
    vec3 attenuationFactor = vec3(1.0);
    vec3 newDirection = refract( direction, normal, n1/refraction ); 
    vec3 reflectedDirection = reflect(direction, normal);
    vec3 brdfReflected = BRDF_Specular_GGX_EnvironmentTest(reflectedDirection, normal, vec3(f0), 0.0);
    vec3 brdfRefracted = BRDF_Specular_GGX_EnvironmentTest(newDirection, -normal, vec3(f0), 0.0);
    attenuationFactor *= ( vec3(1.0) - brdfRefracted);
    outColor += SampleSpecularReflectionTest(vec4(1.0), reflectedDirection ).rgb * brdfReflected;
    int count = 0;

    newDirection = (invModelMat * vec4(newDirection, 0.0)).xyz; 
    newDirection = normalize(newDirection);
    origin = (invModelMat * vec4(origin, 1.0)).xyz;

    // ray bounces 
    for( int i=0; i<RAY_BOUNCES; i++) { 

        vec3 intersectedPos = intersectSphereTest(origin + vec3(epsilon), newDirection);
        vec3 dist = intersectedPos - origin;
        vec3 d = normalize(intersectedPos - centreOffset);
        vec3 mappedNormal = textureCube( normalCube, d ).xyz;

        //vec3 mappedNormal = normalize( vNormal ) * -1.0;


        mappedNormal = 2. * mappedNormal - 1.0;
        //mappedNormal.y += normalOffset;
        mappedNormal = normalize(mappedNormal);
        dist = (modelMatrixOn * vec4(dist, 1.)).xyz;
        float r = sqrt(dot(dist, dist));
        attenuationFactor *= exp(-r*absorbption);
        // refract the ray at first intersection 
        vec3 oldOrigin = origin;
        origin = intersectedPos - normalize(intersectedPos - centreOffset) * distanceOffset;
        vec3 oldDir = newDirection;
        newDirection = refract(newDirection, mappedNormal, refraction/n1);
         
        if( dot(newDirection, newDirection) == 0.0) { // Total Internal Reflection. Continue inside the diamond
            newDirection = reflect(oldDir, mappedNormal);
             //If the ray got trapped even after max iterations, simply sample along the outgoing refraction!
            if( i == RAY_BOUNCES-1 ) {
                vec3 brdfReflected = BRDF_Specular_GGX_EnvironmentTest(-oldDir, mappedNormal, vec3(f0), 0.0);
                vec3 d1 = (modelMatrixOn * vec4(oldDir, 0.0)).xyz;
                outColor += SampleSpecularContributionTest( vec4(1.0), d1 ).rgb * correction * attenuationFactor  * boost * (vec3(1.0) - brdfReflected);
                //outColor = vec3(1.,0.,0.);
                //if(d1.y > 0.95) outColor += d1.y * vec3(1.,0.,0) * attenuationFactor * (vec3(1.0) - brdfReflected) * boost;
            } 
        
        } else { // Add the contribution from outgoing ray, and continue the reflected ray inside the diamond 
           vec3 brdfRefracted = BRDF_Specular_GGX_EnvironmentTest(newDirection, -mappedNormal, vec3(f0), 0.0);
           // outgoing(refracted) ray's contribution
           vec3 d1 = (modelMatrixOn * vec4(newDirection, 0.0)).xyz;
           vec3 colorG = SampleSpecularContributionTest(vec4(1.0), d1 ).rgb * ( vec3(1.0) - brdfRefracted);
           vec3 dir1 = refract(oldDir, mappedNormal, (refraction+aberration)/n1);
           vec3 dir2 = refract(oldDir, mappedNormal, (refraction-aberration)/n1);
           vec3 d2 = (modelMatrixOn * vec4(dir1, 0.0)).xyz;
           vec3 d3 = (modelMatrixOn * vec4(dir2, 0.0)).xyz;
           vec3 colorR = SampleSpecularContributionTest(vec4(1.0), d2 ).rgb * ( vec3(1.0) - brdfRefracted);
           vec3 colorB = SampleSpecularContributionTest(vec4(1.0), d3 ).rgb * ( vec3(1.0) - brdfRefracted);
           outColor += vec3(colorR.r, colorG.g, colorB.b) * correction * attenuationFactor * boost;
           //outColor = oldDir;
           //new reflected ray inside the diamond
           newDirection = reflect(oldDir, mappedNormal);
           vec3 brdfReflected = BRDF_Specular_GGX_EnvironmentTest(newDirection, mappedNormal, vec3(f0), 0.0);
           attenuationFactor *= brdfReflected * boost;
           count++;
        } 
    }
    if(bDebugBounces) outColor = debugBounces(count); 
    //outColor = (textureCube( tCubeMapNormals, direction )).rgb;
    //outColor = texture2D( sphereMap, vUv ).rgb

    return outColor;
    
}
#endif
void main() {

`;

//import { Main } from '../../Main.js';

class Fluid extends MeshPhysicalMaterial {

	constructor( o = {}, extra = {} ) {

		o.metalness = 0.5;
		o.roughness = 0;

        o.clearcoat = 1;
        //o.clearcoatRoughness = 0.25
        //o.transmission = 1
        //o.thickness = 0.02
		
		o.side = DoubleSide;
		
		o.envMapIntensity = 1.2;
        o.reflectivity = 1.0;
        //o.ior=1.7

        o.transparent = true;
        //o.depthWrite = false
        o.opacity = 0.7;
		//o.premultipliedAlpha = true
        o.alphaToCoverage = true;

        o.sheenColor = 0xffffff;

        o.sheen = 0.5;
		super( o );


        this.isModif = false;

        this.modif( o );

        //return

		/**/


	}


    modif( o ){

        if(this.isModif) return

        let self = this;
        o.fillAmount || -0.5;

        this.onBeforeCompile = function ( shader ) {

            let uniforms = shader.uniforms;
            uniforms[ "time" ] = { value: 0 };
            uniforms[ "fillAmount" ] = { value: -0.5 };
            //uniforms[ "wobbleX" ] = { value: 0.0 }
            //uniforms[ "wobbleZ" ] = { value: 0.0 }
            uniforms[ "topColor" ] = { value: new Vector4(1,0,0, 0.7) };
            uniforms[ "rimColor" ] = { value: new Vector4(0,1,0, 0.5) };
            uniforms[ "foamColor" ] = { value: new Vector4(1,1,1, 0.9) };
            uniforms[ "tint" ] = { value: new Vector4(1,1,0,0.8) };
            uniforms[ "rim" ] = { value: 0.1 };
            uniforms[ "rimPower" ] = { value: 0.5 };
            uniforms[ "Line" ] = { value: 0.01 };
            uniforms[ "LineSmooth" ] = { value: 0.1 };

            /*uniforms[ "normalCube" ] = { value: self.normal.texture };
            uniforms[ "bDebugBounces" ] = { value: 0 };

            uniforms[ "mFresnelBias" ] = { value: 0.02 };
            uniforms[ "mFresnelScale" ] = { value: 0.1 };
            uniforms[ "mFresnelPower" ] = { value: 1 };

            uniforms[ "aberration" ] = { value: 0.012 };
            uniforms[ "refraction" ] = { value: 2.417 };

            uniforms[ "normalOffset" ] = { value: 0.0 };
            uniforms[ "squashFactor" ] = { value: 0.98 };
            uniforms[ "distanceOffset" ] = { value: 0 };
            uniforms[ "geometryFactor" ] = { value: 0.28 };

            uniforms[ "absorbption" ] = { value: new Color(0,0,0) };
            uniforms[ "correction" ] = { value: new Color( 0xFFFFFF ) };
            uniforms[ "boost" ] = { value: new Color(.892, .892, .98595025) };

            uniforms[ "radius" ] = { value: 1.5 };
            uniforms[ "centreOffset" ] = { value: new Vector3(0, 0, 0) };*/

            shader.uniforms = uniforms;

            //shader.uniforms.reflectif = this.userData.reflectif;

            var vertex = shader.vertexShader;

            vertex = vertexAdd + vertex;
            vertex = vertex.replace( '#include <color_vertex>', vertexColor  );
            vertex = vertex.replace( '#include <worldpos_vertex>', vertexWorld  );
            //vertex = vertex.replace( '#include <fog_vertex>', vertMainAdd );
            shader.vertexShader = vertex;

            //console.log(vertex)

            var fragment = shader.fragmentShader;

            fragment = fragmentAdd + fragment;

            //console.log(fragment)
            /*fragment = fragment.replace( 'void main() {', `
                #include <extra_fragment>
                void main() {` );

            //fragment = fragment.replace( 'void main() {', fragAdd );*/
            fragment = fragment.replace( '#include <color_fragment>', fragmentColor );

            shader.fragmentShader = fragment;

            self.userData.shader = shader;

            Shader.modify( shader );

        };
/*
        this.customProgramCacheKey = function () {

            return fillAmount;

        };*/

        this.isModif = true;
    }


    dispose() {
        //this.normal.dispose()
        this.dispatchEvent( { type: 'dispose' } );

    }

}

const vertexAdd = `
uniform float time;
uniform float fillAmount;

#define PII 3.1415926538

varying vec3 fillPosition;
varying vec4 vvWorldPosition;

vec4 RotateAroundYInDegrees(vec4 vertex, float degrees)
{
   float alpha = degrees * PII / 180.0;
   float sina = sin(alpha);
   float cosa = cos(alpha);
   mat2 m = mat2(cosa, sina, -sina, cosa);
   return vec4(vertex.yz , m * vertex.xz).xzyw ;                
}

vec3 RotateAround(vec3 In, vec3 Axis, float degrees )
{
    float alpha = degrees * PII / 180.0;
    float s = sin(alpha);
    float c = cos(alpha);
    float one_minus_c = 1.0 - c;
            
    mat3 rot_mat = mat3(
        one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s,
        one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s,
        one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c
    );

    vec3 Out = In * rot_mat;
    return Out;

}
`;
const vertexColor = `
#ifdef USE_COLOR
    vColor = color;
#endif
#ifdef USE_INSTANCING_COLOR
    vColor.xyz = instanceColor.xyz;
#endif
`;

const vertexWorld = `
vec4 worldPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
    worldPosition = instanceMatrix * worldPosition;
#endif
worldPosition = modelMatrix * worldPosition;

vec3 filling = vec3(0.0,fillAmount,0.0);
vec3 worldPosOffset = worldPosition.xyz - filling;
// rotate it around XY
//vec3 worldPosX = RotateAroundYInDegrees(vec4(transformed, 0.0), 360.0).xyz;
vec3 worldPosX = RotateAround( worldPosOffset, vec3(0.0,0.0,1.0), 90.0 );
// rotate around XZ
//vec3 worldPosZ = vec3(worldPosX.y, worldPosX.z, worldPosX.x);
vec3 worldPosZ = RotateAround( worldPosOffset, vec3(1.0,0.0,0.0), 90.0 );
// combine rotations with worldPos, based on sine wave from script
#ifdef USE_INSTANCING_COLOR
vec3 worldPosAdjusted = worldPosition.xyz + (worldPosX * vColor.x) + (worldPosZ * vColor.z);
// how high up the liquid is
fillPosition = worldPosAdjusted - filling;
fillPosition.y -= vColor.y;
#endif
vvWorldPosition = worldPosition;
`;


const fragmentAdd = `
uniform vec4 topColor;
uniform vec4 rimColor;
uniform vec4 foamColor;
uniform vec4 tint;
uniform float rim;
uniform float rimPower;
uniform float Line;
uniform float LineSmooth;

varying vec3 fillPosition;
varying vec4 vvWorldPosition;

`;
const fragmentColor = `
// -------- INIT LIQUID SHADER --------
vec4 col = tint;
//float dotProduct = 1.0 - pow(dot(worldNormal, viewDirection), rimPower);
//vec4 RimResult = vec4(smoothstep(0.5, 1.0, dotProduct));
//RimResult *= rimColor;
//RimResult *= rimColor.w;

float wobble = 0.0;//sin((i.fillPosition.x * _Freq) + (i.fillPosition.z * _Freq ) + ( _Time.y)) * (_Amplitude *wobbleIntensity);  
float movingfillPosition = fillPosition.y + wobble;

// foam edge
float cutoffTop = step(movingfillPosition, 0.5);
float foam = cutoffTop * smoothstep(0.5 - Line - LineSmooth, 0.5 - Line , movingfillPosition);
vec4 foamColored = foam * foamColor;

// rest of the liquid minus the foam
float result = cutoffTop - foam;
vec4 resultColored = result * col;


// both together, with the texture
vec4 finalResult = resultColored + foamColored;
vec4 _topColor = topColor * (foam + result);
//finalResult.rgb += RimResult.rgb;
//finalResult *= _topColor;

diffuseColor.rgb *= finalResult.rgb;
//diffuseColor *= gl_FrontFacing ? finalResult : _topColor;//_topColor;
//diffuseColor = finalResult;
`;

const T={getColor(e){let t=e.toString();t=t.substring(t.lastIndexOf(".")+1);let n,a=[255,255,255];switch(t){case"grass":a=[.223,.827,.325],n=[.741,.498,.258];break;case"dirt":a=[.741,.498,.258];break;case"leaves":a=[.152,.682,.376];break;case"sand":a=[.878,.819,.686];break;case"ice":a=[.65,.882,.96];break;case"stone":a=[.537,.64,.65];break;case"cobblestone":a=[.666,.647,.588];break;case"wood":a=[.603,.321,.152];break;case"snow":a=[.905,.976,1];}return n?[a[0],a[1],a[2],n[0],n[1],n[2]]:[a[0],a[1],a[2]]},fire:{type:"star",numParticles:20,position:[0,0,0],colors:[1,1,0,0,1,1,0,1,1,0,0,1,1,0,0,1,1,0,0,.5,0,0,0,0],lifeTime:2,timeRange:2,startSize:.3,endSize:.9,velocity:[0,.8,0],velocityRange:[.15,.15,.15],gravity:[0,-.2,0],spinSpeedRange:4},smoke:{position:[-2,-.2,0],colors:[0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0],numParticles:20,lifeTime:2,timeRange:2,startSize:.5,endSize:2,velocity:[0,1.6,0],velocityRange:[.2,0,.2],gravity:[0,-.25,0],spinSpeedRange:4,blending:"normal"},addBlock:{type:"cube",numParticles:30,lifeTime:1.5,endTime:1.5,startTime:0,startSize:.25,endSize:.5,sizeRange:.25,spinSpeedRange:2,radius:.25,velocity:[1,0,1],velocityRange:[.25,0,.25],acceleration:[1,0,1],accelerationRange:[.25,0,.25],gravity:[0,.05,0],tween:"outQuad",blending:"normal",alphaTest:.1},removeBlock:{type:"cube",lifeTime:1.5,endTime:1.5,startTime:0,startSize:.5,sizeRange:.25,endSize:.1,spinSpeedRange:2,accelerationRange:[.5,.5,.5],gravity:[0,-.1,0],tween:"outQuad",blending:"normal",alphaTest:.1},explosion:{colors:[1,0,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,1,1,.5,1,1,1,0],type:"cloud",radius:.5,radiusRange:.5,numParticles:400,positionRange:[2,1,2],lifeTime:3,endTime:4,lifeTimeRange:1,startTime:0,startSize:.1,endSize:2,sizeRange:1,accelerationRange:[1,.3,1],acceleration:[.8,.8,.8],gravity:[0,-.5,0],spinSpeedRange:2,luma:!1},playerMove:{trail:!0,colors:[1,1,1,1,.2,.2,.2,0],type:"round",blending:"normal",numParticles:4,maxParticles:1e3,positionRange:[.2,0,.2],lifeTime:1.5,startSize:.5,endSize:1,sizeRange:.25,velocityRange:[.6,0,.6],gravity:[0,.1,0]},vehicleMove:{trail:!0,colors:[.5,.5,.5,.25,.2,.2,.2,0],type:"round",blending:"normal",numParticles:4,maxParticles:2e3,positionRange:[.25,0,.25],lifeTime:1.5,startSize:.5,endSize:1,sizeRange:.25,velocityRange:[.6,0,.6],gravity:[0,.2,0]},vehicleTrack:{trail:!0,colors:[.2,.2,.2,.1,.2,.2,.2,0],type:"Round2",blending:"normal",startSize:.3,endSize:.3,numParticles:4,maxParticles:2e3,position:[0,-.1,0],lifeTime:6,oriented:!0},underWater:{trail:!0,colors:[1,1,1,1,.5,.5,1,0],type:"bubble",blending:"normal",numParticles:1,maxParticles:1e3,positionRange:[.25,0,.25],lifeTime:1.5,startSize:.1,endSize:.5,sizeRange:.05,velocity:[0,1,0],velocityRange:[1,0,1],acceleration:[.2,0,.2],gravity:[0,1,0]},bazookaFire:{trail:!0,colors:[1,0,0,1,1,1,0,.5,1,1,1,0],type:"round",numParticles:2,maxParticles:600,positionRange:[.1,.1,.1],lifeTime:1.5,startSize:.5,endSize:1,sizeRange:.1,velocityRange:[.6,.6,.6],gravity:[0,.1,0],luma:!1}};function L(){this.parent=null,this.position=[0,0,0],this.rotation=[0,0,0],this.name="default",this.type="round",this.tween="linear",this.trail=!1,this.model="",this.numParticles=1,this.maxParticles=0,this.numFrames=1,this.frameDuration=1,this.frameStart=0,this.frameStartRange=0,this.timeRange=99999999,this.startTime=null,this.lifeTime=1,this.endTime=-1,this.lifeTimeRange=0,this.sizeRange=0,this.startSize=1,this.startSizeRange=0,this.endSize=1,this.endSizeRange=0,this.pposition=[0,0,0],this.positionRange=[0,0,0],this.velocity=[0,0,0],this.velocityRange=[0,0,0],this.acceleration=[0,0,0],this.accelerationRange=[0,0,0],this.spinStart=0,this.spinStartRange=0,this.spinSpeed=0,this.spinSpeedRange=0,this.colorMult=[1,1,1,1],this.colorMultRange=[0,0,0,0],this.worldVelocity=[0,0,0],this.gravity=[0,0,0],this.oriented=!1,this.orientation=[0,0,0,1],this.colors=[1,1,1,1],this.blending="additive",this.radius=0,this.radiusRange=0,this.tmpRotation=null,this.alphaTest=0,this.renderOrder=0,this.luma=!0,this.depthWrite=!1,this.transparent=!0;}const C={torad:Math.PI/180,todeg:180/Math.PI,random:()=>Math.random(),rand:(e,t)=>e+C.random()*(t-e),randInt:(e,t)=>e+Math.floor(C.random()*(t-e+1)),plusMinus:e=>(C.random()-.5)*e*2,plusMinusVector:e=>{const t=[];let n=e.length;for(;n--;)t.push(C.plusMinus(e[n]));return t},toTexture:n=>{let a=new Texture(n);return a.minFilter=LinearFilter,a.magFilter=LinearFilter,a.flipY=!1,a.needsUpdate=!0,a},createTextureFromFloats:(e,i,r,o)=>{let s=null;if(null==o){const o=new Uint8Array(r.length);let l;for(let e=0;e<r.length;e++)l=255*r[e],o[e]=l;return s=new DataTexture(o,e,i,RGBAFormat),s.minFilter=LinearFilter,s.magFilter=LinearFilter,s.needsUpdate=!0,s}return s=o,s}},A=function(e){let t;switch(e){case"linear":t="float tween( float k ) { return k; }";break;case"inQuad":t="float tween( float k ) { return k * k; }";break;case"outQuad":t="float tween( float k ) { return k * ( 2.0 - k ); }";break;case"inOutQuad":t="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0 ) return 0.5 * k * k;\n            return - 0.5 * ( --k * ( k - 2.0 ) - 1.0 ); \n        }";break;case"inCubic":t="float tween( float k ) { return k * k * k; }";break;case"outCubic":t="float tween( float k ) { return --k * k * k + 1.0; }";break;case"inOutCubic":t="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0 ) return 0.5 * k * k * k;\n\t\t\treturn 0.5 * ( ( k -= 2.0 ) * k * k + 2.0 ); \n        }";break;case"inQuart":t="float tween( float k ) { return k * k * k * k; }";break;case"outQuart":t="float tween( float k ) { return 1.0 - ( --k * k * k * k ); }";break;case"inOutQuart":t="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0) return 0.5 * k * k * k * k;\n\t\t\treturn - 0.5 * ( ( k -= 2.0 ) * k * k * k - 2.0 ); \n        }";break;case"inQuint":t="float tween( float k ) { return k * k * k * k * k; }";break;case"outQuint":t="float tween( float k ) { return --k * k * k * k * k + 1.0; }";break;case"inOutQuint":t="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0 ) return 0.5 * k * k * k * k * k;\n\t\t\treturn 0.5 * ( ( k -= 2.0 ) * k * k * k * k + 2.0 );\n        }";break;case"inSine":t="#define PI_90 1.570796326794896\n        float tween( float k ) { float j = k * PI_90; return 1.0 - cos( j ); }";break;case"outSine":t="#define PI_90 1.570796326794896\n\t\tfloat tween( float k ) { float j = k * PI_90; return sin( j ); }";break;case"inOutSine":t="#define M_PI 3.14159265358979323846\n\t\tfloat tween( float k ) { \n\t\t\tfloat j = k * M_PI; return 0.5 * (1.0-cos(j));\n        }";break;case"inExpo":t="float tween( float k ) { return k == 0.0 ? 0.0 : pow( 1024.0, k - 1.0 ); }";break;case"outExpo":t="float tween( float k ) { return k == 1.0 ? 1.0 : 1.0 - pow( 2.0, - 10.0 * k ); }";break;case"inOutExpo":t="float tween( float k ) { \n\t\t\tif ( k == 0.0 ) return 0.0;\n\t\t    if ( k == 1.0 ) return 1.0;\n\t\t    if ( ( k *= 2.0 ) < 1.0 ) return 0.5 * pow( 1024.0, k - 1.0 );\n\t\t    return 0.5 * ( - pow( 2.0, - 10.0 * ( k - 1.0 ) ) + 2.0 );\n        }";break;case"inCirc":t="float tween( float k ) { return 1.0 - sqrt( 1.0 - k * k ); }";break;case"outCirc":t="float tween( float k ) { return sqrt( 1.0 - ( --k * k ) ); }";break;case"inOutCirc":t="float tween( float k ) { \n\t\t\tif ( ( k *= 2.0 ) < 1.0) return - 0.5 * ( sqrt( 1.0 - k * k ) - 1.0 );\n\t\t\treturn 0.5 * ( sqrt( 1.0 - ( k -= 2.0 ) * k ) + 1.0 ); \n        }";break;case"inElastic":t="#define TWO_PI 6.28318530717958647692\n        float tween(float k) {\n\t\t    float s;\n\t\t    float a = 0.1;\n\t\t    float p = 0.4;\n\t\t    if ( k == 0.0 ) return 0.0;\n\t\t    if ( k == 1.0 ) return 1.0;\n\t\t    if ( a < 1.0 ) { a = 1.0; s = p * 0.25; }\n\t\t    else s = p * asin( 1.0 / a ) / TWO_PI;\n\t\t    return - ( a * pow( 2.0, 10.0 * ( k -= 1.0 ) ) * sin( ( k - s ) * TWO_PI / p ) );\n\t\t}";break;case"outElastic":t="#define TWO_PI 6.28318530717958647692\n\t\tfloat tween(float k) {\n\t\t    float s;\n\t\t    float a = 0.1; \n\t\t    float p = 0.4;\n\t\t    if ( k == 0.0 ) return 0.0;\n\t\t    if ( k == 1.0 ) return 1.0;\n\t\t    if ( a < 1.0 ) { a = 1.0; s = p * 0.25; }\n\t\t    else s = p * asin( 1.0 / a ) / TWO_PI;\n\t\t    return ( a * pow( 2.0, - 10.0 * k) * sin( ( k - s ) * TWO_PI / p ) + 1.0 );\n\t\t}";break;case"inOutElastic":t="#define TWO_PI 6.28318530717958647692\n\t\tfloat tween(float k) {\n\t\t    float s;\n\t\t    float a = 0.1;\n\t\t    float p = 0.4;\n\t\t    if ( k == 0.0 ) return 0.0;\n\t\t    if ( k == 1.0 ) return 1.0;\n\t\t    if ( a < 1.0 ) { a = 1.0; s = p * 0.25; }\n\t\t    else s = p * asin( 1.0 / a ) / TWO_PI;\n\t\t    if ( ( k *= 2.0 ) < 1.0 ) return - 0.5 * ( a * pow( 2.0, 10.0 * ( k -= 1.0 ) ) * sin( ( k - s ) * TWO_PI / p ) );\n\t\t    return a * pow( 2.0, -10.0 * ( k -= 1.0 ) ) * sin( ( k - s ) * TWO_PI / p ) * 0.5 + 1.0;\n\t\t}";break;case"inBack":t="float tween(float k) {\n\t\t    float s = 1.70158;\n\t\t    return k * k * ( ( s + 1.0 ) * k - s );\n\t\t}";break;case"outBack":t="float tween(float k) {\n\t\t    float s = 1.70158;\n\t\t    return --k * k * ( ( s + 1.0 ) * k + s ) + 1.0;\n\t\t}";break;case"inOutBack":t="float tween(float k) {\n\t\t    float s = 1.70158 * 1.525;\n\t\t    if ( ( k *= 2.0 ) < 1.0 ) return 0.5 * ( k * k * ( ( s + 1.0 ) * k - s ) );\n\t\t    return 0.5 * ( ( k -= 2.0 ) * k * ( ( s + 1.0 ) * k + s ) + 2.0 );\n\t\t}";break;case"inBounce":t="float outBounce(float k) {\n\t\t    if ( k < ( 1.0 / 2.75 ) ) return 7.5625 * k * k;\n\t\t    else if ( k < ( 2.0 / 2.75 ) ) return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\n\t\t    else if ( k < ( 2.5 / 2.75 ) ) return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\n\t\t    else return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\n\t\t}\n\t\tfloat tween(float k) { return 1.0 - outBounce( 1.0 - k ); }";break;case"outBounce":t="float tween(float k) {\n\t\t    if ( k < ( 1.0 / 2.75 ) ) return 7.5625 * k * k;\n\t\t    else if ( k < ( 2.0 / 2.75 ) ) return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\n\t\t    else if ( k < ( 2.5 / 2.75 ) ) return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\n\t\t    else return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\n\t\t}";break;case"inOutBounce":t="float outBounce(float k) {\n\t\t    if ( k < ( 1.0 / 2.75 ) ) return 7.5625 * k * k;\n\t\t    else if ( k < ( 2.0 / 2.75 ) ) return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\n\t\t    else if ( k < ( 2.5 / 2.75 ) ) return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\n\t\t    else return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\n\t\t}\n\t\tfloat inBounce(float k) { return 1.0 - outBounce( 1.0 - k ); }\n\t\tfloat tween(float k) {\n\t\t    if ( k < 0.5 ) return inBounce( k * 2.0 ) * 0.5;\n\t\t    return outBounce( k * 2.0 - 1.0 ) * 0.5 + 0.5;\n\t\t}";}return t},M=[[-.5,-.5],[.5,-.5],[.5,.5],[-.5,.5]],E=new Float32Array(28);class z extends Points{constructor(e,t){super(),this.pe=e,this.count=0,this.color=null,this.texture=null,this.localTime=0,this.time=0,this.endTime=-1,this.num=0,this.matrixAutoUpdate=!1,this.frustumCulled=!1,this.receiveShadow=!1,this.castShadow=!1,this.birthIndex=0,this.luma=!0,t&&this.setParameters(t);}setParameters(e){this.validateParameters(e),this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose(),this.name=e.name,this.isTrail=e.trail||!1,this.parameters=e;const t=this.isTrail?e.maxParticles:e.numParticles;this.allocateParticles_(t,e),this.isTrail||this.createParticles_(0,t,e),e.parent?e.parent.add(this):this.pe.scene.add(this);}makeGeometry(e){this.geometry=e.oriented?new InstancedBufferGeometry:new BufferGeometry,this.isMesh=e.oriented;}setColorRamp(e){const t=e.length/4;if(t%1!=0)throw "colorRamp must have multiple of 4 entries";this.color=C.createTextureFromFloats(t,1,e);}validateParameters(e){var t=new L;for(let n in e)if(void 0===t[n])throw 'unknown particle parameter "'+n+'"';for(let n in t)void 0===e[n]&&(e[n]=t[n]);}perParticle(e,t){}birthParticles(e,t){var n=this.parameters.numParticles;this.parameters.pposition=e,this.parameters.startTime=this.time,this.endTime=this.time+this.parameters.lifeTime,t&&this.setColorRamp(t),this.createParticles_(this.birthIndex,n,this.parameters),this.birthIndex+=n,this.birthIndex+n>=this.parameters.maxParticles&&(this.birthIndex=0);}createParticles_(e,t,n){const a=C.plusMinus,i=C.plusMinusVector,r=this.interleavedBuffer.array;let o,h=t;for(;h--;){this.perParticle(h,n);let u,p=n.lifeTime+a(n.lifeTimeRange),f=null===n.startTime?h*n.lifeTime/t:n.startTime,g=n.frameStart+a(n.frameStartRange),m=(new Vector3).addVectors((new Vector3).fromArray(n.pposition),(new Vector3).fromArray(i(n.positionRange))),b=(new Vector3).addVectors((new Vector3).fromArray(n.velocity),(new Vector3).fromArray(i(n.velocityRange))),k=(new Vector3).addVectors((new Vector3).fromArray(n.acceleration),(new Vector3).fromArray(i(n.accelerationRange))),v=(new Vector4).addVectors((new Vector4).fromArray(n.colorMult),(new Vector4).fromArray(i(n.colorMultRange))),y=n.spinStart+a(n.spinStartRange),x=n.spinSpeed+a(n.spinSpeedRange),w=n.startSize+a(n.sizeRange||n.startSizeRange),S=n.endSize+a(n.sizeRange||n.endSizeRange),T=(new Vector4).fromArray(n.orientation),L=n.positionRange[0]+n.positionRange[1]+n.positionRange[2]===0;if(n.radius){let e=C.rand(0,2*Math.PI);n.tmpRotation=[90,-e*C.todeg,90,"YXZ"];let t=n.radius+a(n.radiusRange),i=new Vector3(Math.cos(e),0,Math.sin(e)).multiplyScalar(t);L&&(m=i),m.length(),u=k.y,k.multiply(i),k.y=u,u=b.y,b.multiply(i);}n.tmpRotation&&(T=(new Quaternion).setFromEuler(new Euler(n.tmpRotation[0]*C.torad,n.tmpRotation[1]*C.torad,n.tmpRotation[2]*C.torad,n.tmpRotation[3])));o=0+28*h*4+28*e*4,r[0+o]=m.x,r[0+o+1]=m.y,r[0+o+2]=m.z,r[0+o+3]=f,r[4+o]=M[0][0],r[4+o+1]=M[0][1],r[4+o+2]=p,r[4+o+3]=g,r[8+o]=b.x,r[8+o+1]=b.y,r[8+o+2]=b.z,r[8+o+3]=w,r[12+o]=k.x,r[12+o+1]=k.y,r[12+o+2]=k.z,r[12+o+3]=S,r[16+o]=y,r[16+o+1]=x,r[16+o+2]=0,r[16+o+3]=0,r[20+o]=T.x,r[20+o+1]=T.y,r[20+o+2]=T.z,r[20+o+3]=T.w,r[24+o]=v.x,r[24+o+1]=v.y,r[24+o+2]=v.z,r[24+o+3]=v.w;}this.interleavedBuffer.needsUpdate=!0,this.material.uniforms.worldVelocity.value.fromArray(n.worldVelocity),this.material.uniforms.gravity.value.fromArray(n.gravity),this.material.uniforms.timeRange.value=n.timeRange,this.material.uniforms.frameDuration.value=n.frameDuration,this.material.uniforms.numFrames.value=n.numFrames,this.material.uniforms.rampSampler.value=this.color,this.material.uniforms.colorSampler.value=this.texture,this.material.blending="normal"===n.blending?NormalBlending:AdditiveBlending,this.updateMatrix();}allocateParticles_(e,t){if(this.count!==e){if(t.oriented||(t.oriented=!1),t.position&&this.position.fromArray(t.position),t.rotation&&this.quaternion.setFromEuler(new Euler(t.rotation[0]*C.torad,t.rotation[1]*C.torad,t.rotation[2]*C.torad)),this.setColorRamp(t.colors),this.texture=this.pe.textures.make(t.type),this.endTime=t.endTime||-1,this.luma=t.luma,this.makeGeometry(t),this.count=e,t.oriented){var n=new InterleavedBuffer(new Float32Array([0,0,0,0,-.5,-.5,0,0,0,0,0,0,.5,-.5,0,0,0,0,0,0,.5,.5,0,0,0,0,0,0,-.5,.5,0,0]),8);this.geometry.setAttribute("position",new InterleavedBufferAttribute(n,3,0)),this.geometry.setAttribute("uv",new InterleavedBufferAttribute(n,2,4)),this.geometry.setIndex(new BufferAttribute(new Uint16Array([0,1,2,0,2,3]),1)),this.interleavedBuffer=new InstancedInterleavedBuffer(new Float32Array(e*E.byteLength),28,1).setUsage(DynamicDrawUsage);}else this.interleavedBuffer=new InterleavedBuffer(new Float32Array(e*E.byteLength),28).setUsage(DynamicDrawUsage);this.geometry.setAttribute("position",new InterleavedBufferAttribute(this.interleavedBuffer,3,0)),this.geometry.setAttribute("startTime",new InterleavedBufferAttribute(this.interleavedBuffer,1,3)),this.geometry.setAttribute("uvLifeTimeFrameStart",new InterleavedBufferAttribute(this.interleavedBuffer,4,4)),this.geometry.setAttribute("velocityStartSize",new InterleavedBufferAttribute(this.interleavedBuffer,4,8)),this.geometry.setAttribute("accelerationEndSize",new InterleavedBufferAttribute(this.interleavedBuffer,4,12)),this.geometry.setAttribute("spinStartSpinSpeed",new InterleavedBufferAttribute(this.interleavedBuffer,4,16)),this.geometry.setAttribute("orientation",new InterleavedBufferAttribute(this.interleavedBuffer,4,20)),this.geometry.setAttribute("colorMult",new InterleavedBufferAttribute(this.interleavedBuffer,4,24)),this.geometry.boundingSphere=new Sphere,this.geometry.boundingSphere.radius=3;let i=AdditiveBlending;switch(t.blending){case"sub":case"subtractive":i=SubtractiveBlending;break;case"multi":case"multiply":i=MultiplyBlending;break;case"normal":i=NormalBlending;break;default:i=AdditiveBlending;}var a={worldVelocity:{value:new Vector3},gravity:{value:new Vector3},timeRange:{value:0},time:{value:0},timeOffset:{value:0},frameDuration:{value:0},numFrames:{value:0},rampSampler:{value:null},colorSampler:{value:null},scale:{value:.5*window.innerHeight},luma:{value:this.luma?this.pe.luminosity:1},alphaTest:{value:t.alphaTest}};this.material=new ShaderMaterial({defines:{USE_ORIENTATION:t.oriented},uniforms:a,vertexShader:(this.pe.isGl2?"":"\nmat4 inverse(mat4 m) {\n\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3], a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3], a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3], a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n    b00 = a00 * a11 - a01 * a10,\n    b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,\n    b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,\n    b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,\n    b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,\n    b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,\n    b11 = a22 * a33 - a23 * a32,\n\n  det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4( a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03, a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07, a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06, a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00, a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n")+A(t.tween||"linear")+"\nprecision mediump float;\nprecision mediump int;\n\n#ifdef USE_ORIENTATION\n\t//uniform mat4 worldViewProjection;\n\t//uniform mat4 world;\n\tattribute vec3 offset;\n\tattribute vec4 orientation;\n#else\n    uniform float scale;\n#endif\n\nuniform vec3 worldVelocity;\nuniform vec3 gravity;\nuniform float timeRange;\nuniform float time;\nuniform float timeOffset;\nuniform float frameDuration;\nuniform float numFrames;\n\nattribute vec4 uvLifeTimeFrameStart;\nattribute float startTime;\nattribute vec4 velocityStartSize;\nattribute vec4 accelerationEndSize;\nattribute vec4 spinStartSpinSpeed;\nattribute vec4 colorMult;\n\nvarying vec2 outputTexcoord;\nvarying float outputPercentLife;\nvarying vec4 outputColorMult;\nvarying mat2 rotationMtx;\n\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n//#include <clipping_planes_pars_vertex>\n\nvec3 lerp( vec3 a, vec3 b, float p ){ return a + (b - a) * p; }\n\nvoid main() \n{\n    float lifeTime = uvLifeTimeFrameStart.z;\n    float frameStart = uvLifeTimeFrameStart.w;\n    float startSize = velocityStartSize.w;\n\n    //vec3 velocity = (modelMatrix * vec4(velocityStartSize.xyz, 0.0)).xyz + worldVelocity;\n\t//vec3 acceleration = (modelMatrix * vec4(accelerationEndSize.xyz, 0.0)).xyz + gravity;\n\n    //vec3 velocity = velocityStartSize.xyz + worldVelocity;\n\t//vec3 acceleration = accelerationEndSize.xyz + gravity;\n\n\tvec3 velocity = velocityStartSize.xyz + (inverse(modelMatrix) * vec4(worldVelocity, 0.0)).xyz;\n\tvec3 acceleration = accelerationEndSize.xyz + (inverse(modelMatrix) * vec4(gravity, 0.0)).xyz;\n\n    float endSize = accelerationEndSize.w;\n    float spinStart = spinStartSpinSpeed.x;\n    float spinSpeed = spinStartSpinSpeed.y;\n\n    float localTime = mod((time - timeOffset - startTime), timeRange);\n    //localTime = tween( localTime );\n    float percentLife = localTime / lifeTime;\n    percentLife = tween( percentLife );\n\n    vec3 posEnd = velocity * lifeTime + acceleration * lifeTime * lifeTime;\n\n    float frame = mod(floor(localTime / frameDuration + frameStart), numFrames);\n    float uOffset = frame / numFrames;\n    float u = uOffset + (uv.x + 0.5) * (1. / numFrames);\n\n    outputTexcoord = vec2(u, uv.y + 0.5);\n    outputColorMult = colorMult;\n\n    float size = mix(startSize, endSize, percentLife);\n\tsize = (percentLife < 0. || percentLife > 1.0) ? 0.0 : size;\n\n\tfloat s = sin(spinStart + spinSpeed * localTime);\n\tfloat c = cos(spinStart + spinSpeed * localTime);\n\n    #ifdef USE_ORIENTATION\n\t\t\n\t\tvec4 rotatedPoint = vec4((uv.x * c + uv.y * s) * size, 0., (uv.x * s - uv.y * c) * size, 1.);\n\t\t//vec3 center = velocity * localTime + acceleration * localTime * localTime + position + offset;\n\t\tvec3 center = (posEnd * percentLife) + position + offset;\n\n\t\tvec4 q2 = orientation + orientation;\n\t\tvec4 qx = orientation.xxxw * q2.xyzx;\n\t\tvec4 qy = orientation.xyyw * q2.xyzy;\n\t\tvec4 qz = orientation.xxzw * q2.xxzz;\n\n\t\tmat4 localMatrix = mat4(\n\t\t    (1.0 - qy.y) - qz.z,  qx.y + qz.w,  qx.z - qy.w, 0,\n\t\t    qx.y - qz.w, (1.0 - qx.x) - qz.z, qy.z + qx.w, 0,\n\t\t    qx.z + qy.w, qy.z - qx.w, (1.0 - qx.x) - qy.y, 0,\n\t\t    center.x, center.y, center.z, 1\n\t\t);\n\t\trotatedPoint = localMatrix * rotatedPoint;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * rotatedPoint;\n\n\t#else\n\n\t    //vec3 pos = position + velocity * localTime + acceleration * localTime * localTime;\n\n\t    vec3 pos = (posEnd * percentLife) + position;\n\t    \n\t    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n        //gl_PointSize = size * 1.5 * ( scale / length( mvPosition.xyz ) );\n        gl_PointSize = size * 1.5 * ( scale / - mvPosition.z );\n\n        mat2 r = mat2( c, -s, s, c);\n        r *= 0.5; r += 0.5;  r = r * 2.0 - 1.0;\n        rotationMtx = r;\n\n        gl_Position = projectionMatrix * mvPosition;\n\n\t#endif\n\n\toutputPercentLife = percentLife;\n\n\t#include <logdepthbuf_vertex>\n\t//#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",fragmentShader:"\nprecision mediump float;\nprecision mediump int;\n\nuniform sampler2D rampSampler;\nuniform sampler2D colorSampler;\nuniform float luma;\nuniform float alphaTest;\n\nvarying vec2 outputTexcoord;\nvarying float outputPercentLife;\nvarying vec4 outputColorMult;\nvarying mat2 rotationMtx;\n\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n//#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t//#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\n\tvec4 diffuseColor = texture2D( rampSampler, vec2(outputPercentLife, 0.5) ) * outputColorMult;\n\n    vec2 uv = vec2(0.0);\n    #ifdef USE_ORIENTATION\n        uv = outputTexcoord;\n\t#else\n\t    uv = gl_PointCoord;\n\t    uv -= 0.5; uv = uv * rotationMtx; uv += 0.5;\n\t#endif\n\n\t// texture\n\tdiffuseColor *= texture2D( colorSampler, uv );\n\n\tif ( diffuseColor.a < alphaTest ) discard;\n\n\tdiffuseColor.rgb *= luma;\n\n\tgl_FragColor = diffuseColor; \n\t#include <fog_fragment>\n\n}\n",side:t.oriented?DoubleSide:FrontSide,blending:i,depthTest:!0,depthWrite:t.depthWrite,transparent:t.transparent}),this.renderOrder=t.renderOrder||0;}}draw(e=0){if(!this.material.uniforms)return;const t=this.material.uniforms;this.time+=this.pe.delta,t.time.value=this.time,t.timeOffset.value=e,t.scale.value=this.pe.hscale,t.luma.value=this.luma?this.pe.luminosity:1,-1!==this.endTime&&this.time>=this.endTime&&this.pe.remove(this.name);}dispose(){this.parent.remove(this),this.geometry.dispose(),this.material.dispose(),this.color.dispose();}raycast(){}clone(e){return void 0===e&&(e=this.pe.createEmitter(this.texture)),e.time=0,e.endTime=this.endTime,e.geometry=this.geometry,e.material=this.material.clone(),e.material.uniforms.rampSampler.value=this.color,e.material.uniforms.colorSampler.value=this.texture,super.copy(e),this.num++,e.name=this.name+this.num,e}}class F extends Map{constructor(){super();}dispose(){this.forEach((e=>{e.dispose();})),this.clear();}make(e){if(!this.has(e)){let t=this["make"+e[0].toUpperCase()+e.substring(1)]();this.set(e,t);}return this.get(e)}makePixel(){const e=[];for(let t=0;t<2;++t)for(let t=0;t<2;++t)e.push(1,1,1,1);return C.createTextureFromFloats(2,2,e)}makeBasic(){const e=[0,.2,.7,1,.7,.2,0,0],t=[];for(let n=0;n<8;++n)for(let a=0;a<8;++a){let i=e[a]*e[n];t.push(i,i,i,1);}return C.createTextureFromFloats(8,8,t)}makeCube(){let e=document.createElement("canvas");e.width=e.height=8;const t=e.getContext("2d");return t.fillStyle="rgba(255,255,255,1.0)",t.fillRect(2,2,4,4),C.toTexture(e)}makeCloud(){let e=16,t=document.createElement("canvas");t.width=t.height=e;const n=t.getContext("2d");let a="rgba(255,255,255,1)",i="rgba(255,255,255,0)",r=n.createRadialGradient(8,6.4,0,8,6.4,6.4);return r.addColorStop(.3,a),r.addColorStop(1,i),n.fillStyle=r,n.fillRect(0,0,e,e),r=n.createRadialGradient(6.4,9.92,0,6.4,9.92,5.6),r.addColorStop(.3,a),r.addColorStop(1,i),n.fillStyle=r,n.fillRect(0,0,e,e),r=n.createRadialGradient(4.32,6.4,0,4.32,6.4,4.16),r.addColorStop(.2,a),r.addColorStop(1,i),n.fillStyle=r,n.fillRect(0,0,e,e),r=n.createRadialGradient(12.16,9.6,0,12.16,9.6,3.68),r.addColorStop(.2,a),r.addColorStop(1,i),n.fillStyle=r,n.fillRect(0,0,e,e),C.toTexture(t)}makeRound(){let e=16,t=document.createElement("canvas");t.width=t.height=e;const n=t.getContext("2d"),a=n.createRadialGradient(8,8,0,8,8,8);return a.addColorStop(0,"rgba(255,255,255,1)"),a.addColorStop(.3,"rgba(255,255,255,0.1)"),a.addColorStop(.9,"rgba(255,255,255,0)"),a.addColorStop(1,"rgba(255,255,255,0)"),n.fillStyle=a,n.fillRect(0,0,e,e),C.toTexture(t)}makeRound2(){let e=16,t=document.createElement("canvas");t.width=t.height=e;const n=t.getContext("2d"),a=n.createRadialGradient(8,8,0,8,8,8);return a.addColorStop(0,"rgba(255,255,255,1)"),a.addColorStop(.9,"rgba(255,255,255,1)"),a.addColorStop(1,"rgba(255,255,255,0)"),n.fillStyle=a,n.fillRect(0,0,e,e),C.toTexture(t)}makeDonut(){let e=32,t=document.createElement("canvas");t.width=t.height=e;const n=t.getContext("2d"),a=n.createRadialGradient(16,16,0,16,16,16);return a.addColorStop(0,"rgba(255,255,255,1)"),a.addColorStop(.9,"rgba(255,255,255,0.1)"),a.addColorStop(1,"rgba(255,255,255,0)"),n.fillStyle=a,n.beginPath(),n.arc(16,16,16,0,2*Math.PI,!1),n.arc(16,16,8,0,2*Math.PI,!0),n.fill(),C.toTexture(t)}makeBubble(){let e=64,t=document.createElement("canvas");t.width=t.height=e;let n="rgba(0,255,255,0)";const a=t.getContext("2d"),i=a.createRadialGradient(25.6,25.6,0,32,32,32);return i.addColorStop(.4,n),i.addColorStop(.9,"rgba(0,255,255,0.6)"),i.addColorStop(.99,"rgba(0,255,255,1)"),i.addColorStop(1,n),a.fillStyle=i,a.fillRect(0,0,e,e),a.fillStyle="rgba(255,255,255,1)",a.beginPath(),a.arc(44.8,25.6,8.96,0,2*Math.PI,!1),a.fill(),a.beginPath(),a.arc(12.8,41.6,3.2,0,2*Math.PI,!1),a.fill(),C.toTexture(t)}makeSmoke(){let e=document.createElement("canvas");e.width=e.height=64;const t=e.getContext("2d");let n=new Image;n.src=P;let a=C.toTexture(e);return n.onload=function(){t.drawImage(n,0,0),a.needsUpdate=!0;},a}makeCircle(){let e=document.createElement("canvas");e.width=e.height=64;const t=e.getContext("2d");return t.strokeStyle="white",t.lineWidth=4,t.beginPath(),t.arc(32,32,30,0,2*Math.PI),t.stroke(),C.toTexture(e)}makeField(){let e=64,t=document.createElement("canvas");t.width=t.height=e;const n=t.getContext("2d"),a=n.createLinearGradient(0,0,0,e);return a.addColorStop(0,"rgba(255,255,255,0)"),a.addColorStop(.8,"rgba(255,255,255,0.4)"),a.addColorStop(1,"rgba(255,255,255,0)"),n.fillStyle=a,n.fillRect(24,0,16,e),C.toTexture(t)}makeStar(){let e=64,t=document.createElement("canvas");t.width=t.height=e;const n=t.getContext("2d"),a=n.createRadialGradient(32,32,0,32,32,32);return a.addColorStop(0,"rgba(255,255,255,0.5)"),a.addColorStop(.5,"rgba(255,255,255,0.1)"),a.addColorStop(.9,"rgba(255,255,255,0)"),n.fillStyle=a,this.star(n,32,6.4,32,32,3),this.star(n,32,25.6,32,32,3),C.toTexture(t)}makeOcto(){let e=64,t=document.createElement("canvas");t.width=t.height=e;const n=t.getContext("2d"),a=n.createRadialGradient(32,32,0,32,32,32);return a.addColorStop(.4,"rgba(255,255,255,0.2)"),a.addColorStop(1,"rgba(255,255,255,0.4)"),n.fillStyle=a,this.star(n,25.6,22.4,32,32,6),n.strokeStyle="rgba(255,255,255,0.1)",n.lineWidth=6,n.stroke(),C.toTexture(t)}star(e,t,n,a,i,r){let o,s,l;e.beginPath(),e.moveTo(a+t,i);for(var c=1;c<=2*r;c++)c%2==0?(l=c*(2*Math.PI)/(2*r),o=a+t*Math.cos(l),s=i+t*Math.sin(l)):(l=c*(2*Math.PI)/(2*r),o=a+n*Math.cos(l),s=i+n*Math.sin(l)),e.lineTo(o,s);e.closePath(),e.fill();}}const P="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAPOklEQVR42rWb224dRRaGq\n7r30Tu2Y5MhmYsZRZqbeahBiCvgPnCBOCeAEEjcI/E2vAfiYqJJgIHE2/Y+Vk2tzf9Ji2XZDsmkpeXu3V1dXf9f61Sr2316wa3Wmj/++GO\nTrkkvSTo3aDKUdB999JHJoMlEYud72tk13ce53kmmX5PWNr///vvpgw8+yPfv30+llPzee+917Xd68ODBM4+/f1HwbYd04XhgouNqx3re0\nF3rc85DtUntmK6zk7G11XHh0fZns9nk1WqVjYR23J2ennZtn7788sv6UgkA/Hq97mzwbevbbwMzEMBJGPj290HnDrC2qe3IzrV7N2oXSR2\nZ2PN4dNbW972JjSOfnJx0o9EoDwaD+sUXX7w8Ah4+fJgbw7nWCphRztnkDzMr0Wwx8ISWVNvTXrNv14xI7u+4LmLpE82xbcd+A50nk0kdj\n8fJCHnzzTfTN998U18KAW+88UY+OjoypjsNdtTGMLQJYXYBDUjTjqC+nYD1XtVbu7Ht23lIsfPW936TiZ0HOP3YRLTNNKG2LW2aVp6dnqZ\n/vfZa/fbbb//vBJiDMcbtgTv71aDs2IMvkl4AbKDJ9tZW94w0k0nmcsOO7bp+j0TErO1nOgeRmIqZQ3UkNlOYp58eP0qL5bJ+99139YUJ+\nP77702l8ttvv51ff/31bjab5f39/a7h3wFv7GP7nfMPqC8qW5htAd8ToKTr+9pXAZ+atH72pCkFMtVmg48Ag55Rt9tt3pRSbx4epPv3H+T\nPP/+8mrP89NNPn48AA95sKw+Hw7xcLvPh4WG3t7eXmhb0+AER4L3/UOKdYFbbPQOs6xknh1MUMfQ71bkiDaO/KvFRZrsD1Hf1xmy2PTy8m\nc0pWli07cMPP4SEP0fAu+++m9ssAz5Pp1MzAXuone+c+mcAAEr9V+0xh5ns3druOe0ZVbv++zERoUdbpOreufZ6Bu1LbVsjoLTxFXtuKaV\nmF1v/NAE//PCDObtk4J8+fZru3LnTNfXPTc0MuBExMBNgxph5+YbeacN0Z+8pT2qqaIYBu6H7JtYmy/tLcJY7LfBaBpkci6zN76aSa3DC6\nbkJuHfvns18Oj8/z/P5PN29e7c3AizWNsmEJ0DrgcwMmnBDx5yHgJGAkzNwL2qfaEN/zvvzLHwBJlDYk1hJc5KN+Zl9wOPHj/Nbb72VF4t\nFMqfSJN26das7Pj7uBDzLAe5mzhwbaqvBzQAmQBBVNPO3mhziH3R96tp2uncm4N6nmPbZPWvA4hjdcRZwSLDUOX3yySfPRsBXX31l6tKSi\n3GaTmfN9g924Jsz9NmeATcbTnr4K03+0eS2AwEJaEMS+L/p2mmTousHTY5s77z/EBIEHFNgNrdEADcBbBXnye9nIoDts88+a1502Lz/yLx\n+3zIt4rl1aLO/51TxZpN/Nvm7wJ+LfYvtM9vL8++3xsf2WwNeYCYCuqd8YExYM6J1viOlJqSi8oRT38Y0BALIqdCCawkwtd85+G4X5bu+R\nX2lqR2q6LzrRMDvaqbO9PChG3wvMzlq+4NUKzNETnCg/ZA0mO51Du1Z2vBEAODxA7TBNOgju8VWtRUlJFxKQGtkM52hAG+q2TQQE2K+4vq\nrTf5CMqP9mFlxWeG+zW7F4THrzjG6sBjziixwC5PWbi3wtIWMVZOiBZT1h6ZU7a8mwICLva4dDGgjsH9tcstASI2P5KTMBI6lytPWybQaM\nFskaXZqO6e21nfVnri+lmrPlBsAyGSsxVYncGcysRVpsPcBkmrgyTad06xXEQD4rIXHrB0NmzCbNpA7Lvk4tt8Cf2gDx4sbcFP1LIIEaso\nCiDiv2L0SiIna9HZeA06ocq311EzA5RhbgTtX25Eky/aL4WlixxtpzPZSAnTB1H/MzMrmqmb9WECxa0LdDQjQAAa0IaZr1WbgR5yzKZKNk\nvtjCpgb8R1Vt/b4lTFaAilyxGM0Aa2wRZj8BqZxrQbsCViV0Pmr2ncCfSwSpiQ72DGgdT+eewx4BxBCmHnsH8FubdYP3RpiWWs9MVDSwCM\nIwDnqEUVttiKhxHDYB/CEExzPvpzbEbMPYInXhJ4Bh7oAMvAAQ2aIWbB1FD1Ybvt1hsBh0zM3tuzMp9CuyVIkFJMLBAC+2kSlDAl7YvUVN\n8PTkOWh5iP6Ql19Dc9XiaKHD+cK99LepcUrSYdPCmk096+UYJ0T1Ru+FVHjAgEsFSlJ5STV1AMkexJ+Q8bEgc8BTGJgYZZzJILjIPSJhi7\nl+akTohFDgV4TCgV+ASHyE7oeCCilsKQdNfDYsLdjzmGnFD1nzM4ldT7AebBe2OL5DgE7lR9MwfVXQypcHQlryZmZAATJB3Bf2tXbvXfFk\nzuwPmxBCFrRexAcR3XHriPweG/Yxy0z44B3oFJIhM4VwRYco/4mfyCg5ceoPwMO+zBoPDkq6BxbsN84o33s6wrANYIPYwF8hQyBXDkS5k1\nOjASIwkmTDnsC6DiWtHyUsGMywL1QAq9h9qNtR9WOYCIZRJN4Lap4If/HSZIuC/wTaQAEEA53aYiREDVggODdA7CZZXgu6ekYBGEngI4zG\nDeARo2IfiX5NNcdF8BpjwN8auC1xxkWHwW8BpD7Q0DvvHzPAJWCjmuq45zyGPWP6oq6M2gGGK6zlUsIyvE8M49msAc4CRAE1Fqf5Jznvk5\nwqQ/ggVRecTaAQTt8FMiJWj0DdKrvPLPi8JaiZvDg0TzYIhGAAwzgVxYeqf6wWML+2/kzTxraEwnABdgegIPg8SeszRvwvSb7So6IGBlwJ\ngK9Id3lAdFEop+4wkQAsXZkFmxeE7cR+FMtnObtvHOA9HExDCZMAEAhvFGYzJSuAE97rwXMmDAPfJv4yuwa71/DbBdWeZw3Mpg5A0rI08J\nnIQJ8kkQekDwBdnN0gjGx6STEf9oQCuNM9aFymzwBPO8a8EiJ4RIwqikMCH0ihcRpHULjBkyEQQiICYm30S4scGKGiCNMHrykwjj9egn91\n0tUv9qmWS/BZIonR9qw1OJnFRKgKnJKLIr0qgF4Aipg48tIVn+sA3CWGsAaH8IAQRM0KZKcaQRoSKgURoPTJLp4AjTjC6W+Oz8gItZMhpb\nHjgCpobSADVUfQgDnRcC+r+UxKzg8SQ5ZYQxxSNyKN4EMQHfORwQJx+da+xdMgCTIRw9INudv0sMGzpAECNaoBKtcFatBgMtBa6JfAVy0/\nwg67itLdaq6zt6XIc9Y6Fqv945FYZC2tKd/+7iiMhBIGJHrMzAqv8w8xRDqf0HVAZwlHPs4nJ2UeC2S4AlWZCHZWVzTZ5YJzBUeF/5ZBn4\n34FgOJw9A3GupiSovN0XGOFaBorML4FNMlIJEP1QFIprLhvhOe2npxNoqAXqiPs0kfm3X5+3KihenmL1JJCChyiEhwr4PAR8iBGSi/hFIu\nSZFjibC7EftoJK8dZ4dM4QYy/9/bccmv7XrLIm3XrtUbquxKlwbCdF2s3/1Hew8xvUcB891hOtIyPUJo7H/qBXYvG0DJT0PDbgRq7XATyy\nHCYUCbR0U8EJA1AJf0CgskTnHbwZ+hbevkflos5yL/dA+fB5nUlj+4tQE/D/SgCxCfpPtky1Gjaq75XD44tNXbgEQzSIukhJZWIjTyautB\nx8JiWbCfQKdEPry1R/z9E2eKuxx75oQKNL88hlJEADLvQMY1Tb7zC/k6RsHehVUGm3iOM58zBTZs3kNKgrLBXtX9Zd8vwJOoTApDK5jvRB\nt8olQVD1fDI3LYcBWsXzC93p6TcXD1hKWwcEfsOFf4nlAx3UGROeleXa3Cly68hd+jklZ+fsBHwngZFT5HgEYbXR8oj2VJexzKYJKzBdi3\nVHiNSQ60Q0AciYRspw/VcX5X/S8gZ4/17qAfs/1bsC/GYoEsF0sZjIb0aGFslTiCzBXmKiE05jxcR67DoAhwKktYZM3PQkT+K9kqDCdjBA\n5wY1ejvpMMPsPJXwqnAP4dEkeTgaI7fGd0MS9UCnGOKRAABJtPPgTzKtwLhCNZhnAx9qva7U6RZ3hH3SPOce5osJWDlFZoNOAK7Qggu/8C\nlBveW8oC6vKyLZ8RNUEMr3jZPMLGsBCRqWqJEDVacpCBc9fZX4qe9WO+3DoAv4katgFEwgLouioiMdJlTMADUO1J5KWib2Q6olgJgHgica\nBatY8YWu1/012fyo175y/8vn/mUUCCiWMg3+8cHlAICFUZtbrddJXoYWZ452/V2m7jr36d3GQo2tLvvKgYhPMASe6DuaysEovs45NKzWfE\nqIF/t9NfpYjJOwl7XdcXFgMeVOIBJydnSX77lY328CQWAcE4EbHzCzhaIEAIBQsmf1YzFyR4wsgaj4LobrIPB5ZUcSFQsBnbwYNF4uhK7T\nAenv0KLUvRJWKJr684CMEPl4sOL743Q7FCcJjfI3Fbw8Y4VU3ak07/JEnEfWXFLROmkl9IZVS7DtI+xTw0q/EsoGFiB9//DG1DyVT3/fVv\nSgZmWgg5Og4RpPs1G/DQH3CErw64NAA2s0hA63w4ZE+Q4EEKe5bwYrqG/jgBC9qgTeH27dvJ3VQmtqU4XDYt474jLWYkHqhjuTvfBjFmgF\nNCCqPFgAe/xBJAnwN959KqGgV/c5kmTjya78TjERgEsbccrWqv/z8c9o/OBjq32SSr7pCArNuh/xGRRXa8DPk9ZjAGWCYccwgRIu42oTA5\nN8UY4oQR0SxRMjVBNmuJ8Js5uuvv+7MFHwMj6s5acWaNl6FfbE01PgXCm9zpyVr7B+zCNEBcMUVY88k29A+VqbytRpwlXmEjxJZb7Px1ma\ntGUaVS9Zmx4EcoodpyRqtQGhLP8Gn4PBYB5yiBY6guNXnIgCTkJOsLv4jqOaaj5NM9LuSHOWUlyEk4jCLTMXab3B8OFIvgPR+QhKrwHGro\nSr8fFoAGd4HsF7Hthk49opG4OVjfZ/j0rZt2+y4DbSgVSEZox/fnzO9izMPcDAEAp6LDDSBZMMGvml+gvjrFzokS+uUk2lHVOfdrJO2bjY\n6NFEmJxIgwAvA/TMrYL2wQcALb1ETmDGfpDDzDPaSLLAivMtbrVZpcX6+y0G6JlnpbAAaS14cAzhsgYCXQAL7uK4v7C8T8gpy9fl8npeNh\nJZ71L7ryUYhwUsKx+T7L5WASAJSEUjBWfK7bQCOIGi/S1lLazadTtPBwUF955179r+A9g9QXq13MV2qXtvxM4Fn+x+D0fC1BkndygAAAAB\nJRU5ErkJggg==";class R{constructor(e,t){this.scene=e,this.isGl2=t.capabilities.isWebGL2,this.emitters=new Map,this.textures=new F,this.now=0,this.last=0,this.delta=0,this.num=0,this.hscale=.5*window.innerHeight,this.luminosity=1;}get(e){return this.emitters.has(e)?this.emitters.get(e):null}add(e,t){e.name||(e.name="PP"+this.num++),this.remove(e.name),e.model&&T[e.model]&&(e={...T[e.model],...e});let n=new z(this,e);return this.emitters.set(e.name,n),n}remove(e){this.emitters.has(e)&&(this.emitters.get(e).dispose(),this.emitters.delete(e));}onresize(e){this.hscale=.5*e;}update(e){this.now=void 0!==e?e:Date.now(),this.delta=.001*(this.now-this.last),this.last=this.now,this.emitters.forEach((e=>{e.draw();}));}dispose(){this.emitters.forEach((e=>{e.dispose();})),this.emitters.clear(),this.textures.dispose(),this.num=0;}addBlock(e,t){let n=e[1]<=4?-2:0,a=T.getColor(t),i=a[0],r=a[1],o=a[2];a.length>3&&(i=a[3],r=a[4],o=a[5]),e[0]+=.5,e[2]+=.5,this.add({position:e,colors:[i,r,o,1,i,r,o,0],renderOrder:n,...T.addBlock});}delBlock(e,t){let n=e[1]<=4?-2:0,a=T.getColor(t),i=a[0],r=a[1],o=a[2];e[0]+=.5,e[2]+=.5,e[1]+=.5;let s=30;a.length>3&&(s=20,this.add({position:[e[0],e[1]+.375,e[2]],positionRange:[.5,.25,.5],colors:[i,r,o,.5,i,r,o,0],numParticles:10,renderOrder:n,...T.removeBlock}),i=a[3],r=a[4],o=a[5]),this.add({position:e,positionRange:[.5,.5,.5],colors:[i,r,o,.5,i,r,o,0],numParticles:s,renderOrder:n,...T.removeBlock});}removePlayerTrail(e){this.remove("PlayerTrail_"+e);}onPlayerWalk(e,t,n){let a=this.get("PlayerTrail_"+t);null===a&&(a=this.addTrail({name:"PlayerTrail_"+t,...T.playerMove}));let i=e.toArray();i[1]+=.2;let r=T.getColor(n),o=[r[0],r[1],r[2],.75,r[0],r[1],r[2],0];r.length>3&&(o=[r[0],r[1],r[2],.75,r[3],r[4],r[5],0]),a.birthParticles(i,o);}onVehicleDrive(e,t){let n=this.get("VehicleTrail_"+t);null===n&&(n=this.addTrail({name:"VehicleTrail_"+t,...T.vehicleMove})),n.birthParticles(e.toArray());}onBazookaFire(e,t){let n=this.get("BazookaTrail_"+t);null===n&&(n=this.addTrail({name:"BazookaTrail_"+t,...T.bazookaFire})),n.birthParticles(e.toArray());}onExplosion(e){this.add({position:e.toArray(),...T.explosion});}}
/**
 * @license
 * Copyright 2010-2021 Uil.js Authors
 * SPDX-License-Identifier: MIT
 */const I={ui:[],dom:null,ID:null,lock:!1,wlock:!1,current:-1,needReZone:!0,needResize:!1,forceZone:!1,isEventsInit:!1,isLeave:!1,downTime:0,prevTime:0,prevDefault:["contextmenu"],pointerEvent:["pointerdown","pointermove","pointerup"],eventOut:["pointercancel","pointerout","pointerleave"],xmlserializer:null,tmpTime:null,tmpImage:null,oldCursor:"auto",input:null,parent:null,firstImput:!0,hiddenImput:null,hiddenSizer:null,hasFocus:!1,startInput:!1,inputRange:[0,0],cursorId:0,str:"",pos:0,startX:-1,moveX:-1,debugInput:!1,isLoop:!1,listens:[],e:{type:null,clientX:0,clientY:0,keyCode:NaN,key:null,delta:0},isMobile:!1,now:null,getTime:function(){return self.performance&&self.performance.now?self.performance.now.bind(performance):Date.now},add:function(e){I.ui.push(e),I.getZone(e),I.isEventsInit||I.initEvents();},testMobile:function(){let e=navigator.userAgent;return !!(e.match(/Android/i)||e.match(/webOS/i)||e.match(/iPhone/i)||e.match(/iPad/i)||e.match(/iPod/i)||e.match(/BlackBerry/i)||e.match(/Windows Phone/i))},remove:function(e){let t=I.ui.indexOf(e);-1!==t&&(I.removeListen(e),I.ui.splice(t,1)),0===I.ui.length&&I.removeEvents();},initEvents:function(){if(I.isEventsInit)return;let e=document.body;I.isMobile=I.testMobile(),I.now=I.getTime(),I.isMobile?e.style.touchAction="none":e.addEventListener("wheel",I,{passive:!1}),e.addEventListener("pointercancel",I),e.addEventListener("pointerleave",I),e.addEventListener("pointermove",I),e.addEventListener("pointerdown",I),e.addEventListener("pointerup",I),e.addEventListener("keydown",I,!1),e.addEventListener("keyup",I,!1),window.addEventListener("resize",I.resize,!1),I.isEventsInit=!0,I.dom=e;},removeEvents:function(){if(!I.isEventsInit)return;let e=document.body;I.isMobile||e.removeEventListener("wheel",I),e.removeEventListener("pointercancel",I),e.removeEventListener("pointerleave",I),e.removeEventListener("pointermove",I),e.removeEventListener("pointerdown",I),e.removeEventListener("pointerup",I),e.removeEventListener("keydown",I),e.removeEventListener("keyup",I),window.removeEventListener("resize",I.resize),I.isEventsInit=!1;},resize:function(){let e,t=I.ui.length;for(;t--;)e=I.ui[t],e.isGui&&!e.isCanvasOnly&&e.autoResize&&e.calc();I.needReZone=!0,I.needResize=!1;},out:function(){console.log("im am out"),I.clearOldID();},in:function(){console.log("im am in");},fakeUp:function(){this.handleEvent({type:"pointerup"});},handleEvent:function(e){-1!==I.prevDefault.indexOf(e.type)&&e.preventDefault(),I.needResize&&I.resize(),I.findZone(I.forceZone);let t=I.e,n=!1;"keydown"===e.type&&I.keydown(e),"keyup"===e.type&&I.keyup(e),"wheel"===e.type?t.delta=e.deltaY>0?1:-1:t.delta=0;let a=e.pointerType;if(t.clientX=("touch"===a?e.pageX:e.clientX)||0,t.clientY=("touch"===a?e.pageY:e.clientY)||0,t.type=e.type,-1!==I.eventOut.indexOf(e.type)&&(n=!0,t.type="mouseup"),"pointerleave"===e.type&&(I.isLeave=!0),"pointerdown"===e.type&&(t.type="mousedown"),"pointerup"===e.type&&(t.type="mouseup"),"pointermove"===e.type&&(I.isLeave&&(I.isLeave=!1,I.resize()),t.type="mousemove"),"mousedown"===t.type){if(I.downTime=I.now(),I.downTime-I.prevTime<200)return I.selectAll(),!1;I.prevTime=I.downTime,I.forceZone=!1;}"mousedown"===t.type&&I.clearInput(),"mousedown"===t.type&&(I.lock=!0),"mouseup"===t.type&&(I.lock=!1),I.isMobile&&"mousedown"===t.type&&I.findID(t),"mousemove"!==t.type||I.lock||I.findID(t),null!==I.ID&&(I.ID.isCanvasOnly&&(t.clientX=I.ID.mouse.x,t.clientY=I.ID.mouse.y),I.ID.handleEvent(t)),I.isMobile&&"mouseup"===t.type&&I.clearOldID(),n&&I.clearOldID();},findID:function(e){let t,n,a,i=I.ui.length,r=-1;for(;i--;)if(t=I.ui[i],t.isCanvasOnly?(n=t.mouse.x,a=t.mouse.y):(n=e.clientX,a=e.clientY),I.onZone(t,n,a)){r=i,r!==I.current&&(I.clearOldID(),I.current=r,I.ID=t);break}-1===r&&I.clearOldID();},clearOldID:function(){I.ID&&(I.current=-1,I.ID.reset(),I.ID=null,I.cursor());},calcUis:(e,t,n,a=!1)=>{let i,r,o,s=e.length,l=0,c=0,d=0;for(;s--;)i=e[c],c++,!a&&i.isGroup&&i.calcUis(),o=i.margin,i.zone.w=i.w,i.zone.h=i.h+o,i.autoWidth?(l=0,i.zone.x=t.x+i.dx,i.zone.y=n,n+=i.h+o,d+=i.h+o):(0===l&&(d+=i.h+o),i.zone.x=t.x+l,i.zone.y=n,r=I.getWidth(i),r?i.zone.w=i.w=r:i.fw&&(i.zone.w=i.w=i.fw),l+=i.zone.w,l>=t.w&&(n+=i.h+o,l=0));return d},findTarget:function(e,t){let n=e.length;for(;n--;)if(I.onZone(e[n],t.clientX,t.clientY))return n;return -1},findZone:function(e){if(I.needReZone||e){for(var t,n=I.ui.length;n--;)t=I.ui[n],I.getZone(t),t.isGui&&t.calcUis();I.needReZone=!1;}},onZone:function(e,t,n){if(void 0===t||void 0===n)return !1;let a=e.zone,i=t-a.x,r=n-a.y,o=i>=0&&r>=0&&i<=a.w&&r<=a.h;return o?e.local.set(i,r):e.local.neg(),o},getWidth:function(e){return e.getDom().clientWidth},getZone:function(e){if(e.isCanvasOnly)return;let t=e.getDom().getBoundingClientRect();e.zone={x:t.left,y:t.top,w:t.width,h:t.height};},cursor:function(e){(e=e||"auto")!==I.oldCursor&&(document.body.style.cursor=e,I.oldCursor=e);},toCanvas:function(e,t,n,a){if(I.xmlserializer||(I.xmlserializer=new XMLSerializer),a&&null!==I.tmpTime&&(clearTimeout(I.tmpTime),I.tmpTime=null),null!==I.tmpTime)return;I.lock&&(I.tmpTime=setTimeout((function(){I.tmpTime=null;}),10));let i=!1;t===e.canvas.width&&n===e.canvas.height||(i=!0),null===I.tmpImage&&(I.tmpImage=new Image);let r=I.tmpImage,o=I.xmlserializer.serializeToString(e.content),s='<svg xmlns="http://www.w3.org/2000/svg" width="'+t+'" height="'+n+'"><foreignObject style="pointer-events: none; left:0;" width="100%" height="100%">'+o+"</foreignObject></svg>";r.onload=function(){let a=e.canvas.getContext("2d");i?(e.canvas.width=t,e.canvas.height=n):a.clearRect(0,0,t,n),a.drawImage(this,0,0),e.onDraw();},r.src="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(s),r.crossOrigin="";},setHidden:function(){null===I.hiddenImput&&(I.hiddenImput=document.createElement("input"),I.hiddenImput.type="text",I.hiddenSizer=document.createElement("div"),document.body.appendChild(I.hiddenImput),document.body.appendChild(I.hiddenSizer));let e=I.debugInput?"":"opacity:0; zIndex:0;",t=I.parent.css.txtselect+"padding:0; width:auto; height:auto; left:10px; top:auto; color:#FFF; background:#000;"+e;I.hiddenImput.style.cssText=t+"bottom:10px;"+(I.debugInput?"":"transform:scale(0);"),I.hiddenSizer.style.cssText=t+"bottom:40px;",I.hiddenImput.style.width=I.input.clientWidth+"px",I.hiddenImput.value=I.str,I.hiddenSizer.innerHTML=I.str,I.hasFocus=!0;},clearHidden:function(e){null!==I.hiddenImput&&(I.hasFocus=!1);},clickPos:function(e){let t=I.str.length,n=0,a=0;for(;t--&&(n+=I.textWidth(I.str[a]),!(n>=e));)a++;return a},upInput:function(e,t){if(null===I.parent)return !1;let n=!1;if(t){let t=I.clickPos(e);I.moveX=t,-1===I.startX?(I.startX=t,I.cursorId=t,I.inputRange=[I.startX,I.startX]):I.moveX!==I.startX&&(I.startX>I.moveX?I.inputRange=[I.moveX,I.startX]:I.inputRange=[I.startX,I.moveX]),n=!0;}else -1!==I.startX&&(I.hasFocus=!0,I.hiddenImput.focus(),I.hiddenImput.selectionStart=I.inputRange[0],I.hiddenImput.selectionEnd=I.inputRange[1],I.startX=-1,n=!0);return n&&I.selectParent(),n},selectAll:function(){I.parent&&(I.str=I.input.textContent,I.inputRange=[0,I.str.length],I.hasFocus=!0,I.hiddenImput.focus(),I.hiddenImput.selectionStart=I.inputRange[0],I.hiddenImput.selectionEnd=I.inputRange[1],I.cursorId=I.inputRange[1],I.selectParent());},selectParent:function(){var e=I.textWidth(I.str.substring(0,I.cursorId)),t=I.textWidth(I.str.substring(0,I.inputRange[0])),n=I.textWidth(I.str.substring(I.inputRange[0],I.inputRange[1]));I.parent.select(e,t,n,I.hiddenSizer.innerHTML);},textWidth:function(e){return null===I.hiddenSizer?0:(e=e.replace(/ /g,"&nbsp;"),I.hiddenSizer.innerHTML=e,I.hiddenSizer.clientWidth)},clearInput:function(){null!==I.parent&&(I.firstImput||I.parent.validate(!0),I.clearHidden(),I.parent.unselect(),I.input.style.background=I.parent.colors.back,I.input.style.borderColor=I.parent.colors.border,I.parent.isEdit=!1,I.input=null,I.parent=null,I.str="",I.firstImput=!0);},setInput:function(e,t){I.clearInput(),I.input=e,I.parent=t,I.input.style.background=I.parent.colors.backoff,I.input.style.borderColor=I.parent.colors.select,I.str=I.input.textContent,I.setHidden();},keydown:function(e){if(null===I.parent)return;let t=e.which;e.shiftKey,I.firstImput=!1,I.hasFocus&&(window.focus(),I.hiddenImput.focus()),I.parent.isEdit=!0,13===t?I.clearInput():I.input.isNum?e.keyCode>47&&e.keyCode<58||e.keyCode>95&&e.keyCode<106||190===e.keyCode||110===e.keyCode||8===e.keyCode||109===e.keyCode?I.hiddenImput.readOnly=!1:I.hiddenImput.readOnly=!0:I.hiddenImput.readOnly=!1;},keyup:function(e){null!==I.parent&&(I.str=I.hiddenImput.value,I.parent.allEqual?I.parent.sameStr(I.str):I.input.textContent=I.str,I.cursorId=I.hiddenImput.selectionStart,I.inputRange=[I.hiddenImput.selectionStart,I.hiddenImput.selectionEnd],I.selectParent(),I.parent.validate());},loop:function(){I.isLoop&&requestAnimationFrame(I.loop),I.update();},update:function(){let e=I.listens.length;for(;e--;)I.listens[e].listening();},removeListen:function(e){let t=I.listens.indexOf(e);-1!==t&&I.listens.splice(t,1),0===I.listens.length&&(I.isLoop=!1);},addListen:function(e){return -1===I.listens.indexOf(e)&&(I.listens.push(e),I.isLoop||(I.isLoop=!0,I.loop()),!0)}},_=I,O={transition:.2,frag:document.createDocumentFragment(),colorRing:null,joystick_0:null,joystick_1:null,circular:null,knob:null,pad2d:null,svgns:"http://www.w3.org/2000/svg",links:"http://www.w3.org/1999/xlink",htmls:"http://www.w3.org/1999/xhtml",DOM_SIZE:["height","width","top","left","bottom","right","margin-left","margin-right","margin-top","margin-bottom"],SVG_TYPE_D:["pattern","defs","transform","stop","animate","radialGradient","linearGradient","animateMotion","use","filter","feColorMatrix"],SVG_TYPE_G:["svg","rect","circle","path","polygon","text","g","line","foreignObject"],PI:Math.PI,TwoPI:2*Math.PI,pi90:.5*Math.PI,pi60:Math.PI/3,torad:Math.PI/180,todeg:180/Math.PI,clamp:(e,t,n)=>(e=e<t?t:e)>n?n:e,isDivid:e=>.5*e===Math.floor(.5*e),size:{w:240,h:20,p:30,s:8},defineColor:(e,t=O.colors)=>{let n={...t},a=["fontFamily","fontWeight","fontShadow","fontSize"],i=!1;e.font&&(e.fontFamily=e.font),e.shadow&&(e.fontShadow=e.shadow),e.weight&&(e.fontWeight=e.weight),e.fontColor&&(e.text=e.fontColor),e.color&&(e.text=e.color),e.text&&(n.text=e.text,e.fontColor||e.color||(n.title=O.ColorLuma(e.text,-.25),n.titleoff=O.ColorLuma(e.text,-.5)),n.textOver=O.ColorLuma(e.text,.25),n.textSelect=O.ColorLuma(e.text,.5)),e.button&&(n.button=e.button,n.border=O.ColorLuma(e.button,.1),n.overoff=O.ColorLuma(e.button,.2)),e.select&&(n.select=e.select,n.over=O.ColorLuma(e.select,-.1)),e.itemBg&&(e.back=e.itemBg),e.back&&(n.back=e.back,n.backoff=O.ColorLuma(e.back,-.1)),e.fontSelect&&(n.textSelect=e.fontSelect),e.groupBorder&&(n.gborder=e.groupBorder),e.bgOver&&(n.backgroundOver=e.bgOver);for(let t in n)void 0!==e[t]&&(n[t]=e[t]);for(let t in e)-1!==a.indexOf(t)&&(i=!0);return i&&O.defineText(n),n},colors:{sx:4,sy:2,radius:2,showOver:1,content:"none",background:"rgba(50,50,50,0.15)",backgroundOver:"rgba(50,50,50,0.3)",title:"#CCC",titleoff:"#BBB",text:"#DDD",textOver:"#EEE",textSelect:"#FFF",back:"rgba(0,0,0,0.2)",backoff:"rgba(0,0,0,0.3)",border:"#4c4c4c",borderSize:1,gborder:"none",groups:"none",button:"#3c3c3c",overoff:"#5c5c5c",over:"#024699",select:"#308AFF",action:"#FF3300",fontFamily:"Consolas, monospace",fontWeight:"normal",fontShadow:"none",fontSize:12,joyOver:"rgba(48,138,255,0.25)",joyOut:"rgba(100,100,100,0.5)",joySelect:"#308AFF",hide:"rgba(0,0,0,0)"},css:{basic:"position:absolute; pointer-events:none; box-sizing:border-box; margin:0; padding:0; overflow:hidden; -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select:none;",button:"display:flex; align-items:center; justify-content:center; text-align:center;",middle:"display:flex; align-items:center; justify-content:left; text-align:left; flex-direction: row-reverse;"},svgs:{g1:"M 6 4 L 0 4 0 6 6 6 6 4 M 6 0 L 0 0 0 2 6 2 6 0 Z",g2:"M 6 0 L 4 0 4 6 6 6 6 0 M 2 0 L 0 0 0 6 2 6 2 0 Z",group:"M 7 7 L 7 8 8 8 8 7 7 7 M 5 7 L 5 8 6 8 6 7 5 7 M 3 7 L 3 8 4 8 4 7 3 7 M 7 5 L 7 6 8 6 8 5 7 5 M 6 6 L 6 5 5 5 5 6 6 6 M 7 3 L 7 4 8 4 8 3 7 3 M 6 4 L 6 3 5 3 5 4 6 4 M 3 5 L 3 6 4 6 4 5 3 5 M 3 3 L 3 4 4 4 4 3 3 3 Z",arrow:"M 3 8 L 8 5 3 2 3 8 Z",arrowDown:"M 5 8 L 8 3 2 3 5 8 Z",arrowUp:"M 5 2 L 2 7 8 7 5 2 Z",solid:"M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 Z",body:"M 13 10 L 13 1 4 1 1 4 1 13 10 13 13 10 M 11 3 L 11 9 9 11 3 11 3 5 5 3 11 3 M 5 4 L 4 5 4 10 9 10 10 9 10 4 5 4 Z",vehicle:"M 13 6 L 11 1 3 1 1 6 1 13 3 13 3 11 11 11 11 13 13 13 13 6 M 2.4 6 L 4 2 10 2 11.6 6 2.4 6 M 12 8 L 12 10 10 10 10 8 12 8 M 4 8 L 4 10 2 10 2 8 4 8 Z",articulation:"M 13 9 L 12 9 9 2 9 1 5 1 5 2 2 9 1 9 1 13 5 13 5 9 4 9 6 5 8 5 10 9 9 9 9 13 13 13 13 9 Z",character:"M 13 4 L 12 3 9 4 5 4 2 3 1 4 5 6 5 8 4 13 6 13 7 9 8 13 10 13 9 8 9 6 13 4 M 6 1 L 6 3 8 3 8 1 6 1 Z",terrain:"M 13 8 L 12 7 Q 9.06 -3.67 5.95 4.85 4.04 3.27 2 7 L 1 8 7 13 13 8 M 3 8 Q 3.78 5.420 5.4 6.6 5.20 7.25 5 8 L 7 8 Q 8.39 -0.16 11 8 L 7 11 3 8 Z",joint:"M 7.7 7.7 Q 8 7.45 8 7 8 6.6 7.7 6.3 7.45 6 7 6 6.6 6 6.3 6.3 6 6.6 6 7 6 7.45 6.3 7.7 6.6 8 7 8 7.45 8 7.7 7.7 M 3.35 8.65 L 1 11 3 13 5.35 10.65 Q 6.1 11 7 11 8.28 11 9.25 10.25 L 7.8 8.8 Q 7.45 9 7 9 6.15 9 5.55 8.4 5 7.85 5 7 5 6.54 5.15 6.15 L 3.7 4.7 Q 3 5.712 3 7 3 7.9 3.35 8.65 M 10.25 9.25 Q 11 8.28 11 7 11 6.1 10.65 5.35 L 13 3 11 1 8.65 3.35 Q 7.9 3 7 3 5.7 3 4.7 3.7 L 6.15 5.15 Q 6.54 5 7 5 7.85 5 8.4 5.55 9 6.15 9 7 9 7.45 8.8 7.8 L 10.25 9.25 Z",ray:"M 9 11 L 5 11 5 12 9 12 9 11 M 12 5 L 11 5 11 9 12 9 12 5 M 11.5 10 Q 10.9 10 10.45 10.45 10 10.9 10 11.5 10 12.2 10.45 12.55 10.9 13 11.5 13 12.2 13 12.55 12.55 13 12.2 13 11.5 13 10.9 12.55 10.45 12.2 10 11.5 10 M 9 10 L 10 9 2 1 1 2 9 10 Z",collision:"M 11 12 L 13 10 10 7 13 4 11 2 7.5 5.5 9 7 7.5 8.5 11 12 M 3 2 L 1 4 4 7 1 10 3 12 8 7 3 2 Z",map:"M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z",material:"M 13 1 L 1 1 1 13 13 13 13 1 M 12 2 L 12 7 7 7 7 12 2 12 2 7 7 7 7 2 12 2 Z",texture:"M 13 4 L 13 1 1 1 1 4 5 4 5 13 9 13 9 4 13 4 Z",object:"M 10 1 L 7 4 4 1 1 1 1 13 4 13 4 5 7 8 10 5 10 13 13 13 13 1 10 1 Z",none:"M 9 5 L 5 5 5 9 9 9 9 5 Z",cursor:"M 4 7 L 1 10 1 12 2 13 4 13 7 10 9 14 14 0 0 5 4 7 Z",load:"M 13 8 L 11.5 6.5 9 9 9 3 5 3 5 9 2.5 6.5 1 8 7 14 13 8 M 9 2 L 9 0 5 0 5 2 9 2 Z",save:"M 9 12 L 5 12 5 14 9 14 9 12 M 11.5 7.5 L 13 6 7 0 1 6 2.5 7.5 5 5 5 11 9 11 9 5 11.5 7.5 Z",extern:"M 14 14 L 14 0 0 0 0 14 14 14 M 12 6 L 12 12 2 12 2 6 12 6 M 12 2 L 12 4 2 4 2 2 12 2 Z"},rezone(){_.needReZone=!0;},getImput:function(){return !!_.input},setStyle:function(e){for(var t in e)O.colors[t]&&(O.colors[t]=e[t]);O.setText();},defineText:function(e){O.setText(e.fontSize,e.text,e.fontFamily,e.fontShadow,e.fontWeight);},setText:function(e,t,n,a,i){let r=O.colors;void 0===n&&(n=r.fontFamily),void 0===e&&(e=r.fontSize),void 0===a&&(a=r.fontShadow),void 0===i&&(i=r.fontWeight),isNaN(e)?-1===e.search("em")&&(e+="px"):e+="px",O.css.txt=O.css.basic+O.css.middle+" font-family:"+n+"; font-weight:"+i+"; font-size:"+e+"; color:"+r.text+"; padding:0px 8px; left:0; top:2px; height:16px; width:100px; overflow:hidden; white-space: nowrap; letter-spacing: normal;","none"!==a&&(O.css.txt+=" text-shadow: 1px 1px 1px "+a+";"),O.css.txtselect=O.css.txt+"padding:0px 4px; border:1px dashed "+r.border+";",O.css.item=O.css.txt+"padding:0px 4px; position:relative; margin-bottom:1px; ";},cloneCss:function(){return {...O.css}},clone:function(e){return e.cloneNode(!0)},setSvg:function(e,t,n,a,i){-1===a?e.setAttributeNS(null,t,n):void 0!==i?e.childNodes[a||0].childNodes[i||0].setAttributeNS(null,t,n):e.childNodes[a||0].setAttributeNS(null,t,n);},setCss:function(e,t){for(let n in t)-1!==O.DOM_SIZE.indexOf(n)?e.style[n]=t[n]+"px":e.style[n]=t[n];},set:function(e,t){for(let n in t)"txt"===n&&(e.textContent=t[n]),"link"===n?e.setAttributeNS(O.links,"xlink:href",t[n]):e.setAttributeNS(null,n,t[n]);},get:function(e,t){if(void 0===t)return e;if(!isNaN(t))return e.childNodes[t];if(t instanceof Array){if(2===t.length)return e.childNodes[t[0]].childNodes[t[1]];if(3===t.length)return e.childNodes[t[0]].childNodes[t[1]].childNodes[t[2]]}},dom:function(e,t,n,a,i){return e=e||"div",-1!==O.SVG_TYPE_D.indexOf(e)||-1!==O.SVG_TYPE_G.indexOf(e)?"svg"===e?(a=document.createElementNS(O.svgns,"svg"),O.set(a,n)):(void 0===a&&(a=document.createElementNS(O.svgns,"svg")),O.addAttributes(a,e,n,i)):a=void 0===a?document.createElementNS(O.htmls,e):a.appendChild(document.createElementNS(O.htmls,e)),t&&(a.style.cssText=t),void 0===i?a:a.childNodes[i||0]},addAttributes:function(e,t,n,a){let i=document.createElementNS(O.svgns,t);return O.set(i,n),O.get(e,a).appendChild(i),-1!==O.SVG_TYPE_G.indexOf(t)&&(i.style.pointerEvents="none"),i},clear:function(e){for(O.purge(e);e.firstChild;)e.firstChild.firstChild&&O.clear(e.firstChild),e.removeChild(e.firstChild);},purge:function(e){let t,n,a=e.attributes;if(a)for(t=a.length;t--;)n=a[t].name,"function"==typeof e[n]&&(e[n]=null);if(a=e.childNodes,a)for(t=a.length;t--;)O.purge(e.childNodes[t]);},addSVGGlowEffect:function(){if(null!==document.getElementById("UILGlow"))return;let e=O.initUILEffects(),t=O.addAttributes(e,"filter",{id:"UILGlow",x:"-20%",y:"-20%",width:"140%",height:"140%"});O.addAttributes(t,"feGaussianBlur",{in:"SourceGraphic",stdDeviation:"3",result:"uilBlur"});let n=O.addAttributes(t,"feMerge",{});for(let e=0;e<=3;e++)O.addAttributes(n,"feMergeNode",{in:"uilBlur"});O.addAttributes(n,"feMergeNode",{in:"SourceGraphic"});},initUILEffects:function(){let e=document.getElementById("UILSVGEffects");return null===e&&(e=O.dom("svg",void 0,{id:"UILSVGEffects",width:"0",height:"0"}),document.body.appendChild(e)),e},ColorLuma:function(e,t){"n"===e&&(e="#000"),(e=String(e).replace(/[^0-9a-f]/gi,"")).length<6&&(e=e[0]+e[0]+e[1]+e[1]+e[2]+e[2]),t=t||0;let n,a,i="#";for(a=0;a<3;a++)n=parseInt(e.substr(2*a,2),16),n=Math.round(Math.min(Math.max(0,n+n*t),255)).toString(16),i+=("00"+n).substr(n.length);return i},findDeepInver:function(e){return .3*e[0]+.59*e[1]+.11*e[2]<=.6},lerpColor:function(e,t,n){let a={};for(let i=0;i<3;i++)a[i]=e[i]+(t[i]-e[i])*n;return a},hexToHtml:function(e){return "#"+("000000"+(e=void 0===e?0:e).toString(16)).substr(-6)},htmlToHex:function(e){return e.toUpperCase().replace("#","0x")},u255:function(e,t){return parseInt(e.substring(t,t+2),16)/255},u16:function(e,t){return parseInt(e.substring(t,t+1),16)/15},unpack:function(e){return 7==e.length?[O.u255(e,1),O.u255(e,3),O.u255(e,5)]:4==e.length?[O.u16(e,1),O.u16(e,2),O.u16(e,3)]:void 0},p255:function(e){let t=Math.round(255*e).toString(16);return t.length<2&&(t="0"+t),t},pack:function(e){return "#"+O.p255(e[0])+O.p255(e[1])+O.p255(e[2])},htmlRgba:function(e,t){return e=O.unpack(e),"rgba("+Math.round(255*e[0])+","+Math.round(255*e[1])+","+Math.round(255*e[2])+","+t+")"},htmlRgb:function(e,t){return "rgb("+Math.round(255*e[0])+","+Math.round(255*e[1])+","+Math.round(255*e[2])+")"},pad:function(e){return 1==e.length&&(e="0"+e),e},rgbToHex:function(e){let t=Math.round(255*e[0]).toString(16),n=Math.round(255*e[1]).toString(16),a=Math.round(255*e[2]).toString(16);return "#"+O.pad(t)+O.pad(n)+O.pad(a)},hueToRgb:function(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e},rgbToHsl:function(e){let t=e[0],n=e[1],a=e[2],i=Math.min(t,n,a),r=Math.max(t,n,a),o=r-i,s=0,l=0,c=(i+r)/2;return c>0&&c<1&&(l=o/(c<.5?2*c:2-2*c)),o>0&&(r==t&&r!=n&&(s+=(n-a)/o),r==n&&r!=a&&(s+=2+(a-t)/o),r==a&&r!=t&&(s+=4+(t-n)/o),s/=6),[s,l,c]},hslToRgb:function(e){let t,n,a=e[0],i=e[1],r=e[2];return 0===i?[r,r,r]:(n=r<=.5?r*(i+1):r+i-r*i,t=2*r-n,[O.hueToRgb(t,n,a+.33333),O.hueToRgb(t,n,a),O.hueToRgb(t,n,a-.33333)])},makeGradiant:function(e,t,n,a){O.dom(e,null,t,n,0);let i,r=n.childNodes[0].childNodes.length-1;for(let e=0;e<a.length;e++)i=a[e],O.dom("stop",null,{offset:i[0]+"%","stop-color":i[1],"stop-opacity":i[2]},n,[0,r]);},makePad:function(e){let t=O.dom("svg",O.css.basic+"position:relative;",{viewBox:"0 0 256 256",width:256,height:256,preserveAspectRatio:"none"});B.dom("rect","",{x:28,y:28,width:200,height:200,fill:O.colors.back},t),B.dom("rect","",{x:38,y:38,width:180,height:180,fill:O.colors.button},t),B.dom("line","",{x1:38,y1:128,x2:218,y2:128,stroke:O.colors.back,"stroke-width":2},t),B.dom("line","",{x1:128,x2:128,y1:38,y2:218,stroke:O.colors.back,"stroke-width":2},t),B.dom("circle","",{cx:128,cy:128,r:5,stroke:O.colors.text,"stroke-width":5,fill:"none"},t),O.pad2d=t;},makeKnob:function(e){let t=O.dom("svg",O.css.basic+"position:relative;",{viewBox:"0 0 128 128",width:128,height:128,preserveAspectRatio:"none"});O.dom("circle","",{cx:64,cy:64,r:34,fill:O.colors.button,stroke:"rgba(0,0,0,0.3)","stroke-width":8},t),O.dom("path","",{d:"",stroke:O.colors.text,"stroke-width":4,fill:"none","stroke-linecap":"round"},t),O.dom("circle","",{cx:64,cy:64,r:41,stroke:"rgba(0,0,0,0.1)","stroke-width":7,fill:"none"},t),O.dom("path","",{d:"",stroke:"rgba(255,255,255,0.3)","stroke-width":2,fill:"none","stroke-linecap":"round","stroke-opacity":.5},t),O.knob=t;},makeCircular:function(e){let t=O.dom("svg",O.css.basic+"position:relative;",{viewBox:"0 0 128 128",width:128,height:128,preserveAspectRatio:"none"});O.dom("circle","",{cx:64,cy:64,r:40,stroke:"rgba(0,0,0,0.1)","stroke-width":10,fill:"none"},t),O.dom("path","",{d:"",stroke:O.colors.text,"stroke-width":7,fill:"none","stroke-linecap":"butt"},t),O.circular=t;},makeJoystick:function(e){let t,n=Math.floor(49),a=Math.floor(.6*n),i=O.dom("svg",O.css.basic+"position:relative;",{viewBox:"0 0 128 128",width:128,height:128,preserveAspectRatio:"none"});if(O.dom("defs",null,{},i),O.dom("g",null,{},i),0===e){t=[[40,"rgb(0,0,0)",.3],[80,"rgb(0,0,0)",0],[90,"rgb(50,50,50)",.4],[100,"rgb(50,50,50)",0]],O.makeGradiant("radialGradient",{id:"grad",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},i,t),t=[[60,"rgb(0,0,0)",.5],[100,"rgb(0,0,0)",0]],O.makeGradiant("radialGradient",{id:"gradS",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},i,t);let e=["rgb(40,40,40)","rgb(48,48,48)","rgb(30,30,30)"],r=["rgb(1,90,197)","rgb(3,95,207)","rgb(0,65,167)"];t=[[30,e[0],1],[60,e[1],1],[80,e[1],1],[100,e[2],1]],O.makeGradiant("radialGradient",{id:"gradIn",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},i,t),t=[[30,r[0],1],[60,r[1],1],[80,r[1],1],[100,r[2],1]],O.makeGradiant("radialGradient",{id:"gradIn2",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},i,t),O.dom("circle","",{cx:64,cy:64,r:n,fill:"url(#grad)"},i),O.dom("circle","",{cx:69,cy:74,r:a+10,fill:"url(#gradS)"},i),O.dom("circle","",{cx:64,cy:64,r:a,fill:"url(#gradIn)"},i),O.joystick_0=i;}else t=[[69,"rgb(0,0,0)",0],[70,"rgb(0,0,0)",.3],[100,"rgb(0,0,0)",0]],O.makeGradiant("radialGradient",{id:"gradX",cx:"50%",cy:"50%",r:"50%",fx:"50%",fy:"50%"},i,t),O.dom("circle","",{cx:64,cy:64,r:n,fill:"none",stroke:"rgba(100,100,100,0.25)","stroke-width":"4"},i),O.dom("circle","",{cx:64,cy:64,r:a+14,fill:"url(#gradX)"},i),O.dom("circle","",{cx:64,cy:64,r:a,fill:"none",stroke:"rgb(100,100,100)","stroke-width":"4"},i),O.joystick_1=i;},makeColorRing:function(){let e=O.dom("svg",O.css.basic+"position:relative;",{viewBox:"0 0 256 256",width:256,height:256,preserveAspectRatio:"none"});O.dom("defs",null,{},e),O.dom("g",null,{},e);let t,n,a,i,r,o,s,l,c,d=8/113/24*Math.PI,u=0,p=[];for(o=0;o<=24;++o){if(a=o/24,i=a*O.TwoPI,t=.5*(u+i),n=1/Math.cos(.5*(i-u)),r=[Math.sin(u),-Math.cos(u),Math.sin(t)*n,-Math.cos(t)*n,Math.sin(i),-Math.cos(i)],p[1]=O.rgbToHex(O.hslToRgb([a,1,.5])),o>0){for(s=6;s--;)r[s]=(113*r[s]+128).toFixed(2);l=" M"+r[0]+" "+r[1]+" Q"+r[2]+" "+r[3]+" "+r[4]+" "+r[5],c=[[0,p[0],1],[100,p[1],1]],O.makeGradiant("linearGradient",{id:"G"+o,x1:r[0],y1:r[1],x2:r[4],y2:r[5],gradientUnits:"userSpaceOnUse"},e,c),O.dom("path","",{d:l,"stroke-width":30,stroke:"url(#G"+o+")","stroke-linecap":"butt"},e,1);}u=i-d,p[0]=p[1];}c=[[0,"#FFFFFF",1],[50,"#FFFFFF",0],[50,"#000000",0],[100,"#000000",1]],O.makeGradiant("linearGradient",{id:"GL0",x1:0,y1:128-84.9,x2:0,y2:212.9,gradientUnits:"userSpaceOnUse"},e,c),c=[[0,"#7f7f7f",1],[50,"#7f7f7f",.5],[100,"#7f7f7f",0]],O.makeGradiant("linearGradient",{id:"GL1",x1:78.95,y1:0,x2:226,y2:0,gradientUnits:"userSpaceOnUse"},e,c),O.dom("g",null,{"transform-origin":"128px 128px",transform:"rotate(0)"},e),O.dom("polygon","",{points:"78.95 43.1 78.95 212.85 226 128",fill:"red"},e,2),O.dom("polygon","",{points:"78.95 43.1 78.95 212.85 226 128",fill:"url(#GL1)","stroke-width":1,stroke:"url(#GL1)"},e,2),O.dom("polygon","",{points:"78.95 43.1 78.95 212.85 226 128",fill:"url(#GL0)","stroke-width":1,stroke:"url(#GL0)"},e,2),O.dom("path","",{d:"M 255.75 136.5 Q 256 132.3 256 128 256 123.7 255.75 119.5 L 241 128 255.75 136.5 Z",fill:"none","stroke-width":2,stroke:"#000"},e,2),O.dom("circle","",{cx:128,cy:128,r:6,"stroke-width":2,stroke:"#000",fill:"none"},e),O.colorRing=e;},icon:function(e,t,n){n=n||40;let a=["<svg xmlns='"+O.svgns+"' version='1.1' xmlns:xlink='"+O.htmls+"' style='pointer-events:none;' preserveAspectRatio='xMinYMax meet' x='0px' y='0px' width='"+n+"px' height='"+n+"px' viewBox='0 0 256 256'><g>"];switch(e){case"logo":a[1]="<path id='logoin' fill='"+t+"' stroke='none' d='"+O.logoFill_d+"'/>";break;case"donate":a[1]="<path id='logoin' fill='"+t+"' stroke='none' d='"+O.logo_donate+"'/>";break;case"neo":a[1]="<path id='logoin' fill='"+t+"' stroke='none' d='"+O.logo_neo+"'/>";break;case"phy":a[1]="<path id='logoin' stroke='"+t+"' stroke-width='49' stroke-linejoin='round' stroke-linecap='butt' fill='none' d='"+O.logo_phy+"'/>";break;case"config":a[1]="<path id='logoin' stroke='"+t+"' stroke-width='49' stroke-linejoin='round' stroke-linecap='butt' fill='none' d='"+O.logo_config+"'/>";break;case"github":a[1]="<path id='logoin' fill='"+t+"' stroke='none' d='"+O.logo_github+"'/>";break;case"save":a[1]="<path stroke='"+t+"' stroke-width='4' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 26.125 17 L 20 22.95 14.05 17 M 20 9.95 L 20 22.95'/><path stroke='"+t,a[1]+="' stroke-width='2.5' stroke-linejoin='round' stroke-linecap='round' fill='none' d='M 32.6 23 L 32.6 25.5 Q 32.6 28.5 29.6 28.5 L 10.6 28.5 Q 7.6 28.5 7.6 25.5 L 7.6 23'/>";}return a[2]="</g></svg>",a.join("\n")},logoFill_d:"\n    M 171 150.75 L 171 33.25 155.5 33.25 155.5 150.75 Q 155.5 162.2 147.45 170.2 139.45 178.25 128 178.25 116.6 178.25 108.55 170.2 100.5 162.2 100.5 150.75 \n    L 100.5 33.25 85 33.25 85 150.75 Q 85 168.65 97.55 181.15 110.15 193.75 128 193.75 145.9 193.75 158.4 181.15 171 168.65 171 150.75 \n    M 200 33.25 L 184 33.25 184 150.8 Q 184 174.1 167.6 190.4 151.3 206.8 128 206.8 104.75 206.8 88.3 190.4 72 174.1 72 150.8 L 72 33.25 56 33.25 56 150.75 \n    Q 56 180.55 77.05 201.6 98.2 222.75 128 222.75 157.8 222.75 178.9 201.6 200 180.55 200 150.75 L 200 33.25 Z\n    ",logo_github:"\n    M 180.5 70 Q 186.3 82.4 181.55 96.55 196.5 111.5 189.7 140.65 183.65 168.35 146 172.7 152.5 178.7 152.55 185.9 L 152.55 218.15 Q 152.84 224.56 159.15 223.3 \n    159.21 223.3 159.25 223.3 181.14 216.25 198.7 198.7 228 169.4 228 128 228 86.6 198.7 57.3 169.4 28 128 28 86.6 28 57.3 57.3 28 86.6 28 128 28 169.4 57.3 198.7 74.85 \n    216.25 96.75 223.3 96.78 223.3 96.8 223.3 103.16 224.54 103.45 218.15 L 103.45 200 Q 82.97 203.1 75.1 196.35 69.85 191.65 68.4 185.45 64.27 177.055 59.4 174.15 49.20 \n    166.87 60.8 167.8 69.85 169.61 75.7 180 81.13 188.09 90 188.55 98.18 188.86 103.45 185.9 103.49 178.67 110 172.7 72.33 168.33 66.3 140.65 59.48 111.49 74.45 96.55 69.7 \n    82.41 75.5 70 84.87 68.74 103.15 80 115.125 76.635 128 76.85 140.85 76.65 152.85 80 171.1 68.75 180.5 70 Z\n    ",logo_neo:"\n    M 219 52 L 206 52 206 166 Q 206 183.4 193.75 195.65 181.4 208 164 208 146.6 208 134.35 195.65 122 183.4 122 166 L 122 90 Q 122 77.6 113.15 68.85 104.4 60 92 60 79.55 \n    60 70.75 68.85 62 77.6 62 90 L 62 204 75 204 75 90 Q 75 83 79.95 78 84.95 73 92 73 99 73 104 78 109 83 109 90 L 109 166 Q 109 188.8 125.15 204.85 141.2 221 164 221 \n    186.75 221 202.95 204.85 219 188.8 219 166 L 219 52 M 194 52 L 181 52 181 166 Q 181 173 176.05 178 171.05 183 164 183 157 183 152 178 147 173 147 166 L 147 90 Q 147 \n    67.2 130.85 51.15 114.8 35 92 35 69.25 35 53.05 51.15 37 67.2 37 90 L 37 204 50 204 50 90 Q 50 72.6 62.25 60.35 74.6 48 92 48 109.4 48 121.65 60.35 134 72.6 134 90 L \n    134 166 Q 134 178.4 142.85 187.15 151.6 196 164 196 176.45 196 185.25 187.15 194 178.4 194 166 L 194 52 Z\n    ",logo_phy:"\n    M 103.55 37.95 L 127.95 37.95 Q 162.35 37.95 186.5 55 210.9 72.35 210.9 96.5 210.9 120.65 186.5 137.7 162.35 155 127.95 155 L 127.95 237.95 M 127.95 155 \n    Q 93.55 155 69.15 137.7 45 120.65 45 96.5 45 72.35 69.15 55 70.9 53.8 72.85 52.85 M 127.95 155 L 127.95 37.95\n    ",logo_config:"\n    M 204.35 51.65 L 173.25 82.75 Q 192 101.5 192 128 L 236 128 M 192 128 Q 192 154.55 173.25 173.25 L 204.4 204.4 M 51.65 51.65 L 82.75 82.75 Q 101.5 64 128 64 \n    L 128 20 M 51.6 204.4 L 82.75 173.25 Q 64 154.55 64 128 L 20 128 M 128 236 L 128 192 Q 101.5 192 82.75 173.25 M 64 128 Q 64 101.5 82.75 82.75 M 173.25 173.25 \n    Q 154.55 192 128 192 M 128 64 Q 154.55 64 173.25 82.75\n    ",logo_donate:"\n    M 171.3 80.3 Q 179.5 62.15 171.3 45.8 164.1 32.5 141.35 30.1 L 94.35 30.1 Q 89.35 30.4 88.3 35.15 L 70.5 148.05 Q 70.2 152.5 73.7 152.6 L 100.95 152.6 107 111.6 Q 108.75 \n    106.55 112.6 106.45 130.45 108.05 145.3 103.9 163.35 98.75 171.3 80.3 M 179.8 71.5 Q 178.6 79.75 174.9 87.85 168.45 102.9 151.9 109.15 140.65 113.95 117.55 113 113.15 \n    112.75 111 117.45 L 102.7 169.95 Q 102.45 173.8 105.5 173.85 L 128.95 173.85 Q 132.2 174.2 133.35 169.65 L 138.3 139.95 Q 139.75 135.6 143.1 135.5 146.6 135.75 150.6 135.65 \n    154.55 135.5 157.35 135.1 160.15 134.7 166.75 132.35 181.35 127.4 187.9 111.2 194.25 95.75 189.5 81.95 186.75 74.85 179.8 71.5 M 103.5 209.9 Q 103.5 202.85 99.7 198.85 95.95 \n    194.75 89.4 194.75 82.8 194.75 79.05 198.85 75.3 202.9 75.3 209.9 75.3 216.85 79.05 220.95 82.8 225.05 89.4 225.05 95.95 225.05 99.7 221 103.5 216.95 103.5 209.9 M 95.45 205.5 \n    Q 95.95 207.3 95.95 209.9 95.95 212.65 95.45 214.35 94.95 216 94 217.3 93.1 218.45 91.9 219 90.7 219.55 89.4 219.55 88.15 219.55 86.95 219.05 85.75 218.55 84.8 217.3 83.9 216.15 \n    83.4 214.35 82.85 212.6 82.85 209.9 82.85 207.3 83.4 205.45 83.95 203.55 84.85 202.45 85.9 201.2 86.95 200.75 88.05 200.25 89.4 200.25 90.7 200.25 91.85 200.8 93.05 201.3 94 202.5 \n    94.9 203.65 95.45 205.5 M 153.3 195.35 L 145.3 195.35 135.5 224.45 142.8 224.45 144.6 218.5 153.75 218.5 155.6 224.45 163.1 224.45 153.3 195.35 M 152.15 213.25 L 146.25 213.25 \n    149.2 203.65 152.15 213.25 M 116.75 195.35 L 107.8 195.35 107.8 224.45 114.5 224.45 114.5 204.2 125.7 224.45 132.75 224.45 132.75 195.35 126.05 195.35 126.05 212.05 116.75 195.35 M \n    66.5 197.65 Q 64.15 196.15 61.45 195.75 58.8 195.35 55.75 195.35 L 46.7 195.35 46.7 224.45 55.8 224.45 Q 58.8 224.45 61.5 224.05 64.15 223.6 66.4 222.15 69.15 220.45 70.9 217.2 \n    72.7 214 72.7 209.95 72.7 205.7 71 202.6 69.35 199.5 66.5 197.65 M 64.2 205 Q 65.2 207 65.2 209.9 65.2 212.75 64.25 214.75 63.3 216.75 61.5 217.85 60 218.85 58.3 218.9 56.6 219 \n    54.15 219 L 54 219 54 200.8 54.15 200.8 Q 56.4 200.8 58.05 200.9 59.7 200.95 61.15 201.75 63.2 202.95 64.2 205 M 210.2 195.35 L 190.5 195.35 190.5 224.45 210.2 224.45 210.2 218.9 \n    197.75 218.9 197.75 211.55 209.2 211.55 209.2 206 197.75 206 197.75 200.9 210.2 200.9 210.2 195.35 M 187.5 195.35 L 163 195.35 163 200.9 171.6 200.9 171.6 224.45 178.9 224.45 178.9 \n    200.9 187.5 200.9 187.5 195.35 Z\n    "};O.setText();const B=O;var N="Consolas, Menlo, Courier, monospace";"\n  .codeflask {\n    -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none;\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n\n  .codeflask, .codeflask * {\n    box-sizing: border-box;\n    border: none;\n    resize: none;\n    outline: none;\n  }\n\n  .codeflask__pre {\n    -o-user-select:none; -ms-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -moz-user-select: none; pointer-events:none;\n    z-index: 3;\n    transform:translate3d(0, 0, 0);\n    box-sizing: border-box;\n    //white-space: pre;\n    padding:0px;\n    word-wrap: normal;\n    box-sizing: border-box;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: visible; !important;\n  }\n\n  .codeflask__textarea {\n\n    background: none;\n    //background:red;\n    border: none;\n    color: "+(function(e,t){return "undefined"!=typeof CSS?CSS.supports(e,t):"undefined"!=typeof document&&function(e){return (e=e.split("-").filter((function(e){return !!e})).map((function(e){return e[0].toUpperCase()+e.substr(1)})).join(""))[0].toLowerCase()+e.substr(1)}(e)in document.body.style}("caret-color","#F00")?"#282923":"#ccc")+";\n    color: rgba(0, 0, 0, 0);\n    z-index: 1;\n    resize: none;\n    //font-family: "+N+";\n    //text-rendering: optimizeSpeed;\n    //text-rendering: inherit;\n    //-webkit-appearance: pre;\n    caret-color: #fff;\n    z-index: 2;\n    width: 100%;\n    height: 100%;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n\n    border: none;\n    outline: none;\n    spellcheck:false;\n    //overflow: hidden;\n    overflow: scroll !important;\n\n  }\n\n  .codeflask--has-line-numbers .codeflask__textarea {\n    width: calc(100% - 40px);\n  }\n\n  .codeflask__code {\n    //padding: 10px;\n    //background:black;\n    display:block;\n    font-size: 15px;\n    line-height: 19px;\n    font-family: "+N+";\n    //overflow: hidden;\n    //overflow: scroll !important;\n    //left:3px;\n    //width: auto;\n    //position: absolute;\n    outline: none;\n    resize: none;\n    box-sizing: content-box;\n    display: inline-block;\n  }\n\n  .codeflask__flatten {\n\n    //background:grey;\n    padding: 10px;\n    font-size: 15px;\n    line-height: 19px;\n    font-family: "+N+";\n    text-rendering: optimizeLegibility;\n    //letter-spacing: 1px;\n    white-space: pre;\n    word-wrap: normal;\n    box-sizing: border-box;\n    position: absolute;\n    top: 0;\n    left: 0;\n    margin: 0 !important;\n    outline: none;\n    text-align: left;\n    cursor:auto;\n    outline: none;\n    border-radius: 0;\n    border-width: 0;\n    background: transparent;\n    //-webkit-background-clip: padding-box;\n    background-clip: padding-box;\n    resize: none;\n\n  }\n\n  .codeflask--has-line-numbers .codeflask__flatten {\n    width: calc(100% - 40px);\n    left: 40px;\n    outline: none;\n  }\n\n  .codeflask__line-highlight {\n    position: absolute;\n    top: 10px;\n    left: 0;\n    width: 100%;\n    height: 19px;\n    background: rgba(0,0,0,0.1);\n\n    z-index: 1;\n    //visibility: hidden;\n    outline: none;\n  }\n\n  .codeflask__lines {\n    padding: 10px 4px;\n    font-size:  15px;\n    line-height: 19px;\n    font-family: "+N+";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 40px;\n    height: 100%;\n    text-align: right;\n    color: #90918b;\n    z-index: 2;\n    outline: none;\n  }\n\n  .codeflask__lines__line {\n    display: block;\n    outline: none;\n  }\n\n  .codeflask.codeflask--has-line-numbers {\n    padding-left: 40px;\n  }\n\n  .codeflask.codeflask--has-line-numbers:before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 40px;\n    height: 100%;\n    //background: #282923;\n    z-index: 1;\n    outline: none;\n  }\n\n  .codeflask__error {\n    padding: 0px 0px;\n    padding-right:4px;\n    font-size:  15px;\n    font-family: "+N+";\n    position: absolute;\n    left: 0;\n    width: 40px;\n    height: 19px;\n    text-align: right;\n    color: #FF0000;\n    background:rgba(255,0,0,0.3);\n    outline: none;\n    z-index: 3;\n    display:none;\n  }\n";var W=function(e){var t=/(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,n=0,a={},i={manual:e.Prism&&e.Prism.manual,disableWorkerMessageHandler:e.Prism&&e.Prism.disableWorkerMessageHandler,util:{encode:function e(t){return t instanceof r?new r(t.type,e(t.content),t.alias):Array.isArray(t)?t.map(e):t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++n}),e.__id},clone:function e(t,n){var a,r;switch(n=n||{},i.util.type(t)){case"Object":if(r=i.util.objId(t),n[r])return n[r];for(var o in a={},n[r]=a,t)t.hasOwnProperty(o)&&(a[o]=e(t[o],n));return a;case"Array":return r=i.util.objId(t),n[r]?n[r]:(a=[],n[r]=a,t.forEach((function(t,i){a[i]=e(t,n);})),a);default:return t}},getLanguage:function(e){for(;e;){var n=t.exec(e.className);if(n)return n[1].toLowerCase();e=e.parentElement;}return "none"},setLanguage:function(e,n){e.className=e.className.replace(RegExp(t,"gi"),""),e.classList.add("language-"+n);},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(a){var e=(/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(a.stack)||[])[1];if(e){var t=document.getElementsByTagName("script");for(var n in t)if(t[n].src==e)return t[n]}return null}},isActive:function(e,t,n){for(var a="no-"+t;e;){var i=e.classList;if(i.contains(t))return !0;if(i.contains(a))return !1;e=e.parentElement;}return !!n}},languages:{plain:a,plaintext:a,text:a,txt:a,extend:function(e,t){var n=i.util.clone(i.languages[e]);for(var a in t)n[a]=t[a];return n},insertBefore:function(e,t,n,a){var r=(a=a||i.languages)[e],o={};for(var s in r)if(r.hasOwnProperty(s)){if(s==t)for(var l in n)n.hasOwnProperty(l)&&(o[l]=n[l]);n.hasOwnProperty(s)||(o[s]=r[s]);}var c=a[e];return a[e]=o,i.languages.DFS(i.languages,(function(t,n){n===c&&t!=e&&(this[t]=o);})),o},DFS:function e(t,n,a,r){r=r||{};var o=i.util.objId;for(var s in t)if(t.hasOwnProperty(s)){n.call(t,s,t[s],a||s);var l=t[s],c=i.util.type(l);"Object"!==c||r[o(l)]?"Array"!==c||r[o(l)]||(r[o(l)]=!0,e(l,n,s,r)):(r[o(l)]=!0,e(l,n,null,r));}}},plugins:{},highlightAll:function(e,t){i.highlightAllUnder(document,e,t);},highlightAllUnder:function(e,t,n){var a={callback:n,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};i.hooks.run("before-highlightall",a),a.elements=Array.prototype.slice.apply(a.container.querySelectorAll(a.selector)),i.hooks.run("before-all-elements-highlight",a);for(var r,o=0;r=a.elements[o++];)i.highlightElement(r,!0===t,a.callback);},highlightElement:function(t,n,a){var r=i.util.getLanguage(t),o=i.languages[r];i.util.setLanguage(t,r);var s=t.parentElement;s&&"pre"===s.nodeName.toLowerCase()&&i.util.setLanguage(s,r);var l={element:t,language:r,grammar:o,code:t.textContent};function c(e){l.highlightedCode=e,i.hooks.run("before-insert",l),l.element.innerHTML=l.highlightedCode,i.hooks.run("after-highlight",l),i.hooks.run("complete",l),a&&a.call(l.element);}if(i.hooks.run("before-sanity-check",l),(s=l.element.parentElement)&&"pre"===s.nodeName.toLowerCase()&&!s.hasAttribute("tabindex")&&s.setAttribute("tabindex","0"),!l.code)return i.hooks.run("complete",l),void(a&&a.call(l.element));if(i.hooks.run("before-highlight",l),l.grammar)if(n&&e.Worker){var d=new Worker(i.filename);d.onmessage=function(e){c(e.data);},d.postMessage(JSON.stringify({language:l.language,code:l.code,immediateClose:!0}));}else c(i.highlight(l.code,l.grammar,l.language));else c(i.util.encode(l.code));},highlight:function(e,t,n){var a={code:e,grammar:t,language:n};if(i.hooks.run("before-tokenize",a),!a.grammar)throw new Error('The language "'+a.language+'" has no grammar.');return a.tokens=i.tokenize(a.code,a.grammar),i.hooks.run("after-tokenize",a),r.stringify(i.util.encode(a.tokens),a.language)},tokenize:function(e,t){var n=t.rest;if(n){for(var a in n)t[a]=n[a];delete t.rest;}var c=new function(){var e={value:null,prev:null,next:null},t={value:null,prev:e,next:null};e.next=t,this.head=e,this.tail=t,this.length=0;};return s(c,c.head,e),function e(t,n,a,c,d,u){for(var p in a)if(a.hasOwnProperty(p)&&a[p]){var h=a[p];h=Array.isArray(h)?h:[h];for(var f=0;f<h.length;++f){if(u&&u.cause==p+","+f)return;var g=h[f],m=g.inside,b=!!g.lookbehind,k=!!g.greedy,v=g.alias;if(k&&!g.pattern.global){var y=g.pattern.toString().match(/[imsuy]*$/)[0];g.pattern=RegExp(g.pattern.source,y+"g");}for(var x=g.pattern||g,w=c.next,S=d;w!==n.tail&&!(u&&S>=u.reach);S+=w.value.length,w=w.next){var T=w.value;if(n.length>t.length)return;if(!(T instanceof r)){var L,C=1;if(k){if(!(L=o(x,S,t,b))||L.index>=t.length)break;var A=L.index,M=L.index+L[0].length,E=S;for(E+=w.value.length;A>=E;)E+=(w=w.next).value.length;if(S=E-=w.value.length,w.value instanceof r)continue;for(var z=w;z!==n.tail&&(E<M||"string"==typeof z.value);z=z.next)C++,E+=z.value.length;C--,T=t.slice(S,E),L.index-=S;}else if(!(L=o(x,0,T,b)))continue;A=L.index;var F=L[0],P=T.slice(0,A),R=T.slice(A+F.length),I=S+T.length;u&&I>u.reach&&(u.reach=I);var _=w.prev;if(P&&(_=s(n,_,P),S+=P.length),l(n,_,C),w=s(n,_,new r(p,m?i.tokenize(F,m):F,v,F)),R&&s(n,w,R),C>1){var O={cause:p+","+f,reach:I};e(t,n,a,w.prev,S,O),u&&O.reach>u.reach&&(u.reach=O.reach);}}}}}}(e,c,t,c.head,0),function(e){for(var t=[],n=e.head.next;n!==e.tail;)t.push(n.value),n=n.next;return t}(c)},hooks:{all:{},add:function(e,t){var n=i.hooks.all;n[e]=n[e]||[],n[e].push(t);},run:function(e,t){var n=i.hooks.all[e];if(n&&n.length)for(var a,r=0;a=n[r++];)a(t);}},Token:r};function r(e,t,n,a){this.type=e,this.content=t,this.alias=n,this.length=0|(a||"").length;}function o(e,t,n,a){e.lastIndex=t;var i=e.exec(n);if(i&&a&&i[1]){var r=i[1].length;i.index+=r,i[0]=i[0].slice(r);}return i}function s(e,t,n){var a=t.next,i={value:n,prev:t,next:a};return t.next=i,a.prev=i,e.length++,i}function l(e,t,n){for(var a=t.next,i=0;i<n&&a!==e.tail;i++)a=a.next;t.next=a,a.prev=t,e.length-=i;}if(e.Prism=i,r.stringify=function e(t,n){if("string"==typeof t)return t;if(Array.isArray(t)){var a="";return t.forEach((function(t){a+=e(t,n);})),a}var r={type:t.type,content:e(t.content,n),tag:"span",classes:["token",t.type],attributes:{},language:n},o=t.alias;o&&(Array.isArray(o)?Array.prototype.push.apply(r.classes,o):r.classes.push(o)),i.hooks.run("wrap",r);var s="";for(var l in r.attributes)s+=" "+l+'="'+(r.attributes[l]||"").replace(/"/g,"&quot;")+'"';return "<"+r.tag+' class="'+r.classes.join(" ")+'"'+s+">"+r.content+"</"+r.tag+">"},!e.document)return e.addEventListener?(i.disableWorkerMessageHandler||e.addEventListener("message",(function(t){var n=JSON.parse(t.data),a=n.language,r=n.code,o=n.immediateClose;e.postMessage(i.highlight(r,i.languages[a],a)),o&&e.close();}),!1),i):i;var c=i.util.currentScript();function d(){i.manual||i.highlightAll();}if(c&&(i.filename=c.src,c.hasAttribute("data-manual")&&(i.manual=!0)),!i.manual){var u=document.readyState;"loading"===u||"interactive"===u&&c&&c.defer?document.addEventListener("DOMContentLoaded",d):window.requestAnimationFrame?window.requestAnimationFrame(d):window.setTimeout(d,16);}return i}("undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{});"undefined"!=typeof module&&module.exports&&(module.exports=W),"undefined"!=typeof global&&(global.Prism=W),W.languages.markup={comment:{pattern:/<!--(?:(?!<!--)[\s\S])*?-->/,greedy:!0},prolog:{pattern:/<\?[\s\S]+?\?>/,greedy:!0},doctype:{pattern:/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,greedy:!0,inside:{"internal-subset":{pattern:/(^[^\[]*\[)[\s\S]+(?=\]>$)/,lookbehind:!0,greedy:!0,inside:null},string:{pattern:/"[^"]*"|'[^']*'/,greedy:!0},punctuation:/^<!|>$|[[\]]/,"doctype-tag":/^DOCTYPE/i,name:/[^\s<>'"]+/}},cdata:{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,greedy:!0},tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"special-attr":[],"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,inside:{punctuation:[{pattern:/^=/,alias:"attr-equals"},{pattern:/^(\s*)["']|["']$/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:[{pattern:/&[\da-z]{1,8};/i,alias:"named-entity"},/&#x?[\da-f]{1,8};/i]},W.languages.markup.tag.inside["attr-value"].inside.entity=W.languages.markup.entity,W.languages.markup.doctype.inside["internal-subset"].inside=W.languages.markup,W.hooks.add("wrap",(function(e){"entity"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,"&"));})),Object.defineProperty(W.languages.markup.tag,"addInlined",{value:function(e,t){var n={};n["language-"+t]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:!0,inside:W.languages[t]},n.cdata=/^<!\[CDATA\[|\]\]>$/i;var a={"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:n}};a["language-"+t]={pattern:/[\s\S]+/,inside:W.languages[t]};var i={};i[e]={pattern:RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g,(function(){return e})),"i"),lookbehind:!0,greedy:!0,inside:a},W.languages.insertBefore("markup","cdata",i);}}),Object.defineProperty(W.languages.markup.tag,"addAttribute",{value:function(e,t){W.languages.markup.tag.inside["special-attr"].push({pattern:RegExp(/(^|["'\s])/.source+"(?:"+e+")"+/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,"i"),lookbehind:!0,inside:{"attr-name":/^[^\s=]+/,"attr-value":{pattern:/=[\s\S]+/,inside:{value:{pattern:/(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,lookbehind:!0,alias:[t,"language-"+t],inside:W.languages[t]},punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}}}});}}),W.languages.html=W.languages.markup,W.languages.mathml=W.languages.markup,W.languages.svg=W.languages.markup,W.languages.xml=W.languages.extend("markup",{}),W.languages.ssml=W.languages.xml,W.languages.atom=W.languages.xml,W.languages.rss=W.languages.xml,function(e){var t=/(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;e.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:RegExp("@[\\w-](?:"+/[^;{\s"']|\s+(?!\s)/.source+"|"+t.source+")*?"+/(?:;|(?=\s*\{))/.source),inside:{rule:/^@[\w-]+/,"selector-function-argument":{pattern:/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,lookbehind:!0,alias:"selector"},keyword:{pattern:/(^|[^\w-])(?:and|not|only|or)(?![\w-])/,lookbehind:!0}}},url:{pattern:RegExp("\\burl\\((?:"+t.source+"|"+/(?:[^\\\r\n()"']|\\[\s\S])*/.source+")\\)","i"),greedy:!0,inside:{function:/^url/i,punctuation:/^\(|\)$/,string:{pattern:RegExp("^"+t.source+"$"),alias:"url"}}},selector:{pattern:RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|"+t.source+")*(?=\\s*\\{)"),lookbehind:!0},string:{pattern:t,greedy:!0},property:{pattern:/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,lookbehind:!0},important:/!important\b/i,function:{pattern:/(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,lookbehind:!0},punctuation:/[(){};:,]/},e.languages.css.atrule.inside.rest=e.languages.css;var n=e.languages.markup;n&&(n.tag.addInlined("style","css"),n.tag.addAttribute("style","css"));}(W),W.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0,greedy:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,boolean:/\b(?:false|true)\b/,function:/\b\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,punctuation:/[{}[\];(),.:]/},W.languages.javascript=W.languages.extend("clike",{"class-name":[W.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype))/,lookbehind:!0}],keyword:[{pattern:/((?:^|\})\s*)catch\b/,lookbehind:!0},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|window|document|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|of|package|private|protected|public|return|static|super|switch|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],function:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,number:{pattern:RegExp(/(^|[^\w$])/.source+"(?:"+/NaN|Infinity|null/.source+"|"+/0[bB][01]+(?:_[01]+)*n?/.source+"|"+/0[oO][0-7]+(?:_[0-7]+)*n?/.source+"|"+/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source+"|"+/\d+(?:_\d+)*n/.source+"|"+/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source+")"+/(?![\w$])/.source),lookbehind:!0},operator:/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?/}),W.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new|)\s+)[\w.\\]+/,W.languages.insertBefore("javascript","keyword",{regex:{pattern:RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source+/\//.source+"(?:"+/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source+"|"+/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source+")"+/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),lookbehind:!0,greedy:!0,inside:{"regex-source":{pattern:/^(\/)[\s\S]+(?=\/[a-z]*$)/,lookbehind:!0,alias:"language-regex",inside:W.languages.regex},"regex-delimiter":/^\/|\/$/,"regex-flags":/^[a-z]+$/}},"function-variable":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,alias:"function"},"function-extra":{pattern:/(?:constructor)/,alias:"keyword"},"keyword-variable":{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|continue|debugger|default|delete|do|else|enum|export|default|extends|for|from|(?:get|set)(?=\s*[\[$\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|new|of|package|private|protected|public|return|static|super|switch|throw|try|typeof|undefined|void|while|with|yield)\b/,alias:"keyword"},"parameter-variable":{pattern:/this/,alias:"keyword"},parameter:[{pattern:/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,lookbehind:!0,inside:W.languages.javascript},{pattern:/(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,inside:W.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,lookbehind:!0,inside:W.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,lookbehind:!0,inside:W.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),W.languages.insertBefore("javascript","string",{hashbang:{pattern:/^#!.*/,greedy:!0,alias:"comment"},"template-string":{pattern:/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:W.languages.javascript}},string:/[\s\S]+/}},"string-property":{pattern:/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,lookbehind:!0,greedy:!0,alias:"property"}}),W.languages.markup&&(W.languages.markup.tag.addInlined("script","javascript"),W.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,"javascript")),W.languages.js=W.languages.javascript,W.languages.c=W.languages.extend("clike",{comment:{pattern:/\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,greedy:!0},string:{pattern:/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,greedy:!0},"class-name":{pattern:/(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,lookbehind:!0},keyword:/\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,function:/\b[a-z_]\w*(?=\s*\()/i,number:/(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/}),W.languages.insertBefore("c","string",{char:{pattern:/'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,greedy:!0}}),W.languages.insertBefore("c","string",{macro:{pattern:/(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,lookbehind:!0,greedy:!0,alias:"property",inside:{string:[{pattern:/^(#\s*include\s*)<[^>]+>/,lookbehind:!0},W.languages.c.string],char:W.languages.c.char,comment:W.languages.c.comment,"macro-name":[{pattern:/(^#\s*define\s+)\w+\b(?!\()/i,lookbehind:!0},{pattern:/(^#\s*define\s+)\w+\b(?=\()/i,lookbehind:!0,alias:"function"}],directive:{pattern:/^(#\s*)[a-z]+/,lookbehind:!0,alias:"keyword"},"directive-hash":/^#/,punctuation:/##|\\(?=[\r\n])/,expression:{pattern:/\S[\s\S]*/,inside:W.languages.c}}}}),W.languages.insertBefore("c","function",{constant:/\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/}),delete W.languages.c.boolean,W.languages.glsl=W.languages.extend("c",{keyword:/\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/});

if ( window.GPUShaderStage === undefined ) {

	window.GPUShaderStage = { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };

}

class WebGPU {

	static isAvailable() {

		return ( navigator.gpu !== undefined );

	}

	static getErrorMessage() {

		let message = 'Your browser does not support <a href="https://gpuweb.github.io/gpuweb/" style="color:blue">WebGPU</a>';

		const element = document.createElement( 'div' );
		element.id = 'webgpumessage';
		element.style.fontFamily = 'monospace';
		element.style.fontSize = '13px';
		element.style.fontWeight = 'normal';
		element.style.textAlign = 'center';
		element.style.background = '#fff';
		element.style.color = '#000';
		element.style.padding = '1.5em';
		element.style.width = '400px';
		element.style.margin = '5em auto 0';

		element.innerHTML = message;

		return element;

	}

}

/** __
*    _)_|_|_
*   __) |_| | 2023
*  @author lo.th / https://github.com/lo-th
* 
*  MAIN THREE.JS / PHY
*/

let activeWebGPU = false;
let isWebGPU = false;
//let debugLight = false

let oldPause = false;

let engineName, version, introText;
let oldLeft = 0;

let childEditor = null;
let isExternEditor = false;
let particles = null;

let stats = null;
let maxFps = 60;

let groundColor = 0x808080;
let groundAutoColor = true;

const CameraBase = {
	
	theta:0,
	phi:12,
	distance:12,
	fov:50,
	x:0,
	y:2,
	z:0,
	time:0
};


// default config
const setting = {

	envmap:'clear',//'basic',
	
	groundSize:[ 60, 60 ],
	groundPos:[ 0, 0, 0 ],
	groundAlpha: true,
	groundOpacity:1,
	groundReflect:0.1,
	ground:true,
	water:false,
	fog:false,
	vignette:true,

	shadow:0.75,

};

const options = {

	key: false,

	mode:'HIGH',
	quality: 2,

	demo:'start',
	envmap:'null', //'basic',
	substep:1,
	fps:60,
	gravity:[0,-9.81,0],

	tone:'ACESFilmic',
	exposure: 1,
	envPower: 1,
	envBlur:0,
	legacy:false,

	light_1: 2.5,
	light_2: 1,

	show_light: false,
	show_stat: false,

	shadow:0.5,//0.25,
	shadowType:'PCSS',
	shadowGamma:1,//0.25,//1,
	shadowLuma:0.5, //0.75,//0,
    shadowContrast:2,//2.5,//1,

    reflect:0.1,
    renderMode:0,
    fogMode:1,

    lightSizeUV:1.3,
    nearPlane:9.5,
    rings:11,
    nSample:17,

    composer:false,

};

let hub3d = null;
let renderStart = false;
let dom, camera, controls, scene, renderer, loop = null, composer = null, followGroup, helperGroup, ground = null;

let code = '';
let editor = null;
let script = null;
let isLoadCode = true;
let needResize = true;

//const timer = new Timer(60)
const size = { w:0, h:0, r:0, left:0 };
const tm = { now:0, delta:0, then:0, inter: 1000/60, tmp:0, n:0, dt:0, fps:0 };

const toneMappingOptions = {
	None: THREE$1.NoToneMapping,
	Linear: THREE$1.LinearToneMapping,
	Reinhard: THREE$1.ReinhardToneMapping,
	Cineon: THREE$1.CineonToneMapping,
	ACESFilmic: THREE$1.ACESFilmicToneMapping,
	Uncharted2: THREE$1.CustomToneMapping
};

const shadowMapType = {
	PCSS: THREE$1.BasicShadowMap,
	PCF: THREE$1.PCFShadowMap,
	PCFSoft: THREE$1.PCFSoftShadowMap,
	VSM: THREE$1.VSMShadowMap
};

const Version = {
    Oimo: '1.2.2',
    Ammo: '3.0',
    Physx: '5.01.03',
    Rapier: '0.10.0',
    Havok: '0.10.0',
};

//let isMobile = false

const Main$1 = {

	Hub:Hub,

	engineType:'',
	currentDemmo:'',
	isWorker:true,
	devMode:false,
	engineList: [ 'OIMO', 'AMMO', 'PHYSX', 'HAVOK', 'RAPIER'],
	demoList:[],
	demoLink:[],
	envList:[],
	isMobile:false,
	isEditor:false,

	motor:Motor,

	start: async ( o = {} ) => {

		Hub.setMain( Main$1 );
		Gui.setMain( Main$1 );

		activeWebGPU = o.webGPU || false;

		const gpuTier = await A$1();
	    const perf = gpuTier;
	    //console.log(perf)

	    Main$1.isMobile = perf.isMobile;

		if( Main$1.isMobile || perf.fps < 60 ){ 
			options.mode = 'LOW';
			options.quality = 1;
		}

		switch(perf.tier){
			case 1: options.fps = 15; break
			case 2: options.fps = 30; break
			case 3: options.fps = 60; break
		}

		Main$1.engineType = o.type || 'PHYSX';

		Main$1.isWorker = Main$1.isMobile ? false : true;

		let urlParams = new URLSearchParams( window.location.search );
		if( urlParams.has('E') ){
			let eng = urlParams.get('E');
			Main$1.isWorker = eng.search('w_') !== -1;
			Main$1.devMode = eng.search('dev_') !== -1;
			Main$1.engineType = eng.substring( eng.lastIndexOf('_')+1 ).toUpperCase();
		}

		let n = Main$1.engineType.toLowerCase();
		engineName = n.charAt(0).toUpperCase() + n.slice(1);

		version = Version[ engineName ];

		//if( Main.devMode ) Main.engineList.push('RAPIER')//, 'CANNON')

		//o.link = LinkWasm[ engineName ]
		o.type = Main$1.engineType;
		o.devMode = Main$1.devMode;
		o.worker = Main$1.isWorker;
		o.callback = init;

		introText = ( Main$1.isWorker ? 'WORKER ' : 'DIRECT ' ) + Main$1.engineType + ' ' + version;

		options.show_stat = Main$1.devMode;

		//Motor.engine = Main.engineType
		window.engine = Main$1.engineType;//Motor.engine

		Motor.init( o );
	
	},


    setComposer:( b ) => { setComposer(); },
    showDebugLight:( b ) => { showDebugLight(b); },
    showStatistic:( b ) => { showStatistic(b); },
    setShadow:( v ) => { setShadow(v); },
    upShader:() => { upShader(); },

    getCamera:() => ( controls.info ),
    setCamera:(o) => { setCamera(o); },

    getCode:() => ( code ),
	getScene:() => ( scene ),
	getRenderer:() => ( renderer ),
	getControler:() => ( controls ),
	getCodeName:() => ( options.demo ),
	getGround:() => ( ground ),

	getHub3d:() => ( hub3d ),
	//getWorker:() => ( 'Worker' + (Main.isWorker ? ' On' : ' Off') ),
	getDemos:() => {

		let d = Motor.get('demos', 'json');
		Main$1.demoLink = [ ...d.Basic, ...d.Advanced, ...d[Main$1.engineType] ];
		if( Main$1.devMode ) Main$1.demoLink = [ ...Main$1.demoLink, ...d.Dev ];

		let i = Main$1.demoLink.length, l;
	    while(i--){
	    	l =  Main$1.demoLink[i];
	    	Main$1.demoList[i] = l.substring( l.lastIndexOf('/')+1 );
	    }

		Main$1.envList = [...d.Envmap];
		//return Main.demoList
	},

	lightIntensity:() => { lightIntensity(); },
	envmapIntensity:() => { setEnvmapIntensity(); },
	setReflect:(v) => { setReflect(v); },


	getOption:() => ( options ),
	getSetting:() => ( setting ),
	getComposer:() => ( composer ),
	getToneMappingOptions:() => ( toneMappingOptions ),

	setLeft:( x ) => { size.left = x; onResize(); },
	setCode:( code ) => { },
	getMouseDown:() => { return mouseDown },
	externEditor:() => { externEditor(); },
	injectCode: ( cc ) => { inject(cc); },

	addParticle: ( o ) => { return addParticle( o ) },
	getParticle: ( name ) => { return getParticle( name ) },
	initParticle: () => { return initParticle() },

	loadDemo: ( name ) => { loadDemo( name ); },
	extraCode: ( url, callback ) => { editor.loadExtra( url, callback ); },

	showEditor: ( b ) => { editor.show( b ); },
	changeMode: ( v ) => {
	    let low = options.mode === 'LOW';
	    setShadow( low ? 0 : 0.5 );
		setReflect( low ? 0 : 0.8 );
	},

	showGui: () => { Gui.showHide(); },
	resetGui: () => { Gui.reset(); },
	setEnv: (name, chageUI) => { setEnv(name); },
	setBlur: (v) => {
        Env.setBlur( options.envBlur );
	},

	setColors: ( palette ) => {

		//console.log( palette )

		if( hub3d ) hub3d.color = Gui.tool.htmlToHex( palette.darkVibrant ); 



		groundColor = Gui.tool.htmlToHex( palette.ground );

		if( ground && groundAutoColor ) ground.setColor( groundColor );

		Gui.tool.htmlRgba( palette.darkMuted, 0.4 );
		//console.log(c)

		Hub.setTopColor( Gui.tool.htmlRgba(palette.darkMuted, 0.4) );

	}

};

Motor.log = Hub.log;


Motor.initParticle = Main$1.initParticle;
Motor.addParticle = Main$1.addParticle;
Motor.getParticle = Main$1.getParticle;
Motor.getGround = Main$1.getGround;

Motor.extraCode = Main$1.extraCode;


window.phy = Motor;
window.math = Motor.math;
window.Main = Main$1;

window.THREE = THREE$1;
window.hub = Hub;
window.Planet = Planet;
window.Building = Building;
window.Sparkle = Sparkle;

window.Diamond = Diamond;
window.Fluid = Fluid;


const init = () => {

	isWebGPU = activeWebGPU ? WebGPU.isAvailable() : false;
 
	if( isWebGPU ) console.log('use webgpu !!');


	// https://threejs.org/docs/#api/en/renderers/WebGLRenderer

	let powerPreference ='default';
	//let powerPreference ='high-performance'
	//let powerPreference ='low-power'// for mobile

	let pixelRatio = window.devicePixelRatio;
	let antialias = pixelRatio > 1 ? false : true;
	if( pixelRatio > 2 ) pixelRatio = 2;

	Motor.getScene();

	size.w = window.innerWidth;
	size.h = window.innerHeight;
	size.r = size.w / size.h;

	// RENDERER

	if( isWebGPU ) renderer = new WebGPURenderer({ antialias:false, alpha:false, premultipliedAlpha: false });
	else renderer = new THREE$1.WebGLRenderer( { 
		antialias:antialias, 
		powerPreference:powerPreference,
		//premultipliedAlpha: false,
		//stencil: false,
		alpha: false,
	});
	
	renderer.setPixelRatio( pixelRatio );
	renderer.setSize( size.w, size.h );
	renderer.setClearColor( 0x000000, 1 );

	//renderer.outputColorSpace = THREE.sRGBEncoding
	//renderer.outputColorSpace = THREE.SRGBColorSpace;
	renderer.toneMapping = toneMappingOptions[options.tone];
	renderer.toneMappingExposure = options.exposure;//Math.pow( options.exposure, 5.0 );//
	//renderer.useLegacyLights = options.legacy;

	//console.log(renderer)

	// DOM
    document.body.appendChild( renderer.domElement );
	dom = renderer.domElement;
	dom.style.position = 'absolute';

	// SHADER

	Shader.renderer = renderer;

	if( !isWebGPU ){
		Shader.setGl2(  isWebGPU ? false : renderer.capabilities.isWebGL2 );
		Shader.init( options );
	}

	// SCENE

	scene = new THREE$1.Scene();
	renderer.setClearColor ( new THREE$1.Color( 0x808080 ) ); 
	//scene.background = new THREE.Color( 0x272822 )

	// GROUP

	followGroup = new THREE$1.Group();
	followGroup.name = 'followGroup';
	scene.add( followGroup );

	helperGroup = new THREE$1.Group();
	helperGroup.name = 'helperGroup';
	scene.add( helperGroup );

	scene.helper = helperGroup;



	addLight();

	// CAMERA / CONTROLER

	camera = new THREE$1.PerspectiveCamera( 50, size.r, 0.1, 1000 );
	scene.add( camera );



	controls = new Controller( camera, renderer.domElement, followGroup );
	//controls.target.y = 2
	controls.minDistance = 0.1;
    controls.maxDistance = 100;
    controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
    controls.dampingFactor = 0.25;//25//0.25;
    controls.screenSpacePanning = true;
    controls.zoomToCursor = true;
    //controls.enable = false
    //controls.maxPolarAngle = Math.PI / 2

    //setCamera()

	//controls.update()

	
	// avoid track run in background
	document.addEventListener( 'visibilitychange', onVisible );

	window.addEventListener( 'resize', onResize );
	document.body.addEventListener( 'dragover', function(e){ e.preventDefault(); }, false );
    document.body.addEventListener( 'dragend', function(e){ e.preventDefault(); }, false );
    document.body.addEventListener( 'dragleave', function(e){ e.preventDefault();}, false );
	document.body.addEventListener( 'drop', drop, false );


	Hub.init( camera, size, introText );

	editor = new Editor();

	Env.init( renderer, scene );
	Env.setMain( Main$1 );

	start();

	Motor.load( 'demos.json', next );

};

const drop = (e) => {

	e.preventDefault();
	const file = e.dataTransfer.files[0];
    const reader = new FileReader();
    const name = file.name;
    const type = name.substring(name.lastIndexOf('.')+1, name.length );
    const finalName = name.substring( name.lastIndexOf('/')+1, name.lastIndexOf('.') );

    //console.log(type, name)

    switch( type ){
    	case 'js': reader.readAsText( file ); break;
    	case 'fbx': case 'glb':  reader.readAsArrayBuffer( file ); break;
    	case 'hdr' : case 'exr' :
    	options.envmap = finalName;
    	Env.load( ( window.URL || window.webkitURL ).createObjectURL( file ), null, type ); 
    	break;
    }

    reader.onload = function ( e ) {

    	switch(type){
	    	case 'js': directDemo( finalName, e.target.result ); break;
	    	
	    }
    };

};

const next = () => {

	Main$1.getDemos();


	//hideMat = Motor.getHideMat()

    Motor.setContent( scene );
    Motor.setControl( controls );
    Motor.setExtendShader( Shader.add );
    Motor.setAddControl( addControl );

    // activate mouse drag
    Motor.activeMouse( controls );


	let hash = location.hash.substr( 1 );
    if( hash !== '' ) options.demo = hash;

    Hub.endLoading();

	loadDemo( options.demo );


	//if(isWebGPU) options.show_stat = false
	//if( options.show_stat ) showStatistic( true )

};

const start = () => {
	if(renderStart) return
	//if( isWebGPU ) renderer.setAnimationLoop( render );
	//else { if( loop === null) render(0) }

	if( loop === null) render(0);
	renderStart = true;
};

const addControl = () => {
	if( Main$1.isMobile ) Hub.addJoystick();
};


//--------------------
//   LIGHT
//--------------------

const lightIntensity = (a,b) => {

	if( a ) options.light_1 = a;
	if( b ) options.light_2 = b;

	Lights.update( { sunIntensity:options.light_1, hemiIntensity:options.light_2 });

};

const addLight = () => {

	Lights.add({ 
		type:'direct', name:'sun',
	    intensity:options.light_1*0.7, distance:6, parent:followGroup,
	    shadow:{ range:4, near:1, far:9, bias:-0.0005, radius:4, quality: 1024 * options.quality },
	});

	/////

	Lights.add({ 
	    type:'direct', name:'sun2',
	    intensity:options.light_1*0.3, distance:20, parent:followGroup,
	    shadow:{ range:40, near:5, far:40, bias:!isWebGPU ? -0.005 : 0.005, radius:2, quality: 1024 * options.quality }
	});

	if( !isWebGPU ){	
		Lights.add({ 
			type:'hemi', name:'hemi',
			intensity:options.light_2, 
			pos:[0,3,0], 
			parent:followGroup 
		});
	}

	////

	if( options.mode === 'LOW' ){
		options.shadow = 0;
		options.reflect = 0;
	}

	if( !isWebGPU ){

		Lights.castShadow( options.shadow !== 0 );
		renderer.shadowMap.enabled = options.shadow !== 0; 
		renderer.shadowMap.type = shadowMapType[options.shadowType];

	}

	////

};

/*const clearShadow = ( o ) => {

	if(light) light.shadow.dispose()
	if(light3) light3.shadow.dispose()
	
}*/

const resetLight = ( o ) => {

	const dt = {
		sunPos: [0.27, 1, 0.5],
		sunColor: 0xFFFFFF,
		skyColor: 0xFFFFFF,
		groundColor: 0x808080, 
	};

	Lights.update( dt );

};

const showDebugLight = ( b ) => {

	let v = Lights.addHelper( b, helperGroup );
	Env.preview( v );

};

const setShadow = ( v ) => {

	if( isWebGPU ) return

	options.shadow = v;

	if( options.shadow === 0 ){
		Lights.castShadow( false );
		if( !isWebGPU ) renderer.shadowMap.enabled = false;
		//clearShadow()
	} else {
		if( !renderer.shadowMap.enabled ){
			Lights.castShadow( true );
			if( !isWebGPU ) renderer.shadowMap.enabled = true;
		}
	}

	//if( light.shadowHelper ) light.shadowHelper.visible = options.shadow !== 0

	Main$1.upShader();

};



// 

//--------------------
//   GROUND
//--------------------

const addVignette = ( o ) => {

	if( hub3d === null && !isWebGPU ){

		hub3d = new Hub3D();
		camera.add( hub3d );

	}

};

const removeVignette = () => {

	if( hub3d === null ) return

    //camera.remove( hub3d );
	hub3d.dispose();
    hub3d = null;

};

	
//--------------------
//   GROUND
//--------------------

const addGround = ( o ) => {

	//groundAutoColor = !o.groundColor//false
    if( o.groundReflect ) options.reflect = o.groundReflect;

	//if( isWebGPU ) return

	if( ground === null ){

		// add reflect ground
		ground = new Reflector({

	    	textureSize: 1024 * options.quality,
	        clipBias:0.003,
	        encoding:true,
	        reflect: options.reflect,
	        water:o.water,
	        //color:groundColor,
	        round:true,
	        normal:true

	    });
	    scene.add( ground );

	} else {
		ground.reset();
	}

    ground.setSize( o.groundSize );
    ground.position.fromArray( o.groundPos );

    if( o.groundColor ) ground.setColor( o.groundColor );
    else ground.setColor( groundColor );

	ground.setAlphaMap( o.groundAlpha );
	ground.setOpacity( o.groundOpacity );
	ground.setReflect( o.groundReflect );
	ground.setWater( o.water );
    //scene.add( ground )
    Motor.addMaterial( ground.material,  true );

    

    //Gui.reset()

};

const removeGround = () => {

	if( ground === null ) return

	//scene.remove( ground )
	ground.dispose();
    ground = null;

};




//--------------------
//
//   CODE SIDE
//
//--------------------

const directDemo = ( name, result ) => {

	//let findDemo = Gui.resetDemoGroup( name )

	//unSelect()

	Main$1.currentDemo = name;
	options.demo = name;
	location.hash = name;

	Hub.upMenu();

	inject( result, true );

};

const loadDemo = ( name ) => {

	let idd = Main$1.demoList.indexOf(name);

	if( idd === -1 ){ 
		name = 'start';
		idd = 0;
	}

	//let findDemo = Gui.resetDemoGroup( name )
	//if(!findDemo) name = 'start'

	//unSelect()
    
    Main$1.currentDemo = name;
	options.demo = name;
	location.hash = name;

	//console.log(options.demo)

	Hub.upMenu();

	Motor.load( './demos/' + Main$1.demoLink[idd] + '.js', inject );

};

const inject = ( newCode, force = false ) => {

	isLoadCode = !newCode;
	code = isLoadCode ? Motor.getScript( options.demo ) : newCode;

	if( force ) isLoadCode = true;

	if(window['onReset']){ 
		window['onReset']();
		window['onReset'] = null;
	}

	//Hub.log()
	Hub.reset();
	Shader.reset();
	editor.reset();

	//resetLight()

	if( particles ) particles.dispose();
	
	
	if( isLoadCode ){
		//console.log('is full reset !!!')
		//Shader.reset()
	    resetLight(); 
		Motor.poolDispose();
	}

	phy.mouseMode('drag');
	phy.reset( refreshCode );

};

const refreshCode = () => {

	if( script !== null){ 
		script.remove();
		script = null;
	}
		
	script = document.createElement("script");
    script.language = "javascript";
    script.type = "text/javascript";
    script.id = "demo";
    script.async = false;//true;
    script.innerHTML = '{' + code + '}';
    document.body.appendChild( script );

    if( isLoadCode ) changeEditorCode();

    let ev = code.search( 'phy.view' );
    let evh = code.search( '//phy.view' );
	
    if( ev === -1 || evh !== -1 ) view( setting );
    /*else {

    	let t = code.substring(ev+10, code.indexOf('})'))
    	//let f = JSON.parse('{'+t+'}');
    	console.log( t )
    }*/
    if( code.search( 'phy.set' ) === -1 ) Motor.set();

    window['demo']();

    Gui.doReset();



};

const changeEditorCode = () => {

	if( isExternEditor ) send({ type:'set', code:code, name:options.demo });
    else editor.set( code, options.demo );

};

//--------------------
//   STOP ENGINE
//--------------------

const onVisible = () => {

	if( document.hidden ) {
		oldPause = Motor.getPause();
		Motor.pause( true );
	}
	else Motor.pause( oldPause );

};


//--------------------
//   RESIZE
//--------------------

const onResize = () => {

	size.w = window.innerWidth - size.left;
	size.h = window.innerHeight;
	size.r = size.w / size.h;
	needResize = true;

};

const doResize = () => {

	//if( !needResize ) return
	dom.style.left = size.left + 'px';
	camera.aspect = size.r;
	camera.updateProjectionMatrix();
	renderer.setSize( size.w, size.h );
	if(composer) composer.resize( size );
	if(particles) particles.onresize( size.h );
	Hub.resize( size );
    Motor.resize( size );
	needResize = false;

	//console.log(dom.clientLeft)

};



//--------------------
//   RENDER
//--------------------

const render = ( stamp = 0 ) => {

    //console.time('step')
	// TIME
	tm.now = stamp;
	tm.delta = tm.now - tm.then;
	tm.dt = tm.delta * 0.001;

	if( needResize ) doResize();

    

	// UPDATE PHY
	Motor.doStep( stamp );

	// UPDATE PARTICLE
    if( particles ) particles.update( stamp );

	// UPDATE CAMERA
	if( controls ){ 
		if( controls.enableDamping && controls.enable ) controls.update();
		if( controls.follow ) controls.follow( tm.dt );
	}

    // UPDATE TWEEN
	//TWEEN.update( stamp );

	// RENDER
	if( composer && composer.enabled ) composer.render( tm.dt );
	else renderer.render( scene, camera );

	Gui.update();

	upStat();

	//console.timeEnd('step')


	//if( !isWebGPU ) 
	loop = requestAnimationFrame( render );

	

};

const upStat = () => {

	//Hub.showTimeTest( Motor.getTimeTest() )

	// three fps
	if ( tm.now - 1000 > tm.tmp ){ 
		tm.tmp = tm.now; 
		tm.fps = tm.n; 
		tm.n = 0; 
	}

	tm.n++;
	tm.then = tm.now;

	if( tm.fps > maxFps ) {
		maxFps = tm.fps;
		Motor.setMaxFps( maxFps );
	}

	//Hub.setFps( 'T:' + tm.fps + ' | P:' + Motor.getFps() )
	Hub.setFps(  tm.fps + ' ~ ' + Motor.getFps() );
	getFullStats();

};

//--------------------
//   GUI FUCTION
//--------------------

//const gotoGithub = () => { window.open( 'https://github.com/lo-th/phy', '_blank' ) }
const upShader = () => { Shader.up( options ); };

const setReflect = ( v ) => {

	if(v) options.reflect = v;

	if(!ground) return
	ground.setReflect( options.reflect );

};




/*function firstFunction() {
      return new Promise((resolve, reject) => {
          let y = 0
          setTimeout(() => {
            for (let i=0; i<10; i++) {
               y++
            }
             console.log('Loop completed.')  
             resolve(y)
          }, 2000)
      })
    }*/
//async 
const view = ( o = {} ) => {

	o = { ...setting, ...o };

	groundAutoColor = !o.groundColor;//false

	//console.log('view', o)

	//const result = await firstFunction()

	if( o.envmap ){ 
		setEnv( o.envmap);
		options.envBlur = o.envblur || 0;
		Env.setBlur( options.envBlur );
	}

	setShadow( o.shadow );

	//if( o.fog ) 
	if( o.fog ){ 
		scene.fog = new THREE$1.Fog( Env.getFogColor().getHex(), 1, 50 );
		options.fogMode = 1;
	}
	else if( o.fogexp ){ 
		scene.fog = new THREE$1.FogExp2( Env.getFogColor().getHex(), o.fogexp || 0.01 );
		options.fogMode = 0;
	}
	else scene.fog = null;

	// reflect floor
	if( o.ground ) addGround( o );
	else removeGround();

	if( o.vignette ) addVignette();
	else removeVignette();

	//if( isLoadCode ) controls.moveCam( {...cam, ...o })

	if( isLoadCode ) setCamera( o );

	Shader.up( options );
	
};

Motor.view = view;

const setCamera = ( o ) => {

	//if(o) for( let i in o ){ if( cam[i] !== undefined ) cam[i] = o[i] }

    controls.moveCam( {...CameraBase, ...o } );
    controls.update();

};



//async function setEnv( name, chageUI ) {
const setEnv = ( name, chageUI ) => {

	//if(isWebGPU) return

	if( name !== options.envmap ){

		if ( !isNaN(name) ) options.envmap = 'null';
		else options.envmap = name;

		Env.set( name );
		
	}




	//options.envmap = name
	//Env.load( './assets/textures/equirectangular/'+options.envmap+'.hdr' )

};

//--------------------
//   EXTERN EDITOR
//--------------------

const externEditor = () => {

	if( !childEditor ){
		let hash = location.hash;
		oldLeft = size.left || 500;
		isExternEditor = true;
		childEditor = window.open('editor.html'+hash, 'Editor', 'height='+size.h+', width='+oldLeft);
	    window.addEventListener( 'message', message, false );

	    //window.open('/pageaddress.html','winname','directories=no,titlebar=no,status=no,menubar=no,scrollbars=no,resizable=no,width=400,height=350');

	    childEditor.onload = () => {
	    	send( { type : 'connect' } ); 
	    	editor.close();
	    	size.left = 0;
	    	onResize();
	    };

	} 

	/*if( isExternEditor ){
		isExternEditor = false; 
		size.left = oldLeft
		send( { type : 'close' } )
	}*/

	

};

const message = ( e ) => {

	switch( e.data.type ){

		case 'connect' :

            console.log('connect'); 

        break;

        case 'inject' :

           inject( e.data.code );

        break;

        case 'close' :
           //console.log('close') 
           send( { type : 'close' } );
           window.removeEventListener( 'message', message, false );
           childEditor = null;
           isExternEditor = false; 
           editor.open();
		   size.left = oldLeft;
        break;

	}

};

const send = ( data ) => {

	if( childEditor ) childEditor.postMessage( data,'*' );

};


//--------------------
//   OPTION
//--------------------

const setEnvmapIntensity = ( v ) => {

	Motor.setEnvmapIntensity( options.envPower );

	/*let g = Motor.getScene()
	g.traverse( function ( node ) {
		if( node.isMesh ){ 
			if( !node.material.userData.envp ) node.material.userData.envp = node.material.envMapIntensity
			node.material.envMapIntensity = node.material.userData.envp * options.envPower
		}
	})*/

	//if(!ground.material.userData.envp) ground.material.userData.envp = ground.material.envMapIntensity
	//ground.material.envMapIntensity = ground.material.userData.envp * options.envPower

};

const showStatistic = ( b ) => {

	if(isWebGPU) return

	if( b && !stats ){
		stats = new Stats( renderer );
	}

	if( !b && stats ){

		stats = null;
		Hub.setStats();
		
	}

};



const getFullStats = () => {

    if ( !stats ) return
    Hub.setStats( stats.get() );
    
};


//--------------------
//   POST PROCESS
//--------------------

const setComposer = ( b ) => {

	if(options.composer){
		if( composer === null ) composer = new Composer( renderer, scene, camera, controls, size );
		composer.enabled = true;

	} else {
		if( composer ){
			composer.dispose();
			composer = null;
		} 
	}

	Gui.postprocessEdit();

};


//--------------------
//  PARTICLE
//--------------------

const initParticle = ( ) => {

   if( !particles ) particles = new R( scene, renderer );

};

const addParticle = ( o = {} ) => {

   if( !particles ) particles = new R( scene, renderer );
   return particles.add( o )

};

const getParticle = ( name ) => {
	
	if( !particles ) particles = new R( scene, renderer );
   return particles.get( name )

};

export { Main$1 as Main };
